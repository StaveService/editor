/**
 * alphaTab v1.1.0 (, build 3)
 * 
 * Copyright Â© 2020, Daniel Kuschny and Contributors, All rights reserved.
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 * 
 * SoundFont loading and Audio Synthesis based on TinySoundFont (licensed under MIT)
 * Copyright (C) 2017, 2018 Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
 * 
 * TinySoundFont is based on SFZero (licensed under MIT)
 * Copyright (C) 2012 Steve Folta (https://github.com/stevefolta/SFZero)
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.alphaTab = {}));
}(this, (function (exports) { 'use strict';

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    (function (AlphaTabErrorType) {
        AlphaTabErrorType[AlphaTabErrorType["General"] = 0] = "General";
        AlphaTabErrorType[AlphaTabErrorType["Format"] = 1] = "Format";
        AlphaTabErrorType[AlphaTabErrorType["AlphaTex"] = 2] = "AlphaTex";
    })(exports.AlphaTabErrorType || (exports.AlphaTabErrorType = {}));
    var AlphaTabError = /** @class */ (function (_super) {
        __extends(AlphaTabError, _super);
        function AlphaTabError(type, message, inner) {
            var _this = _super.call(this, message) || this;
            _this.type = type;
            _this.inner = inner !== null && inner !== void 0 ? inner : null;
            Object.setPrototypeOf(_this, AlphaTabError.prototype);
            return _this;
        }
        return AlphaTabError;
    }(Error));

    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * An invalid input format was detected (e.g. invalid setting values, file formats,...)
     */
    var FormatError = /** @class */ (function (_super) {
        __extends$1(FormatError, _super);
        function FormatError(message) {
            var _this = _super.call(this, exports.AlphaTabErrorType.Format, message) || this;
            Object.setPrototypeOf(_this, FormatError.prototype);
            return _this;
        }
        return FormatError;
    }(AlphaTabError));

    /**
     * This public class provides names for all general midi instruments.
     */
    var GeneralMidi = /** @class */ (function () {
        function GeneralMidi() {
        }
        GeneralMidi.getValue = function (name) {
            if (!GeneralMidi._values) {
                GeneralMidi._values = new Map();
            }
            name = name.toLowerCase().split(' ').join('');
            return GeneralMidi._values.has(name) ? GeneralMidi._values.get(name) : 0;
        };
        GeneralMidi.isPiano = function (program) {
            return program <= 7 || program >= 16 && program <= 23;
        };
        GeneralMidi.isGuitar = function (program) {
            return program >= 24 && program <= 39 || program === 105 || program === 43;
        };
        GeneralMidi._values = new Map([
            ['acousticgrandpiano', 0], ['brightacousticpiano', 1], ['electricgrandpiano', 2],
            ['honkytonkpiano', 3], ['electricpiano1', 4], ['electricpiano2', 5], ['harpsichord', 6],
            ['clavinet', 7], ['celesta', 8], ['glockenspiel', 9], ['musicbox', 10], ['vibraphone', 11],
            ['marimba', 12], ['xylophone', 13], ['tubularbells', 14], ['dulcimer', 15],
            ['drawbarorgan', 16], ['percussiveorgan', 17], ['rockorgan', 18], ['churchorgan', 19],
            ['reedorgan', 20], ['accordion', 21], ['harmonica', 22], ['tangoaccordion', 23],
            ['acousticguitarnylon', 24], ['acousticguitarsteel', 25], ['electricguitarjazz', 26],
            ['electricguitarclean', 27], ['electricguitarmuted', 28], ['overdrivenguitar', 29],
            ['distortionguitar', 30], ['guitarharmonics', 31], ['acousticbass', 32],
            ['electricbassfinger', 33], ['electricbasspick', 34], ['fretlessbass', 35],
            ['slapbass1', 36], ['slapbass2', 37], ['synthbass1', 38], ['synthbass2', 39],
            ['violin', 40], ['viola', 41], ['cello', 42], ['contrabass', 43], ['tremolostrings', 44],
            ['pizzicatostrings', 45], ['orchestralharp', 46], ['timpani', 47], ['stringensemble1', 48],
            ['stringensemble2', 49], ['synthstrings1', 50], ['synthstrings2', 51], ['choiraahs', 52],
            ['voiceoohs', 53], ['synthvoice', 54], ['orchestrahit', 55], ['trumpet', 56],
            ['trombone', 57], ['tuba', 58], ['mutedtrumpet', 59], ['frenchhorn', 60],
            ['brasssection', 61], ['synthbrass1', 62], ['synthbrass2', 63], ['sopranosax', 64],
            ['altosax', 65], ['tenorsax', 66], ['baritonesax', 67], ['oboe', 68], ['englishhorn', 69],
            ['bassoon', 70], ['clarinet', 71], ['piccolo', 72], ['flute', 73], ['recorder', 74],
            ['panflute', 75], ['blownbottle', 76], ['shakuhachi', 77], ['whistle', 78], ['ocarina', 79],
            ['lead1square', 80], ['lead2sawtooth', 81], ['lead3calliope', 82], ['lead4chiff', 83],
            ['lead5charang', 84], ['lead6voice', 85], ['lead7fifths', 86], ['lead8bassandlead', 87],
            ['pad1newage', 88], ['pad2warm', 89], ['pad3polysynth', 90], ['pad4choir', 91],
            ['pad5bowed', 92], ['pad6metallic', 93], ['pad7halo', 94], ['pad8sweep', 95],
            ['fx1rain', 96], ['fx2soundtrack', 97], ['fx3crystal', 98], ['fx4atmosphere', 99],
            ['fx5brightness', 100], ['fx6goblins', 101], ['fx7echoes', 102], ['fx8scifi', 103],
            ['sitar', 104], ['banjo', 105], ['shamisen', 106], ['koto', 107], ['kalimba', 108],
            ['bagpipe', 109], ['fiddle', 110], ['shanai', 111], ['tinklebell', 112], ['agogo', 113],
            ['steeldrums', 114], ['woodblock', 115], ['taikodrum', 116], ['melodictom', 117],
            ['synthdrum', 118], ['reversecymbal', 119], ['guitarfretnoise', 120], ['breathnoise', 121],
            ['seashore', 122], ['birdtweet', 123], ['telephonering', 124], ['helicopter', 125],
            ['applause', 126], ['gunshot', 127]
        ]);
        return GeneralMidi;
    }());

    /**
     * Lists all fingers.
     */
    var Fingers;
    (function (Fingers) {
        /**
         * Unknown type (not documented)
         */
        Fingers[Fingers["Unknown"] = -2] = "Unknown";
        /**
         * No finger, dead note
         */
        Fingers[Fingers["NoOrDead"] = -1] = "NoOrDead";
        /**
         * The thumb
         */
        Fingers[Fingers["Thumb"] = 0] = "Thumb";
        /**
         * The index finger
         */
        Fingers[Fingers["IndexFinger"] = 1] = "IndexFinger";
        /**
         * The middle finger
         */
        Fingers[Fingers["MiddleFinger"] = 2] = "MiddleFinger";
        /**
         * The annular finger
         */
        Fingers[Fingers["AnnularFinger"] = 3] = "AnnularFinger";
        /**
         * The little finger
         */
        Fingers[Fingers["LittleFinger"] = 4] = "LittleFinger";
    })(Fingers || (Fingers = {}));

    /**
     * Lists the different modes on how rhythm notation is shown on the tab staff.
     */
    (function (TabRhythmMode) {
        /**
         * Rhythm notation is hidden.
         */
        TabRhythmMode[TabRhythmMode["Hidden"] = 0] = "Hidden";
        /**
         * Rhythm notation is shown with individual beams per beat.
         */
        TabRhythmMode[TabRhythmMode["ShowWithBeams"] = 1] = "ShowWithBeams";
        /**
         * Rhythm notation is shown and behaves like normal score notation with connected bars.
         */
        TabRhythmMode[TabRhythmMode["ShowWithBars"] = 2] = "ShowWithBars";
    })(exports.TabRhythmMode || (exports.TabRhythmMode = {}));
    (function (FingeringMode) {
        /**
         * Fingerings will be shown in the standard notation staff.
         */
        FingeringMode[FingeringMode["ScoreDefault"] = 0] = "ScoreDefault";
        /**
         * Fingerings will be shown in the standard notation staff. Piano finger style is enforced, where
         * fingers are rendered as 1-5 instead of p,i,m,a,c and T,1,2,3,4.
         */
        FingeringMode[FingeringMode["ScoreForcePiano"] = 1] = "ScoreForcePiano";
        /**
         * Fingerings will be shown in a effect band above the tabs in case
         * they have only a single note on the beat.
         */
        FingeringMode[FingeringMode["SingleNoteEffectBand"] = 2] = "SingleNoteEffectBand";
        /**
         * Fingerings will be shown in a effect band above the tabs in case
         * they have only a single note on the beat. Piano finger style is enforced, where
         * fingers are rendered as 1-5 instead of p,i,m,a,c and T,1,2,3,4.
         */
        FingeringMode[FingeringMode["SingleNoteEffectBandForcePiano"] = 3] = "SingleNoteEffectBandForcePiano";
    })(exports.FingeringMode || (exports.FingeringMode = {}));
    (function (NotationMode) {
        /**
         * Music elements will be displayed and played as in Guitar Pro.
         */
        NotationMode[NotationMode["GuitarPro"] = 0] = "GuitarPro";
        /**
         * Music elements will be displayed and played as in traditional songbooks.
         * Changes:
         * 1. Bends
         *   For bends additional grace beats are introduced.
         *   Bends are categorized into gradual and fast bends.
         *   - Gradual bends are indicated by beat text "grad" or "grad.". Bend will sound along the beat duration.
         *   - Fast bends are done right before the next note. If the next note is tied even on-beat of the next note.
         * 2. Whammy Bars
         *   Dips are shown as simple annotation over the beats
         *   Whammy Bars are categorized into gradual and fast.
         *   - Gradual whammys are indicated by beat text "grad" or "grad.". Whammys will sound along the beat duration.
         *   - Fast whammys are done right the beat.
         * 3. Let Ring
         *   Tied notes with let ring are not shown in standard notation
         *   Let ring does not cause a longer playback, duration is defined via tied notes.
         */
        NotationMode[NotationMode["SongBook"] = 1] = "SongBook";
    })(exports.NotationMode || (exports.NotationMode = {}));
    /**
     * Lists all major music notation elements that are part
     * of the music sheet and can be dynamically controlled to be shown
     * or hidden.
     */
    var NotationElement;
    (function (NotationElement) {
        /**
         * The score title shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreTitle"] = 0] = "ScoreTitle";
        /**
         * The score subtitle shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreSubTitle"] = 1] = "ScoreSubTitle";
        /**
         * The score artist shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreArtist"] = 2] = "ScoreArtist";
        /**
         * The score album shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreAlbum"] = 3] = "ScoreAlbum";
        /**
         * The score words author shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreWords"] = 4] = "ScoreWords";
        /**
         * The score music author shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreMusic"] = 5] = "ScoreMusic";
        /**
         * The score words&music author shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreWordsAndMusic"] = 6] = "ScoreWordsAndMusic";
        /**
         * The score copyright owner shown at the start of the music sheet.
         */
        NotationElement[NotationElement["ScoreCopyright"] = 7] = "ScoreCopyright";
        /**
         * The tuning information of the guitar shown
         * above the staves.
         */
        NotationElement[NotationElement["GuitarTuning"] = 8] = "GuitarTuning";
        /**
         * The track names which are shown in the accolade.
         */
        NotationElement[NotationElement["TrackNames"] = 9] = "TrackNames";
        /**
         * The chord diagrams for guitars. Usually shown
         * below the score info.
         */
        NotationElement[NotationElement["ChordDiagrams"] = 10] = "ChordDiagrams";
        /**
         * Parenthesis that are shown for tied bends
         * if they are preceeded by bends.
         */
        NotationElement[NotationElement["ParenthesisOnTiedBends"] = 11] = "ParenthesisOnTiedBends";
        /**
         * The tab number for tied notes if the
         * bend of a note is increased at that point.
         */
        NotationElement[NotationElement["TabNotesOnTiedBends"] = 12] = "TabNotesOnTiedBends";
        /**
         * Zero tab numbers on "dive whammys".
         */
        NotationElement[NotationElement["ZerosOnDiveWhammys"] = 13] = "ZerosOnDiveWhammys";
        /**
         * The alternate endings information on repeats shown above the staff.
         */
        NotationElement[NotationElement["EffectAlternateEndings"] = 14] = "EffectAlternateEndings";
        /**
         * The information about the fret on which the capo is placed shown above the staff.
         */
        NotationElement[NotationElement["EffectCapo"] = 15] = "EffectCapo";
        /**
         * The chord names shown above beats shown above the staff.
         */
        NotationElement[NotationElement["EffectChordNames"] = 16] = "EffectChordNames";
        /**
         * The crescendo/decrescendo angle  shown above the staff.
         */
        NotationElement[NotationElement["EffectCrescendo"] = 17] = "EffectCrescendo";
        /**
         * The beat dynamics  shown above the staff.
         */
        NotationElement[NotationElement["EffectDynamics"] = 18] = "EffectDynamics";
        /**
         * The curved angle for fade in/out effects  shown above the staff.
         */
        NotationElement[NotationElement["EffectFadeIn"] = 19] = "EffectFadeIn";
        /**
         * The fermata symbol shown above the staff.
         */
        NotationElement[NotationElement["EffectFermata"] = 20] = "EffectFermata";
        /**
         * The fingering information.
         */
        NotationElement[NotationElement["EffectFingering"] = 21] = "EffectFingering";
        /**
         * The harmonics names shown above the staff.
         * (does not represent the harmonic note heads)
         */
        NotationElement[NotationElement["EffectHarmonics"] = 22] = "EffectHarmonics";
        /**
         * The let ring name and line above the staff.
         */
        NotationElement[NotationElement["EffectLetRing"] = 23] = "EffectLetRing";
        /**
         * The lyrics of the track shown above the staff.
         */
        NotationElement[NotationElement["EffectLyrics"] = 24] = "EffectLyrics";
        /**
         * The section markers shown above the staff.
         */
        NotationElement[NotationElement["EffectMarker"] = 25] = "EffectMarker";
        /**
         * The ottava symbol and lines shown above the staff.
         */
        NotationElement[NotationElement["EffectOttavia"] = 26] = "EffectOttavia";
        /**
         * The palm mute name and line shown above the staff.
         */
        NotationElement[NotationElement["EffectPalmMute"] = 27] = "EffectPalmMute";
        /**
         * The pick slide information shown above the staff.
         * (does not control the pick slide lines)
         */
        NotationElement[NotationElement["EffectPickSlide"] = 28] = "EffectPickSlide";
        /**
         * The pick stroke symbols shown above the staff.
         */
        NotationElement[NotationElement["EffectPickStroke"] = 29] = "EffectPickStroke";
        /**
         * The slight beat vibrato waves shown above the staff.
         */
        NotationElement[NotationElement["EffectSlightBeatVibrato"] = 30] = "EffectSlightBeatVibrato";
        /**
         * The slight note vibrato waves shown above the staff.
         */
        NotationElement[NotationElement["EffectSlightNoteVibrato"] = 31] = "EffectSlightNoteVibrato";
        /**
         * The tap/slap/pop effect names shown above the staff.
         */
        NotationElement[NotationElement["EffectTap"] = 32] = "EffectTap";
        /**
         * The tempo information shown above the staff.
         */
        NotationElement[NotationElement["EffectTempo"] = 33] = "EffectTempo";
        /**
         * The additional beat text shown above the staff.
         */
        NotationElement[NotationElement["EffectText"] = 34] = "EffectText";
        /**
         * The trill name and waves shown above the staff.
         */
        NotationElement[NotationElement["EffectTrill"] = 35] = "EffectTrill";
        /**
         * The triplet feel symbol shown above the staff.
         */
        NotationElement[NotationElement["EffectTripletFeel"] = 36] = "EffectTripletFeel";
        /**
         * The whammy bar information shown above the staff.
         * (does not control the whammy lines shown within the staff)
         */
        NotationElement[NotationElement["EffectWhammyBar"] = 37] = "EffectWhammyBar";
        /**
         * The wide beat vibrato waves shown above the staff.
         */
        NotationElement[NotationElement["EffectWideBeatVibrato"] = 38] = "EffectWideBeatVibrato";
        /**
         * The wide note vibrato waves shown above the staff.
         */
        NotationElement[NotationElement["EffectWideNoteVibrato"] = 39] = "EffectWideNoteVibrato";
        /**
         * The left hand tap symbol shown above the staff.
         */
        NotationElement[NotationElement["EffectLeftHandTap"] = 40] = "EffectLeftHandTap";
    })(NotationElement || (NotationElement = {}));
    /**
     * The notation settings control how various music notation elements are shown and behaving
     * @json
     */
    var NotationSettings = /** @class */ (function () {
        function NotationSettings() {
            /**
             * Gets or sets the mode to use for display and play music notation elements.
             */
            this.notationMode = exports.NotationMode.GuitarPro;
            /**
             * Gets or sets the fingering mode to use.
             */
            this.fingeringMode = exports.FingeringMode.ScoreDefault;
            /**
             * Gets or sets the configuration on whether music notation elements are visible or not.
             * If notation elements are not specified, the default configuration will be applied.
             */
            this.elements = new Map();
            /**
             * Whether to show rhythm notation in the guitar tablature.
             */
            this.rhythmMode = exports.TabRhythmMode.Hidden;
            /**
             * The height of the rythm bars.
             */
            this.rhythmHeight = 15;
            /**
             * The transposition pitch offsets for the individual tracks.
             * They apply to rendering and playback.
             */
            this.transpositionPitches = [];
            /**
             * The transposition pitch offsets for the individual tracks.
             * They apply to rendering only.
             */
            this.displayTranspositionPitches = [];
            /**
             * If set to true the guitar tabs on grace beats are rendered smaller.
             */
            this.smallGraceTabNotes = true;
            /**
             * If set to true bend arrows expand to the end of the last tied note
             * of the string. Otherwise they end on the next beat.
             */
            this.extendBendArrowsOnTiedNotes = true;
            /**
             * If set to true, line effects (like w/bar, let-ring etc)
             * are drawn until the end of the beat instead of the start.
             */
            this.extendLineEffectsToBeatEnd = false;
            /**
             * Gets or sets the height for slurs. The factor is multiplied with the a logarithmic distance
             * between slur start and end.
             */
            this.slurHeight = 5.0;
        }
        /**
         * Gets whether the given music notation element should be shown
         * @param element the element to check
         * @returns true if the element should be shown, otherwise false.
         */
        NotationSettings.prototype.isNotationElementVisible = function (element) {
            if (this.elements.has(element)) {
                return this.elements.get(element);
            }
            if (NotationSettings.defaultElements.has(element)) {
                return NotationSettings.defaultElements.get(element);
            }
            return true;
        };
        NotationSettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        NotationSettings.prototype.fillToJson = function (json) { json.notationMode = this.notationMode; json.fingeringMode = this.fingeringMode; json.elements = {}; this.elements.forEach(function ($mv, $mk) { json.elements[$mk] = $mv; }); json.rhythmMode = this.rhythmMode; json.rhythmHeight = this.rhythmHeight; json.transpositionPitches = this.transpositionPitches.slice(); json.displayTranspositionPitches = this.displayTranspositionPitches.slice(); json.smallGraceTabNotes = this.smallGraceTabNotes; json.extendBendArrowsOnTiedNotes = this.extendBendArrowsOnTiedNotes; json.extendLineEffectsToBeatEnd = this.extendLineEffectsToBeatEnd; json.slurHeight = this.slurHeight; };
        NotationSettings.fromJson = function (json) { if (!json)
            return null; var obj = new NotationSettings(); obj.fillFromJson(json); return obj; };
        NotationSettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        NotationSettings.prototype.setProperty = function (property, value) { switch (property) {
            case "notationmode":
                this.notationMode = isNaN(parseInt(value)) ? exports.NotationMode[Object.keys(exports.NotationMode).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "fingeringmode":
                this.fingeringMode = isNaN(parseInt(value)) ? exports.FingeringMode[Object.keys(exports.FingeringMode).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "elements":
                this.elements = new Map();
                for (var $mk in value)
                    if (value.hasOwnProperty($mk))
                        this.elements.set(isNaN(parseInt($mk)) ? NotationElement[Object.keys(NotationElement).find(function ($k) { return $k.toLowerCase() === $mk.toLowerCase(); })] : parseInt($mk), value[$mk]);
                return true;
            case "rhythmmode":
                this.rhythmMode = isNaN(parseInt(value)) ? exports.TabRhythmMode[Object.keys(exports.TabRhythmMode).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "rhythmheight":
                this.rhythmHeight = value;
                return true;
            case "transpositionpitches":
                this.transpositionPitches = value.slice();
                return true;
            case "displaytranspositionpitches":
                this.displayTranspositionPitches = value.slice();
                return true;
            case "smallgracetabnotes":
                this.smallGraceTabNotes = value;
                return true;
            case "extendbendarrowsontiednotes":
                this.extendBendArrowsOnTiedNotes = value;
                return true;
            case "extendlineeffectstobeatend":
                this.extendLineEffectsToBeatEnd = value;
                return true;
            case "slurheight":
                this.slurHeight = value;
                return true;
        } return false; };
        /**
         * Gets the default configuration of the {@see notationElements} setting. Do not modify
         * this map as it might not result in the expected side effects.
         * If items are not listed explicitly in this list, they are considered visible.
         */
        NotationSettings.defaultElements = new Map([
            [NotationElement.ZerosOnDiveWhammys, false]
        ]);
        return NotationSettings;
    }());

    var TuningParseResult = /** @class */ (function () {
        function TuningParseResult() {
            this.note = null;
            this.noteValue = 0;
            this.octave = 0;
        }
        Object.defineProperty(TuningParseResult.prototype, "realValue", {
            get: function () {
                return this.octave * 12 + this.noteValue;
            },
            enumerable: false,
            configurable: true
        });
        return TuningParseResult;
    }());
    /**
     * This public class contains some utilities for working with model public classes
     */
    var ModelUtils = /** @class */ (function () {
        function ModelUtils() {
        }
        ModelUtils.getIndex = function (duration) {
            var index = 0;
            var value = duration;
            if (value < 0) {
                return index;
            }
            return Math.log2(duration) | 0;
        };
        ModelUtils.keySignatureIsFlat = function (ks) {
            return ks < 0;
        };
        ModelUtils.keySignatureIsNatural = function (ks) {
            return ks === 0;
        };
        ModelUtils.keySignatureIsSharp = function (ks) {
            return ks > 0;
        };
        ModelUtils.applyPitchOffsets = function (settings, score) {
            for (var i = 0; i < score.tracks.length; i++) {
                if (i < settings.notation.displayTranspositionPitches.length) {
                    for (var _i = 0, _a = score.tracks[i].staves; _i < _a.length; _i++) {
                        var staff = _a[_i];
                        staff.displayTranspositionPitch = -settings.notation.displayTranspositionPitches[i];
                    }
                }
                if (i < settings.notation.transpositionPitches.length) {
                    for (var _b = 0, _c = score.tracks[i].staves; _b < _c.length; _b++) {
                        var staff = _c[_b];
                        staff.transpositionPitch = -settings.notation.transpositionPitches[i];
                    }
                }
            }
        };
        ModelUtils.fingerToString = function (settings, beat, finger, leftHand) {
            if (settings.notation.fingeringMode === exports.FingeringMode.ScoreForcePiano ||
                settings.notation.fingeringMode === exports.FingeringMode.SingleNoteEffectBandForcePiano ||
                GeneralMidi.isPiano(beat.voice.bar.staff.track.playbackInfo.program)) {
                switch (finger) {
                    case Fingers.Unknown:
                    case Fingers.NoOrDead:
                        return null;
                    case Fingers.Thumb:
                        return '1';
                    case Fingers.IndexFinger:
                        return '2';
                    case Fingers.MiddleFinger:
                        return '3';
                    case Fingers.AnnularFinger:
                        return '4';
                    case Fingers.LittleFinger:
                        return '5';
                    default:
                        return null;
                }
            }
            if (leftHand) {
                switch (finger) {
                    case Fingers.Unknown:
                    case Fingers.NoOrDead:
                        return '0';
                    case Fingers.Thumb:
                        return 'T';
                    case Fingers.IndexFinger:
                        return '1';
                    case Fingers.MiddleFinger:
                        return '2';
                    case Fingers.AnnularFinger:
                        return '3';
                    case Fingers.LittleFinger:
                        return '4';
                    default:
                        return null;
                }
            }
            switch (finger) {
                case Fingers.Unknown:
                case Fingers.NoOrDead:
                    return null;
                case Fingers.Thumb:
                    return 'p';
                case Fingers.IndexFinger:
                    return 'i';
                case Fingers.MiddleFinger:
                    return 'm';
                case Fingers.AnnularFinger:
                    return 'a';
                case Fingers.LittleFinger:
                    return 'c';
                default:
                    return null;
            }
        };
        /**
         * Checks if the given string is a tuning inticator.
         * @param name
         * @returns
         */
        ModelUtils.isTuning = function (name) {
            return !!ModelUtils.parseTuning(name);
        };
        ModelUtils.parseTuning = function (name) {
            var note = '';
            var octave = '';
            for (var i = 0; i < name.length; i++) {
                var c = name.charCodeAt(i);
                if (c >= 0x30 && c <= 0x39) {
                    // number without note?
                    if (!note) {
                        return null;
                    }
                    octave += String.fromCharCode(c);
                }
                else if ((c >= 0x41 && c <= 0x5a) || (c >= 0x61 && c <= 0x7a) || c === 0x23) {
                    note += String.fromCharCode(c);
                }
                else {
                    return null;
                }
            }
            if (!octave || !note) {
                return null;
            }
            var result = new TuningParseResult();
            result.octave = parseInt(octave) + 1;
            result.note = note.toLowerCase();
            result.noteValue = ModelUtils.getToneForText(result.note);
            return result;
        };
        ModelUtils.getTuningForText = function (str) {
            var result = ModelUtils.parseTuning(str);
            if (!result) {
                return -1;
            }
            return result.realValue;
        };
        ModelUtils.getToneForText = function (note) {
            var b = 0;
            switch (note.toLowerCase()) {
                case 'c':
                    b = 0;
                    break;
                case 'c#':
                case 'db':
                    b = 1;
                    break;
                case 'd':
                    b = 2;
                    break;
                case 'd#':
                case 'eb':
                    b = 3;
                    break;
                case 'e':
                    b = 4;
                    break;
                case 'f':
                    b = 5;
                    break;
                case 'f#':
                case 'gb':
                    b = 6;
                    break;
                case 'g':
                    b = 7;
                    break;
                case 'g#':
                case 'ab':
                    b = 8;
                    break;
                case 'a':
                    b = 9;
                    break;
                case 'a#':
                case 'bb':
                    b = 10;
                    break;
                case 'b':
                    b = 11;
                    break;
                default:
                    return 0;
            }
            return b;
        };
        ModelUtils.newGuid = function () {
            return (Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1) +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1) +
                '-' +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1) +
                '-' +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1) +
                '-' +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1) +
                '-' +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1) +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1) +
                Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1));
        };
        ModelUtils.isAlmostEqualTo = function (a, b) {
            return Math.abs(a - b) < 0.00001;
        };
        ModelUtils.toHexString = function (n, digits) {
            if (digits === void 0) { digits = 0; }
            var s = '';
            var hexChars = '0123456789ABCDEF';
            do {
                s = String.fromCharCode(hexChars.charCodeAt(n & 15)) + s;
                n = n >> 4;
            } while (n > 0);
            while (s.length < digits) {
                s = '0' + s;
            }
            return s;
        };
        return ModelUtils;
    }());

    /**
     * @json_immutable
     */
    var Color = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link Color} class.
         * @param r The red component.
         * @param g The green component.
         * @param b The blue component.
         * @param a The alpha component.
         */
        function Color(r, g, b, a) {
            if (a === void 0) { a = 0xff; }
            /**
             * Gets or sets the raw RGBA value.
             */
            this.raw = 0;
            this.raw = 0;
            this.raw = ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);
            this.updateRgba();
        }
        Color.prototype.updateRgba = function () {
            if (this.a === 0xff) {
                this.rgba =
                    '#' +
                        ModelUtils.toHexString(this.r, 2) +
                        ModelUtils.toHexString(this.g, 2) +
                        ModelUtils.toHexString(this.b, 2);
            }
            else {
                this.rgba = "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a / 255.0 + ")";
            }
        };
        Object.defineProperty(Color.prototype, "a", {
            get: function () {
                return (this.raw >> 24) & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "r", {
            get: function () {
                return (this.raw >> 16) & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "g", {
            get: function () {
                return (this.raw >> 8) & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Color.prototype, "b", {
            get: function () {
                return this.raw & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        Color.random = function (opacity) {
            if (opacity === void 0) { opacity = 100; }
            return new Color((Math.random() * 255) | 0, (Math.random() * 255) | 0, (Math.random() * 255) | 0, opacity);
        };
        /**
         * @target web
         */
        Color.fromJson = function (json) {
            if (!json) {
                return null;
            }
            if (json instanceof Color) {
                return json;
            }
            switch (typeof json) {
                case 'number':
                    var c = new Color(0, 0, 0, 0);
                    c.raw = json | 0;
                    c.updateRgba();
                    return c;
                case 'string':
                    if (json.startsWith('#')) {
                        if (json.length === 4) {
                            // #RGB
                            return new Color(parseInt(json.substring(1, 1), 16) * 17, parseInt(json.substring(2, 1), 16) * 17, parseInt(json.substring(3, 1), 16) * 17);
                        }
                        if (json.length === 5) {
                            // #RGBA
                            return new Color(parseInt(json.substring(1, 1), 16) * 17, parseInt(json.substring(2, 1), 16) * 17, parseInt(json.substring(3, 1), 16) * 17, parseInt(json.substring(4, 1), 16) * 17);
                        }
                        if (json.length === 7) {
                            // #RRGGBB
                            return new Color(parseInt(json.substring(1, 2), 16), parseInt(json.substring(3, 2), 16), parseInt(json.substring(5, 2), 16));
                        }
                        if (json.length === 9) {
                            // #RRGGBBAA
                            return new Color(parseInt(json.substring(1, 2), 16), parseInt(json.substring(3, 2), 16), parseInt(json.substring(5, 2), 16), parseInt(json.substring(7, 2), 16));
                        }
                    }
                    else if (json.startsWith('rgba') || json.startsWith('rgb')) {
                        var start = json.indexOf('(');
                        var end = json.lastIndexOf(')');
                        if (start === -1 || end === -1) {
                            throw new FormatError('No values specified for rgb/rgba function');
                        }
                        var numbers = json.substring(start + 1, end - start - 1).split(',');
                        if (numbers.length === 3) {
                            return new Color(parseInt(numbers[0]), parseInt(numbers[1]), parseInt(numbers[2]));
                        }
                        if (numbers.length === 4) {
                            return new Color(parseInt(numbers[0]), parseInt(numbers[1]), parseInt(numbers[2]), parseFloat(numbers[3]) * 255);
                        }
                    }
                    break;
            }
            throw new FormatError('Unsupported format for color');
        };
        /**
         * @target web
         */
        Color.toJson = function (obj) {
            return obj.raw;
        };
        Color.BlackRgb = '#000000';
        return Color;
    }());

    /**
     * Lists all flags for font styles.
     */
    var FontStyle;
    (function (FontStyle) {
        /**
         * No flags.
         */
        FontStyle[FontStyle["Plain"] = 0] = "Plain";
        /**
         * Font is bold
         */ FontStyle[FontStyle["Bold"] = 1] = "Bold";
        /**
         * Font is italic.
         */ FontStyle[FontStyle["Italic"] = 2] = "Italic";
    })(FontStyle || (FontStyle = {}));
    /**
     * @json_immutable
     */
    var Font = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link Font} class.
         * @param family The family.
         * @param size The size.
         * @param style The style.
         */
        function Font(family, size, style) {
            if (style === void 0) { style = FontStyle.Plain; }
            this._cssScale = 0.0;
            this.family = family;
            this.size = size;
            this.style = style;
            this._css = this.toCssString(1);
        }
        Object.defineProperty(Font.prototype, "isBold", {
            get: function () {
                return (this.style & FontStyle.Bold) !== 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Font.prototype, "isItalic", {
            get: function () {
                return (this.style & FontStyle.Italic) !== 0;
            },
            enumerable: false,
            configurable: true
        });
        Font.prototype.clone = function () {
            return new Font(this.family, this.size, this.style);
        };
        Font.prototype.toCssString = function (scale) {
            if (!this._css || !(Math.abs(scale - this._cssScale) < 0.01)) {
                var buf = '';
                if (this.isBold) {
                    buf += 'bold ';
                }
                if (this.isItalic) {
                    buf += 'italic ';
                }
                buf += this.size * scale;
                buf += 'px ';
                buf += "'";
                buf += this.family;
                buf += "'";
                this._css = buf;
                this._cssScale = scale;
            }
            return this._css;
        };
        /**
         * @target web
         */
        Font.fromJson = function (value) {
            if (!value) {
                return null;
            }
            if (value instanceof Font) {
                return value;
            }
            if (typeof value === 'object' && value.family) {
                return new Font(value.family, value.size, value.style);
            }
            if (typeof value === 'string' && !Environment.isRunningInWorker) {
                var el = document.createElement('span');
                el.setAttribute('style', 'font: ' + value);
                var style = el.style;
                if (!style.fontFamily) {
                    style.fontFamily = 'sans-serif';
                }
                var family = style.fontFamily;
                if ((family.startsWith("'") && family.endsWith("'")) || (family.startsWith('"') && family.endsWith('"'))) {
                    family = family.substr(1, family.length - 2);
                }
                var fontSizeString = style.fontSize.toLowerCase();
                var fontSize = 0;
                // as per https://websemantics.uk/articles/font-size-conversion/
                switch (fontSizeString) {
                    case 'xx-small':
                        fontSize = 7;
                        break;
                    case 'x-small':
                        fontSize = 10;
                        break;
                    case 'small':
                    case 'smaller':
                        fontSize = 13;
                        break;
                    case 'medium':
                        fontSize = 16;
                        break;
                    case 'large':
                    case 'larger':
                        fontSize = 18;
                        break;
                    case 'x-large':
                        fontSize = 24;
                        break;
                    case 'xx-large':
                        fontSize = 32;
                        break;
                    default:
                        try {
                            if (fontSizeString.endsWith('em')) {
                                fontSize = parseFloat(fontSizeString.substr(0, fontSizeString.length - 2)) * 16;
                            }
                            else if (fontSizeString.endsWith('pt')) {
                                fontSize = (parseFloat(fontSizeString.substr(0, fontSizeString.length - 2)) * 16.0) / 12.0;
                            }
                            else if (fontSizeString.endsWith('px')) {
                                fontSize = parseFloat(fontSizeString.substr(0, fontSizeString.length - 2));
                            }
                            else {
                                fontSize = 12;
                            }
                        }
                        catch (e) {
                            fontSize = 12;
                        }
                        break;
                }
                var fontStyle = FontStyle.Plain;
                if (style.fontStyle === 'italic') {
                    fontStyle |= FontStyle.Italic;
                }
                var fontWeightString = style.fontWeight.toLowerCase();
                switch (fontWeightString) {
                    case 'normal':
                    case 'lighter':
                        break;
                    default:
                        fontStyle |= FontStyle.Bold;
                        break;
                }
                return new Font(family, fontSize, fontStyle);
            }
            return null;
        };
        /**
         * @target web
         */
        Font.toJson = function (font) {
            return {
                family: font.family,
                size: font.size,
                style: font.style
            };
        };
        return Font;
    }());

    /**
     * This public class contains central definitions for controlling the visual appearance.
     * @json
     */
    var RenderingResources = /** @class */ (function () {
        function RenderingResources() {
            /**
             * Gets or sets the font to use for displaying the songs copyright information in the header of the music sheet.
             */
            this.copyrightFont = new Font(RenderingResources.sansFont, 12, FontStyle.Bold);
            /**
             * Gets or sets the font to use for displaying the songs title in the header of the music sheet.
             */
            this.titleFont = new Font(RenderingResources.serifFont, 32, FontStyle.Plain);
            /**
             * Gets or sets the font to use for displaying the songs subtitle in the header of the music sheet.
             */
            this.subTitleFont = new Font(RenderingResources.serifFont, 20, FontStyle.Plain);
            /**
             * Gets or sets the font to use for displaying the lyrics information in the header of the music sheet.
             */
            this.wordsFont = new Font(RenderingResources.serifFont, 15, FontStyle.Plain);
            /**
             * Gets or sets the font to use for displaying certain effect related elements in the music sheet.
             */
            this.effectFont = new Font(RenderingResources.serifFont, 12, FontStyle.Italic);
            /**
             * Gets or sets the font to use for displaying the fretboard numbers in chord diagrams.
             */
            this.fretboardNumberFont = new Font(RenderingResources.sansFont, 11, FontStyle.Plain);
            /**
             * Gets or sets the font to use for displaying the guitar tablature numbers in the music sheet.
             */
            this.tablatureFont = new Font(RenderingResources.sansFont, 13, FontStyle.Plain);
            /**
             * Gets or sets the font to use for grace notation related texts in the music sheet.
             */
            this.graceFont = new Font(RenderingResources.sansFont, 11, FontStyle.Plain);
            /**
             * Gets or sets the color to use for rendering the lines of staves.
             */
            this.staffLineColor = new Color(165, 165, 165, 0xff);
            /**
             * Gets or sets the color to use for rendering bar separators, the accolade and repeat signs.
             */
            this.barSeparatorColor = new Color(34, 34, 17, 0xff);
            /**
             * Gets or sets the font to use for displaying the bar numbers above the music sheet.
             */
            this.barNumberFont = new Font(RenderingResources.sansFont, 11, FontStyle.Plain);
            /**
             * Gets or sets the color to use for displaying the bar numbers above the music sheet.
             */
            this.barNumberColor = new Color(200, 0, 0, 0xff);
            /**
             * Gets or sets the font to use for displaying finger information in the music sheet.
             */
            this.fingeringFont = new Font(RenderingResources.serifFont, 14, FontStyle.Plain);
            /**
             * Gets or sets the font to use for section marker labels shown above the music sheet.
             */
            this.markerFont = new Font(RenderingResources.serifFont, 14, FontStyle.Bold);
            /**
             * Gets or sets the color to use for music notation elements of the primary voice.
             */
            this.mainGlyphColor = new Color(0, 0, 0, 0xff);
            /**
             * Gets or sets the color to use for music notation elements of the secondary voices.
             */
            this.secondaryGlyphColor = new Color(0, 0, 0, 100);
            /**
             * Gets or sets the color to use for displaying the song information above the music sheet.
             */
            this.scoreInfoColor = new Color(0, 0, 0, 0xff);
        }
        RenderingResources.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        RenderingResources.prototype.fillToJson = function (json) { json.copyrightFont = (Font.toJson(this.copyrightFont)); json.titleFont = (Font.toJson(this.titleFont)); json.subTitleFont = (Font.toJson(this.subTitleFont)); json.wordsFont = (Font.toJson(this.wordsFont)); json.effectFont = (Font.toJson(this.effectFont)); json.fretboardNumberFont = (Font.toJson(this.fretboardNumberFont)); json.tablatureFont = (Font.toJson(this.tablatureFont)); json.graceFont = (Font.toJson(this.graceFont)); json.staffLineColor = (Color.toJson(this.staffLineColor)); json.barSeparatorColor = (Color.toJson(this.barSeparatorColor)); json.barNumberFont = (Font.toJson(this.barNumberFont)); json.barNumberColor = (Color.toJson(this.barNumberColor)); json.fingeringFont = (Font.toJson(this.fingeringFont)); json.markerFont = (Font.toJson(this.markerFont)); json.mainGlyphColor = (Color.toJson(this.mainGlyphColor)); json.secondaryGlyphColor = (Color.toJson(this.secondaryGlyphColor)); json.scoreInfoColor = (Color.toJson(this.scoreInfoColor)); };
        RenderingResources.fromJson = function (json) { if (!json)
            return null; var obj = new RenderingResources(); obj.fillFromJson(json); return obj; };
        RenderingResources.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        RenderingResources.prototype.setProperty = function (property, value) { switch (property) {
            case "copyrightfont":
                this.copyrightFont = (Font.fromJson(value));
                return true;
            case "titlefont":
                this.titleFont = (Font.fromJson(value));
                return true;
            case "subtitlefont":
                this.subTitleFont = (Font.fromJson(value));
                return true;
            case "wordsfont":
                this.wordsFont = (Font.fromJson(value));
                return true;
            case "effectfont":
                this.effectFont = (Font.fromJson(value));
                return true;
            case "fretboardnumberfont":
                this.fretboardNumberFont = (Font.fromJson(value));
                return true;
            case "tablaturefont":
                this.tablatureFont = (Font.fromJson(value));
                return true;
            case "gracefont":
                this.graceFont = (Font.fromJson(value));
                return true;
            case "stafflinecolor":
                this.staffLineColor = (Color.fromJson(value));
                return true;
            case "barseparatorcolor":
                this.barSeparatorColor = (Color.fromJson(value));
                return true;
            case "barnumberfont":
                this.barNumberFont = (Font.fromJson(value));
                return true;
            case "barnumbercolor":
                this.barNumberColor = (Color.fromJson(value));
                return true;
            case "fingeringfont":
                this.fingeringFont = (Font.fromJson(value));
                return true;
            case "markerfont":
                this.markerFont = (Font.fromJson(value));
                return true;
            case "mainglyphcolor":
                this.mainGlyphColor = (Color.fromJson(value));
                return true;
            case "secondaryglyphcolor":
                this.secondaryGlyphColor = (Color.fromJson(value));
                return true;
            case "scoreinfocolor":
                this.scoreInfoColor = (Color.fromJson(value));
                return true;
        } return false; };
        RenderingResources.sansFont = 'Arial';
        RenderingResources.serifFont = 'Georgia';
        return RenderingResources;
    }());

    (function (StaveProfile) {
        /**
         * The profile is auto detected by the track configurations.
         */
        StaveProfile[StaveProfile["Default"] = 0] = "Default";
        /**
         * Standard music notation and guitar tablature are rendered.
         */
        StaveProfile[StaveProfile["ScoreTab"] = 1] = "ScoreTab";
        /**
         * Only standard music notation is rendered.
         */
        StaveProfile[StaveProfile["Score"] = 2] = "Score";
        /**
         * Only guitar tablature is rendered.
         */
        StaveProfile[StaveProfile["Tab"] = 3] = "Tab";
        /**
         * Only guitar tablature is rendered, but also rests and time signatures are not shown.
         * This profile is typically used in multi-track scenarios.
         */
        StaveProfile[StaveProfile["TabMixed"] = 4] = "TabMixed";
    })(exports.StaveProfile || (exports.StaveProfile = {}));
    (function (LayoutMode) {
        /**
         * Bars are aligned in rows using a fixed width.
         */
        LayoutMode[LayoutMode["Page"] = 0] = "Page";
        /**
         * Bars are aligned horizontally in one row
         */
        LayoutMode[LayoutMode["Horizontal"] = 1] = "Horizontal";
    })(exports.LayoutMode || (exports.LayoutMode = {}));
    /**
     * The display settings control how the general layout and display of alphaTab is done.
     * @json
     */
    var DisplaySettings = /** @class */ (function () {
        function DisplaySettings() {
            /**
             * Sets the zoom level of the rendered notation
             */
            this.scale = 1.0;
            /**
             * The default stretch force to use for layouting.
             */
            this.stretchForce = 1.0;
            /**
             * The layouting mode used to arrange the the notation.
             */
            this.layoutMode = exports.LayoutMode.Page;
            /**
             * The stave profile to use.
             */
            this.staveProfile = exports.StaveProfile.Default;
            /**
             * Limit the displayed bars per row.
             */
            this.barsPerRow = -1;
            /**
             * The bar start number to start layouting with. Note that this is the bar number and not an index!
             */
            this.startBar = 1;
            /**
             * The amount of bars to render overall.
             */
            this.barCount = -1;
            /**
             * The number of bars that should be rendered per partial. This setting is not used by all layouts.
             */
            this.barCountPerPartial = 10;
            /**
             * Gets or sets the resources used during rendering. This defines all fonts and colors used.
             */
            this.resources = new RenderingResources();
            /**
             * Gets or sets the padding between the music notation and the border.
             */
            this.padding = null;
        }
        DisplaySettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        DisplaySettings.prototype.fillToJson = function (json) { json.scale = this.scale; json.stretchForce = this.stretchForce; json.layoutMode = this.layoutMode; json.staveProfile = this.staveProfile; json.barsPerRow = this.barsPerRow; json.startBar = this.startBar; json.barCount = this.barCount; json.barCountPerPartial = this.barCountPerPartial; if (json.resources)
            this.resources.fillToJson(json.resources);
        else
            json.resources = (RenderingResources.toJson(this.resources)); json.padding = this.padding ? this.padding.slice() : null; };
        DisplaySettings.fromJson = function (json) { if (!json)
            return null; var obj = new DisplaySettings(); obj.fillFromJson(json); return obj; };
        DisplaySettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        DisplaySettings.prototype.setProperty = function (property, value) { switch (property) {
            case "scale":
                this.scale = value;
                return true;
            case "stretchforce":
                this.stretchForce = value;
                return true;
            case "layoutmode":
                this.layoutMode = isNaN(parseInt(value)) ? exports.LayoutMode[Object.keys(exports.LayoutMode).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "staveprofile":
                this.staveProfile = isNaN(parseInt(value)) ? exports.StaveProfile[Object.keys(exports.StaveProfile).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "barsperrow":
                this.barsPerRow = value;
                return true;
            case "startbar":
                this.startBar = value;
                return true;
            case "barcount":
                this.barCount = value;
                return true;
            case "barcountperpartial":
                this.barCountPerPartial = value;
                return true;
            case "padding":
                this.padding = value ? value.slice() : null;
                return true;
        } if (["resources"].indexOf(property) >= 0) {
            if (this.resources)
                this.resources.fillFromJson(value);
            else
                this.resources = (RenderingResources.fromJson(value));
            return true;
        }
        else {
            for (var _i = 0, _a = ["resources"]; _i < _a.length; _i++) {
                var $c = _a[_i];
                if (property.indexOf($c) === 0) {
                    if (!this.resources)
                        this.resources = new RenderingResources();
                    if (this.resources.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } return false; };
        return DisplaySettings;
    }());

    /**
     * This is the base public class for creating new song importers which
     * enable reading scores from any binary datasource
     */
    var ScoreImporter = /** @class */ (function () {
        function ScoreImporter() {
        }
        /**
         * Initializes the importer with the given data and settings.
         */
        ScoreImporter.prototype.init = function (data, settings) {
            this.data = data;
            this.settings = settings;
        };
        return ScoreImporter;
    }());

    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * The exception thrown by a {@link ScoreImporter} in case the
     * binary data does not contain a reader compatible structure.
     */
    var UnsupportedFormatError = /** @class */ (function (_super) {
        __extends$2(UnsupportedFormatError, _super);
        function UnsupportedFormatError(message, inner) {
            if (message === void 0) { message = 'Unsupported format'; }
            if (inner === void 0) { inner = null; }
            var _this = _super.call(this, exports.AlphaTabErrorType.Format, message) || this;
            _this.inner = inner;
            Object.setPrototypeOf(_this, UnsupportedFormatError.prototype);
            return _this;
        }
        return UnsupportedFormatError;
    }(AlphaTabError));

    /**
     * Lists all types of note acceuntations
     */
    var AccentuationType;
    (function (AccentuationType) {
        /**
         * No accentuation
         */
        AccentuationType[AccentuationType["None"] = 0] = "None";
        /**
         * Normal accentuation
         */
        AccentuationType[AccentuationType["Normal"] = 1] = "Normal";
        /**
         * Heavy accentuation
         */
        AccentuationType[AccentuationType["Heavy"] = 2] = "Heavy";
    })(AccentuationType || (AccentuationType = {}));

    /**
     * This public enumeration lists all types of automations.
     */
    var AutomationType;
    (function (AutomationType) {
        /**
         * Tempo change.
         */
        AutomationType[AutomationType["Tempo"] = 0] = "Tempo";
        /**
         * Colume change.
         */
        AutomationType[AutomationType["Volume"] = 1] = "Volume";
        /**
         * Instrument change.
         */
        AutomationType[AutomationType["Instrument"] = 2] = "Instrument";
        /**
         * Balance change.
         */
        AutomationType[AutomationType["Balance"] = 3] = "Balance";
    })(AutomationType || (AutomationType = {}));
    /**
     * Automations are used to change the behaviour of a song.
     */
    var Automation = /** @class */ (function () {
        function Automation() {
            /**
             * Gets or sets whether the automation is applied linear.
             */
            this.isLinear = false;
            /**
             * Gets or sets the type of the automation.
             */
            this.type = AutomationType.Tempo;
            /**
             * Gets or sets the target value of the automation.
             */
            this.value = 0;
            /**
             * Gets or sets the relative position of of the automation.
             */
            this.ratioPosition = 0;
            /**
             * Gets or sets the additional text of the automation.
             */
            this.text = '';
        }
        Automation.buildTempoAutomation = function (isLinear, ratioPosition, value, reference) {
            if (reference < 1 || reference > 5) {
                reference = 2;
            }
            var references = new Float32Array([1, 0.5, 1.0, 1.5, 2.0, 3.0]);
            var automation = new Automation();
            automation.type = AutomationType.Tempo;
            automation.isLinear = isLinear;
            automation.ratioPosition = ratioPosition;
            automation.value = value * references[reference];
            return automation;
        };
        Automation.copyTo = function (src, dst) {
            dst.isLinear = src.isLinear;
            dst.ratioPosition = src.ratioPosition;
            dst.text = src.text;
            dst.type = src.type;
            dst.value = src.value;
        };
        Automation.prototype.clone = function () {
            var a = new Automation();
            Automation.copyTo(this, a);
            return a;
        };
        return Automation;
    }());

    /**
     * This public enumeration lists all supported Clefs.
     */
    var Clef;
    (function (Clef) {
        /**
         * Neutral clef.
         */
        Clef[Clef["Neutral"] = 0] = "Neutral";
        /**
         * C3 clef
         */
        Clef[Clef["C3"] = 1] = "C3";
        /**
         * C4 clef
         */
        Clef[Clef["C4"] = 2] = "C4";
        /**
         * F4 clef
         */
        Clef[Clef["F4"] = 3] = "F4";
        /**
         * G2 clef
         */
        Clef[Clef["G2"] = 4] = "G2";
    })(Clef || (Clef = {}));

    /**
     * Lists all ottavia.
     */
    var Ottavia;
    (function (Ottavia) {
        /**
         * 2 octaves higher
         */
        Ottavia[Ottavia["_15ma"] = 0] = "_15ma";
        /**
         * 1 octave higher
         */
        Ottavia[Ottavia["_8va"] = 1] = "_8va";
        /**
         * Normal
         */
        Ottavia[Ottavia["Regular"] = 2] = "Regular";
        /**
         * 1 octave lower
         */
        Ottavia[Ottavia["_8vb"] = 3] = "_8vb";
        /**
         * 2 octaves lower.
         */
        Ottavia[Ottavia["_15mb"] = 4] = "_15mb";
    })(Ottavia || (Ottavia = {}));

    /**
     * Lists all simile mark types as they are assigned to bars.
     */
    var SimileMark;
    (function (SimileMark) {
        /**
         * No simile mark is applied
         */
        SimileMark[SimileMark["None"] = 0] = "None";
        /**
         * A simple simile mark. The previous bar is repeated.
         */
        SimileMark[SimileMark["Simple"] = 1] = "Simple";
        /**
         * A double simile mark. This value is assigned to the first
         * bar of the 2 repeat bars.
         */
        SimileMark[SimileMark["FirstOfDouble"] = 2] = "FirstOfDouble";
        /**
         * A double simile mark. This value is assigned to the second
         * bar of the 2 repeat bars.
         */
        SimileMark[SimileMark["SecondOfDouble"] = 3] = "SecondOfDouble";
    })(SimileMark || (SimileMark = {}));

    /**
     * A bar is a single block within a track, also known as Measure.
     */
    var Bar = /** @class */ (function () {
        function Bar() {
            /**
             * Gets or sets the unique id of this bar.
             */
            this.id = Bar._globalBarId++;
            /**
             * Gets or sets the zero-based index of this bar within the staff.
             */
            this.index = 0;
            /**
             * Gets or sets the next bar that comes after this bar.
             */
            this.nextBar = null;
            /**
             * Gets or sets the previous bar that comes before this bar.
             */
            this.previousBar = null;
            /**
             * Gets or sets the clef on this bar.
             */
            this.clef = Clef.G2;
            /**
             * Gets or sets the ottava applied to the clef.
             */
            this.clefOttava = Ottavia.Regular;
            /**
             * Gets or sets the list of voices contained in this bar.
             */
            this.voices = [];
            /**
             * Gets or sets the simile mark on this bar.
             */
            this.simileMark = SimileMark.None;
        }
        Object.defineProperty(Bar.prototype, "masterBar", {
            get: function () {
                return this.staff.track.score.masterBars[this.index];
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Bar.prototype, "isEmpty", {
            get: function () {
                for (var i = 0, j = this.voices.length; i < j; i++) {
                    if (!this.voices[i].isEmpty) {
                        return false;
                    }
                }
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Bar.copyTo = function (src, dst) {
            dst.id = src.id;
            dst.index = src.index;
            dst.clef = src.clef;
            dst.clefOttava = src.clefOttava;
            dst.simileMark = src.simileMark;
        };
        Bar.prototype.addVoice = function (voice) {
            voice.bar = this;
            voice.index = this.voices.length;
            this.voices.push(voice);
        };
        Bar.prototype.finish = function (settings) {
            for (var i = 0, j = this.voices.length; i < j; i++) {
                var voice = this.voices[i];
                voice.finish(settings);
            }
        };
        Bar.prototype.calculateDuration = function () {
            var duration = 0;
            for (var _i = 0, _a = this.voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                var voiceDuration = voice.calculateDuration();
                if (voiceDuration > duration) {
                    duration = voiceDuration;
                }
            }
            return duration;
        };
        Bar._globalBarId = 0;
        return Bar;
    }());

    var MidiUtils = /** @class */ (function () {
        function MidiUtils() {
        }
        /**
         * Converts the given midi tick duration into milliseconds.
         * @param ticks The duration in midi ticks
         * @param tempo The current tempo in BPM.
         * @returns The converted duration in milliseconds.
         */
        MidiUtils.ticksToMillis = function (ticks, tempo) {
            return (ticks * (60000.0 / (tempo * MidiUtils.QuarterTime))) | 0;
        };
        /**
         * Converts the given midi tick duration into milliseconds.
         * @param millis The duration in milliseconds
         * @param tempo The current tempo in BPM.
         * @returns The converted duration in midi ticks.
         */
        MidiUtils.millisToTicks = function (millis, tempo) {
            return (millis / (60000.0 / (tempo * MidiUtils.QuarterTime))) | 0;
        };
        /**
         * Converts a duration value to its ticks equivalent.
         */
        MidiUtils.toTicks = function (duration) {
            return MidiUtils.valueToTicks(duration);
        };
        /**
         * Converts a numerical value to its ticks equivalent.
         * @param duration the numerical proportion to convert. (i.E. timesignature denominator, note duration,...)
         */
        MidiUtils.valueToTicks = function (duration) {
            var denomninator = duration;
            if (denomninator < 0) {
                denomninator = 1 / -denomninator;
            }
            return (MidiUtils.QuarterTime * (4.0 / denomninator)) | 0;
        };
        MidiUtils.applyDot = function (ticks, doubleDotted) {
            if (doubleDotted) {
                return ticks + ((ticks / 4) | 0) * 3;
            }
            return ticks + ((ticks / 2) | 0);
        };
        MidiUtils.applyTuplet = function (ticks, numerator, denominator) {
            return ((ticks * denominator) / numerator) | 0;
        };
        MidiUtils.removeTuplet = function (ticks, numerator, denominator) {
            return ((ticks * numerator) / denominator) | 0;
        };
        MidiUtils.dynamicToVelocity = function (dyn) {
            return MidiUtils.MinVelocity + dyn * MidiUtils.VelocityIncrement;
        };
        MidiUtils.QuarterTime = 960;
        MidiUtils.MinVelocity = 15;
        MidiUtils.VelocityIncrement = 16;
        return MidiUtils;
    }());

    /**
     * A single point of a bending graph. Used to
     * describe WhammyBar and String Bending effects.
     */
    var BendPoint = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link BendPoint} class.
         * @param offset The offset.
         * @param value The value.
         */
        function BendPoint(offset, value) {
            if (offset === void 0) { offset = 0; }
            if (value === void 0) { value = 0; }
            this.offset = offset;
            this.value = value;
        }
        BendPoint.copyTo = function (src, dst) {
            dst.offset = src.offset;
            dst.value = src.value;
        };
        BendPoint.prototype.clone = function () {
            var point = new BendPoint(0, 0);
            BendPoint.copyTo(this, point);
            return point;
        };
        BendPoint.MaxPosition = 60;
        BendPoint.MaxValue = 12;
        return BendPoint;
    }());

    /**
     * Lists the different bend styles
     */
    var BendStyle;
    (function (BendStyle) {
        /**
         * The bends are as described by the bend points
         */
        BendStyle[BendStyle["Default"] = 0] = "Default";
        /**
         * The bends are gradual over the beat duration.
         */
        BendStyle[BendStyle["Gradual"] = 1] = "Gradual";
        /**
         * The bends are done fast before the next note.
         */
        BendStyle[BendStyle["Fast"] = 2] = "Fast";
    })(BendStyle || (BendStyle = {}));

    /**
     * Lists all types of bends
     */
    var BendType;
    (function (BendType) {
        /**
         * No bend at all
         */
        BendType[BendType["None"] = 0] = "None";
        /**
         * Individual points define the bends in a flexible manner.
         * This system was mainly used in Guitar Pro 3-5
         */
        BendType[BendType["Custom"] = 1] = "Custom";
        /**
         * Simple Bend from an unbended string to a higher note.
         */
        BendType[BendType["Bend"] = 2] = "Bend";
        /**
         * Release of a bend that was started on an earlier note.
         */
        BendType[BendType["Release"] = 3] = "Release";
        /**
         * A bend that starts from an unbended string,
         * and also releases the bend after some time.
         */
        BendType[BendType["BendRelease"] = 4] = "BendRelease";
        /**
         * Holds a bend that was started on an earlier note
         */
        BendType[BendType["Hold"] = 5] = "Hold";
        /**
         * A bend that is already started before the note is played then it is held until the end.
         */
        BendType[BendType["Prebend"] = 6] = "Prebend";
        /**
         * A bend that is already started before the note is played and
         * bends even further, then it is held until the end.
         */
        BendType[BendType["PrebendBend"] = 7] = "PrebendBend";
        /**
         * A bend that is already started before the note is played and
         * then releases the bend to a lower note where it is held until the end.
         */
        BendType[BendType["PrebendRelease"] = 8] = "PrebendRelease";
    })(BendType || (BendType = {}));

    /**
     * Lists all types of how to brush multiple notes on a beat.
     */
    var BrushType;
    (function (BrushType) {
        /**
         * No brush.
         */
        BrushType[BrushType["None"] = 0] = "None";
        /**
         * Normal brush up.
         */
        BrushType[BrushType["BrushUp"] = 1] = "BrushUp";
        /**
         * Normal brush down.
         */
        BrushType[BrushType["BrushDown"] = 2] = "BrushDown";
        /**
         * Arpeggio up.
         */
        BrushType[BrushType["ArpeggioUp"] = 3] = "ArpeggioUp";
        /**
         * Arpeggio down.
         */
        BrushType[BrushType["ArpeggioDown"] = 4] = "ArpeggioDown";
    })(BrushType || (BrushType = {}));

    /**
     * Lists all Crescendo and Decrescendo types.
     */
    var CrescendoType;
    (function (CrescendoType) {
        /**
         * No crescendo applied.
         */
        CrescendoType[CrescendoType["None"] = 0] = "None";
        /**
         * Normal crescendo applied.
         */
        CrescendoType[CrescendoType["Crescendo"] = 1] = "Crescendo";
        /**
         * Normal decrescendo applied.
         */
        CrescendoType[CrescendoType["Decrescendo"] = 2] = "Decrescendo";
    })(CrescendoType || (CrescendoType = {}));

    /**
     * Lists all durations of a beat.
     */
    var Duration;
    (function (Duration) {
        /**
         * A quadruple whole note duration
         */
        Duration[Duration["QuadrupleWhole"] = -4] = "QuadrupleWhole";
        /**
         * A double whole note duration
         */
        Duration[Duration["DoubleWhole"] = -2] = "DoubleWhole";
        /**
         * A whole note duration
         */
        Duration[Duration["Whole"] = 1] = "Whole";
        /**
         * A 1/2 note duration
         */
        Duration[Duration["Half"] = 2] = "Half";
        /**
         * A 1/4 note duration
         */
        Duration[Duration["Quarter"] = 4] = "Quarter";
        /**
         * A 1/8 note duration
         */
        Duration[Duration["Eighth"] = 8] = "Eighth";
        /**
         * A 1/16 note duration
         */
        Duration[Duration["Sixteenth"] = 16] = "Sixteenth";
        /**
         * A 1/32 note duration
         */
        Duration[Duration["ThirtySecond"] = 32] = "ThirtySecond";
        /**
         * A 1/64 note duration
         */
        Duration[Duration["SixtyFourth"] = 64] = "SixtyFourth";
        /**
         * A 1/128 note duration
         */
        Duration[Duration["OneHundredTwentyEighth"] = 128] = "OneHundredTwentyEighth";
        /**
         * A 1/256 note duration
         */
        Duration[Duration["TwoHundredFiftySixth"] = 256] = "TwoHundredFiftySixth";
    })(Duration || (Duration = {}));

    /**
     * Lists all dynamics.
     */
    var DynamicValue;
    (function (DynamicValue) {
        /**
         * pianississimo (very very soft)
         */
        DynamicValue[DynamicValue["PPP"] = 0] = "PPP";
        /**
         * pianissimo (very soft)
         */
        DynamicValue[DynamicValue["PP"] = 1] = "PP";
        /**
         * piano (soft)
         */
        DynamicValue[DynamicValue["P"] = 2] = "P";
        /**
         * mezzo-piano (half soft)
         */
        DynamicValue[DynamicValue["MP"] = 3] = "MP";
        /**
         * mezzo-forte (half loud)
         */
        DynamicValue[DynamicValue["MF"] = 4] = "MF";
        /**
         * forte (loud)
         */
        DynamicValue[DynamicValue["F"] = 5] = "F";
        /**
         * fortissimo (very loud)
         */
        DynamicValue[DynamicValue["FF"] = 6] = "FF";
        /**
         * fortississimo (very very loud)
         */
        DynamicValue[DynamicValue["FFF"] = 7] = "FFF";
    })(DynamicValue || (DynamicValue = {}));

    /**
     * Lists all types of grace notes
     */
    var GraceType;
    (function (GraceType) {
        /**
         * No grace, normal beat.
         */
        GraceType[GraceType["None"] = 0] = "None";
        /**
         * The beat contains on-beat grace notes.
         */
        GraceType[GraceType["OnBeat"] = 1] = "OnBeat";
        /**
         * The beat contains before-beat grace notes.
         */
        GraceType[GraceType["BeforeBeat"] = 2] = "BeforeBeat";
        /**
         * The beat contains very special bend-grace notes used in SongBook style displays.
         */
        GraceType[GraceType["BendGrace"] = 3] = "BendGrace";
    })(GraceType || (GraceType = {}));

    /**
     * Lists all harmonic types.
     */
    var HarmonicType;
    (function (HarmonicType) {
        /**
         * No harmonics.
         */
        HarmonicType[HarmonicType["None"] = 0] = "None";
        /**
         * Natural harmonic
         */
        HarmonicType[HarmonicType["Natural"] = 1] = "Natural";
        /**
         * Artificial harmonic
         */
        HarmonicType[HarmonicType["Artificial"] = 2] = "Artificial";
        /**
         * Pinch harmonics
         */
        HarmonicType[HarmonicType["Pinch"] = 3] = "Pinch";
        /**
         * Tap harmonics
         */
        HarmonicType[HarmonicType["Tap"] = 4] = "Tap";
        /**
         * Semi harmonics
         */
        HarmonicType[HarmonicType["Semi"] = 5] = "Semi";
        /**
         * Feedback harmonics
         */
        HarmonicType[HarmonicType["Feedback"] = 6] = "Feedback";
    })(HarmonicType || (HarmonicType = {}));

    /**
     * Lists the modes how accidentals are handled for notes
     */
    var NoteAccidentalMode;
    (function (NoteAccidentalMode) {
        /**
         * Accidentals are calculated automatically.
         */
        NoteAccidentalMode[NoteAccidentalMode["Default"] = 0] = "Default";
        /**
         * If the default behavior calculates a Sharp, use flat instead (and vice versa).
         */
        NoteAccidentalMode[NoteAccidentalMode["SwapAccidentals"] = 1] = "SwapAccidentals";
        /**
         * This will try to ensure that no accidental is shown.
         */
        NoteAccidentalMode[NoteAccidentalMode["ForceNone"] = 2] = "ForceNone";
        /**
         * This will move the note one line down and applies a Naturalize.
         */
        NoteAccidentalMode[NoteAccidentalMode["ForceNatural"] = 3] = "ForceNatural";
        /**
         * This will move the note one line down and applies a Sharp.
         */
        NoteAccidentalMode[NoteAccidentalMode["ForceSharp"] = 4] = "ForceSharp";
        /**
         * This will move the note to be shown 2 half-notes deeper with a double sharp symbol
         */
        NoteAccidentalMode[NoteAccidentalMode["ForceDoubleSharp"] = 5] = "ForceDoubleSharp";
        /**
         * This will move the note one line up and applies a Flat.
         */
        NoteAccidentalMode[NoteAccidentalMode["ForceFlat"] = 6] = "ForceFlat";
        /**
         * This will move the note two half notes up with a double flag symbol.
         */
        NoteAccidentalMode[NoteAccidentalMode["ForceDoubleFlat"] = 7] = "ForceDoubleFlat";
    })(NoteAccidentalMode || (NoteAccidentalMode = {}));

    /**
     * This public enum lists all different types of finger slide-ins on a string.
     */
    var SlideInType;
    (function (SlideInType) {
        /**
         * No slide.
         */
        SlideInType[SlideInType["None"] = 0] = "None";
        /**
         * Slide into the note from below on the same string.
         */
        SlideInType[SlideInType["IntoFromBelow"] = 1] = "IntoFromBelow";
        /**
         * Slide into the note from above on the same string.
         */
        SlideInType[SlideInType["IntoFromAbove"] = 2] = "IntoFromAbove";
    })(SlideInType || (SlideInType = {}));

    /**
     * This public enum lists all different types of finger slide-outs on a string.
     */
    var SlideOutType;
    (function (SlideOutType) {
        /**
         * No slide.
         */
        SlideOutType[SlideOutType["None"] = 0] = "None";
        /**
         * Shift slide to next note on same string
         */
        SlideOutType[SlideOutType["Shift"] = 1] = "Shift";
        /**
         * Legato slide to next note on same string.
         */
        SlideOutType[SlideOutType["Legato"] = 2] = "Legato";
        /**
         * Slide out from the note from upwards on the same string.
         */
        SlideOutType[SlideOutType["OutUp"] = 3] = "OutUp";
        /**
         * Slide out from the note from downwards on the same string.
         */
        SlideOutType[SlideOutType["OutDown"] = 4] = "OutDown";
        /**
         * Pickslide down on this note
         */
        SlideOutType[SlideOutType["PickSlideDown"] = 5] = "PickSlideDown";
        /**
         * Pickslide up on this note
         */
        SlideOutType[SlideOutType["PickSlideUp"] = 6] = "PickSlideUp";
    })(SlideOutType || (SlideOutType = {}));

    /**
     * This public enum lists all vibrato types that can be performed.
     */
    var VibratoType;
    (function (VibratoType) {
        /**
         * No vibrato.
         */
        VibratoType[VibratoType["None"] = 0] = "None";
        /**
         * A slight vibrato.
         */
        VibratoType[VibratoType["Slight"] = 1] = "Slight";
        /**
         * A wide vibrato.
         */
        VibratoType[VibratoType["Wide"] = 2] = "Wide";
    })(VibratoType || (VibratoType = {}));

    /**
     * @target web
     */
    var Lazy = /** @class */ (function () {
        function Lazy(factory) {
            this._value = undefined;
            this._factory = factory;
        }
        Object.defineProperty(Lazy.prototype, "value", {
            get: function () {
                if (this._value === undefined) {
                    this._value = this._factory();
                }
                return this._value;
            },
            enumerable: false,
            configurable: true
        });
        return Lazy;
    }());

    /**
     * Defines all loglevels.
     * @json
     */
    (function (LogLevel) {
        /**
         * No logging
         */
        LogLevel[LogLevel["None"] = 0] = "None";
        /**
         * Debug level (internal details are displayed).
         */
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        /**
         * Info level (only important details are shown)
         */
        LogLevel[LogLevel["Info"] = 2] = "Info";
        /**
         * Warning level
         */
        LogLevel[LogLevel["Warning"] = 3] = "Warning";
        /**
         * Error level.
         */
        LogLevel[LogLevel["Error"] = 4] = "Error";
    })(exports.LogLevel || (exports.LogLevel = {}));

    var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    var ConsoleLogger = /** @class */ (function () {
        function ConsoleLogger() {
        }
        ConsoleLogger.format = function (category, msg) {
            return "[AlphaTab][" + category + "] " + msg;
        };
        ConsoleLogger.prototype.debug = function (category, msg) {
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            console.debug.apply(console, __spreadArrays([ConsoleLogger.format(category, msg)], details));
        };
        ConsoleLogger.prototype.warning = function (category, msg) {
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            console.warn.apply(console, __spreadArrays([ConsoleLogger.format(category, msg)], details));
        };
        ConsoleLogger.prototype.info = function (category, msg) {
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            console.info.apply(console, __spreadArrays([ConsoleLogger.format(category, msg)], details));
        };
        ConsoleLogger.prototype.error = function (category, msg) {
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            console.error.apply(console, __spreadArrays([ConsoleLogger.format(category, msg)], details));
        };
        ConsoleLogger.logLevel = exports.LogLevel.Info;
        return ConsoleLogger;
    }());
    var Logger = /** @class */ (function () {
        function Logger() {
        }
        Logger.shouldLog = function (level) {
            return Logger.logLevel !== exports.LogLevel.None && level >= Logger.logLevel;
        };
        Logger.debug = function (category, msg) {
            var _a;
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            if (Logger.shouldLog(exports.LogLevel.Debug)) {
                (_a = Logger.log).debug.apply(_a, __spreadArrays([category, msg], details));
            }
        };
        Logger.warning = function (category, msg) {
            var _a;
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            if (Logger.shouldLog(exports.LogLevel.Warning)) {
                (_a = Logger.log).warning.apply(_a, __spreadArrays([category, msg], details));
            }
        };
        Logger.info = function (category, msg) {
            var _a;
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            if (Logger.shouldLog(exports.LogLevel.Info)) {
                (_a = Logger.log).info.apply(_a, __spreadArrays([category, msg], details));
            }
        };
        Logger.error = function (category, msg) {
            var _a;
            var details = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                details[_i - 2] = arguments[_i];
            }
            if (Logger.shouldLog(exports.LogLevel.Error)) {
                (_a = Logger.log).error.apply(_a, __spreadArrays([category, msg], details));
            }
        };
        Logger.logLevel = exports.LogLevel.Info;
        Logger.log = new ConsoleLogger();
        return Logger;
    }());

    /**
     * Lists all types of pick strokes.
     */
    var PickStroke;
    (function (PickStroke) {
        /**
         * No pickstroke used.
         */
        PickStroke[PickStroke["None"] = 0] = "None";
        /**
         * Pickstroke up.
         */
        PickStroke[PickStroke["Up"] = 1] = "Up";
        /**
         * Pickstroke down
         */
        PickStroke[PickStroke["Down"] = 2] = "Down";
    })(PickStroke || (PickStroke = {}));

    /**
     * Lists all music font symbols used within alphaTab. The names
     * and values are aligned with the SMuFL standard.
     */
    var MusicFontSymbol;
    (function (MusicFontSymbol) {
        MusicFontSymbol[MusicFontSymbol["None"] = -1] = "None";
        MusicFontSymbol[MusicFontSymbol["GClef"] = 57424] = "GClef";
        MusicFontSymbol[MusicFontSymbol["CClef"] = 57436] = "CClef";
        MusicFontSymbol[MusicFontSymbol["FClef"] = 57442] = "FClef";
        MusicFontSymbol[MusicFontSymbol["UnpitchedPercussionClef1"] = 57449] = "UnpitchedPercussionClef1";
        MusicFontSymbol[MusicFontSymbol["SixStringTabClef"] = 57453] = "SixStringTabClef";
        MusicFontSymbol[MusicFontSymbol["FourStringTabClef"] = 57454] = "FourStringTabClef";
        MusicFontSymbol[MusicFontSymbol["TimeSig0"] = 57472] = "TimeSig0";
        MusicFontSymbol[MusicFontSymbol["TimeSig1"] = 57473] = "TimeSig1";
        MusicFontSymbol[MusicFontSymbol["TimeSig2"] = 57474] = "TimeSig2";
        MusicFontSymbol[MusicFontSymbol["TimeSig3"] = 57475] = "TimeSig3";
        MusicFontSymbol[MusicFontSymbol["TimeSig4"] = 57476] = "TimeSig4";
        MusicFontSymbol[MusicFontSymbol["TimeSig5"] = 57477] = "TimeSig5";
        MusicFontSymbol[MusicFontSymbol["TimeSig6"] = 57478] = "TimeSig6";
        MusicFontSymbol[MusicFontSymbol["TimeSig7"] = 57479] = "TimeSig7";
        MusicFontSymbol[MusicFontSymbol["TimeSig8"] = 57480] = "TimeSig8";
        MusicFontSymbol[MusicFontSymbol["TimeSig9"] = 57481] = "TimeSig9";
        MusicFontSymbol[MusicFontSymbol["TimeSigCommon"] = 57482] = "TimeSigCommon";
        MusicFontSymbol[MusicFontSymbol["TimeSigCutCommon"] = 57483] = "TimeSigCutCommon";
        MusicFontSymbol[MusicFontSymbol["NoteheadDoubleWholeSquare"] = 57505] = "NoteheadDoubleWholeSquare";
        MusicFontSymbol[MusicFontSymbol["NoteheadDoubleWhole"] = 57504] = "NoteheadDoubleWhole";
        MusicFontSymbol[MusicFontSymbol["NoteheadWhole"] = 57506] = "NoteheadWhole";
        MusicFontSymbol[MusicFontSymbol["NoteheadHalf"] = 57507] = "NoteheadHalf";
        MusicFontSymbol[MusicFontSymbol["NoteheadBlack"] = 57508] = "NoteheadBlack";
        MusicFontSymbol[MusicFontSymbol["NoteheadNull"] = 57509] = "NoteheadNull";
        MusicFontSymbol[MusicFontSymbol["NoteheadXOrnate"] = 57514] = "NoteheadXOrnate";
        MusicFontSymbol[MusicFontSymbol["NoteheadTriangleUpWhole"] = 57531] = "NoteheadTriangleUpWhole";
        MusicFontSymbol[MusicFontSymbol["NoteheadTriangleUpHalf"] = 57532] = "NoteheadTriangleUpHalf";
        MusicFontSymbol[MusicFontSymbol["NoteheadTriangleUpBlack"] = 57534] = "NoteheadTriangleUpBlack";
        MusicFontSymbol[MusicFontSymbol["NoteheadDiamondBlackWide"] = 57564] = "NoteheadDiamondBlackWide";
        MusicFontSymbol[MusicFontSymbol["NoteheadDiamondWhite"] = 57565] = "NoteheadDiamondWhite";
        MusicFontSymbol[MusicFontSymbol["NoteheadDiamondWhiteWide"] = 57566] = "NoteheadDiamondWhiteWide";
        MusicFontSymbol[MusicFontSymbol["NoteheadCircleX"] = 57523] = "NoteheadCircleX";
        MusicFontSymbol[MusicFontSymbol["NoteheadXWhole"] = 57511] = "NoteheadXWhole";
        MusicFontSymbol[MusicFontSymbol["NoteheadXHalf"] = 57512] = "NoteheadXHalf";
        MusicFontSymbol[MusicFontSymbol["NoteheadXBlack"] = 57513] = "NoteheadXBlack";
        MusicFontSymbol[MusicFontSymbol["NoteheadParenthesis"] = 57550] = "NoteheadParenthesis";
        MusicFontSymbol[MusicFontSymbol["NoteheadSlashedBlack2"] = 57552] = "NoteheadSlashedBlack2";
        MusicFontSymbol[MusicFontSymbol["NoteheadCircleSlash"] = 57591] = "NoteheadCircleSlash";
        MusicFontSymbol[MusicFontSymbol["NoteheadHeavyX"] = 57592] = "NoteheadHeavyX";
        MusicFontSymbol[MusicFontSymbol["NoteheadHeavyXHat"] = 57593] = "NoteheadHeavyXHat";
        MusicFontSymbol[MusicFontSymbol["NoteQuarterUp"] = 57813] = "NoteQuarterUp";
        MusicFontSymbol[MusicFontSymbol["NoteEighthUp"] = 57815] = "NoteEighthUp";
        MusicFontSymbol[MusicFontSymbol["Tremolo3"] = 57890] = "Tremolo3";
        MusicFontSymbol[MusicFontSymbol["Tremolo2"] = 57889] = "Tremolo2";
        MusicFontSymbol[MusicFontSymbol["Tremolo1"] = 57888] = "Tremolo1";
        MusicFontSymbol[MusicFontSymbol["FlagEighthUp"] = 57920] = "FlagEighthUp";
        MusicFontSymbol[MusicFontSymbol["FlagEighthDown"] = 57921] = "FlagEighthDown";
        MusicFontSymbol[MusicFontSymbol["FlagSixteenthUp"] = 57922] = "FlagSixteenthUp";
        MusicFontSymbol[MusicFontSymbol["FlagSixteenthDown"] = 57923] = "FlagSixteenthDown";
        MusicFontSymbol[MusicFontSymbol["FlagThirtySecondUp"] = 57924] = "FlagThirtySecondUp";
        MusicFontSymbol[MusicFontSymbol["FlagThirtySecondDown"] = 57925] = "FlagThirtySecondDown";
        MusicFontSymbol[MusicFontSymbol["FlagSixtyFourthUp"] = 57926] = "FlagSixtyFourthUp";
        MusicFontSymbol[MusicFontSymbol["FlagSixtyFourthDown"] = 57927] = "FlagSixtyFourthDown";
        MusicFontSymbol[MusicFontSymbol["FlagOneHundredTwentyEighthUp"] = 57928] = "FlagOneHundredTwentyEighthUp";
        MusicFontSymbol[MusicFontSymbol["FlagOneHundredTwentyEighthDown"] = 57929] = "FlagOneHundredTwentyEighthDown";
        MusicFontSymbol[MusicFontSymbol["FlagTwoHundredFiftySixthUp"] = 57930] = "FlagTwoHundredFiftySixthUp";
        MusicFontSymbol[MusicFontSymbol["FlagTwoHundredFiftySixthDown"] = 57931] = "FlagTwoHundredFiftySixthDown";
        MusicFontSymbol[MusicFontSymbol["AccidentalFlat"] = 57952] = "AccidentalFlat";
        MusicFontSymbol[MusicFontSymbol["AccidentalNatural"] = 57953] = "AccidentalNatural";
        MusicFontSymbol[MusicFontSymbol["AccidentalSharp"] = 57954] = "AccidentalSharp";
        MusicFontSymbol[MusicFontSymbol["AccidentalDoubleSharp"] = 57955] = "AccidentalDoubleSharp";
        MusicFontSymbol[MusicFontSymbol["AccidentalDoubleFlat"] = 57956] = "AccidentalDoubleFlat";
        MusicFontSymbol[MusicFontSymbol["AccidentalQuarterToneFlatArrowUp"] = 57968] = "AccidentalQuarterToneFlatArrowUp";
        MusicFontSymbol[MusicFontSymbol["AccidentalQuarterToneSharpArrowUp"] = 57972] = "AccidentalQuarterToneSharpArrowUp";
        MusicFontSymbol[MusicFontSymbol["AccidentalQuarterToneNaturalArrowUp"] = 57970] = "AccidentalQuarterToneNaturalArrowUp";
        MusicFontSymbol[MusicFontSymbol["ArticAccentAbove"] = 58528] = "ArticAccentAbove";
        MusicFontSymbol[MusicFontSymbol["ArticStaccatoAbove"] = 58530] = "ArticStaccatoAbove";
        MusicFontSymbol[MusicFontSymbol["ArticMarcatoAbove"] = 58540] = "ArticMarcatoAbove";
        MusicFontSymbol[MusicFontSymbol["FermataAbove"] = 58560] = "FermataAbove";
        MusicFontSymbol[MusicFontSymbol["FermataShortAbove"] = 58564] = "FermataShortAbove";
        MusicFontSymbol[MusicFontSymbol["FermataLongAbove"] = 58566] = "FermataLongAbove";
        MusicFontSymbol[MusicFontSymbol["RestLonga"] = 58593] = "RestLonga";
        MusicFontSymbol[MusicFontSymbol["RestDoubleWhole"] = 58594] = "RestDoubleWhole";
        MusicFontSymbol[MusicFontSymbol["RestWhole"] = 58595] = "RestWhole";
        MusicFontSymbol[MusicFontSymbol["RestHalf"] = 58596] = "RestHalf";
        MusicFontSymbol[MusicFontSymbol["RestQuarter"] = 58597] = "RestQuarter";
        MusicFontSymbol[MusicFontSymbol["RestEighth"] = 58598] = "RestEighth";
        MusicFontSymbol[MusicFontSymbol["RestSixteenth"] = 58599] = "RestSixteenth";
        MusicFontSymbol[MusicFontSymbol["RestThirtySecond"] = 58600] = "RestThirtySecond";
        MusicFontSymbol[MusicFontSymbol["RestSixtyFourth"] = 58601] = "RestSixtyFourth";
        MusicFontSymbol[MusicFontSymbol["RestOneHundredTwentyEighth"] = 58602] = "RestOneHundredTwentyEighth";
        MusicFontSymbol[MusicFontSymbol["RestTwoHundredFiftySixth"] = 58603] = "RestTwoHundredFiftySixth";
        MusicFontSymbol[MusicFontSymbol["Repeat1Bar"] = 58624] = "Repeat1Bar";
        MusicFontSymbol[MusicFontSymbol["Repeat2Bars"] = 58625] = "Repeat2Bars";
        MusicFontSymbol[MusicFontSymbol["Ottava"] = 58640] = "Ottava";
        MusicFontSymbol[MusicFontSymbol["OttavaAlta"] = 58641] = "OttavaAlta";
        MusicFontSymbol[MusicFontSymbol["OttavaBassaVb"] = 58652] = "OttavaBassaVb";
        MusicFontSymbol[MusicFontSymbol["Quindicesima"] = 58644] = "Quindicesima";
        MusicFontSymbol[MusicFontSymbol["QuindicesimaAlta"] = 58645] = "QuindicesimaAlta";
        MusicFontSymbol[MusicFontSymbol["DynamicPPP"] = 58666] = "DynamicPPP";
        MusicFontSymbol[MusicFontSymbol["DynamicPP"] = 58667] = "DynamicPP";
        MusicFontSymbol[MusicFontSymbol["DynamicPiano"] = 58656] = "DynamicPiano";
        MusicFontSymbol[MusicFontSymbol["DynamicMP"] = 58668] = "DynamicMP";
        MusicFontSymbol[MusicFontSymbol["DynamicMF"] = 58669] = "DynamicMF";
        MusicFontSymbol[MusicFontSymbol["DynamicForte"] = 58658] = "DynamicForte";
        MusicFontSymbol[MusicFontSymbol["DynamicFF"] = 58671] = "DynamicFF";
        MusicFontSymbol[MusicFontSymbol["DynamicFFF"] = 58672] = "DynamicFFF";
        MusicFontSymbol[MusicFontSymbol["OrnamentTrill"] = 58726] = "OrnamentTrill";
        MusicFontSymbol[MusicFontSymbol["StringsDownBow"] = 58896] = "StringsDownBow";
        MusicFontSymbol[MusicFontSymbol["StringsUpBow"] = 58898] = "StringsUpBow";
        MusicFontSymbol[MusicFontSymbol["PictEdgeOfCymbal"] = 59177] = "PictEdgeOfCymbal";
        MusicFontSymbol[MusicFontSymbol["GuitarGolpe"] = 59458] = "GuitarGolpe";
        MusicFontSymbol[MusicFontSymbol["FretboardX"] = 59481] = "FretboardX";
        MusicFontSymbol[MusicFontSymbol["FretboardO"] = 59482] = "FretboardO";
        MusicFontSymbol[MusicFontSymbol["WiggleTrill"] = 60068] = "WiggleTrill";
        MusicFontSymbol[MusicFontSymbol["WiggleVibratoMediumFast"] = 60126] = "WiggleVibratoMediumFast";
        MusicFontSymbol[MusicFontSymbol["OctaveBaselineM"] = 60565] = "OctaveBaselineM";
        MusicFontSymbol[MusicFontSymbol["OctaveBaselineB"] = 60563] = "OctaveBaselineB";
    })(MusicFontSymbol || (MusicFontSymbol = {}));

    /**
     * This public enum lists all different text alignments
     */
    var TextAlign;
    (function (TextAlign) {
        /**
         * Text is left aligned.
         */
        TextAlign[TextAlign["Left"] = 0] = "Left";
        /**
         * Text is centered.
         */ TextAlign[TextAlign["Center"] = 1] = "Center";
        /**
         * Text is right aligned.
         */ TextAlign[TextAlign["Right"] = 2] = "Right";
    })(TextAlign || (TextAlign = {}));
    /**
     * This public enum lists all base line modes
     */
    var TextBaseline;
    (function (TextBaseline) {
        /**
         * Text is aligned on top.
         */
        TextBaseline[TextBaseline["Top"] = 0] = "Top";
        /**
         * Text is aligned middle
         */ TextBaseline[TextBaseline["Middle"] = 1] = "Middle";
        /**
         * Text is aligend on the bottom.
         */ TextBaseline[TextBaseline["Bottom"] = 2] = "Bottom";
    })(TextBaseline || (TextBaseline = {}));

    /**
     * Describes an instrument articulation which is used for percussions.
     */
    var InstrumentArticulation = /** @class */ (function () {
        function InstrumentArticulation(staffLine, outputMidiNumber, noteHeadDefault, noteHeadHalf, noteHeadWhole, techniqueSymbol, techniqueSymbolPlacement) {
            if (staffLine === void 0) { staffLine = 0; }
            if (outputMidiNumber === void 0) { outputMidiNumber = 0; }
            if (noteHeadDefault === void 0) { noteHeadDefault = MusicFontSymbol.None; }
            if (noteHeadHalf === void 0) { noteHeadHalf = MusicFontSymbol.None; }
            if (noteHeadWhole === void 0) { noteHeadWhole = MusicFontSymbol.None; }
            if (techniqueSymbol === void 0) { techniqueSymbol = MusicFontSymbol.None; }
            if (techniqueSymbolPlacement === void 0) { techniqueSymbolPlacement = TextBaseline.Middle; }
            this.outputMidiNumber = outputMidiNumber;
            this.staffLine = staffLine;
            this.noteHeadDefault = noteHeadDefault;
            this.noteHeadHalf = noteHeadHalf !== MusicFontSymbol.None ? noteHeadHalf : noteHeadDefault;
            this.noteHeadWhole = noteHeadWhole !== MusicFontSymbol.None ? noteHeadWhole : noteHeadDefault;
            this.techniqueSymbol = techniqueSymbol;
            this.techniqueSymbolPlacement = techniqueSymbolPlacement;
        }
        InstrumentArticulation.copyTo = function (src, dst) {
            dst.outputMidiNumber = src.outputMidiNumber;
            dst.staffLine = src.staffLine;
            dst.noteHeadDefault = src.noteHeadDefault;
            dst.noteHeadHalf = src.noteHeadHalf;
            dst.noteHeadWhole = src.noteHeadWhole;
            dst.techniqueSymbol = src.techniqueSymbol;
            dst.techniqueSymbolPlacement = src.techniqueSymbolPlacement;
        };
        InstrumentArticulation.prototype.getSymbol = function (duration) {
            switch (duration) {
                case Duration.Whole:
                    return this.noteHeadWhole;
                case Duration.Half:
                    return this.noteHeadHalf;
                default:
                    return this.noteHeadDefault;
            }
        };
        return InstrumentArticulation;
    }());

    var PercussionMapper = /** @class */ (function () {
        function PercussionMapper() {
        }
        PercussionMapper.articulationFromElementVariation = function (element, variation) {
            if (element < PercussionMapper.gp6ElementAndVariationToArticulation.length) {
                if (variation >= PercussionMapper.gp6ElementAndVariationToArticulation.length) {
                    variation = 0;
                }
                return PercussionMapper.gp6ElementAndVariationToArticulation[element][variation];
            }
            // unknown combination, should not happen, fallback to some default value (Snare hit)
            return 38;
        };
        PercussionMapper.getArticulation = function (n) {
            var articulationIndex = n.percussionArticulation;
            var trackArticulations = n.beat.voice.bar.staff.track.percussionArticulations;
            if (articulationIndex < trackArticulations.length) {
                return trackArticulations[articulationIndex];
            }
            return PercussionMapper.getArticulationByValue(articulationIndex);
        };
        PercussionMapper.getElementAndVariation = function (n) {
            var articulation = PercussionMapper.getArticulation(n);
            if (!articulation) {
                return [-1, -1];
            }
            // search for the first element/variation combination with the same midi output 
            for (var element = 0; element < PercussionMapper.gp6ElementAndVariationToArticulation.length; element++) {
                var variations = PercussionMapper.gp6ElementAndVariationToArticulation[element];
                for (var variation = 0; variation < variations.length; variation++) {
                    var gp6Articulation = PercussionMapper.getArticulationByValue(variations[variation]);
                    if ((gp6Articulation === null || gp6Articulation === void 0 ? void 0 : gp6Articulation.outputMidiNumber) === articulation.outputMidiNumber) {
                        return [element, variation];
                    }
                }
            }
            return [-1, -1];
        };
        PercussionMapper.getArticulationByValue = function (midiNumber) {
            if (PercussionMapper.instrumentArticulations.has(midiNumber)) {
                return PercussionMapper.instrumentArticulations.get(midiNumber);
            }
            return null;
        };
        PercussionMapper.gp6ElementAndVariationToArticulation = [
            // known GP6 elements and variations, analyzed from a GPX test file
            // with all instruments inside manually aligned with the same names of articulations in GP7
            // [{articulation index}]   // [{element number}] => {element name} ({variation[0]}, {variation[1]}, {variation[2]})
            [35, 35, 35],
            [38, 91, 37],
            [99, 100, 99],
            [56, 100, 56],
            [102, 103, 102],
            [43, 43, 43],
            [45, 45, 45],
            [47, 47, 47],
            [48, 48, 48],
            [50, 50, 50],
            [42, 92, 46],
            [44, 44, 44],
            [57, 98, 57],
            [49, 97, 49],
            [55, 95, 55],
            [51, 93, 127],
            [52, 96, 52],
        ];
        /*
         * This map was generated using the following steps:
         * 1. Make a new GP7 file with a drumkit track
         * 2. Add one note for each midi value using the instrument panel
         * 3. Load the file in alphaTab and set a breakpoint in the GP7 importer.
         * 4. Use the following snipped in the console to generate the map initializer (fix enums manually):
         * parser = new DOMParser();
         * xmlDoc = parser.parseFromString(xml, 'text/xml');
         * articulations = xmlDoc.getElementsByTagName('Articulation');
         * existingArticulations = new Map();
         * s = '';
         * for(let i = 0; i < articulations.length; i++) {
         *     const articulation = articulations[i];
         *     let midi = articulation.getElementsByTagName('InputMidiNumbers');
         * 	if(midi.length === 1) {
         * 		midi = midi[0].textContent;
         *      const outputMidiNumber = articulation.getElementsByTagName('OutputMidiNumber')[0].textContent
         * 		const staffLine = articulation.getElementsByTagName('StaffLine')[0].textContent;
         * 		const techniqueSymbol = articulation.getElementsByTagName('TechniqueSymbol')[0].textContent;
         * 		const techniquePlacement = articulation.getElementsByTagName('TechniquePlacement')[0].textContent;
         * 		const noteHeads = articulation.getElementsByTagName('Noteheads')[0].textContent.split(' ').map(n=>n = 'MusicFontSymbol.' + n);
         * 		if(!existingArticulations.has(midi)) {
         *        if(techniqueSymbol) {
         * 		    s += `[${midi}, new InstrumentArticulation(${staffLine}, ${outputMidiNumber}, ${noteHeads[0]}, ${noteHeads[1]}, ${noteHeads[2]}, ${techniqueSymbol}, ${techniquePlacement})],\r\n`;
         *        }
         *        else {
         * 		    s += `[${midi}, new InstrumentArticulation(${staffLine}, ${outputMidiNumber}, ${noteHeads[0]}, ${noteHeads[1]}, ${noteHeads[2]})],\r\n`;
         *        }
         * 		  existingArticulations.set(midi, true);
         * 		}
         * 	}
         * }
         * copy(s)
         */
        PercussionMapper.instrumentArticulations = new Map([
            [38, new InstrumentArticulation(3, 38, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [37, new InstrumentArticulation(3, 37, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [91, new InstrumentArticulation(3, 38, MusicFontSymbol.NoteheadDiamondWhite, MusicFontSymbol.NoteheadDiamondWhite, MusicFontSymbol.NoteheadDiamondWhite)],
            [42, new InstrumentArticulation(-1, 42, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [92, new InstrumentArticulation(-1, 46, MusicFontSymbol.NoteheadCircleSlash, MusicFontSymbol.NoteheadCircleSlash, MusicFontSymbol.NoteheadCircleSlash)],
            [46, new InstrumentArticulation(-1, 46, MusicFontSymbol.NoteheadCircleX, MusicFontSymbol.NoteheadCircleX, MusicFontSymbol.NoteheadCircleX)],
            [44, new InstrumentArticulation(9, 44, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [35, new InstrumentArticulation(8, 35, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [36, new InstrumentArticulation(7, 36, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [50, new InstrumentArticulation(1, 50, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [48, new InstrumentArticulation(2, 48, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [47, new InstrumentArticulation(4, 47, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [45, new InstrumentArticulation(5, 45, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [43, new InstrumentArticulation(6, 43, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [93, new InstrumentArticulation(0, 51, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.PictEdgeOfCymbal, TextBaseline.Bottom)],
            [51, new InstrumentArticulation(0, 51, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [53, new InstrumentArticulation(0, 53, MusicFontSymbol.NoteheadDiamondWhite, MusicFontSymbol.NoteheadDiamondWhite, MusicFontSymbol.NoteheadDiamondWhite)],
            [94, new InstrumentArticulation(0, 51, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.ArticStaccatoAbove, TextBaseline.Top)],
            [55, new InstrumentArticulation(-2, 55, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [95, new InstrumentArticulation(-2, 55, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.ArticStaccatoAbove, TextBaseline.Bottom)],
            [52, new InstrumentArticulation(-3, 52, MusicFontSymbol.NoteheadHeavyXHat, MusicFontSymbol.NoteheadHeavyXHat, MusicFontSymbol.NoteheadHeavyXHat)],
            [96, new InstrumentArticulation(-3, 52, MusicFontSymbol.NoteheadHeavyXHat, MusicFontSymbol.NoteheadHeavyXHat, MusicFontSymbol.NoteheadHeavyXHat)],
            [49, new InstrumentArticulation(-2, 49, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX)],
            [97, new InstrumentArticulation(-2, 49, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.ArticStaccatoAbove, TextBaseline.Bottom)],
            [57, new InstrumentArticulation(-1, 57, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX)],
            [98, new InstrumentArticulation(-1, 57, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.NoteheadHeavyX, MusicFontSymbol.ArticStaccatoAbove, TextBaseline.Bottom)],
            [99, new InstrumentArticulation(1, 56, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpHalf, MusicFontSymbol.NoteheadTriangleUpWhole)],
            [100, new InstrumentArticulation(1, 56, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXHalf, MusicFontSymbol.NoteheadXWhole)],
            [56, new InstrumentArticulation(0, 56, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpHalf, MusicFontSymbol.NoteheadTriangleUpWhole)],
            [101, new InstrumentArticulation(0, 56, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXHalf, MusicFontSymbol.NoteheadXWhole)],
            [102, new InstrumentArticulation(-1, 56, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpHalf, MusicFontSymbol.NoteheadTriangleUpWhole)],
            [103, new InstrumentArticulation(-1, 56, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXHalf, MusicFontSymbol.NoteheadXWhole)],
            [77, new InstrumentArticulation(-9, 77, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack)],
            [76, new InstrumentArticulation(-10, 76, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack)],
            [60, new InstrumentArticulation(-4, 60, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [104, new InstrumentArticulation(-5, 60, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.NoteheadParenthesis, TextBaseline.Middle)],
            [105, new InstrumentArticulation(-6, 60, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [61, new InstrumentArticulation(-7, 61, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [106, new InstrumentArticulation(-8, 61, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.NoteheadParenthesis, TextBaseline.Middle)],
            [107, new InstrumentArticulation(-16, 61, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [66, new InstrumentArticulation(10, 66, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [65, new InstrumentArticulation(9, 65, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [68, new InstrumentArticulation(12, 68, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [67, new InstrumentArticulation(11, 67, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [64, new InstrumentArticulation(17, 64, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [108, new InstrumentArticulation(16, 64, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [109, new InstrumentArticulation(15, 64, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.NoteheadParenthesis, TextBaseline.Middle)],
            [63, new InstrumentArticulation(14, 63, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [110, new InstrumentArticulation(13, 63, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [62, new InstrumentArticulation(19, 62, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.NoteheadParenthesis, TextBaseline.Middle)],
            [72, new InstrumentArticulation(-11, 72, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [71, new InstrumentArticulation(-17, 71, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [73, new InstrumentArticulation(38, 73, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [74, new InstrumentArticulation(37, 74, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [86, new InstrumentArticulation(36, 86, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [87, new InstrumentArticulation(35, 87, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadParenthesis, TextBaseline.Middle)],
            [54, new InstrumentArticulation(3, 54, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack)],
            [111, new InstrumentArticulation(2, 54, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.StringsUpBow, TextBaseline.Bottom)],
            [112, new InstrumentArticulation(1, 54, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.NoteheadTriangleUpBlack, MusicFontSymbol.StringsDownBow, TextBaseline.Bottom)],
            [113, new InstrumentArticulation(-7, 54, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [79, new InstrumentArticulation(30, 79, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [78, new InstrumentArticulation(29, 78, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [58, new InstrumentArticulation(28, 58, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [81, new InstrumentArticulation(27, 81, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [80, new InstrumentArticulation(26, 80, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadParenthesis, TextBaseline.Middle)],
            [114, new InstrumentArticulation(25, 43, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [115, new InstrumentArticulation(18, 49, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [116, new InstrumentArticulation(24, 49, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [69, new InstrumentArticulation(23, 69, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [117, new InstrumentArticulation(22, 69, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.StringsUpBow, TextBaseline.Bottom)],
            [85, new InstrumentArticulation(21, 85, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [75, new InstrumentArticulation(20, 75, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [70, new InstrumentArticulation(-12, 70, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [118, new InstrumentArticulation(-13, 70, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.StringsUpBow, TextBaseline.Bottom)],
            [119, new InstrumentArticulation(-14, 70, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [120, new InstrumentArticulation(-15, 70, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.StringsUpBow, TextBaseline.Bottom)],
            [82, new InstrumentArticulation(-23, 54, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [122, new InstrumentArticulation(-24, 54, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.StringsUpBow, TextBaseline.Bottom)],
            [84, new InstrumentArticulation(-18, 53, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [123, new InstrumentArticulation(-19, 53, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole, MusicFontSymbol.StringsUpBow, TextBaseline.Bottom)],
            [83, new InstrumentArticulation(-20, 53, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [124, new InstrumentArticulation(-21, 62, MusicFontSymbol.NoteheadNull, MusicFontSymbol.NoteheadNull, MusicFontSymbol.NoteheadNull, MusicFontSymbol.GuitarGolpe, TextBaseline.Top)],
            [125, new InstrumentArticulation(-22, 62, MusicFontSymbol.NoteheadNull, MusicFontSymbol.NoteheadNull, MusicFontSymbol.NoteheadNull, MusicFontSymbol.GuitarGolpe, TextBaseline.Bottom)],
            [39, new InstrumentArticulation(3, 39, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [40, new InstrumentArticulation(3, 40, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [31, new InstrumentArticulation(3, 40, MusicFontSymbol.NoteheadSlashedBlack2, MusicFontSymbol.NoteheadSlashedBlack2, MusicFontSymbol.NoteheadSlashedBlack2)],
            [41, new InstrumentArticulation(5, 41, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadHalf, MusicFontSymbol.NoteheadWhole)],
            [59, new InstrumentArticulation(2, 59, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.PictEdgeOfCymbal, TextBaseline.Bottom)],
            [126, new InstrumentArticulation(2, 59, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [127, new InstrumentArticulation(2, 59, MusicFontSymbol.NoteheadDiamondWhite, MusicFontSymbol.NoteheadDiamondWhite, MusicFontSymbol.NoteheadDiamondWhite)],
            [29, new InstrumentArticulation(2, 59, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.ArticStaccatoAbove, TextBaseline.Top)],
            [30, new InstrumentArticulation(-3, 49, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [33, new InstrumentArticulation(3, 37, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack, MusicFontSymbol.NoteheadXBlack)],
            [34, new InstrumentArticulation(3, 38, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadBlack, MusicFontSymbol.NoteheadBlack)]
        ]);
        return PercussionMapper;
    }());

    /**
     * A note is a single played sound on a fretted instrument.
     * It consists of a fret offset and a string on which the note is played on.
     * It also can be modified by a lot of different effects.
     */
    var Note = /** @class */ (function () {
        function Note() {
            /**
             * Gets or sets the unique id of this note.
             */
            this.id = Note.GlobalNoteId++;
            /**
             * Gets or sets the zero-based index of this note within the beat.
             */
            this.index = 0;
            /**
             * Gets or sets the accentuation of this note.
             */
            this.accentuated = AccentuationType.None;
            /**
             * Gets or sets the bend type for this note.
             */
            this.bendType = BendType.None;
            /**
             * Gets or sets the bend style for this note.
             */
            this.bendStyle = BendStyle.Default;
            /**
             * Gets or sets the note from which this note continues the bend.
             */
            this.bendOrigin = null;
            /**
             * Gets or sets whether this note continues a bend from a previous note.
             */
            this.isContinuedBend = false;
            /**
             * Gets or sets a list of the points defining the bend behavior.
             */
            this.bendPoints = [];
            /**
             * Gets or sets the bend point with the highest bend value.
             */
            this.maxBendPoint = null;
            /**
             * Gets or sets the fret on which this note is played on the instrument.
             */
            this.fret = -1;
            /**
             * Gets or sets the string number where the note is placed.
             * 1 is the lowest string on the guitar and the bottom line on the tablature.
             * It then increases the the number of strings on available on the track.
             */
            this.string = -1;
            /**
             * Gets or sets the octave on which this note is played.
             */
            this.octave = -1;
            /**
             * Gets or sets the tone of this note within the octave.
             */
            this.tone = -1;
            /**
             * Gets or sets the index of percussion articulation in the related `track.percussionArticulations`.
             * If the articulation is not listed in `track.percussionArticulations` the following list based on GP7 applies:
             * - 029 Ride (choke)
             * - 030 Cymbal (hit)
             * - 031 Snare (side stick)
             * - 033 Snare (side stick)
             * - 034 Snare (hit)
             * - 035 Kick (hit)
             * - 036 Kick (hit)
             * - 037 Snare (side stick)
             * - 038 Snare (hit)
             * - 039 Hand Clap (hit)
             * - 040 Snare (hit)
             * - 041 Low Floor Tom (hit)
             * - 042 Hi-Hat (closed)
             * - 043 Very Low Tom (hit)
             * - 044 Pedal Hi-Hat (hit)
             * - 045 Low Tom (hit)
             * - 046 Hi-Hat (open)
             * - 047 Mid Tom (hit)
             * - 048 High Tom (hit)
             * - 049 Crash high (hit)
             * - 050 High Floor Tom (hit)
             * - 051 Ride (middle)
             * - 052 China (hit)
             * - 053 Ride (bell)
             * - 054 Tambourine (hit)
             * - 055 Splash (hit)
             * - 056 Cowbell medium (hit)
             * - 057 Crash medium (hit)
             * - 058 Vibraslap (hit)
             * - 059 Ride (edge)
             * - 060 Hand (hit)
             * - 061 Hand (hit)
             * - 062 Conga high (mute)
             * - 063 Conga high (hit)
             * - 064 Conga low (hit)
             * - 065 Timbale high (hit)
             * - 066 Timbale low (hit)
             * - 067 Agogo high (hit)
             * - 068 Agogo tow (hit)
             * - 069 Cabasa (hit)
             * - 070 Left Maraca (hit)
             * - 071 Whistle high (hit)
             * - 072 Whistle low (hit)
             * - 073 Guiro (hit)
             * - 074 Guiro (scrap-return)
             * - 075 Claves (hit)
             * - 076 Woodblock high (hit)
             * - 077 Woodblock low (hit)
             * - 078 Cuica (mute)
             * - 079 Cuica (open)
             * - 080 Triangle (rnute)
             * - 081 Triangle (hit)
             * - 082 Shaker (hit)
             * - 083 Tinkle Bell (hat)
             * - 083 Jingle Bell (hit)
             * - 084 Bell Tree (hit)
             * - 085 Castanets (hit)
             * - 086 Surdo (hit)
             * - 087 Surdo (mute)
             * - 091 Snare (rim shot)
             * - 092 Hi-Hat (half)
             * - 093 Ride (edge)
             * - 094 Ride (choke)
             * - 095 Splash (choke)
             * - 096 China (choke)
             * - 097 Crash high (choke)
             * - 098 Crash medium (choke)
             * - 099 Cowbell low (hit)
             * - 100 Cowbell low (tip)
             * - 101 Cowbell medium (tip)
             * - 102 Cowbell high (hit)
             * - 103 Cowbell high (tip)
             * - 104 Hand (mute)
             * - 105 Hand (slap)
             * - 106 Hand (mute)
             * - 107 Hand (slap)
             * - 108 Conga low (slap)
             * - 109 Conga low (mute)
             * - 110 Conga high (slap)
             * - 111 Tambourine (return)
             * - 112 Tambourine (roll)
             * - 113 Tambourine (hand)
             * - 114 Grancassa (hit)
             * - 115 Piatti (hat)
             * - 116 Piatti (hand)
             * - 117 Cabasa (return)
             * - 118 Left Maraca (return)
             * - 119 Right Maraca (hit)
             * - 120 Right Maraca (return)
             * - 122 Shaker (return)
             * - 123 Bell Tee (return)
             * - 124 Golpe (thumb)
             * - 125 Golpe (finger)
             * - 126 Ride (middle)
             * - 127 Ride (bell)
             */
            this.percussionArticulation = -1;
            /**
             * Gets or sets whether this note is visible on the music sheet.
             */
            this.isVisible = true;
            /**
             * Gets a value indicating whether the note is left hand tapped.
             */
            this.isLeftHandTapped = false;
            /**
             * Gets or sets whether this note starts a hammeron or pulloff.
             */
            this.isHammerPullOrigin = false;
            /**
             * Gets the origin of the hammeron/pulloff of this note.
             */
            this.hammerPullOrigin = null;
            /**
             * Gets the destination for the hammeron/pullof started by this note.
             */
            this.hammerPullDestination = null;
            /**
             * Gets or sets whether this note finishes a slur.
             */
            this.isSlurDestination = false;
            /**
             * Gets or sets the note where the slur of this note starts.
             */
            this.slurOrigin = null;
            /**
             * Gets or sets the note where the slur of this note ends.
             */
            this.slurDestination = null;
            /**
             * Gets or sets the harmonic type applied to this note.
             */
            this.harmonicType = HarmonicType.None;
            /**
             * Gets or sets the value defining the harmonic pitch.
             */
            this.harmonicValue = 0;
            /**
             * Gets or sets whether the note is a ghost note and shown in parenthesis. Also this will make the note a bit more silent.
             */
            this.isGhost = false;
            /**
             * Gets or sets whether this note has a let-ring effect.
             */
            this.isLetRing = false;
            /**
             * Gets or sets the destination note for the let-ring effect.
             */
            this.letRingDestination = null;
            /**
             * Gets or sets whether this note has a palm-mute effect.
             */
            this.isPalmMute = false;
            /**
             * Gets or sets the destination note for the palm-mute effect.
             */
            this.palmMuteDestination = null;
            /**
             * Gets or sets whether the note is shown and played as dead note.
             */
            this.isDead = false;
            /**
             * Gets or sets whether the note is played as staccato.
             */
            this.isStaccato = false;
            /**
             * Gets or sets the slide-in type this note is played with.
             */
            this.slideInType = SlideInType.None;
            /**
             * Gets or sets the slide-out type this note is played with.
             */
            this.slideOutType = SlideOutType.None;
            /**
             * Gets or sets the target note for several slide types.
             */
            this.slideTarget = null;
            /**
             * Gets or sets the source note for several slide types.
             */
            this.slideOrigin = null;
            /**
             * Gets or sets whether a vibrato is played on the note.
             */
            this.vibrato = VibratoType.None;
            /**
             * Gets or sets the origin of the tied if this note is tied.
             */
            this.tieOrigin = null;
            /**
             * Gets or sets the desination of the tie.
             */
            this.tieDestination = null;
            /**
             * Gets or sets whether this note is ends a tied note.
             */
            this.isTieDestination = false;
            /**
             * Gets or sets the fingers used for this note on the left hand.
             */
            this.leftHandFinger = Fingers.Unknown;
            /**
             * Gets or sets the fingers used for this note on the right hand.
             */
            this.rightHandFinger = Fingers.Unknown;
            /**
             * Gets or sets whether this note has fingering defined.
             */
            this.isFingering = false;
            /**
             * Gets or sets the target note value for the trill effect.
             */
            this.trillValue = -1;
            /**
             * Gets or sets the speed of the trill effect.
             */
            this.trillSpeed = Duration.ThirtySecond;
            /**
             * Gets or sets the percentual duration of the note relative to the overall beat duration .
             */
            this.durationPercent = 1;
            /**
             * Gets or sets how accidetnals for this note should  be handled.
             */
            this.accidentalMode = NoteAccidentalMode.Default;
            /**
             * Gets or sets the dynamics for this note.
             */
            this.dynamics = DynamicValue.F;
            this.isEffectSlurOrigin = false;
            this.hasEffectSlur = false;
            this.effectSlurOrigin = null;
            this.effectSlurDestination = null;
        }
        Object.defineProperty(Note.prototype, "hasBend", {
            get: function () {
                return this.bendType !== BendType.None;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isStringed", {
            get: function () {
                return this.string >= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isPiano", {
            get: function () {
                return !this.isStringed && this.octave >= 0 && this.tone >= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isPercussion", {
            get: function () {
                return !this.isStringed && this.percussionArticulation >= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "element", {
            /**
             * Gets or sets the percusson element.
             * @deprecated
             */
            get: function () {
                return this.isPercussion ? PercussionMapper.getElementAndVariation(this)[0] : -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "variation", {
            /**
             * Gets or sets the variation of this note.
             * * @deprecated
             */
            get: function () {
                return this.isPercussion ? PercussionMapper.getElementAndVariation(this)[1] : -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isHammerPullDestination", {
            get: function () {
                return !!this.hammerPullOrigin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isSlurOrigin", {
            get: function () {
                return !!this.slurDestination;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isHarmonic", {
            get: function () {
                return this.harmonicType !== HarmonicType.None;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isTieOrigin", {
            get: function () {
                return !!this.tieDestination;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "trillFret", {
            get: function () {
                return this.trillValue - this.stringTuning;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isTrill", {
            get: function () {
                return this.trillValue >= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "isEffectSlurDestination", {
            get: function () {
                return !!this.effectSlurOrigin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "stringTuning", {
            get: function () {
                return this.beat.voice.bar.staff.capo + Note.getStringTuning(this.beat.voice.bar.staff, this.string);
            },
            enumerable: false,
            configurable: true
        });
        Note.getStringTuning = function (staff, noteString) {
            if (staff.tuning.length > 0) {
                return staff.tuning[staff.tuning.length - (noteString - 1) - 1];
            }
            return 0;
        };
        Object.defineProperty(Note.prototype, "realValue", {
            get: function () {
                if (this.isPercussion) {
                    return this.percussionArticulation;
                }
                if (this.isStringed) {
                    if (this.harmonicType === HarmonicType.Natural) {
                        return this.harmonicPitch + this.stringTuning - this.beat.voice.bar.staff.transpositionPitch;
                    }
                    return this.fret + this.stringTuning - this.beat.voice.bar.staff.transpositionPitch + this.harmonicPitch;
                }
                if (this.isPiano) {
                    return this.octave * 12 + this.tone - this.beat.voice.bar.staff.transpositionPitch;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "harmonicPitch", {
            get: function () {
                if (this.harmonicType === HarmonicType.None || !this.isStringed) {
                    return 0;
                }
                var value = this.harmonicValue;
                // add semitones to reach corresponding harmonic frets
                if (ModelUtils.isAlmostEqualTo(value, 2.4)) {
                    return 36;
                }
                if (ModelUtils.isAlmostEqualTo(value, 2.7)) {
                    // Fret 3 2nd octave + minor seventh
                    return 34;
                }
                if (value < 3) {
                    // no natural harmonics below fret 3
                    return 0;
                }
                if (value <= 3.5) {
                    // Fret 3 2nd octave + fifth
                    return 31;
                }
                if (value <= 4) {
                    return 28;
                }
                if (value <= 5) {
                    return 24;
                }
                if (value <= 6) {
                    return 34;
                }
                if (value <= 7) {
                    return 19;
                }
                if (value <= 8.5) {
                    return 36;
                }
                if (value <= 9) {
                    return 28;
                }
                if (value <= 10) {
                    return 34;
                }
                if (value <= 11) {
                    return 0;
                }
                if (value <= 12) {
                    return 12;
                }
                if (value < 14) {
                    // fret 13,14 stay
                    return 0;
                }
                if (value <= 15) {
                    return 34;
                }
                if (value <= 16) {
                    return 28;
                }
                if (value <= 17) {
                    return 36;
                }
                if (value <= 18) {
                    return 0;
                }
                if (value <= 19) {
                    return 19;
                }
                if (value <= 21) {
                    //  20,21 stay
                    return 0;
                }
                if (value <= 22) {
                    return 36;
                }
                if (value <= 24) {
                    return 24;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "initialBendValue", {
            get: function () {
                if (this.hasBend) {
                    return (this.bendPoints[0].value / 2) | 0;
                }
                else if (this.bendOrigin) {
                    return (this.bendOrigin.bendPoints[this.bendOrigin.bendPoints.length - 1].value / 2) | 0;
                }
                else if (this.isTieDestination && this.tieOrigin.bendOrigin) {
                    return (this.tieOrigin.bendOrigin.bendPoints[this.tieOrigin.bendOrigin.bendPoints.length - 1].value / 2) | 0;
                }
                else if (this.beat.hasWhammyBar) {
                    return (this.beat.whammyBarPoints[0].value / 2) | 0;
                }
                else if (this.beat.isContinuedWhammy) {
                    return (this.beat.previousBeat.whammyBarPoints[this.beat.previousBeat.whammyBarPoints.length - 1].value / 2) | 0;
                }
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "displayValue", {
            get: function () {
                return this.displayValueWithoutBend + this.initialBendValue;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "displayValueWithoutBend", {
            get: function () {
                var noteValue = this.realValue;
                if (this.harmonicType !== HarmonicType.Natural && this.harmonicType !== HarmonicType.None) {
                    noteValue -= this.harmonicPitch;
                }
                switch (this.beat.ottava) {
                    case Ottavia._15ma:
                        noteValue -= 24;
                        break;
                    case Ottavia._8va:
                        noteValue -= 12;
                        break;
                    case Ottavia.Regular:
                        break;
                    case Ottavia._8vb:
                        noteValue += 12;
                        break;
                    case Ottavia._15mb:
                        noteValue += 24;
                        break;
                }
                switch (this.beat.voice.bar.clefOttava) {
                    case Ottavia._15ma:
                        noteValue -= 24;
                        break;
                    case Ottavia._8va:
                        noteValue -= 12;
                        break;
                    case Ottavia.Regular:
                        break;
                    case Ottavia._8vb:
                        noteValue += 12;
                        break;
                    case Ottavia._15mb:
                        noteValue += 24;
                        break;
                }
                return noteValue - this.beat.voice.bar.staff.displayTranspositionPitch;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Note.prototype, "hasQuarterToneOffset", {
            get: function () {
                if (this.hasBend) {
                    return this.bendPoints[0].value % 2 !== 0;
                }
                if (this.bendOrigin) {
                    return this.bendOrigin.bendPoints[this.bendOrigin.bendPoints.length - 1].value % 2 !== 0;
                }
                if (this.beat.hasWhammyBar) {
                    return this.beat.whammyBarPoints[0].value % 2 !== 0;
                }
                if (this.beat.isContinuedWhammy) {
                    return (this.beat.previousBeat.whammyBarPoints[this.beat.previousBeat.whammyBarPoints.length - 1].value %
                        2 !==
                        0);
                }
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Note.copyTo = function (src, dst) {
            dst.id = src.id;
            dst.accentuated = src.accentuated;
            dst.fret = src.fret;
            dst.string = src.string;
            dst.harmonicValue = src.harmonicValue;
            dst.harmonicType = src.harmonicType;
            dst.isGhost = src.isGhost;
            dst.isLetRing = src.isLetRing;
            dst.isPalmMute = src.isPalmMute;
            dst.isDead = src.isDead;
            dst.isStaccato = src.isStaccato;
            dst.slideInType = src.slideInType;
            dst.slideOutType = src.slideOutType;
            dst.vibrato = src.vibrato;
            dst.isTieDestination = src.isTieDestination;
            dst.isSlurDestination = src.isSlurDestination;
            dst.isHammerPullOrigin = src.isHammerPullOrigin;
            dst.leftHandFinger = src.leftHandFinger;
            dst.rightHandFinger = src.rightHandFinger;
            dst.isFingering = src.isFingering;
            dst.trillValue = src.trillValue;
            dst.trillSpeed = src.trillSpeed;
            dst.durationPercent = src.durationPercent;
            dst.accidentalMode = src.accidentalMode;
            dst.dynamics = src.dynamics;
            dst.octave = src.octave;
            dst.tone = src.tone;
            dst.percussionArticulation = src.percussionArticulation;
            dst.bendType = src.bendType;
            dst.bendStyle = src.bendStyle;
            dst.isContinuedBend = src.isContinuedBend;
            dst.isVisible = src.isVisible;
            dst.isLeftHandTapped = src.isLeftHandTapped;
        };
        Note.prototype.clone = function () {
            var n = new Note();
            var id = n.id;
            Note.copyTo(this, n);
            for (var i = 0, j = this.bendPoints.length; i < j; i++) {
                n.addBendPoint(this.bendPoints[i].clone());
            }
            n.id = id;
            return n;
        };
        Note.prototype.addBendPoint = function (point) {
            this.bendPoints.push(point);
            if (!this.maxBendPoint || point.value > this.maxBendPoint.value) {
                this.maxBendPoint = point;
            }
            if (this.bendType === BendType.None) {
                this.bendType = BendType.Custom;
            }
        };
        Note.prototype.finish = function (settings) {
            var _this = this;
            var nextNoteOnLine = new Lazy(function () { return Note.nextNoteOnSameLine(_this); });
            var isSongBook = settings && settings.notation.notationMode === exports.NotationMode.SongBook;
            // connect ties
            if (this.isTieDestination) {
                this.chain();
                // implicit let ring
                if (isSongBook && this.tieOrigin && this.tieOrigin.isLetRing) {
                    this.isLetRing = true;
                }
            }
            // connect letring
            if (this.isLetRing) {
                if (!nextNoteOnLine.value || !nextNoteOnLine.value.isLetRing) {
                    this.letRingDestination = this;
                }
                else {
                    this.letRingDestination = nextNoteOnLine.value;
                }
                if (isSongBook && this.isTieDestination && !this.tieOrigin.hasBend) {
                    this.isVisible = false;
                }
            }
            // connect palmmute
            if (this.isPalmMute) {
                if (!nextNoteOnLine.value || !nextNoteOnLine.value.isPalmMute) {
                    this.palmMuteDestination = this;
                }
                else {
                    this.palmMuteDestination = nextNoteOnLine.value;
                }
            }
            // set hammeron/pulloffs
            if (this.isHammerPullOrigin) {
                this.hammerPullDestination = Note.findHammerPullDestination(this);
                if (!this.hammerPullDestination) {
                    this.isHammerPullOrigin = false;
                }
                else {
                    this.hammerPullDestination.hammerPullOrigin = this;
                }
            }
            // set slides
            switch (this.slideOutType) {
                case SlideOutType.Shift:
                case SlideOutType.Legato:
                    this.slideTarget = nextNoteOnLine.value;
                    if (!this.slideTarget) {
                        this.slideOutType = SlideOutType.None;
                    }
                    else {
                        this.slideTarget.slideOrigin = this;
                    }
                    break;
            }
            var effectSlurDestination = null;
            if (this.isHammerPullOrigin && this.hammerPullDestination) {
                effectSlurDestination = this.hammerPullDestination;
            }
            else if (this.slideOutType === SlideOutType.Legato && this.slideTarget) {
                effectSlurDestination = this.slideTarget;
            }
            if (effectSlurDestination) {
                this.hasEffectSlur = true;
                if (this.effectSlurOrigin && this.beat.pickStroke === PickStroke.None) {
                    this.effectSlurOrigin.effectSlurDestination = effectSlurDestination;
                    this.effectSlurOrigin.effectSlurDestination.effectSlurOrigin = this.effectSlurOrigin;
                    this.effectSlurOrigin = null;
                }
                else {
                    this.isEffectSlurOrigin = true;
                    this.effectSlurDestination = effectSlurDestination;
                    this.effectSlurDestination.effectSlurOrigin = this;
                }
            }
            // try to detect what kind of bend was used and cleans unneeded points if required
            // Guitar Pro 6 and above (gpif.xml) uses exactly 4 points to define all bends
            if (this.bendPoints.length > 0 && this.bendType === BendType.Custom) {
                var isContinuedBend = (this.isContinuedBend = !!this.tieOrigin && this.tieOrigin.hasBend);
                if (this.bendPoints.length === 4) {
                    var origin_1 = this.bendPoints[0];
                    var middle1 = this.bendPoints[1];
                    var middle2 = this.bendPoints[2];
                    var destination = this.bendPoints[3];
                    // the middle points are used for holds, anything else is a new feature we do not support yet
                    if (middle1.value === middle2.value) {
                        // bend higher?
                        if (destination.value > origin_1.value) {
                            if (middle1.value > destination.value) {
                                this.bendType = BendType.BendRelease;
                            }
                            else if (!isContinuedBend && origin_1.value > 0) {
                                this.bendType = BendType.PrebendBend;
                                this.bendPoints.splice(2, 1);
                                this.bendPoints.splice(1, 1);
                            }
                            else {
                                this.bendType = BendType.Bend;
                                this.bendPoints.splice(2, 1);
                                this.bendPoints.splice(1, 1);
                            }
                        }
                        else if (destination.value < origin_1.value) {
                            // origin must be > 0 otherwise it's no release, we cannot bend negative
                            if (isContinuedBend) {
                                this.bendType = BendType.Release;
                                this.bendPoints.splice(2, 1);
                                this.bendPoints.splice(1, 1);
                            }
                            else {
                                this.bendType = BendType.PrebendRelease;
                                this.bendPoints.splice(2, 1);
                                this.bendPoints.splice(1, 1);
                            }
                        }
                        else {
                            if (middle1.value > origin_1.value) {
                                this.bendType = BendType.BendRelease;
                            }
                            else if (origin_1.value > 0 && !isContinuedBend) {
                                this.bendType = BendType.Prebend;
                                this.bendPoints.splice(2, 1);
                                this.bendPoints.splice(1, 1);
                            }
                            else {
                                this.bendType = BendType.Hold;
                                this.bendPoints.splice(2, 1);
                                this.bendPoints.splice(1, 1);
                            }
                        }
                    }
                    else {
                        Logger.warning('Model', 'Unsupported bend type detected, fallback to custom', null);
                    }
                }
                else if (this.bendPoints.length === 2) {
                    var origin_2 = this.bendPoints[0];
                    var destination = this.bendPoints[1];
                    // bend higher?
                    if (destination.value > origin_2.value) {
                        if (!isContinuedBend && origin_2.value > 0) {
                            this.bendType = BendType.PrebendBend;
                        }
                        else {
                            this.bendType = BendType.Bend;
                        }
                    }
                    else if (destination.value < origin_2.value) {
                        // origin must be > 0 otherwise it's no release, we cannot bend negative
                        if (isContinuedBend) {
                            this.bendType = BendType.Release;
                        }
                        else {
                            this.bendType = BendType.PrebendRelease;
                        }
                    }
                    else {
                        this.bendType = BendType.Hold;
                    }
                }
            }
            else if (this.bendPoints.length === 0) {
                this.bendType = BendType.None;
            }
            // initial bend pitch offsets and forced accidentals don't play well together
            // we reset it
            if (this.initialBendValue > 0) {
                this.accidentalMode = NoteAccidentalMode.Default;
            }
        };
        Note.nextNoteOnSameLine = function (note) {
            var nextBeat = note.beat.nextBeat;
            // keep searching in same bar
            while (nextBeat && nextBeat.voice.bar.index <= note.beat.voice.bar.index + Note.MaxOffsetForSameLineSearch) {
                var noteOnString = nextBeat.getNoteOnString(note.string);
                if (noteOnString) {
                    return noteOnString;
                }
                nextBeat = nextBeat.nextBeat;
            }
            return null;
        };
        Note.findHammerPullDestination = function (note) {
            // For Hammer-Pull destinations we have 2 potential candidates
            // 1. A note on the same string
            // 2. A note on a different string, but with a left-hand-tapping applied
            // for the second case we have a special logic to search for notes:
            // 1. We first search on lower strings, then on higher strings
            // 2. If we find a note with a left-hand-tap applied it becomes the target
            // 3. If we find a note without a left-hand-tap we stop searching in this direction
            var nextBeat = note.beat.nextBeat;
            // keep searching in same bar
            while (nextBeat && nextBeat.voice.bar.index <= note.beat.voice.bar.index + Note.MaxOffsetForSameLineSearch) {
                // 1. same string first
                var noteOnString = nextBeat.getNoteOnString(note.string);
                if (noteOnString) {
                    return noteOnString;
                }
                // 2. search toward lower strings
                for (var str = note.string; str > 0; str--) {
                    noteOnString = nextBeat.getNoteOnString(str);
                    if (noteOnString) {
                        if (noteOnString.isLeftHandTapped) {
                            return noteOnString;
                        }
                        else {
                            break;
                        }
                    }
                }
                // 3. search toward higher strings
                for (var str = note.string; str <= note.beat.voice.bar.staff.tuning.length; str++) {
                    noteOnString = nextBeat.getNoteOnString(str);
                    if (noteOnString) {
                        if (noteOnString.isLeftHandTapped) {
                            return noteOnString;
                        }
                        else {
                            break;
                        }
                    }
                }
                // nothing found, search on next beat
                nextBeat = nextBeat.nextBeat;
            }
            return null;
        };
        Note.findTieOrigin = function (note) {
            var previousBeat = note.beat.previousBeat;
            // keep searching in same bar
            while (previousBeat &&
                previousBeat.voice.bar.index >= note.beat.voice.bar.index - Note.MaxOffsetForSameLineSearch) {
                if (note.isStringed) {
                    var noteOnString = previousBeat.getNoteOnString(note.string);
                    if (noteOnString) {
                        return noteOnString;
                    }
                }
                else {
                    if (note.octave === -1 && note.tone === -1) {
                        // if the note has no value (e.g. alphaTex dash tie), we try to find a matching
                        // note on the previous beat by index.
                        if (note.index < previousBeat.notes.length) {
                            return previousBeat.notes[note.index];
                        }
                    }
                    else {
                        var noteWithValue = previousBeat.getNoteWithRealValue(note.realValue);
                        if (noteWithValue) {
                            return noteWithValue;
                        }
                    }
                }
                previousBeat = previousBeat.previousBeat;
            }
            return null;
        };
        Note.prototype.chain = function () {
            if (!this.isTieDestination) {
                return;
            }
            if (!this.tieOrigin) {
                this.tieOrigin = Note.findTieOrigin(this);
            }
            if (!this.tieOrigin) {
                this.isTieDestination = false;
            }
            else {
                this.tieOrigin.tieDestination = this;
                this.fret = this.tieOrigin.fret;
                this.octave = this.tieOrigin.octave;
                this.tone = this.tieOrigin.tone;
                if (this.tieOrigin.hasBend) {
                    this.bendOrigin = this.tieOrigin;
                }
            }
        };
        Note.GlobalNoteId = 0;
        Note.MaxOffsetForSameLineSearch = 3;
        return Note;
    }());

    /**
     * Represents a list of beats that are grouped within the same tuplet.
     */
    var TupletGroup = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link TupletGroup} class.
         * @param voice The voice this group belongs to.
         */
        function TupletGroup(voice) {
            this._isEqualLengthTuplet = true;
            this.totalDuration = 0;
            /**
             * Gets or sets the list of beats contained in this group.
             */
            this.beats = [];
            /**
             * Gets a value indicating whether the tuplet group is fully filled.
             */
            this.isFull = false;
            this.voice = voice;
        }
        TupletGroup.prototype.check = function (beat) {
            if (this.beats.length === 0) {
                // accept first beat
                this.beats.push(beat);
                this.totalDuration += beat.playbackDuration;
                return true;
            }
            if (beat.graceType !== GraceType.None) {
                // grace notes do not break tuplet group, but also do not contribute to them.
                return true;
            }
            if (beat.voice !== this.voice ||
                this.isFull ||
                beat.tupletNumerator !== this.beats[0].tupletNumerator ||
                beat.tupletDenominator !== this.beats[0].tupletDenominator) {
                // only same tuplets are potentially accepted
                return false;
            }
            // TBH: I do not really know how the 100% tuplet grouping of Guitar Pro might work
            // it sometimes has really strange rules where notes filling 3 quarters, are considered a full 3:2 tuplet
            // in alphaTab we have now 2 rules where we consider a tuplet full:
            // 1. if all beats have the same length, the tuplet must contain N notes of an N:M tuplet
            // 2. if we have mixed beats, we check if the current set of beats, matches a N:M tuplet
            //    by checking all potential note durations.
            // this logic is very likely not 100% correct but for most cases the tuplets
            // appeared correct.
            if (beat.playbackDuration !== this.beats[0].playbackDuration) {
                this._isEqualLengthTuplet = false;
            }
            this.beats.push(beat);
            this.totalDuration += beat.playbackDuration;
            if (this._isEqualLengthTuplet) {
                if (this.beats.length === this.beats[0].tupletNumerator) {
                    this.isFull = true;
                }
            }
            else {
                var factor = (this.beats[0].tupletNumerator / this.beats[0].tupletDenominator) | 0;
                for (var _i = 0, _a = TupletGroup.AllTicks; _i < _a.length; _i++) {
                    var potentialMatch = _a[_i];
                    if (this.totalDuration === potentialMatch * factor) {
                        this.isFull = true;
                        break;
                    }
                }
            }
            return true;
        };
        TupletGroup.HalfTicks = 1920;
        TupletGroup.QuarterTicks = 960;
        TupletGroup.EighthTicks = 480;
        TupletGroup.SixteenthTicks = 240;
        TupletGroup.ThirtySecondTicks = 120;
        TupletGroup.SixtyFourthTicks = 60;
        TupletGroup.OneHundredTwentyEighthTicks = 30;
        TupletGroup.TwoHundredFiftySixthTicks = 15;
        TupletGroup.AllTicks = [
            TupletGroup.HalfTicks,
            TupletGroup.QuarterTicks,
            TupletGroup.EighthTicks,
            TupletGroup.SixteenthTicks,
            TupletGroup.ThirtySecondTicks,
            TupletGroup.SixtyFourthTicks,
            TupletGroup.OneHundredTwentyEighthTicks,
            TupletGroup.TwoHundredFiftySixthTicks
        ];
        return TupletGroup;
    }());

    /**
     * Lists all types of whammy bars
     */
    var WhammyType;
    (function (WhammyType) {
        /**
         * No whammy at all
         */
        WhammyType[WhammyType["None"] = 0] = "None";
        /**
         * Individual points define the whammy in a flexible manner.
         * This system was mainly used in Guitar Pro 3-5
         */
        WhammyType[WhammyType["Custom"] = 1] = "Custom";
        /**
         * Simple dive to a lower or higher note.
         */
        WhammyType[WhammyType["Dive"] = 2] = "Dive";
        /**
         * A dive to a lower or higher note and releasing it back to normal.
         */
        WhammyType[WhammyType["Dip"] = 3] = "Dip";
        /**
         * Continue to hold the whammy at the position from a previous whammy.
         */
        WhammyType[WhammyType["Hold"] = 4] = "Hold";
        /**
         * Dive to a lower or higher note before playing it.
         */
        WhammyType[WhammyType["Predive"] = 5] = "Predive";
        /**
         * Dive to a lower or higher note before playing it, then change to another
         * note.
         */
        WhammyType[WhammyType["PrediveDive"] = 6] = "PrediveDive";
    })(WhammyType || (WhammyType = {}));

    /**
     * Lists the different modes on how beaming for a beat should be done.
     */
    var BeatBeamingMode;
    (function (BeatBeamingMode) {
        /**
         * Automatic beaming based on the timing rules.
         */
        BeatBeamingMode[BeatBeamingMode["Auto"] = 0] = "Auto";
        /**
         * Force a split to the next beat.
         */
        BeatBeamingMode[BeatBeamingMode["ForceSplitToNext"] = 1] = "ForceSplitToNext";
        /**
         * Force a merge with the next beat.
         */
        BeatBeamingMode[BeatBeamingMode["ForceMergeWithNext"] = 2] = "ForceMergeWithNext";
    })(BeatBeamingMode || (BeatBeamingMode = {}));
    /**
     * A beat is a single block within a bar. A beat is a combination
     * of several notes played at the same time.
     */
    var Beat = /** @class */ (function () {
        function Beat() {
            /**
             * Gets or sets the unique id of this beat.
             */
            this.id = Beat._globalBeatId++;
            /**
             * Gets or sets the zero-based index of this beat within the voice.
             */
            this.index = 0;
            /**
             * Gets or sets the previous beat within the whole song.
             */
            this.previousBeat = null;
            /**
             * Gets or sets the next beat within the whole song.
             */
            this.nextBeat = null;
            /**
             * Gets or sets the list of notes contained in this beat.
             */
            this.notes = [];
            /**
             * Gets the lookup where the notes per string are registered.
             * If this staff contains string based notes this lookup allows fast access.
             */
            this.noteStringLookup = new Map();
            /**
             * Gets the lookup where the notes per value are registered.
             * If this staff contains string based notes this lookup allows fast access.
             */
            this.noteValueLookup = new Map();
            /**
             * Gets or sets a value indicating whether this beat is considered empty.
             */
            this.isEmpty = false;
            /**
             * Gets or sets which whammy bar style should be used for this bar.
             */
            this.whammyStyle = BendStyle.Default;
            /**
             * Gets or sets the ottava applied to this beat.
             */
            this.ottava = Ottavia.Regular;
            /**
             * Gets or sets the fermata applied to this beat.
             */
            this.fermata = null;
            /**
             * Gets a value indicating whether this beat starts a legato slur.
             */
            this.isLegatoOrigin = false;
            /**
             * Gets or sets the note with the lowest pitch in this beat. Only visible notes are considered.
             */
            this.minNote = null;
            /**
             * Gets or sets the note with the highest pitch in this beat. Only visible notes are considered.
             */
            this.maxNote = null;
            /**
             * Gets or sets the note with the highest string number in this beat. Only visible notes are considered.
             */
            this.maxStringNote = null;
            /**
             * Gets or sets the note with the lowest string number in this beat. Only visible notes are considered.
             */
            this.minStringNote = null;
            /**
             * Gets or sets the duration of this beat.
             */
            this.duration = Duration.Quarter;
            /**
             * Gets or sets whether any note in this beat has a let-ring applied.
             */
            this.isLetRing = false;
            /**
             * Gets or sets whether any note in this beat has a palm-mute paplied.
             */
            this.isPalmMute = false;
            /**
             * Gets or sets a list of all automations on this beat.
             */
            this.automations = [];
            /**
             * Gets or sets the number of dots applied to the duration of this beat.
             */
            this.dots = 0;
            /**
             * Gets or sets a value indicating whether this beat is fade-in.
             */
            this.fadeIn = false;
            /**
             * Gets or sets the lyrics shown on this beat.
             */
            this.lyrics = null;
            /**
             * Gets or sets a value indicating whether the beat is played in rasgueado style.
             */
            this.hasRasgueado = false;
            /**
             * Gets or sets a value indicating whether the notes on this beat are played with a pop-style (bass).
             */
            this.pop = false;
            /**
             * Gets or sets a value indicating whether the notes on this beat are played with a slap-style (bass).
             */
            this.slap = false;
            /**
             * Gets or sets a value indicating whether the notes on this beat are played with a tap-style (bass).
             */
            this.tap = false;
            /**
             * Gets or sets the text annotation shown on this beat.
             */
            this.text = null;
            /**
             * Gets or sets the brush type applied to the notes of this beat.
             */
            this.brushType = BrushType.None;
            /**
             * Gets or sets the duration of the brush between the notes in midi ticks.
             */
            this.brushDuration = 0;
            /**
             * Gets or sets the tuplet denominator.
             */
            this.tupletDenominator = -1;
            /**
             * Gets or sets the tuplet numerator.
             */
            this.tupletNumerator = -1;
            this.tupletGroup = null;
            /**
             * Gets or sets whether this beat continues a whammy effect.
             */
            this.isContinuedWhammy = false;
            /**
             * Gets or sets the whammy bar style of this beat.
             */
            this.whammyBarType = WhammyType.None;
            /**
             * Gets or sets the points defining the whammy bar usage.
             */
            this.whammyBarPoints = [];
            /**
             * Gets or sets the highest point with for the highest whammy bar value.
             */
            this.maxWhammyPoint = null;
            /**
             * Gets or sets the highest point with for the lowest whammy bar value.
             */
            this.minWhammyPoint = null;
            /**
             * Gets or sets the vibrato effect used on this beat.
             */
            this.vibrato = VibratoType.None;
            /**
             * Gets or sets the ID of the chord used on this beat.
             */
            this.chordId = null;
            /**
             * Gets or sets the grace style of this beat.
             */
            this.graceType = GraceType.None;
            /**
             * Gets or sets the pickstroke applied on this beat.
             */
            this.pickStroke = PickStroke.None;
            /**
             * Gets or sets the speed of the tremolo effect.
             */
            this.tremoloSpeed = null;
            /**
             * Gets or sets whether a crescendo/decrescendo is applied on this beat.
             */
            this.crescendo = CrescendoType.None;
            /**
             * The timeline position of the voice within the current bar as it is displayed. (unit: midi ticks)
             * This might differ from the actual playback time due to special grace types.
             */
            this.displayStart = 0;
            /**
             * The timeline position of the voice within the current bar as it is played. (unit: midi ticks)
             * This might differ from the actual playback time due to special grace types.
             */
            this.playbackStart = 0;
            /**
             * Gets or sets the duration that is used for the display of this beat. It defines the size/width of the beat in
             * the music sheet. (unit: midi ticks).
             */
            this.displayDuration = 0;
            /**
             * Gets or sets the duration that the note is played during the audio generation.
             */
            this.playbackDuration = 0;
            /**
             * Gets or sets the dynamics applied to this beat.
             */
            this.dynamics = DynamicValue.F;
            /**
             * Gets or sets a value indicating whether the beam direction should be inverted.
             */
            this.invertBeamDirection = false;
            /**
             * Gets or sets the preferred beam direction as specified in the input source.
             */
            this.preferredBeamDirection = null;
            this.isEffectSlurOrigin = false;
            this.effectSlurOrigin = null;
            this.effectSlurDestination = null;
            /**
             * Gets or sets how the beaming should be done for this beat.
             */
            this.beamingMode = BeatBeamingMode.Auto;
        }
        Object.defineProperty(Beat.prototype, "isLastOfVoice", {
            get: function () {
                return this.index === this.voice.beats.length - 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "isLegatoDestination", {
            get: function () {
                return !!this.previousBeat && this.previousBeat.isLegatoOrigin;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "isRest", {
            get: function () {
                return this.isEmpty || this.notes.length === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "hasTuplet", {
            get: function () {
                return (!(this.tupletDenominator === -1 && this.tupletNumerator === -1) &&
                    !(this.tupletDenominator === 1 && this.tupletNumerator === 1));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "hasWhammyBar", {
            get: function () {
                return this.whammyBarType !== WhammyType.None;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "hasChord", {
            get: function () {
                return !!this.chordId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "chord", {
            get: function () {
                return this.chordId ? this.voice.bar.staff.chords.get(this.chordId) : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "isTremolo", {
            get: function () {
                return !!this.tremoloSpeed;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "absoluteDisplayStart", {
            get: function () {
                return this.voice.bar.masterBar.start + this.displayStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "absolutePlaybackStart", {
            get: function () {
                return this.voice.bar.masterBar.start + this.playbackStart;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Beat.prototype, "isEffectSlurDestination", {
            get: function () {
                return !!this.effectSlurOrigin;
            },
            enumerable: false,
            configurable: true
        });
        Beat.copyTo = function (src, dst) {
            dst.id = src.id;
            dst.index = src.index;
            dst.isEmpty = src.isEmpty;
            dst.duration = src.duration;
            dst.dots = src.dots;
            dst.fadeIn = src.fadeIn;
            if (src.lyrics) {
                dst.lyrics = new Array(src.lyrics.length);
                for (var i = 0; i < src.lyrics.length; i++) {
                    dst.lyrics[i] = src.lyrics[i];
                }
            }
            dst.pop = src.pop;
            dst.hasRasgueado = src.hasRasgueado;
            dst.slap = src.slap;
            dst.tap = src.tap;
            dst.text = src.text;
            dst.brushType = src.brushType;
            dst.brushDuration = src.brushDuration;
            dst.tupletDenominator = src.tupletDenominator;
            dst.tupletNumerator = src.tupletNumerator;
            dst.vibrato = src.vibrato;
            dst.chordId = src.chordId;
            dst.graceType = src.graceType;
            dst.pickStroke = src.pickStroke;
            dst.tremoloSpeed = src.tremoloSpeed;
            dst.crescendo = src.crescendo;
            dst.displayStart = src.displayStart;
            dst.displayDuration = src.displayDuration;
            dst.playbackStart = src.playbackStart;
            dst.playbackDuration = src.playbackDuration;
            dst.dynamics = src.dynamics;
            dst.isLegatoOrigin = src.isLegatoOrigin;
            dst.invertBeamDirection = src.invertBeamDirection;
            dst.preferredBeamDirection = src.preferredBeamDirection;
            dst.whammyBarType = src.whammyBarType;
            dst.isContinuedWhammy = src.isContinuedWhammy;
            dst.ottava = src.ottava;
            dst.whammyStyle = src.whammyStyle;
            dst.beamingMode = src.beamingMode;
        };
        Beat.prototype.clone = function () {
            var beat = new Beat();
            var id = beat.id;
            for (var _i = 0, _a = this.whammyBarPoints; _i < _a.length; _i++) {
                var p = _a[_i];
                beat.addWhammyBarPoint(p.clone());
            }
            for (var _b = 0, _c = this.notes; _b < _c.length; _b++) {
                var n = _c[_b];
                beat.addNoteInternal(n.clone(), n.realValue);
            }
            Beat.copyTo(this, beat);
            for (var _d = 0, _e = this.automations; _d < _e.length; _d++) {
                var a = _e[_d];
                beat.automations.push(a.clone());
            }
            beat.id = id;
            return beat;
        };
        Beat.prototype.addWhammyBarPoint = function (point) {
            this.whammyBarPoints.push(point);
            if (!this.maxWhammyPoint || point.value > this.maxWhammyPoint.value) {
                this.maxWhammyPoint = point;
            }
            if (!this.minWhammyPoint || point.value < this.minWhammyPoint.value) {
                this.minWhammyPoint = point;
            }
            if (this.whammyBarType === WhammyType.None) {
                this.whammyBarType = WhammyType.Custom;
            }
        };
        Beat.prototype.removeWhammyBarPoint = function (index) {
            // check index
            if (index < 0 || index >= this.whammyBarPoints.length) {
                return;
            }
            // remove point
            this.whammyBarPoints.splice(index, 1);
            var point = this.whammyBarPoints[index];
            // update maxWhammy point if required
            if (point === this.maxWhammyPoint) {
                this.maxWhammyPoint = null;
                for (var _i = 0, _a = this.whammyBarPoints; _i < _a.length; _i++) {
                    var currentPoint = _a[_i];
                    if (!this.maxWhammyPoint || currentPoint.value > this.maxWhammyPoint.value) {
                        this.maxWhammyPoint = currentPoint;
                    }
                }
            }
            if (point === this.minWhammyPoint) {
                this.minWhammyPoint = null;
                for (var _b = 0, _c = this.whammyBarPoints; _b < _c.length; _b++) {
                    var currentPoint = _c[_b];
                    if (!this.minWhammyPoint || currentPoint.value < this.minWhammyPoint.value) {
                        this.minWhammyPoint = currentPoint;
                    }
                }
            }
        };
        Beat.prototype.addNote = function (note) {
            this.addNoteInternal(note, -1);
        };
        Beat.prototype.addNoteInternal = function (note, realValue) {
            if (realValue === void 0) { realValue = -1; }
            note.beat = this;
            note.index = this.notes.length;
            this.notes.push(note);
            if (note.isStringed) {
                this.noteStringLookup.set(note.string, note);
            }
            if (realValue === -1) {
                realValue = note.realValue;
            }
            this.noteValueLookup.set(realValue, note);
        };
        Beat.prototype.removeNote = function (note) {
            var index = this.notes.indexOf(note);
            if (index >= 0) {
                this.notes.splice(index, 1);
            }
        };
        Beat.prototype.getAutomation = function (type) {
            for (var i = 0, j = this.automations.length; i < j; i++) {
                var automation = this.automations[i];
                if (automation.type === type) {
                    return automation;
                }
            }
            return null;
        };
        Beat.prototype.getNoteOnString = function (noteString) {
            if (this.noteStringLookup.has(noteString)) {
                return this.noteStringLookup.get(noteString);
            }
            return null;
        };
        Beat.prototype.calculateDuration = function () {
            var ticks = MidiUtils.toTicks(this.duration);
            if (this.dots === 2) {
                ticks = MidiUtils.applyDot(ticks, true);
            }
            else if (this.dots === 1) {
                ticks = MidiUtils.applyDot(ticks, false);
            }
            if (this.tupletDenominator > 0 && this.tupletNumerator >= 0) {
                ticks = MidiUtils.applyTuplet(ticks, this.tupletNumerator, this.tupletDenominator);
            }
            return ticks;
        };
        Beat.prototype.updateDurations = function () {
            var ticks = this.calculateDuration();
            this.playbackDuration = ticks;
            this.displayDuration = ticks;
            switch (this.graceType) {
                case GraceType.BeforeBeat:
                case GraceType.OnBeat:
                    switch (this.duration) {
                        case Duration.Sixteenth:
                            this.playbackDuration = MidiUtils.toTicks(Duration.SixtyFourth);
                            break;
                        case Duration.ThirtySecond:
                            this.playbackDuration = MidiUtils.toTicks(Duration.OneHundredTwentyEighth);
                            break;
                        default:
                            this.playbackDuration = MidiUtils.toTicks(Duration.ThirtySecond);
                            break;
                    }
                    break;
                case GraceType.BendGrace:
                    this.playbackDuration /= 2;
                    break;
                default:
                    var previous = this.previousBeat;
                    if (previous && previous.graceType === GraceType.BendGrace) {
                        this.playbackDuration = previous.playbackDuration;
                    }
                    else {
                        while (previous && previous.graceType === GraceType.OnBeat) {
                            // if the previous beat is a on-beat grace it steals the duration from this beat
                            this.playbackDuration -= previous.playbackDuration;
                            previous = previous.previousBeat;
                        }
                    }
                    break;
            }
        };
        Beat.prototype.finishTuplet = function () {
            var previousBeat = this.previousBeat;
            var currentTupletGroup = previousBeat ? previousBeat.tupletGroup : null;
            if (this.hasTuplet || (this.graceType !== GraceType.None && currentTupletGroup)) {
                if (!previousBeat || !currentTupletGroup || !currentTupletGroup.check(this)) {
                    currentTupletGroup = new TupletGroup(this.voice);
                    currentTupletGroup.check(this);
                }
                this.tupletGroup = currentTupletGroup;
            }
        };
        Beat.prototype.finish = function (settings) {
            var displayMode = !settings ? exports.NotationMode.GuitarPro : settings.notation.notationMode;
            var isGradual = this.text === 'grad' || this.text === 'grad.';
            if (isGradual && displayMode === exports.NotationMode.SongBook) {
                this.text = '';
            }
            var needCopyBeatForBend = false;
            this.minNote = null;
            this.maxNote = null;
            this.minStringNote = null;
            this.maxStringNote = null;
            var visibleNotes = 0;
            var isEffectSlurBeat = false;
            for (var i = 0, j = this.notes.length; i < j; i++) {
                var note = this.notes[i];
                note.finish(settings);
                if (note.isLetRing) {
                    this.isLetRing = true;
                }
                if (note.isPalmMute) {
                    this.isPalmMute = true;
                }
                if (displayMode === exports.NotationMode.SongBook && note.hasBend && this.graceType !== GraceType.BendGrace) {
                    if (!note.isTieOrigin) {
                        switch (note.bendType) {
                            case BendType.Bend:
                            case BendType.PrebendRelease:
                            case BendType.PrebendBend:
                                needCopyBeatForBend = true;
                                break;
                        }
                    }
                    if (isGradual || note.bendStyle === BendStyle.Gradual) {
                        isGradual = true;
                        note.bendStyle = BendStyle.Gradual;
                        needCopyBeatForBend = false;
                    }
                    else {
                        note.bendStyle = BendStyle.Fast;
                    }
                }
                if (note.isVisible) {
                    visibleNotes++;
                    if (!this.minNote || note.realValue < this.minNote.realValue) {
                        this.minNote = note;
                    }
                    if (!this.maxNote || note.realValue > this.maxNote.realValue) {
                        this.maxNote = note;
                    }
                    if (!this.minStringNote || note.string < this.minStringNote.string) {
                        this.minStringNote = note;
                    }
                    if (!this.maxStringNote || note.string > this.maxStringNote.string) {
                        this.maxStringNote = note;
                    }
                    if (note.hasEffectSlur) {
                        isEffectSlurBeat = true;
                    }
                }
            }
            if (isEffectSlurBeat) {
                if (this.effectSlurOrigin) {
                    this.effectSlurOrigin.effectSlurDestination = this.nextBeat;
                    if (this.effectSlurOrigin.effectSlurDestination) {
                        this.effectSlurOrigin.effectSlurDestination.effectSlurOrigin = this.effectSlurOrigin;
                    }
                    this.effectSlurOrigin = null;
                }
                else {
                    this.isEffectSlurOrigin = true;
                    this.effectSlurDestination = this.nextBeat;
                    if (this.effectSlurDestination) {
                        this.effectSlurDestination.effectSlurOrigin = this;
                    }
                }
            }
            if (this.notes.length > 0 && visibleNotes === 0) {
                this.isEmpty = true;
            }
            // we need to clean al letring/palmmute flags for rests
            // in case the effect is not continued on this beat
            if (!this.isRest && (!this.isLetRing || !this.isPalmMute)) {
                var currentBeat = this.previousBeat;
                while (currentBeat && currentBeat.isRest) {
                    if (!this.isLetRing) {
                        currentBeat.isLetRing = false;
                    }
                    if (!this.isPalmMute) {
                        currentBeat.isPalmMute = false;
                    }
                    currentBeat = currentBeat.previousBeat;
                }
            }
            else if (this.isRest &&
                this.previousBeat &&
                settings &&
                settings.notation.notationMode === exports.NotationMode.GuitarPro) {
                if (this.previousBeat.isLetRing) {
                    this.isLetRing = true;
                }
                if (this.previousBeat.isPalmMute) {
                    this.isPalmMute = true;
                }
            }
            // try to detect what kind of bend was used and cleans unneeded points if required
            // Guitar Pro 6 and above (gpif.xml) uses exactly 4 points to define all whammys
            if (this.whammyBarPoints.length > 0 && this.whammyBarType === WhammyType.Custom) {
                if (displayMode === exports.NotationMode.SongBook) {
                    this.whammyStyle = isGradual ? BendStyle.Gradual : BendStyle.Fast;
                }
                var isContinuedWhammy = !!this.previousBeat && this.previousBeat.hasWhammyBar;
                this.isContinuedWhammy = isContinuedWhammy;
                if (this.whammyBarPoints.length === 4) {
                    var origin_1 = this.whammyBarPoints[0];
                    var middle1 = this.whammyBarPoints[1];
                    var middle2 = this.whammyBarPoints[2];
                    var destination = this.whammyBarPoints[3];
                    // the middle points are used for holds, anything else is a new feature we do not support yet
                    if (middle1.value === middle2.value) {
                        // constant decrease or increase
                        if ((origin_1.value < middle1.value && middle1.value < destination.value) ||
                            (origin_1.value > middle1.value && middle1.value > destination.value)) {
                            if (origin_1.value !== 0 && !isContinuedWhammy) {
                                this.whammyBarType = WhammyType.PrediveDive;
                            }
                            else {
                                this.whammyBarType = WhammyType.Dive;
                            }
                            this.whammyBarPoints.splice(2, 1);
                            this.whammyBarPoints.splice(1, 1);
                        }
                        else if ((origin_1.value > middle1.value && middle1.value < destination.value) ||
                            (origin_1.value < middle1.value && middle1.value > destination.value)) {
                            this.whammyBarType = WhammyType.Dip;
                            if (middle1.offset === middle2.offset || displayMode === exports.NotationMode.SongBook) {
                                this.whammyBarPoints.splice(2, 1);
                            }
                        }
                        else if (origin_1.value === middle1.value && middle1.value === destination.value) {
                            if (origin_1.value !== 0 && !isContinuedWhammy) {
                                this.whammyBarType = WhammyType.Predive;
                            }
                            else {
                                this.whammyBarType = WhammyType.Hold;
                            }
                            this.whammyBarPoints.splice(2, 1);
                            this.whammyBarPoints.splice(1, 1);
                        }
                        else {
                            Logger.warning('Model', 'Unsupported whammy type detected, fallback to custom', null);
                        }
                    }
                    else {
                        Logger.warning('Model', 'Unsupported whammy type detected, fallback to custom', null);
                    }
                }
            }
            this.updateDurations();
            if (needCopyBeatForBend) {
                // if this beat is a simple bend convert it to a grace beat
                // and generate a placeholder beat with tied notes
                var cloneBeat = this.clone();
                cloneBeat.id = Beat._globalBeatId++;
                cloneBeat.pickStroke = PickStroke.None;
                for (var i = 0, j = cloneBeat.notes.length; i < j; i++) {
                    var cloneNote = cloneBeat.notes[i];
                    var note = this.notes[i];
                    // remove bend on cloned note
                    cloneNote.bendType = BendType.None;
                    cloneNote.maxBendPoint = null;
                    cloneNote.bendPoints = [];
                    cloneNote.bendStyle = BendStyle.Default;
                    cloneNote.id = Note.GlobalNoteId++;
                    // fix ties
                    if (note.isTieOrigin) {
                        cloneNote.tieDestination = note.tieDestination;
                        note.tieDestination.tieOrigin = cloneNote;
                    }
                    if (note.isTieDestination) {
                        cloneNote.tieOrigin = note.tieOrigin;
                        note.tieOrigin.tieDestination = cloneNote;
                    }
                    // if the note has a bend which is continued on the next note
                    // we need to convert this note into a hold bend
                    if (note.hasBend && note.isTieOrigin) {
                        var tieDestination = Note.findTieOrigin(note);
                        if (tieDestination && tieDestination.hasBend) {
                            cloneNote.bendType = BendType.Hold;
                            var lastPoint = note.bendPoints[note.bendPoints.length - 1];
                            cloneNote.addBendPoint(new BendPoint(0, lastPoint.value));
                            cloneNote.addBendPoint(new BendPoint(BendPoint.MaxPosition, lastPoint.value));
                        }
                    }
                    // mark as tied note
                    cloneNote.isTieDestination = true;
                }
                this.graceType = GraceType.BendGrace;
                this.updateDurations();
                this.voice.insertBeat(this, cloneBeat);
            }
        };
        /**
         * Checks whether the current beat is timewise before the given beat.
         * @param beat
         * @returns
         */
        Beat.prototype.isBefore = function (beat) {
            return (this.voice.bar.index < beat.voice.bar.index ||
                (beat.voice.bar.index === this.voice.bar.index && this.index < beat.index));
        };
        /**
         * Checks whether the current beat is timewise after the given beat.
         * @param beat
         * @returns
         */
        Beat.prototype.isAfter = function (beat) {
            return (this.voice.bar.index > beat.voice.bar.index ||
                (beat.voice.bar.index === this.voice.bar.index && this.index > beat.index));
        };
        Beat.prototype.hasNoteOnString = function (noteString) {
            return this.noteStringLookup.has(noteString);
        };
        Beat.prototype.getNoteWithRealValue = function (noteRealValue) {
            if (this.noteValueLookup.has(noteRealValue)) {
                return this.noteValueLookup.get(noteRealValue);
            }
            return null;
        };
        Beat.prototype.chain = function () {
            for (var _i = 0, _a = this.notes; _i < _a.length; _i++) {
                var n = _a[_i];
                n.chain();
            }
        };
        Beat._globalBeatId = 0;
        return Beat;
    }());

    /**
     * A chord definition.
     */
    var Chord = /** @class */ (function () {
        function Chord() {
            /**
             * Gets or sets the name of the chord
             */
            this.name = '';
            /**
             * Indicates the first fret of the chord diagram.
             */
            this.firstFret = 1;
            /**
             * Gets or sets the frets played on the individual strings for this chord.
             * - The order in this list goes from the highest string to the lowest string.
             * - -1 indicates that the string is not played.
             */
            this.strings = [];
            /**
             * Gets or sets a list of frets where the finger should hold a barre
             */
            this.barreFrets = [];
            /**
             * Gets or sets whether the chord name is shown above the chord diagram.
             */
            this.showName = true;
            /**
             * Gets or sets whether the chord diagram is shown.
             */
            this.showDiagram = true;
            /**
             * Gets or sets whether the fingering is shown below the chord diagram.
             */
            this.showFingering = true;
        }
        Chord.copyTo = function (src, dst) {
            dst.firstFret = src.firstFret;
            dst.name = src.name;
            dst.strings = src.strings.slice(0);
            dst.barreFrets = src.barreFrets.slice(0);
            dst.showName = src.showName;
            dst.showDiagram = src.showDiagram;
            dst.showFingering = src.showFingering;
        };
        return Chord;
    }());

    var LyricsState;
    (function (LyricsState) {
        LyricsState[LyricsState["IgnoreSpaces"] = 0] = "IgnoreSpaces";
        LyricsState[LyricsState["Begin"] = 1] = "Begin";
        LyricsState[LyricsState["Text"] = 2] = "Text";
        LyricsState[LyricsState["Comment"] = 3] = "Comment";
        LyricsState[LyricsState["Dash"] = 4] = "Dash";
    })(LyricsState || (LyricsState = {}));
    /**
     * Represents the lyrics of a song.
     */
    var Lyrics = /** @class */ (function () {
        function Lyrics() {
            /**
             * Gets or sets he start bar on which the lyrics should begin.
             */
            this.startBar = 0;
            /**
             * Gets or sets the raw lyrics text in Guitar Pro format.
             * (spaces split word syllables, plus merge syllables, [..] are comments)
             */
            this.text = '';
        }
        Lyrics.prototype.finish = function () {
            this.chunks = [];
            this.parse(this.text, 0, this.chunks);
        };
        Lyrics.prototype.parse = function (str, p, chunks) {
            if (!str) {
                return;
            }
            var state = LyricsState.Begin;
            var next = LyricsState.Begin;
            var skipSpace = false;
            var start = 0;
            while (p < str.length) {
                var c = str.charCodeAt(p);
                switch (state) {
                    case LyricsState.IgnoreSpaces:
                        switch (c) {
                            case Lyrics.CharCodeLF:
                            case Lyrics.CharCodeCR:
                            case Lyrics.CharCodeTab:
                                break;
                            case Lyrics.CharCodeSpace:
                                if (!skipSpace) {
                                    state = next;
                                    continue;
                                }
                                break;
                            default:
                                skipSpace = false;
                                state = next;
                                continue;
                        }
                        break;
                    case LyricsState.Begin:
                        switch (c) {
                            case Lyrics.CharCodeBrackedOpen:
                                state = LyricsState.Comment;
                                break;
                            default:
                                start = p;
                                state = LyricsState.Text;
                                continue;
                        }
                        break;
                    case LyricsState.Comment:
                        switch (c) {
                            case Lyrics.CharCodeBrackedClose:
                                state = LyricsState.Begin;
                                break;
                        }
                        break;
                    case LyricsState.Text:
                        switch (c) {
                            case Lyrics.CharCodeDash:
                                state = LyricsState.Dash;
                                break;
                            case Lyrics.CharCodeCR:
                            case Lyrics.CharCodeLF:
                            case Lyrics.CharCodeSpace:
                                var txt = str.substr(start, p - start);
                                chunks.push(this.prepareChunk(txt));
                                state = LyricsState.IgnoreSpaces;
                                next = LyricsState.Begin;
                                break;
                        }
                        break;
                    case LyricsState.Dash:
                        switch (c) {
                            case Lyrics.CharCodeDash:
                                break;
                            default:
                                var txt = str.substr(start, p - start);
                                chunks.push(this.prepareChunk(txt));
                                skipSpace = true;
                                state = LyricsState.IgnoreSpaces;
                                next = LyricsState.Begin;
                                continue;
                        }
                        break;
                }
                p++;
            }
            if (state === LyricsState.Text) {
                if (p !== start) {
                    chunks.push(str.substr(start, p - start));
                }
            }
        };
        Lyrics.prototype.prepareChunk = function (txt) {
            return txt.split('+').join(' ');
        };
        Lyrics.CharCodeLF = 10;
        Lyrics.CharCodeTab = 9;
        Lyrics.CharCodeCR = 13;
        Lyrics.CharCodeSpace = 32;
        Lyrics.CharCodeBrackedClose = 93;
        Lyrics.CharCodeBrackedOpen = 91;
        Lyrics.CharCodeDash = 45;
        return Lyrics;
    }());

    /**
     * This public enumeration lists all available key signatures
     */
    var KeySignature;
    (function (KeySignature) {
        /**
         * Cb (7 flats)
         */
        KeySignature[KeySignature["Cb"] = -7] = "Cb";
        /**
         * Gb (6 flats)
         */
        KeySignature[KeySignature["Gb"] = -6] = "Gb";
        /**
         * Db (5 flats)
         */
        KeySignature[KeySignature["Db"] = -5] = "Db";
        /**
         * Ab (4 flats)
         */
        KeySignature[KeySignature["Ab"] = -4] = "Ab";
        /**
         * Eb (3 flats)
         */
        KeySignature[KeySignature["Eb"] = -3] = "Eb";
        /**
         * Bb (2 flats)
         */
        KeySignature[KeySignature["Bb"] = -2] = "Bb";
        /**
         * F (1 flat)
         */
        KeySignature[KeySignature["F"] = -1] = "F";
        /**
         * C (no signs)
         */
        KeySignature[KeySignature["C"] = 0] = "C";
        /**
         * G (1 sharp)
         */
        KeySignature[KeySignature["G"] = 1] = "G";
        /**
         * D (2 sharp)
         */
        KeySignature[KeySignature["D"] = 2] = "D";
        /**
         * A (3 sharp)
         */
        KeySignature[KeySignature["A"] = 3] = "A";
        /**
         * E (4 sharp)
         */
        KeySignature[KeySignature["E"] = 4] = "E";
        /**
         * B (5 sharp)
         */
        KeySignature[KeySignature["B"] = 5] = "B";
        /**
         * F# (6 sharp)
         */
        KeySignature[KeySignature["FSharp"] = 6] = "FSharp";
        /**
         * C# (8 sharp)
         */
        KeySignature[KeySignature["CSharp"] = 7] = "CSharp";
    })(KeySignature || (KeySignature = {}));

    /**
     * This public enumeration lists all available types of KeySignatures
     */
    var KeySignatureType;
    (function (KeySignatureType) {
        /**
         * Major
         */
        KeySignatureType[KeySignatureType["Major"] = 0] = "Major";
        /**
         * Minor
         */
        KeySignatureType[KeySignatureType["Minor"] = 1] = "Minor";
    })(KeySignatureType || (KeySignatureType = {}));

    /**
     * This public enumeration lists all feels of triplets.
     */
    var TripletFeel;
    (function (TripletFeel) {
        /**
         * No triplet feel
         */
        TripletFeel[TripletFeel["NoTripletFeel"] = 0] = "NoTripletFeel";
        /**
         * Triplet 16th
         */
        TripletFeel[TripletFeel["Triplet16th"] = 1] = "Triplet16th";
        /**
         * Triplet 8th
         */
        TripletFeel[TripletFeel["Triplet8th"] = 2] = "Triplet8th";
        /**
         * Dotted 16th
         */
        TripletFeel[TripletFeel["Dotted16th"] = 3] = "Dotted16th";
        /**
         * Dotted 8th
         */
        TripletFeel[TripletFeel["Dotted8th"] = 4] = "Dotted8th";
        /**
         * Scottish 16th
         */
        TripletFeel[TripletFeel["Scottish16th"] = 5] = "Scottish16th";
        /**
         * Scottish 8th
         */
        TripletFeel[TripletFeel["Scottish8th"] = 6] = "Scottish8th";
    })(TripletFeel || (TripletFeel = {}));

    /**
     * The MasterBar stores information about a bar which affects
     * all tracks.
     */
    var MasterBar = /** @class */ (function () {
        function MasterBar() {
            /**
             * Gets or sets the bitflag for the alternate endings. Each bit defines for which repeat counts
             * the bar is played.
             */
            this.alternateEndings = 0;
            /**
             * Gets or sets the next masterbar in the song.
             */
            this.nextMasterBar = null;
            /**
             * Gets or sets the next masterbar in the song.
             */
            this.previousMasterBar = null;
            /**
             * Gets the zero based index of the masterbar.
             */
            this.index = 0;
            /**
             * Gets or sets the key signature used on all bars.
             */
            this.keySignature = KeySignature.C;
            /**
             * Gets or sets the type of key signature (major/minor)
             */
            this.keySignatureType = KeySignatureType.Major;
            /**
             * Gets or sets whether a double bar is shown for this masterbar.
             */
            this.isDoubleBar = false;
            /**
             * Gets or sets whether a repeat section starts on this masterbar.
             */
            this.isRepeatStart = false;
            /**
             * Gets or sets the number of repeats for the current repeat section.
             */
            this.repeatCount = 0;
            /**
             * Gets or sets the time signature numerator.
             */
            this.timeSignatureNumerator = 4;
            /**
             * Gets or sets the time signature denominiator.
             */
            this.timeSignatureDenominator = 4;
            /**
             * Gets or sets whether this is bar has a common time signature.
             */
            this.timeSignatureCommon = false;
            /**
             * Gets or sets the triplet feel that is valid for this bar.
             */
            this.tripletFeel = TripletFeel.NoTripletFeel;
            /**
             * Gets or sets the new section information for this bar.
             */
            this.section = null;
            /**
             * Gets or sets the tempo automation for this bar.
             */
            this.tempoAutomation = null;
            /**
             * Gets or sets the fermatas for this bar. The key is the offset of the fermata in midi ticks.
             */
            this.fermata = new Map();
            /**
             * The timeline position of the voice within the whole score. (unit: midi ticks)
             */
            this.start = 0;
            /**
             * Gets or sets a value indicating whether the master bar is an anacrusis (aka. pickup bar)
             */
            this.isAnacrusis = false;
        }
        Object.defineProperty(MasterBar.prototype, "isRepeatEnd", {
            get: function () {
                return this.repeatCount > 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MasterBar.prototype, "isSectionStart", {
            get: function () {
                return !!this.section;
            },
            enumerable: false,
            configurable: true
        });
        MasterBar.copyTo = function (src, dst) {
            dst.isAnacrusis = src.isAnacrusis;
            dst.alternateEndings = src.alternateEndings;
            dst.index = src.index;
            dst.keySignature = src.keySignature;
            dst.keySignatureType = src.keySignatureType;
            dst.isDoubleBar = src.isDoubleBar;
            dst.isRepeatStart = src.isRepeatStart;
            dst.repeatCount = src.repeatCount;
            dst.timeSignatureNumerator = src.timeSignatureNumerator;
            dst.timeSignatureDenominator = src.timeSignatureDenominator;
            dst.timeSignatureCommon = src.timeSignatureCommon;
            dst.tripletFeel = src.tripletFeel;
            dst.start = src.start;
        };
        /**
         * Calculates the time spent in this bar. (unit: midi ticks)
         */
        MasterBar.prototype.calculateDuration = function (respectAnacrusis) {
            if (respectAnacrusis === void 0) { respectAnacrusis = true; }
            if (this.isAnacrusis && respectAnacrusis) {
                var duration = 0;
                for (var _i = 0, _a = this.score.tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                        var staff = _c[_b];
                        var barDuration = this.index < staff.bars.length
                            ? staff.bars[this.index].calculateDuration()
                            : 0;
                        if (barDuration > duration) {
                            duration = barDuration;
                        }
                    }
                }
                return duration;
            }
            return this.timeSignatureNumerator * MidiUtils.valueToTicks(this.timeSignatureDenominator);
        };
        /**
         * Adds a fermata to the masterbar.
         * @param offset The offset of the fermata within the bar in midi ticks.
         * @param fermata The fermata.
         */
        MasterBar.prototype.addFermata = function (offset, fermata) {
            this.fermata.set(offset, fermata);
        };
        /**
         * Gets the fermata for a given beat.
         * @param beat The beat to get the fermata for.
         * @returns
         */
        MasterBar.prototype.getFermata = function (beat) {
            if (this.fermata.has(beat.playbackStart)) {
                return this.fermata.get(beat.playbackStart);
            }
            return null;
        };
        MasterBar.MaxAlternateEndings = 8;
        return MasterBar;
    }());

    /**
     * This class represents the rendering stylesheet.
     * It contains settings which control the display of the score when rendered.
     */
    var RenderStylesheet = /** @class */ (function () {
        function RenderStylesheet() {
            /**
             * Gets or sets whether dynamics are hidden.
             */
            this.hideDynamics = false;
        }
        RenderStylesheet.copyTo = function (src, dst) {
            dst.hideDynamics = src.hideDynamics;
        };
        return RenderStylesheet;
    }());

    /**
     * This public class can store the information about a group of measures which are repeated
     */
    var RepeatGroup = /** @class */ (function () {
        function RepeatGroup() {
            /**
             * All masterbars repeated within this group
             */
            this.masterBars = [];
            /**
             * a list of masterbars which open the group.
             */
            this.openings = [];
            /**
             * a list of masterbars which close the group.
             */
            this.closings = [];
            /**
             * true if the repeat group was opened well
             */
            this.isOpened = false;
            /**
             * true if the repeat group was closed well
             */
            this.isClosed = false;
        }
        RepeatGroup.prototype.addMasterBar = function (masterBar) {
            if (this.openings.length === 0) {
                this.openings.push(masterBar);
            }
            this.masterBars.push(masterBar);
            masterBar.repeatGroup = this;
            if (masterBar.isRepeatEnd) {
                this.closings.push(masterBar);
                this.isClosed = true;
                if (!this.isOpened) {
                    this.masterBars[0].isRepeatStart = true;
                    this.isOpened = true;
                }
            }
            else if (this.isClosed) {
                this.isClosed = false;
                this.openings.push(masterBar);
            }
        };
        return RepeatGroup;
    }());

    /**
     * The score is the root node of the complete
     * model. It stores the basic information of
     * a song and stores the sub components.
     */
    var Score = /** @class */ (function () {
        function Score() {
            this._currentRepeatGroup = new RepeatGroup();
            /**
             * The album of this song.
             */
            this.album = '';
            /**
             * The artist who performs this song.
             */
            this.artist = '';
            /**
             * The owner of the copyright of this song.
             */
            this.copyright = '';
            /**
             * Additional instructions
             */
            this.instructions = '';
            /**
             * The author of the music.
             */
            this.music = '';
            /**
             * Some additional notes about the song.
             */
            this.notices = '';
            /**
             * The subtitle of the song.
             */
            this.subTitle = '';
            /**
             * The title of the song.
             */
            this.title = '';
            /**
             * The author of the song lyrics
             */
            this.words = '';
            /**
             * The author of this tablature.
             */
            this.tab = '';
            /**
             * Gets or sets the global tempo of the song in BPM. The tempo might change via {@link MasterBar.tempo}.
             */
            this.tempo = 120;
            /**
             * Gets or sets the name/label of the tempo.
             */
            this.tempoLabel = '';
            /**
             * Gets or sets a list of all masterbars contained in this song.
             */
            this.masterBars = [];
            /**
             * Gets or sets a list of all tracks contained in this song.
             */
            this.tracks = [];
            /**
             * Gets or sets the rendering stylesheet for this song.
             */
            this.stylesheet = new RenderStylesheet();
        }
        Score.copyTo = function (src, dst) {
            dst.album = src.album;
            dst.artist = src.artist;
            dst.copyright = src.copyright;
            dst.instructions = src.instructions;
            dst.music = src.music;
            dst.notices = src.notices;
            dst.subTitle = src.subTitle;
            dst.title = src.title;
            dst.words = src.words;
            dst.tab = src.tab;
            dst.tempo = src.tempo;
            dst.tempoLabel = src.tempoLabel;
        };
        Score.prototype.rebuildRepeatGroups = function () {
            var currentGroup = new RepeatGroup();
            for (var _i = 0, _a = this.masterBars; _i < _a.length; _i++) {
                var bar = _a[_i];
                // if the group is closed only the next upcoming header can
                // reopen the group in case of a repeat alternative, so we
                // remove the current group
                if (bar.isRepeatStart || (this._currentRepeatGroup.isClosed && bar.alternateEndings <= 0)) {
                    currentGroup = new RepeatGroup();
                }
                currentGroup.addMasterBar(bar);
            }
        };
        Score.prototype.addMasterBar = function (bar) {
            bar.score = this;
            bar.index = this.masterBars.length;
            if (this.masterBars.length !== 0) {
                bar.previousMasterBar = this.masterBars[this.masterBars.length - 1];
                bar.previousMasterBar.nextMasterBar = bar;
                bar.start = bar.previousMasterBar.start + bar.previousMasterBar.calculateDuration();
            }
            // if the group is closed only the next upcoming header can
            // reopen the group in case of a repeat alternative, so we
            // remove the current group
            if (bar.isRepeatStart || (this._currentRepeatGroup.isClosed && bar.alternateEndings <= 0)) {
                this._currentRepeatGroup = new RepeatGroup();
            }
            this._currentRepeatGroup.addMasterBar(bar);
            this.masterBars.push(bar);
        };
        Score.prototype.addTrack = function (track) {
            track.score = this;
            track.index = this.tracks.length;
            this.tracks.push(track);
        };
        Score.prototype.finish = function (settings) {
            for (var i = 0, j = this.tracks.length; i < j; i++) {
                this.tracks[i].finish(settings);
            }
        };
        return Score;
    }());

    /**
     * This public class is used to describe the beginning of a
     * section within a song. It acts like a marker.
     */
    var Section = /** @class */ (function () {
        function Section() {
            /**
             * Gets or sets the marker ID for this section.
             */
            this.marker = '';
            /**
             * Gets or sets the descriptional text of this section.
             */
            this.text = '';
        }
        Section.copyTo = function (src, dst) {
            dst.marker = src.marker;
            dst.text = src.text;
        };
        return Section;
    }());

    /**
     * This public class stores the midi specific information of a track needed
     * for playback.
     */
    var PlaybackInformation = /** @class */ (function () {
        function PlaybackInformation() {
            /**
             * Gets or sets the volume (0-16)
             */
            this.volume = 15;
            /**
             * Gets or sets the balance (0-16; 8=center)
             */
            this.balance = 8;
            /**
             * Gets or sets the midi port to use.
             */
            this.port = 1;
            /**
             * Gets or sets the midi program to use.
             */
            this.program = 0;
            /**
             * Gets or sets the primary channel for all normal midi events.
             */
            this.primaryChannel = 0;
            /**
             * Gets or sets the secondary channel for special midi events.
             */
            this.secondaryChannel = 0;
            /**
             * Gets or sets whether the track is muted.
             */
            this.isMute = false;
            /**
             * Gets or sets whether the track is playing alone.
             */
            this.isSolo = false;
        }
        PlaybackInformation.copyTo = function (src, dst) {
            dst.volume = src.volume;
            dst.balance = src.balance;
            dst.port = src.port;
            dst.program = src.program;
            dst.primaryChannel = src.primaryChannel;
            dst.secondaryChannel = src.secondaryChannel;
            dst.isMute = src.isMute;
            dst.isSolo = src.isSolo;
        };
        return PlaybackInformation;
    }());

    /**
     * This class describes a single staff within a track. There are instruments like pianos
     * where a single track can contain multiple staffs.
     */
    var Staff = /** @class */ (function () {
        function Staff() {
            /**
             * Gets or sets the zero-based index of this staff within the track.
             */
            this.index = 0;
            /**
             * Gets or sets a list of all bars contained in this staff.
             */
            this.bars = [];
            /**
             * Gets or sets a list of all chords defined for this staff. {@link Beat.chordId} refers to entries in this lookup.
             */
            this.chords = new Map();
            /**
             * Gets or sets the fret on which a capo is set. s
             */
            this.capo = 0;
            /**
             * Gets or sets the number of semitones this track should be
             * transposed. This applies to rendering and playback.
             */
            this.transpositionPitch = 0;
            /**
             * Gets or sets the number of semitones this track should be
             * transposed. This applies only to rendering.
             */
            this.displayTranspositionPitch = 0;
            /**
             * Get or set the guitar tuning of the guitar. This tuning also indicates the number of strings shown in the
             * guitar tablature. Unlike the {@link Note.string} property this array directly represents
             * the order of the tracks shown in the tablature. The first item is the most top tablature line.
             */
            this.tuning = [];
            /**
             * Gets or sets the name of the tuning.
             */
            this.tuningName = "";
            /**
             * Gets or sets whether the tabs are shown.
             */
            this.showTablature = true;
            /**
             * Gets or sets whether the standard notation is shown.
             */
            this.showStandardNotation = true;
            /**
             * Gets or sets whether the staff contains percussion notation
             */
            this.isPercussion = false;
            /**
             * The number of lines shown for the standard notation.
             * For some percussion instruments this number might vary.
             */
            this.standardNotationLineCount = 5;
        }
        Object.defineProperty(Staff.prototype, "isStringed", {
            get: function () {
                return this.tuning.length > 0;
            },
            enumerable: false,
            configurable: true
        });
        Staff.copyTo = function (src, dst) {
            dst.capo = src.capo;
            dst.index = src.index;
            dst.tuning = src.tuning.slice();
            dst.transpositionPitch = src.transpositionPitch;
            dst.displayTranspositionPitch = src.displayTranspositionPitch;
            dst.showStandardNotation = src.showStandardNotation;
            dst.showTablature = src.showTablature;
            dst.isPercussion = src.isPercussion;
            dst.standardNotationLineCount = src.standardNotationLineCount;
        };
        Staff.prototype.finish = function (settings) {
            for (var i = 0, j = this.bars.length; i < j; i++) {
                this.bars[i].finish(settings);
            }
        };
        Staff.prototype.addChord = function (chordId, chord) {
            chord.staff = this;
            this.chords.set(chordId, chord);
        };
        Staff.prototype.addBar = function (bar) {
            var bars = this.bars;
            bar.staff = this;
            bar.index = bars.length;
            if (bars.length > 0) {
                bar.previousBar = bars[bars.length - 1];
                bar.previousBar.nextBar = bar;
            }
            bars.push(bar);
        };
        return Staff;
    }());

    /**
     * This public class describes a single track or instrument of score.
     * It is bascially a list of staffs containing individual music notation kinds.
     */
    var Track = /** @class */ (function () {
        function Track() {
            /**
             * Gets or sets the zero-based index of this track.
             */
            this.index = 0;
            /**
             * Gets or sets the list of staffs that are defined for this track.
             */
            this.staves = [];
            /**
             * Gets or sets the playback information for this track.
             */
            this.playbackInfo = new PlaybackInformation();
            /**
             * Gets or sets the display color defined for this track.
             */
            this.color = new Color(200, 0, 0, 255);
            /**
             * Gets or sets the long name of this track.
             */
            this.name = '';
            /**
             * Gets or sets the short name of this track.
             */
            this.shortName = '';
            /**
             * Gets or sets a mapping on which staff liens particular percussion instruments
             * should be shown.
             */
            this.percussionArticulations = [];
        }
        Track.prototype.ensureStaveCount = function (staveCount) {
            while (this.staves.length < staveCount) {
                this.addStaff(new Staff());
            }
        };
        Track.prototype.addStaff = function (staff) {
            staff.index = this.staves.length;
            staff.track = this;
            this.staves.push(staff);
        };
        Track.copyTo = function (src, dst) {
            dst.name = src.name;
            dst.shortName = src.shortName;
            dst.index = src.index;
            dst.color.raw = src.color.raw;
            dst.color.rgba = src.color.rgba;
        };
        Track.prototype.finish = function (settings) {
            if (!this.shortName) {
                this.shortName = this.name;
                if (this.shortName.length > Track.ShortNameMaxLength) {
                    this.shortName = this.shortName.substr(0, Track.ShortNameMaxLength);
                }
            }
            for (var i = 0, j = this.staves.length; i < j; i++) {
                this.staves[i].finish(settings);
            }
        };
        Track.prototype.applyLyrics = function (lyrics) {
            for (var _i = 0, lyrics_1 = lyrics; _i < lyrics_1.length; _i++) {
                var lyric = lyrics_1[_i];
                lyric.finish();
            }
            var staff = this.staves[0];
            for (var li = 0; li < lyrics.length; li++) {
                var lyric = lyrics[li];
                if (lyric.startBar >= 0 && lyric.startBar < staff.bars.length) {
                    var beat = staff.bars[lyric.startBar].voices[0].beats[0];
                    for (var ci = 0; ci < lyric.chunks.length && beat; ci++) {
                        // skip rests and empty beats
                        while (beat && (beat.isEmpty || beat.isRest)) {
                            beat = beat.nextBeat;
                        }
                        // mismatch between chunks and beats might lead to missing beats
                        if (beat) {
                            // initialize lyrics list for beat if required
                            if (!beat.lyrics) {
                                beat.lyrics = new Array(lyrics.length);
                            }
                            // assign chunk
                            beat.lyrics[li] = lyric.chunks[ci];
                            beat = beat.nextBeat;
                        }
                    }
                }
            }
        };
        Track.ShortNameMaxLength = 10;
        return Track;
    }());

    /**
     * This public class represents a predefined string tuning.
     */
    var Tuning = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link Tuning} class.
         * @param name The name.
         * @param tuning The tuning.
         * @param isStandard if set to`true`[is standard].
         */
        function Tuning(name, tuning, isStandard) {
            this.isStandard = isStandard;
            this.name = name;
            this.tunings = tuning;
        }
        Tuning.getTextForTuning = function (tuning, includeOctave) {
            var octave = (tuning / 12) | 0;
            var note = tuning % 12;
            var notes = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
            var result = notes[note];
            if (includeOctave) {
                result += octave - 1;
            }
            return result;
        };
        /**
         * Gets the default tuning for the given string count.
         * @param stringCount The string count.
         * @returns The tuning for the given string count or null if the string count is not defined.
         */
        Tuning.getDefaultTuningFor = function (stringCount) {
            if (Tuning._defaultTunings.has(stringCount)) {
                return Tuning._defaultTunings.get(stringCount);
            }
            return null;
        };
        /**
         * Gets a list of all tuning presets for a given stirng count.
         * @param stringCount The string count.
         * @returns The list of known tunings for the given string count or an empty list if the string count is not defined.
         */
        Tuning.getPresetsFor = function (stringCount) {
            switch (stringCount) {
                case 7:
                    return Tuning._sevenStrings;
                case 6:
                    return Tuning._sixStrings;
                case 5:
                    return Tuning._fiveStrings;
                case 4:
                    return Tuning._fourStrings;
            }
            return [];
        };
        Tuning.initialize = function () {
            Tuning._defaultTunings.set(7, new Tuning('Guitar 7 strings', [64, 59, 55, 50, 45, 40, 35], true));
            Tuning._sevenStrings.push(Tuning._defaultTunings.get(7));
            Tuning._defaultTunings.set(6, new Tuning('Guitar Standard Tuning', [64, 59, 55, 50, 45, 40], true));
            Tuning._sixStrings.push(Tuning._defaultTunings.get(6));
            Tuning._sixStrings.push(new Tuning('Guitar Tune down Â½ step', [63, 58, 54, 49, 44, 39], false));
            Tuning._sixStrings.push(new Tuning('Guitar Tune down 1 step', [62, 57, 53, 48, 43, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Tune down 2 step', [60, 55, 51, 46, 41, 36], false));
            Tuning._sixStrings.push(new Tuning('Guitar Dropped D Tuning', [64, 59, 55, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Dropped D Tuning variant', [64, 57, 55, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Double Dropped D Tuning', [62, 59, 55, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Dropped E Tuning', [66, 61, 57, 52, 47, 40], false));
            Tuning._sixStrings.push(new Tuning('Guitar Dropped C Tuning', [62, 57, 53, 48, 43, 36], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open C Tuning', [64, 60, 55, 48, 43, 36], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Cm Tuning', [63, 60, 55, 48, 43, 36], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open C6 Tuning', [64, 57, 55, 48, 43, 36], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Cmaj7 Tuning', [64, 59, 55, 52, 43, 36], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open D Tuning', [62, 57, 54, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Dm Tuning', [62, 57, 53, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open D5 Tuning', [62, 57, 50, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open D6 Tuning', [62, 59, 54, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Dsus4 Tuning', [62, 57, 55, 50, 45, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open E Tuning', [64, 59, 56, 52, 47, 40], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Em Tuning', [64, 59, 55, 52, 47, 40], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Esus11 Tuning', [64, 59, 55, 52, 45, 40], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open F Tuning', [65, 60, 53, 48, 45, 41], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open G Tuning', [62, 59, 55, 50, 43, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Gm Tuning', [62, 58, 55, 50, 43, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open G6 Tuning', [64, 59, 55, 50, 43, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Gsus4 Tuning', [62, 60, 55, 50, 43, 38], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open A Tuning', [64, 61, 57, 52, 45, 40], false));
            Tuning._sixStrings.push(new Tuning('Guitar Open Am Tuning', [64, 60, 57, 52, 45, 40], false));
            Tuning._sixStrings.push(new Tuning('Guitar Nashville Tuning', [64, 59, 67, 62, 57, 52], false));
            Tuning._sixStrings.push(new Tuning('Bass 6 Strings Tuning', [48, 43, 38, 33, 28, 23], false));
            Tuning._sixStrings.push(new Tuning('Lute or Vihuela Tuning', [64, 59, 54, 50, 45, 40], false));
            Tuning._defaultTunings.set(5, new Tuning('Bass 5 Strings Tuning', [43, 38, 33, 28, 23], true));
            Tuning._fiveStrings.push(Tuning._defaultTunings.get(5));
            Tuning._fiveStrings.push(new Tuning('Banjo Dropped C Tuning', [62, 59, 55, 48, 67], false));
            Tuning._fiveStrings.push(new Tuning('Banjo Open D Tuning', [62, 57, 54, 50, 69], false));
            Tuning._fiveStrings.push(new Tuning('Banjo Open G Tuning', [62, 59, 55, 50, 67], false));
            Tuning._fiveStrings.push(new Tuning('Banjo G Minor Tuning', [62, 58, 55, 50, 67], false));
            Tuning._fiveStrings.push(new Tuning('Banjo G Modal Tuning', [62, 57, 55, 50, 67], false));
            Tuning._defaultTunings.set(4, new Tuning('Bass Standard Tuning', [43, 38, 33, 28], true));
            Tuning._fourStrings.push(Tuning._defaultTunings.get(4));
            Tuning._fourStrings.push(new Tuning('Bass Tune down Â½ step', [42, 37, 32, 27], false));
            Tuning._fourStrings.push(new Tuning('Bass Tune down 1 step', [41, 36, 31, 26], false));
            Tuning._fourStrings.push(new Tuning('Bass Tune down 2 step', [39, 34, 29, 24], false));
            Tuning._fourStrings.push(new Tuning('Bass Dropped D Tuning', [43, 38, 33, 26], false));
            Tuning._fourStrings.push(new Tuning('Ukulele C Tuning', [45, 40, 36, 43], false));
            Tuning._fourStrings.push(new Tuning('Ukulele G Tuning', [52, 47, 43, 38], false));
            Tuning._fourStrings.push(new Tuning('Mandolin Standard Tuning', [64, 57, 50, 43], false));
            Tuning._fourStrings.push(new Tuning('Mandolin or Violin Tuning', [76, 69, 62, 55], false));
            Tuning._fourStrings.push(new Tuning('Viola Tuning', [69, 62, 55, 48], false));
            Tuning._fourStrings.push(new Tuning('Cello Tuning', [57, 50, 43, 36], false));
        };
        /**
         * Tries to find a known tuning by a given list of tuning values.
         * @param strings The values defining the tuning.
         * @returns The known tuning.
         */
        Tuning.findTuning = function (strings) {
            var tunings = Tuning.getPresetsFor(strings.length);
            for (var t = 0, tc = tunings.length; t < tc; t++) {
                var tuning = tunings[t];
                var equals = true;
                for (var i = 0, j = strings.length; i < j; i++) {
                    if (strings[i] !== tuning.tunings[i]) {
                        equals = false;
                        break;
                    }
                }
                if (equals) {
                    return tuning;
                }
            }
            return null;
        };
        Tuning._sevenStrings = [];
        Tuning._sixStrings = [];
        Tuning._fiveStrings = [];
        Tuning._fourStrings = [];
        Tuning._defaultTunings = new Map();
        return Tuning;
    }());
    Tuning.initialize();

    /**
     * A voice represents a group of beats
     * that can be played during a bar.
     */
    var Voice = /** @class */ (function () {
        function Voice() {
            /**
             * Gets or sets the zero-based index of this voice within the bar.
             */
            this.index = 0;
            /**
             * Gets or sets the list of beats contained in this voice.
             */
            this.beats = [];
            /**
             * Gets or sets a value indicating whether this voice is empty.
             */
            this.isEmpty = true;
        }
        Voice.copyTo = function (src, dst) {
            dst.index = src.index;
            dst.isEmpty = src.isEmpty;
        };
        Voice.prototype.insertBeat = function (after, newBeat) {
            newBeat.nextBeat = after.nextBeat;
            if (newBeat.nextBeat) {
                newBeat.nextBeat.previousBeat = newBeat;
            }
            newBeat.previousBeat = after;
            newBeat.voice = this;
            after.nextBeat = newBeat;
            this.beats.splice(after.index + 1, 0, newBeat);
        };
        Voice.prototype.addBeat = function (beat) {
            beat.voice = this;
            beat.index = this.beats.length;
            this.beats.push(beat);
            if (!beat.isEmpty) {
                this.isEmpty = false;
            }
        };
        Voice.prototype.chain = function (beat) {
            if (!this.bar) {
                return;
            }
            if (beat.index < this.beats.length - 1) {
                beat.nextBeat = this.beats[beat.index + 1];
                beat.nextBeat.previousBeat = beat;
            }
            else if (beat.isLastOfVoice && beat.voice.bar.nextBar) {
                var nextVoice = this.bar.nextBar.voices[this.index];
                if (nextVoice.beats.length > 0) {
                    beat.nextBeat = nextVoice.beats[0];
                    beat.nextBeat.previousBeat = beat;
                }
                else {
                    beat.nextBeat.previousBeat = beat;
                }
            }
            beat.chain();
        };
        Voice.prototype.addGraceBeat = function (beat) {
            if (this.beats.length === 0) {
                this.addBeat(beat);
                return;
            }
            // remove last beat
            var lastBeat = this.beats[this.beats.length - 1];
            this.beats.splice(this.beats.length - 1, 1);
            // insert grace beat
            this.addBeat(beat);
            // reinsert last beat
            this.addBeat(lastBeat);
            this.isEmpty = false;
        };
        Voice.prototype.getBeatAtDisplayStart = function (displayStart) {
            if (this._beatLookup.has(displayStart)) {
                return this._beatLookup.get(displayStart);
            }
            return null;
        };
        Voice.prototype.finish = function (settings) {
            this._beatLookup = new Map();
            for (var index = 0; index < this.beats.length; index++) {
                var beat = this.beats[index];
                beat.index = index;
                this.chain(beat);
            }
            var currentDisplayTick = 0;
            var currentPlaybackTick = 0;
            for (var i = 0; i < this.beats.length; i++) {
                var beat = this.beats[i];
                beat.index = i;
                beat.finish(settings);
                if (beat.graceType === GraceType.None || beat.graceType === GraceType.BendGrace) {
                    beat.displayStart = currentDisplayTick;
                    beat.playbackStart = currentPlaybackTick;
                    currentDisplayTick += beat.displayDuration;
                    currentPlaybackTick += beat.playbackDuration;
                }
                else {
                    if (!beat.previousBeat || beat.previousBeat.graceType === GraceType.None) {
                        // find note which is not a grace note
                        var nonGrace = beat;
                        var numberOfGraceBeats = 0;
                        while (nonGrace && nonGrace.graceType !== GraceType.None) {
                            nonGrace = nonGrace.nextBeat;
                            numberOfGraceBeats++;
                        }
                        var graceDuration = Duration.Eighth;
                        var stolenDuration = 0;
                        if (numberOfGraceBeats === 1) {
                            graceDuration = Duration.Eighth;
                        }
                        else if (numberOfGraceBeats === 2) {
                            graceDuration = Duration.Sixteenth;
                        }
                        else {
                            graceDuration = Duration.ThirtySecond;
                        }
                        if (nonGrace) {
                            nonGrace.updateDurations();
                        }
                        // grace beats have 1/4 size of the non grace beat preceeding them
                        var perGraceDisplayDuration = !beat.previousBeat
                            ? MidiUtils.toTicks(Duration.ThirtySecond)
                            : (((beat.previousBeat.displayDuration / 4) | 0) / numberOfGraceBeats) | 0;
                        // move all grace beats
                        var graceBeat = this.beats[i];
                        for (var j = 0; j < numberOfGraceBeats && graceBeat; j++) {
                            graceBeat.duration = graceDuration;
                            graceBeat.updateDurations();
                            graceBeat.displayStart =
                                currentDisplayTick - (numberOfGraceBeats - j + 1) * perGraceDisplayDuration;
                            graceBeat.displayDuration = perGraceDisplayDuration;
                            stolenDuration += graceBeat.playbackDuration;
                            graceBeat = graceBeat.nextBeat;
                        }
                        // steal needed duration from beat duration
                        if (beat.graceType === GraceType.BeforeBeat) {
                            if (beat.previousBeat) {
                                beat.previousBeat.playbackDuration -= stolenDuration;
                            }
                            currentPlaybackTick -= stolenDuration;
                        }
                        else if (nonGrace && beat.graceType === GraceType.OnBeat) {
                            nonGrace.playbackDuration -= stolenDuration;
                        }
                    }
                    beat.playbackStart = currentPlaybackTick;
                    currentPlaybackTick = beat.playbackStart + beat.playbackDuration;
                }
                if (beat.fermata) {
                    this.bar.masterBar.addFermata(beat.playbackStart, beat.fermata);
                }
                else {
                    beat.fermata = this.bar.masterBar.getFermata(beat);
                }
                beat.finishTuplet();
                this._beatLookup.set(beat.displayStart, beat);
            }
        };
        Voice.prototype.calculateDuration = function () {
            if (this.isEmpty || this.beats.length === 0) {
                return 0;
            }
            var lastBeat = this.beats[this.beats.length - 1];
            var firstBeat = this.beats[0];
            return lastBeat.playbackStart + lastBeat.playbackDuration - firstBeat.playbackStart;
        };
        return Voice;
    }());

    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * A list of terminals recognized by the alphaTex-parser
     */
    var AlphaTexSymbols;
    (function (AlphaTexSymbols) {
        AlphaTexSymbols[AlphaTexSymbols["No"] = 0] = "No";
        AlphaTexSymbols[AlphaTexSymbols["Eof"] = 1] = "Eof";
        AlphaTexSymbols[AlphaTexSymbols["Number"] = 2] = "Number";
        AlphaTexSymbols[AlphaTexSymbols["DoubleDot"] = 3] = "DoubleDot";
        AlphaTexSymbols[AlphaTexSymbols["Dot"] = 4] = "Dot";
        AlphaTexSymbols[AlphaTexSymbols["String"] = 5] = "String";
        AlphaTexSymbols[AlphaTexSymbols["Tuning"] = 6] = "Tuning";
        AlphaTexSymbols[AlphaTexSymbols["LParensis"] = 7] = "LParensis";
        AlphaTexSymbols[AlphaTexSymbols["RParensis"] = 8] = "RParensis";
        AlphaTexSymbols[AlphaTexSymbols["LBrace"] = 9] = "LBrace";
        AlphaTexSymbols[AlphaTexSymbols["RBrace"] = 10] = "RBrace";
        AlphaTexSymbols[AlphaTexSymbols["Pipe"] = 11] = "Pipe";
        AlphaTexSymbols[AlphaTexSymbols["MetaCommand"] = 12] = "MetaCommand";
        AlphaTexSymbols[AlphaTexSymbols["Multiply"] = 13] = "Multiply";
        AlphaTexSymbols[AlphaTexSymbols["LowerThan"] = 14] = "LowerThan";
        AlphaTexSymbols[AlphaTexSymbols["Property"] = 15] = "Property";
    })(AlphaTexSymbols || (AlphaTexSymbols = {}));
    var AlphaTexError = /** @class */ (function (_super) {
        __extends$3(AlphaTexError, _super);
        function AlphaTexError(message) {
            var _this = _super.call(this, exports.AlphaTabErrorType.AlphaTex, message) || this;
            _this.position = 0;
            _this.nonTerm = '';
            _this.expected = AlphaTexSymbols.No;
            _this.symbol = AlphaTexSymbols.No;
            Object.setPrototypeOf(_this, AlphaTexError.prototype);
            return _this;
        }
        AlphaTexError.symbolError = function (position, nonTerm, expected, symbol, symbolData) {
            if (symbolData === void 0) { symbolData = null; }
            var message;
            if (!symbolData) {
                message = "MalFormed AlphaTex: @" + position + ": Error on block " + nonTerm + ", expected a " + AlphaTexSymbols[expected] + " found a " + AlphaTexSymbols[symbol] + ": '" + symbolData + "'";
            }
            else {
                message = "MalFormed AlphaTex: @" + position + ": Error on block " + nonTerm + ", invalid value: " + symbolData;
            }
            var exception = new AlphaTexError(message);
            exception.position = position;
            exception.nonTerm = nonTerm;
            exception.expected = expected;
            exception.symbol = symbol;
            exception.symbolData = symbolData;
            return exception;
        };
        AlphaTexError.errorMessage = function (position, message) {
            message = 'MalFormed AlphaTex: @' + position + ': ' + message;
            var exception = new AlphaTexError(message);
            exception.position = position;
            return exception;
        };
        return AlphaTexError;
    }(AlphaTabError));
    /**
     * This importer can parse alphaTex markup into a score structure.
     */
    var AlphaTexImporter = /** @class */ (function (_super) {
        __extends$3(AlphaTexImporter, _super);
        function AlphaTexImporter() {
            var _this = _super.call(this) || this;
            _this._trackChannel = 0;
            _this._ch = 0;
            _this._curChPos = 0;
            _this._sy = AlphaTexSymbols.No;
            _this._allowNegatives = false;
            _this._allowTuning = false;
            _this._currentDuration = Duration.QuadrupleWhole;
            _this._currentDynamics = DynamicValue.PPP;
            _this._currentTuplet = 0;
            return _this;
        }
        Object.defineProperty(AlphaTexImporter.prototype, "name", {
            get: function () {
                return 'AlphaTex';
            },
            enumerable: false,
            configurable: true
        });
        AlphaTexImporter.prototype.readScore = function () {
            var _this = this;
            try {
                this._allowTuning = true;
                this._lyrics = new Map();
                this.createDefaultScore();
                this._curChPos = 0;
                this._currentDuration = Duration.Quarter;
                this._currentDynamics = DynamicValue.F;
                this._currentTuplet = 1;
                this._ch = this.nextChar();
                this._sy = this.newSy();
                if (this._sy === AlphaTexSymbols.LowerThan) {
                    // potential XML, stop parsing (alphaTex never starts with <)
                    throw new UnsupportedFormatError('Unknown start sign <');
                }
                this.score();
                this.consolidate();
                this._score.finish(this.settings);
                this._score.rebuildRepeatGroups();
                this._lyrics.forEach(function (lyrics, track) {
                    _this._score.tracks[track].applyLyrics(lyrics);
                });
                return this._score;
            }
            catch (e) {
                if (e instanceof AlphaTexError) {
                    throw new UnsupportedFormatError(e.message);
                }
                else {
                    throw e;
                }
            }
        };
        AlphaTexImporter.prototype.consolidate = function () {
            // the number of bars per staff and track could be inconsistent,
            // we need to ensure all staffs of all tracks have the correct number of bars
            for (var _i = 0, _a = this._score.tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                    var staff = _c[_b];
                    while (staff.bars.length < this._score.masterBars.length) {
                        var bar = this.newBar(staff);
                        var emptyBeat = new Beat();
                        emptyBeat.isEmpty = true;
                        bar.voices[0].addBeat(emptyBeat);
                    }
                }
            }
        };
        AlphaTexImporter.prototype.error = function (nonterm, expected, symbolError) {
            if (symbolError === void 0) { symbolError = true; }
            var e;
            if (symbolError) {
                e = AlphaTexError.symbolError(this._curChPos, nonterm, expected, this._sy, null);
            }
            else {
                e = AlphaTexError.symbolError(this._curChPos, nonterm, expected, expected, this._syData);
            }
            Logger.error(this.name, e.message);
            throw e;
        };
        AlphaTexImporter.prototype.errorMessage = function (message) {
            var e = AlphaTexError.errorMessage(this._curChPos, message);
            Logger.error(this.name, e.message);
            throw e;
        };
        /**
         * Initializes the song with some required default values.
         * @returns
         */
        AlphaTexImporter.prototype.createDefaultScore = function () {
            this._score = new Score();
            this._score.tempo = 120;
            this._score.tempoLabel = '';
            this.newTrack();
        };
        AlphaTexImporter.prototype.newTrack = function () {
            this._currentTrack = new Track();
            this._currentTrack.ensureStaveCount(1);
            this._currentTrack.playbackInfo.program = 25;
            this._currentTrack.playbackInfo.primaryChannel = this._trackChannel++;
            this._currentTrack.playbackInfo.secondaryChannel = this._trackChannel++;
            this._currentStaff = this._currentTrack.staves[0];
            this._currentStaff.displayTranspositionPitch = -12;
            this._currentStaff.tuning = Tuning.getDefaultTuningFor(6).tunings;
            this._score.addTrack(this._currentTrack);
            this._lyrics.set(this._currentTrack.index, []);
            this._currentDynamics = DynamicValue.F;
        };
        /**
         * Converts a clef string into the clef value.
         * @param str the string to convert
         * @returns the clef value
         */
        AlphaTexImporter.prototype.parseClefFromString = function (str) {
            switch (str.toLowerCase()) {
                case 'g2':
                case 'treble':
                    return Clef.G2;
                case 'f4':
                case 'bass':
                    return Clef.F4;
                case 'c3':
                case 'tenor':
                    return Clef.C3;
                case 'c4':
                case 'alto':
                    return Clef.C4;
                case 'n':
                case 'neutral':
                    return Clef.Neutral;
                default:
                    return Clef.G2;
                // error("clef-value", AlphaTexSymbols.String, false);
            }
        };
        /**
         * Converts a clef tuning into the clef value.
         * @param i the tuning value to convert
         * @returns the clef value
         */
        AlphaTexImporter.prototype.parseClefFromInt = function (i) {
            switch (i) {
                case 43:
                    return Clef.G2;
                case 65:
                    return Clef.F4;
                case 48:
                    return Clef.C3;
                case 60:
                    return Clef.C4;
                default:
                    return Clef.G2;
            }
        };
        AlphaTexImporter.prototype.parseTripletFeelFromString = function (str) {
            switch (str.toLowerCase()) {
                case 'no':
                case 'none':
                    return TripletFeel.NoTripletFeel;
                case 't16':
                case 'triplet-16th':
                    return TripletFeel.Triplet16th;
                case 't8':
                case 'triplet-8th':
                    return TripletFeel.Triplet8th;
                case 'd16':
                case 'dotted-16th':
                    return TripletFeel.Dotted16th;
                case 'd8':
                case 'dotted-8th':
                    return TripletFeel.Dotted8th;
                case 's16':
                case 'scottish-16th':
                    return TripletFeel.Scottish16th;
                case 's8':
                case 'scottish-8th':
                    return TripletFeel.Scottish8th;
                default:
                    return TripletFeel.NoTripletFeel;
            }
        };
        AlphaTexImporter.prototype.parseTripletFeelFromInt = function (i) {
            switch (i) {
                case 0:
                    return TripletFeel.NoTripletFeel;
                case 1:
                    return TripletFeel.Triplet16th;
                case 2:
                    return TripletFeel.Triplet8th;
                case 3:
                    return TripletFeel.Dotted16th;
                case 4:
                    return TripletFeel.Dotted8th;
                case 5:
                    return TripletFeel.Scottish16th;
                case 6:
                    return TripletFeel.Scottish8th;
                default:
                    return TripletFeel.NoTripletFeel;
            }
        };
        /**
         * Converts a keysignature string into the assocciated value.
         * @param str the string to convert
         * @returns the assocciated keysignature value
         */
        AlphaTexImporter.prototype.parseKeySignature = function (str) {
            switch (str.toLowerCase()) {
                case 'cb':
                    return -7;
                case 'gb':
                    return -6;
                case 'db':
                    return -5;
                case 'ab':
                    return -4;
                case 'eb':
                    return -3;
                case 'bb':
                    return -2;
                case 'f':
                    return -1;
                case 'c':
                    return 0;
                case 'g':
                    return 1;
                case 'd':
                    return 2;
                case 'a':
                    return 3;
                case 'e':
                    return 4;
                case 'b':
                    return 5;
                case 'f#':
                    return 6;
                case 'c#':
                    return 7;
                default:
                    return 0;
                // error("keysignature-value", AlphaTexSymbols.String, false); return 0
            }
        };
        /**
         * Reads the next character of the source stream.
         */
        AlphaTexImporter.prototype.nextChar = function () {
            var b = this.data.readByte();
            if (b === -1) {
                this._ch = 0;
            }
            else {
                this._ch = b;
                this._curChPos++;
            }
            return this._ch;
        };
        /**
         * Reads the next terminal symbol.
         */
        AlphaTexImporter.prototype.newSy = function () {
            this._sy = AlphaTexSymbols.No;
            do {
                if (this._ch === AlphaTexImporter.Eof) {
                    this._sy = AlphaTexSymbols.Eof;
                }
                else if (this._ch === 0x20 || this._ch === 0x0b || this._ch === 0x0d || this._ch === 0x0a || this._ch === 0x09) {
                    // skip whitespaces
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x2f /* / */) {
                    this._ch = this.nextChar();
                    if (this._ch === 0x2f /* / */) {
                        // single line comment
                        while (this._ch !== 0x0d /* \r */ &&
                            this._ch !== 0x0a /* \n */ &&
                            this._ch !== AlphaTexImporter.Eof) {
                            this._ch = this.nextChar();
                        }
                    }
                    else if (this._ch === 0x2a /* * */) {
                        // multiline comment
                        while (this._ch !== 0) {
                            if (this._ch === 0x2a /* * */) {
                                this._ch = this.nextChar();
                                if (this._ch === 0x2f /* / */) {
                                    this._ch = this.nextChar();
                                    break;
                                }
                            }
                            else {
                                this._ch = this.nextChar();
                            }
                        }
                    }
                    else {
                        this.error('symbol', AlphaTexSymbols.String, false);
                    }
                }
                else if (this._ch === 0x22 /* " */ || this._ch === 0x27 /* ' */) {
                    var startChar = this._ch;
                    this._ch = this.nextChar();
                    var s = '';
                    this._sy = AlphaTexSymbols.String;
                    while (this._ch !== startChar && this._ch !== AlphaTexImporter.Eof) {
                        s += String.fromCharCode(this._ch);
                        this._ch = this.nextChar();
                    }
                    this._syData = s;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x2d /* - */) {
                    // negative number
                    // is number?
                    if (this._allowNegatives && this.isDigit(this._ch)) {
                        var num = this.readNumber();
                        this._sy = AlphaTexSymbols.Number;
                        this._syData = num;
                    }
                    else {
                        this._sy = AlphaTexSymbols.String;
                        this._syData = this.readName();
                    }
                }
                else if (this._ch === 0x2e /* . */) {
                    this._sy = AlphaTexSymbols.Dot;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x3a /* : */) {
                    this._sy = AlphaTexSymbols.DoubleDot;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x28 /* ( */) {
                    this._sy = AlphaTexSymbols.LParensis;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x5c /* \ */) {
                    this._ch = this.nextChar();
                    var name_1 = this.readName();
                    this._sy = AlphaTexSymbols.MetaCommand;
                    this._syData = name_1;
                }
                else if (this._ch === 0x29 /* ) */) {
                    this._sy = AlphaTexSymbols.RParensis;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x7b /* { */) {
                    this._sy = AlphaTexSymbols.LBrace;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x7d /* } */) {
                    this._sy = AlphaTexSymbols.RBrace;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x7c /* | */) {
                    this._sy = AlphaTexSymbols.Pipe;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x2a /* * */) {
                    this._sy = AlphaTexSymbols.Multiply;
                    this._ch = this.nextChar();
                }
                else if (this._ch === 0x3c /* < */) {
                    this._sy = AlphaTexSymbols.LowerThan;
                    this._ch = this.nextChar();
                }
                else if (this.isDigit(this._ch)) {
                    var num = this.readNumber();
                    this._sy = AlphaTexSymbols.Number;
                    this._syData = num;
                }
                else if (AlphaTexImporter.isLetter(this._ch)) {
                    var name_2 = this.readName();
                    var tuning = this._allowTuning ? ModelUtils.parseTuning(name_2) : null;
                    if (tuning) {
                        this._sy = AlphaTexSymbols.Tuning;
                        this._syData = tuning;
                    }
                    else {
                        this._sy = AlphaTexSymbols.String;
                        this._syData = name_2;
                    }
                }
                else {
                    this.error('symbol', AlphaTexSymbols.String, false);
                }
            } while (this._sy === AlphaTexSymbols.No);
            return this._sy;
        };
        /**
         * Checks if the given character is a letter.
         * (no control characters, whitespaces, numbers or dots)
         * @param code the character
         * @returns true if the given character is a letter, otherwise false.
         */
        AlphaTexImporter.isLetter = function (code) {
            // no control characters, whitespaces, numbers or dots
            return (!AlphaTexImporter.isTerminal(code) &&
                ((code >= 0x21 && code <= 0x2f) || (code >= 0x3a && code <= 0x7e) || code > 0x80)); /* Unicode Symbols */
        };
        /**
         * Checks if the given charater is a non terminal.
         * @param ch the character
         * @returns true if the given character is a terminal, otherwise false.
         */
        AlphaTexImporter.isTerminal = function (ch) {
            return (ch === 0x2e /* . */ ||
                ch === 0x7b /* { */ ||
                ch === 0x7d /* } */ ||
                ch === 0x5b /* [ */ ||
                ch === 0x5d /* ] */ ||
                ch === 0x28 /* ( */ ||
                ch === 0x29 /* ) */ ||
                ch === 0x7c /* | */ ||
                ch === 0x27 /* ' */ ||
                ch === 0x22 /* " */ ||
                ch === 0x5c /* \ */);
        };
        /**
         * Checks if the given character is a digit.
         * @param code the character
         * @returns true if the given character is a digit, otherwise false.
         */
        AlphaTexImporter.prototype.isDigit = function (code) {
            return (code >= 0x30 && code <= 0x39) /*0-9*/ || (code === 0x2d /* - */ && this._allowNegatives); // allow - if negatives
        };
        /**
         * Reads a string from the stream.
         * @returns the read string.
         */
        AlphaTexImporter.prototype.readName = function () {
            var str = '';
            do {
                str += String.fromCharCode(this._ch);
                this._ch = this.nextChar();
            } while (AlphaTexImporter.isLetter(this._ch) || this.isDigit(this._ch) || this._ch === 0x23);
            return str;
        };
        /**
         * Reads a number from the stream.
         * @returns the read number.
         */
        AlphaTexImporter.prototype.readNumber = function () {
            var str = '';
            do {
                str += String.fromCharCode(this._ch);
                this._ch = this.nextChar();
            } while (this.isDigit(this._ch));
            return parseInt(str);
        };
        AlphaTexImporter.prototype.score = function () {
            this.metaData();
            this.bars();
        };
        AlphaTexImporter.prototype.metaData = function () {
            var anyMeta = false;
            var continueReading = true;
            while (this._sy === AlphaTexSymbols.MetaCommand && continueReading) {
                var syData = this._syData.toLowerCase();
                switch (syData) {
                    case 'title':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.title = this._syData;
                        }
                        else {
                            this.error('title', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'subtitle':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.subTitle = this._syData;
                        }
                        else {
                            this.error('subtitle', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'artist':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.artist = this._syData;
                        }
                        else {
                            this.error('artist', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'album':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.album = this._syData;
                        }
                        else {
                            this.error('album', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'words':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.words = this._syData;
                        }
                        else {
                            this.error('words', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'music':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.music = this._syData;
                        }
                        else {
                            this.error('music', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'copyright':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.String) {
                            this._score.copyright = this._syData;
                        }
                        else {
                            this.error('copyright', AlphaTexSymbols.String, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    case 'tempo':
                        this._sy = this.newSy();
                        if (this._sy === AlphaTexSymbols.Number) {
                            this._score.tempo = this._syData;
                        }
                        else {
                            this.error('tempo', AlphaTexSymbols.Number, true);
                        }
                        this._sy = this.newSy();
                        anyMeta = true;
                        break;
                    default:
                        if (this.handleStaffMeta()) {
                            anyMeta = true;
                        }
                        else if (anyMeta) {
                            // invalid meta encountered
                            this.error('metaDataTags', AlphaTexSymbols.String, false);
                        }
                        else {
                            // fall forward to bar meta if unknown score meta was found
                            continueReading = false;
                        }
                        break;
                }
            }
            if (anyMeta) {
                if (this._sy !== AlphaTexSymbols.Dot) {
                    this.error('song', AlphaTexSymbols.Dot, true);
                }
                this._sy = this.newSy();
            }
            else if (this._sy === AlphaTexSymbols.Dot) {
                this._sy = this.newSy();
            }
        };
        AlphaTexImporter.prototype.handleStaffMeta = function () {
            var syData = this._syData.toLowerCase();
            switch (syData) {
                case 'capo':
                    this._sy = this.newSy();
                    if (this._sy === AlphaTexSymbols.Number) {
                        this._currentStaff.capo = this._syData;
                    }
                    else {
                        this.error('capo', AlphaTexSymbols.Number, true);
                    }
                    this._sy = this.newSy();
                    return true;
                case 'tuning':
                    this._sy = this.newSy();
                    var strings = this._currentStaff.tuning.length;
                    switch (this._sy) {
                        case AlphaTexSymbols.String:
                            var text = this._syData.toLowerCase();
                            if (text === 'piano' || text === 'none' || text === 'voice') {
                                // clear tuning
                                this._currentStaff.tuning = [];
                            }
                            else {
                                this.error('tuning', AlphaTexSymbols.Tuning, true);
                            }
                            this._sy = this.newSy();
                            break;
                        case AlphaTexSymbols.Tuning:
                            var tuning = [];
                            do {
                                var t = this._syData;
                                tuning.push(t.realValue);
                                this._sy = this.newSy();
                            } while (this._sy === AlphaTexSymbols.Tuning);
                            this._currentStaff.tuning = tuning;
                            break;
                        default:
                            this.error('tuning', AlphaTexSymbols.Tuning, true);
                            break;
                    }
                    if (strings !== this._currentStaff.tuning.length && this._currentStaff.chords.size > 0) {
                        this.errorMessage('Tuning must be defined before any chord');
                    }
                    return true;
                case 'instrument':
                    this._sy = this.newSy();
                    if (this._sy === AlphaTexSymbols.Number) {
                        var instrument = this._syData;
                        if (instrument >= 0 && instrument <= 128) {
                            this._currentTrack.playbackInfo.program = this._syData;
                        }
                        else {
                            this.error('instrument', AlphaTexSymbols.Number, false);
                        }
                    }
                    else if (this._sy === AlphaTexSymbols.String) {
                        var instrumentName = this._syData.toLowerCase();
                        this._currentTrack.playbackInfo.program = GeneralMidi.getValue(instrumentName);
                    }
                    else {
                        this.error('instrument', AlphaTexSymbols.Number, true);
                    }
                    this._currentStaff.displayTranspositionPitch = GeneralMidi.isGuitar(this._currentTrack.playbackInfo.program)
                        ? -12
                        : 0;
                    this._sy = this.newSy();
                    return true;
                case 'lyrics':
                    this._sy = this.newSy();
                    var lyrics = new Lyrics();
                    lyrics.startBar = 0;
                    lyrics.text = '';
                    if (this._sy === AlphaTexSymbols.Number) {
                        lyrics.startBar = this._syData;
                        this._sy = this.newSy();
                    }
                    if (this._sy === AlphaTexSymbols.String) {
                        lyrics.text = this._syData;
                        this._sy = this.newSy();
                    }
                    else {
                        this.error('lyrics', AlphaTexSymbols.String, true);
                    }
                    this._lyrics.get(this._currentTrack.index).push(lyrics);
                    return true;
                case 'chord':
                    this._sy = this.newSy();
                    var chord = new Chord();
                    this.chordProperties(chord);
                    if (this._sy === AlphaTexSymbols.String) {
                        chord.name = this._syData;
                        this._sy = this.newSy();
                    }
                    else {
                        this.error('chord-name', AlphaTexSymbols.Number, true);
                    }
                    for (var i = 0; i < this._currentStaff.tuning.length; i++) {
                        if (this._sy === AlphaTexSymbols.Number) {
                            chord.strings.push(this._syData);
                        }
                        else if (this._sy === AlphaTexSymbols.String && this._syData.toLowerCase() === 'x') {
                            chord.strings.push(-1);
                        }
                        this._sy = this.newSy();
                    }
                    this._currentStaff.addChord(chord.name.toLowerCase(), chord);
                    return true;
                default:
                    return false;
            }
        };
        AlphaTexImporter.prototype.chordProperties = function (chord) {
            if (this._sy !== AlphaTexSymbols.LBrace) {
                return;
            }
            this._sy = this.newSy();
            while (this._sy === AlphaTexSymbols.String) {
                switch (this._syData.toLowerCase()) {
                    case 'firstfret':
                        this._sy = this.newSy();
                        switch (this._sy) {
                            case AlphaTexSymbols.Number:
                                chord.firstFret = this._syData;
                                break;
                            default:
                                this.error('chord-firstfret', AlphaTexSymbols.Number, true);
                                break;
                        }
                        this._sy = this.newSy();
                        break;
                    case 'showdiagram':
                        this._sy = this.newSy();
                        switch (this._sy) {
                            case AlphaTexSymbols.String:
                                chord.showDiagram = this._syData.toLowerCase() !== 'false';
                                break;
                            case AlphaTexSymbols.Number:
                                chord.showDiagram = this._syData !== 0;
                                break;
                            default:
                                this.error('chord-showdiagram', AlphaTexSymbols.String, true);
                                break;
                        }
                        this._sy = this.newSy();
                        break;
                    case 'showfingering':
                        this._sy = this.newSy();
                        switch (this._sy) {
                            case AlphaTexSymbols.String:
                                chord.showDiagram = this._syData.toLowerCase() !== 'false';
                                break;
                            case AlphaTexSymbols.Number:
                                chord.showFingering = this._syData !== 0;
                                break;
                            default:
                                this.error('chord-showfingering', AlphaTexSymbols.String, true);
                                break;
                        }
                        this._sy = this.newSy();
                        break;
                    case 'showname':
                        this._sy = this.newSy();
                        switch (this._sy) {
                            case AlphaTexSymbols.String:
                                chord.showName = this._syData.toLowerCase() !== 'false';
                                break;
                            case AlphaTexSymbols.Number:
                                chord.showName = this._syData !== 0;
                                break;
                            default:
                                this.error('chord-showname', AlphaTexSymbols.String, true);
                                break;
                        }
                        this._sy = this.newSy();
                        break;
                    case 'barre':
                        this._sy = this.newSy();
                        while (this._sy === AlphaTexSymbols.Number) {
                            chord.barreFrets.push(this._syData);
                            this._sy = this.newSy();
                        }
                        break;
                    default:
                        this.error('chord-properties', AlphaTexSymbols.String, false);
                        break;
                }
            }
            if (this._sy !== AlphaTexSymbols.RBrace) {
                this.error('chord-properties', AlphaTexSymbols.RBrace, true);
            }
            this._sy = this.newSy();
        };
        AlphaTexImporter.prototype.bars = function () {
            this.bar();
            while (this._sy !== AlphaTexSymbols.Eof) {
                // read pipe from last bar
                if (this._sy === AlphaTexSymbols.Pipe) {
                    this._sy = this.newSy();
                    this.bar();
                }
                else if (this._sy === AlphaTexSymbols.MetaCommand) {
                    this.bar();
                }
                else {
                    break;
                }
            }
        };
        AlphaTexImporter.prototype.trackStaffMeta = function () {
            if (this._sy === AlphaTexSymbols.MetaCommand) {
                var syData = this._syData.toLowerCase();
                if (syData === 'track') {
                    this._sy = this.newSy();
                    // new track starting? - if no masterbars it's the \track of the initial track.
                    if (this._score.masterBars.length > 0) {
                        this.newTrack();
                    }
                    // name
                    if (this._sy === AlphaTexSymbols.String) {
                        this._currentTrack.name = this._syData;
                        this._sy = this.newSy();
                    }
                    // short name
                    if (this._sy === AlphaTexSymbols.String) {
                        this._currentTrack.shortName = this._syData;
                        this._sy = this.newSy();
                    }
                }
                if (this._sy === AlphaTexSymbols.MetaCommand) {
                    syData = this._syData.toLowerCase();
                    if (syData === 'staff') {
                        this._sy = this.newSy();
                        if (this._currentTrack.staves[0].bars.length > 0) {
                            this._currentTrack.ensureStaveCount(this._currentTrack.staves.length + 1);
                            this._currentStaff = this._currentTrack.staves[this._currentTrack.staves.length - 1];
                            this._currentDynamics = DynamicValue.F;
                        }
                        this.staffProperties();
                    }
                }
            }
        };
        AlphaTexImporter.prototype.staffProperties = function () {
            if (this._sy !== AlphaTexSymbols.LBrace) {
                return;
            }
            this._sy = this.newSy();
            var showStandardNotation = false;
            var showTabs = false;
            while (this._sy === AlphaTexSymbols.String) {
                switch (this._syData.toLowerCase()) {
                    case 'score':
                        showStandardNotation = true;
                        this._sy = this.newSy();
                        break;
                    case 'tabs':
                        showTabs = true;
                        this._sy = this.newSy();
                        break;
                    default:
                        this.error('staff-properties', AlphaTexSymbols.String, false);
                        break;
                }
            }
            if (showStandardNotation || showTabs) {
                this._currentStaff.showStandardNotation = showStandardNotation;
                this._currentStaff.showTablature = showTabs;
            }
            if (this._sy !== AlphaTexSymbols.RBrace) {
                this.error('staff-properties', AlphaTexSymbols.RBrace, true);
            }
            this._sy = this.newSy();
        };
        AlphaTexImporter.prototype.bar = function () {
            this.trackStaffMeta();
            var bar = this.newBar(this._currentStaff);
            if (this._currentStaff.bars.length > this._score.masterBars.length) {
                var master = new MasterBar();
                this._score.addMasterBar(master);
                if (master.index > 0) {
                    master.keySignature = master.previousMasterBar.keySignature;
                    master.keySignatureType = master.previousMasterBar.keySignatureType;
                    master.timeSignatureDenominator = master.previousMasterBar.timeSignatureDenominator;
                    master.timeSignatureNumerator = master.previousMasterBar.timeSignatureNumerator;
                    master.tripletFeel = master.previousMasterBar.tripletFeel;
                }
            }
            this.barMeta(bar);
            var voice = bar.voices[0];
            while (this._sy !== AlphaTexSymbols.Pipe && this._sy !== AlphaTexSymbols.Eof) {
                if (!this.beat(voice)) {
                    break;
                }
            }
            if (voice.beats.length === 0) {
                var emptyBeat = new Beat();
                emptyBeat.isEmpty = true;
                voice.addBeat(emptyBeat);
            }
        };
        AlphaTexImporter.prototype.newBar = function (staff) {
            var bar = new Bar();
            staff.addBar(bar);
            if (bar.index > 0) {
                bar.clef = bar.previousBar.clef;
            }
            var voice = new Voice();
            bar.addVoice(voice);
            return bar;
        };
        AlphaTexImporter.prototype.beat = function (voice) {
            // duration specifier?
            this.beatDuration();
            var beat = new Beat();
            voice.addBeat(beat);
            if (voice.bar.masterBar.tempoAutomation && voice.beats.length === 1) {
                beat.automations.push(voice.bar.masterBar.tempoAutomation);
            }
            // notes
            if (this._sy === AlphaTexSymbols.LParensis) {
                this._sy = this.newSy();
                this.note(beat);
                while (this._sy !== AlphaTexSymbols.RParensis && this._sy !== AlphaTexSymbols.Eof) {
                    if (!this.note(beat)) {
                        break;
                    }
                }
                if (this._sy !== AlphaTexSymbols.RParensis) {
                    this.error('note-list', AlphaTexSymbols.RParensis, true);
                }
                this._sy = this.newSy();
            }
            else if (this._sy === AlphaTexSymbols.String && this._syData.toLowerCase() === 'r') {
                // rest voice -> no notes
                this._sy = this.newSy();
            }
            else {
                if (!this.note(beat)) {
                    voice.beats.splice(voice.beats.length - 1, 1);
                    return false;
                }
            }
            // new duration
            if (this._sy === AlphaTexSymbols.Dot) {
                this._allowNegatives = true;
                this._sy = this.newSy();
                this._allowNegatives = false;
                if (this._sy !== AlphaTexSymbols.Number) {
                    this.error('duration', AlphaTexSymbols.Number, true);
                }
                this._currentDuration = this.parseDuration(this._syData);
                this._sy = this.newSy();
            }
            beat.duration = this._currentDuration;
            beat.dynamics = this._currentDynamics;
            if (this._currentTuplet !== 1 && !beat.hasTuplet) {
                this.applyTuplet(beat, this._currentTuplet);
            }
            // beat multiplier (repeat beat n times)
            var beatRepeat = 1;
            if (this._sy === AlphaTexSymbols.Multiply) {
                this._sy = this.newSy();
                // multiplier count
                if (this._sy !== AlphaTexSymbols.Number) {
                    this.error('multiplier', AlphaTexSymbols.Number, true);
                }
                else {
                    beatRepeat = this._syData;
                }
                this._sy = this.newSy();
            }
            this.beatEffects(beat);
            for (var i = 0; i < beatRepeat - 1; i++) {
                voice.addBeat(beat.clone());
            }
            return true;
        };
        AlphaTexImporter.prototype.beatDuration = function () {
            if (this._sy !== AlphaTexSymbols.DoubleDot) {
                return;
            }
            this._allowNegatives = true;
            this._sy = this.newSy();
            this._allowNegatives = false;
            if (this._sy !== AlphaTexSymbols.Number) {
                this.error('duration', AlphaTexSymbols.Number, true);
            }
            this._currentDuration = this.parseDuration(this._syData);
            this._currentTuplet = 1;
            this._sy = this.newSy();
            if (this._sy !== AlphaTexSymbols.LBrace) {
                return;
            }
            this._sy = this.newSy();
            while (this._sy === AlphaTexSymbols.String) {
                var effect = this._syData.toLowerCase();
                switch (effect) {
                    case 'tu':
                        this._sy = this.newSy();
                        if (this._sy !== AlphaTexSymbols.Number) {
                            this.error('duration-tuplet', AlphaTexSymbols.Number, true);
                        }
                        this._currentTuplet = this._syData;
                        this._sy = this.newSy();
                        break;
                    default:
                        this.error('beat-duration', AlphaTexSymbols.String, false);
                        break;
                }
            }
            if (this._sy !== AlphaTexSymbols.RBrace) {
                this.error('beat-duration', AlphaTexSymbols.RBrace, true);
            }
            this._sy = this.newSy();
        };
        AlphaTexImporter.prototype.beatEffects = function (beat) {
            if (this._sy !== AlphaTexSymbols.LBrace) {
                return;
            }
            this._sy = this.newSy();
            while (this._sy === AlphaTexSymbols.String) {
                this._syData = this._syData.toLowerCase();
                if (!this.applyBeatEffect(beat)) {
                    this.error('beat-effects', AlphaTexSymbols.String, false);
                }
            }
            if (this._sy !== AlphaTexSymbols.RBrace) {
                this.error('beat-effects', AlphaTexSymbols.RBrace, true);
            }
            this._sy = this.newSy();
        };
        /**
         * Tries to apply a beat effect to the given beat.
         * @returns true if a effect could be applied, otherwise false
         */
        AlphaTexImporter.prototype.applyBeatEffect = function (beat) {
            var syData = this._syData.toLowerCase();
            if (syData === 'f') {
                beat.fadeIn = true;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'v') {
                beat.vibrato = VibratoType.Slight;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 's') {
                beat.slap = true;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'p') {
                beat.pop = true;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'tt') {
                beat.tap = true;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'dd') {
                beat.dots = 2;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'd') {
                beat.dots = 1;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'su') {
                beat.pickStroke = PickStroke.Up;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'sd') {
                beat.pickStroke = PickStroke.Down;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'tu') {
                this._sy = this.newSy();
                if (this._sy !== AlphaTexSymbols.Number) {
                    this.error('tuplet', AlphaTexSymbols.Number, true);
                    return false;
                }
                this.applyTuplet(beat, this._syData);
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'tb' || syData === 'tbe') {
                var exact = syData === 'tbe';
                // read points
                this._sy = this.newSy();
                if (this._sy !== AlphaTexSymbols.LParensis) {
                    this.error('tremolobar-effect', AlphaTexSymbols.LParensis, true);
                    return false;
                }
                this._allowNegatives = true;
                this._sy = this.newSy();
                while (this._sy !== AlphaTexSymbols.RParensis && this._sy !== AlphaTexSymbols.Eof) {
                    var offset = 0;
                    var value = 0;
                    if (exact) {
                        if (this._sy !== AlphaTexSymbols.Number) {
                            this.error('tremolobar-effect', AlphaTexSymbols.Number, true);
                            return false;
                        }
                        offset = this._syData;
                        this._sy = this.newSy();
                        if (this._sy !== AlphaTexSymbols.Number) {
                            this.error('tremolobar-effect', AlphaTexSymbols.Number, true);
                            return false;
                        }
                        value = this._syData;
                    }
                    else {
                        if (this._sy !== AlphaTexSymbols.Number) {
                            this.error('tremolobar-effect', AlphaTexSymbols.Number, true);
                            return false;
                        }
                        offset = 0;
                        value = this._syData;
                    }
                    beat.addWhammyBarPoint(new BendPoint(offset, value));
                    this._sy = this.newSy();
                }
                while (beat.whammyBarPoints.length > 60) {
                    beat.removeWhammyBarPoint(beat.whammyBarPoints.length - 1);
                }
                // set positions
                if (!exact) {
                    var count = beat.whammyBarPoints.length;
                    var step = (60 / count) | 0;
                    var i = 0;
                    while (i < count) {
                        beat.whammyBarPoints[i].offset = Math.min(60, i * step);
                        i++;
                    }
                }
                else {
                    beat.whammyBarPoints.sort(function (a, b) {
                        return a.offset - b.offset;
                    });
                }
                this._allowNegatives = false;
                if (this._sy !== AlphaTexSymbols.RParensis) {
                    this.error('tremolobar-effect', AlphaTexSymbols.RParensis, true);
                    return false;
                }
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'ch') {
                this._sy = this.newSy();
                var chordName = this._syData;
                var chordId = chordName.toLowerCase();
                if (!this._currentStaff.chords.has(chordId)) {
                    var chord = new Chord();
                    chord.showDiagram = false;
                    chord.name = chordName;
                    this._currentStaff.addChord(chordId, chord);
                }
                beat.chordId = chordId;
                this._sy = this.newSy();
                return true;
            }
            if (syData === 'gr') {
                this._sy = this.newSy();
                if (this._syData.toLowerCase() === 'ob') {
                    beat.graceType = GraceType.OnBeat;
                    this._sy = this.newSy();
                }
                else if (this._syData.toLowerCase() === 'b') {
                    beat.graceType = GraceType.BendGrace;
                    this._sy = this.newSy();
                }
                else {
                    beat.graceType = GraceType.BeforeBeat;
                }
                return true;
            }
            if (syData === 'dy') {
                this.newSy();
                switch (this._syData.toLowerCase()) {
                    case 'ppp':
                        beat.dynamics = DynamicValue.PPP;
                        break;
                    case 'pp':
                        beat.dynamics = DynamicValue.PP;
                        break;
                    case 'p':
                        beat.dynamics = DynamicValue.P;
                        break;
                    case 'mp':
                        beat.dynamics = DynamicValue.MP;
                        break;
                    case 'mf':
                        beat.dynamics = DynamicValue.MF;
                        break;
                    case 'f':
                        beat.dynamics = DynamicValue.F;
                        break;
                    case 'ff':
                        beat.dynamics = DynamicValue.FF;
                        break;
                    case 'fff':
                        beat.dynamics = DynamicValue.FFF;
                        break;
                }
                this._currentDynamics = beat.dynamics;
                this.newSy();
                return true;
            }
            if (syData === 'cre') {
                beat.crescendo = CrescendoType.Crescendo;
                this.newSy();
                return true;
            }
            if (syData === 'dec') {
                beat.crescendo = CrescendoType.Decrescendo;
                this.newSy();
                return true;
            }
            if (syData === 'tp') {
                this._sy = this.newSy();
                var duration = Duration.Eighth;
                if (this._sy === AlphaTexSymbols.Number) {
                    switch (this._syData) {
                        case 8:
                            duration = Duration.Eighth;
                            break;
                        case 16:
                            duration = Duration.Sixteenth;
                            break;
                        case 32:
                            duration = Duration.ThirtySecond;
                            break;
                        default:
                            duration = Duration.Eighth;
                            break;
                    }
                    this._sy = this.newSy();
                }
                beat.tremoloSpeed = duration;
                return true;
            }
            return false;
        };
        AlphaTexImporter.prototype.applyTuplet = function (beat, tuplet) {
            switch (tuplet) {
                case 3:
                    beat.tupletNumerator = 3;
                    beat.tupletDenominator = 2;
                    break;
                case 5:
                    beat.tupletNumerator = 5;
                    beat.tupletDenominator = 4;
                    break;
                case 6:
                    beat.tupletNumerator = 6;
                    beat.tupletDenominator = 4;
                    break;
                case 7:
                    beat.tupletNumerator = 7;
                    beat.tupletDenominator = 4;
                    break;
                case 9:
                    beat.tupletNumerator = 9;
                    beat.tupletDenominator = 8;
                    break;
                case 10:
                    beat.tupletNumerator = 10;
                    beat.tupletDenominator = 8;
                    break;
                case 11:
                    beat.tupletNumerator = 11;
                    beat.tupletDenominator = 8;
                    break;
                case 12:
                    beat.tupletNumerator = 12;
                    beat.tupletDenominator = 8;
                    break;
                default:
                    beat.tupletNumerator = 1;
                    beat.tupletDenominator = 1;
                    break;
            }
        };
        AlphaTexImporter.prototype.note = function (beat) {
            // fret.string
            var isDead = false;
            var isTie = false;
            var fret = -1;
            var octave = -1;
            var tone = -1;
            switch (this._sy) {
                case AlphaTexSymbols.Number:
                    fret = this._syData;
                    break;
                case AlphaTexSymbols.String:
                    isDead = this._syData === 'x';
                    isTie = this._syData === '-';
                    if (isTie || isDead) {
                        fret = 0;
                    }
                    else {
                        this.error('note-fret', AlphaTexSymbols.Number, true);
                    }
                    break;
                case AlphaTexSymbols.Tuning:
                    var tuning = this._syData;
                    octave = tuning.octave;
                    tone = tuning.noteValue;
                    break;
                default:
                    return false;
            }
            this._sy = this.newSy(); // Fret done
            var isFretted = octave === -1 && this._currentStaff.tuning.length > 0;
            var noteString = -1;
            if (isFretted) {
                // Fret [Dot] String
                if (this._sy !== AlphaTexSymbols.Dot) {
                    this.error('note', AlphaTexSymbols.Dot, true);
                }
                this._sy = this.newSy(); // dot done
                if (this._sy !== AlphaTexSymbols.Number) {
                    this.error('note-string', AlphaTexSymbols.Number, true);
                }
                noteString = this._syData;
                if (noteString < 1 || noteString > this._currentStaff.tuning.length) {
                    this.error('note-string', AlphaTexSymbols.Number, false);
                }
                this._sy = this.newSy(); // string done
            }
            // read effects
            var note = new Note();
            if (isFretted) {
                note.string = this._currentStaff.tuning.length - (noteString - 1);
                note.isDead = isDead;
                note.isTieDestination = isTie;
                if (!isTie) {
                    note.fret = fret;
                }
            }
            else {
                note.octave = octave;
                note.tone = tone;
                note.isTieDestination = isTie;
            }
            beat.addNote(note);
            this.noteEffects(note);
            return true;
        };
        AlphaTexImporter.prototype.noteEffects = function (note) {
            if (this._sy !== AlphaTexSymbols.LBrace) {
                return;
            }
            this._sy = this.newSy();
            while (this._sy === AlphaTexSymbols.String) {
                var syData = this._syData.toLowerCase();
                this._syData = syData;
                if (syData === 'b' || syData === 'be') {
                    var exact = this._syData === 'be';
                    // read points
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.LParensis) {
                        this.error('bend-effect', AlphaTexSymbols.LParensis, true);
                    }
                    this._sy = this.newSy();
                    while (this._sy !== AlphaTexSymbols.RParensis && this._sy !== AlphaTexSymbols.Eof) {
                        var offset = 0;
                        var value = 0;
                        if (exact) {
                            if (this._sy !== AlphaTexSymbols.Number) {
                                this.error('bend-effect-value', AlphaTexSymbols.Number, true);
                            }
                            offset = this._syData;
                            this._sy = this.newSy();
                            if (this._sy !== AlphaTexSymbols.Number) {
                                this.error('bend-effect-value', AlphaTexSymbols.Number, true);
                            }
                            value = this._syData;
                        }
                        else {
                            if (this._sy !== AlphaTexSymbols.Number) {
                                this.error('bend-effect-value', AlphaTexSymbols.Number, true);
                            }
                            value = this._syData;
                        }
                        note.addBendPoint(new BendPoint(offset, value));
                        this._sy = this.newSy();
                    }
                    while (note.bendPoints.length > 60) {
                        note.bendPoints.splice(note.bendPoints.length - 1, 1);
                    }
                    // set positions
                    if (exact) {
                        note.bendPoints.sort(function (a, b) {
                            return a.offset - b.offset;
                        });
                    }
                    else {
                        var count = note.bendPoints.length;
                        var step = (60 / (count - 1)) | 0;
                        var i = 0;
                        while (i < count) {
                            note.bendPoints[i].offset = Math.min(60, i * step);
                            i++;
                        }
                    }
                    if (this._sy !== AlphaTexSymbols.RParensis) {
                        this.error('bend-effect', AlphaTexSymbols.RParensis, true);
                    }
                    this._sy = this.newSy();
                }
                else if (syData === 'nh') {
                    note.harmonicType = HarmonicType.Natural;
                    this._sy = this.newSy();
                }
                else if (syData === 'ah') {
                    // todo: Artificial Key
                    note.harmonicType = HarmonicType.Artificial;
                    this._sy = this.newSy();
                }
                else if (syData === 'th') {
                    // todo: store tapped fret in data
                    note.harmonicType = HarmonicType.Tap;
                    this._sy = this.newSy();
                }
                else if (syData === 'ph') {
                    note.harmonicType = HarmonicType.Pinch;
                    this._sy = this.newSy();
                }
                else if (syData === 'sh') {
                    note.harmonicType = HarmonicType.Semi;
                    this._sy = this.newSy();
                }
                else if (syData === 'tr') {
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.Number) {
                        this.error('trill-effect', AlphaTexSymbols.Number, true);
                    }
                    var fret = this._syData;
                    this._sy = this.newSy();
                    var duration = Duration.Sixteenth;
                    if (this._sy === AlphaTexSymbols.Number) {
                        switch (this._syData) {
                            case 16:
                                duration = Duration.Sixteenth;
                                break;
                            case 32:
                                duration = Duration.ThirtySecond;
                                break;
                            case 64:
                                duration = Duration.SixtyFourth;
                                break;
                            default:
                                duration = Duration.Sixteenth;
                                break;
                        }
                        this._sy = this.newSy();
                    }
                    note.trillValue = fret + note.stringTuning;
                    note.trillSpeed = duration;
                }
                else if (syData === 'v') {
                    this._sy = this.newSy();
                    note.vibrato = VibratoType.Slight;
                }
                else if (syData === 'sl') {
                    this._sy = this.newSy();
                    note.slideOutType = SlideOutType.Legato;
                }
                else if (syData === 'ss') {
                    this._sy = this.newSy();
                    note.slideOutType = SlideOutType.Shift;
                }
                else if (syData === 'sib') {
                    this._sy = this.newSy();
                    note.slideInType = SlideInType.IntoFromBelow;
                }
                else if (syData === 'sia') {
                    this._sy = this.newSy();
                    note.slideInType = SlideInType.IntoFromAbove;
                }
                else if (syData === 'sou') {
                    this._sy = this.newSy();
                    note.slideOutType = SlideOutType.OutUp;
                }
                else if (syData === 'sod') {
                    this._sy = this.newSy();
                    note.slideOutType = SlideOutType.OutDown;
                }
                else if (syData === 'psd') {
                    this._sy = this.newSy();
                    note.slideOutType = SlideOutType.PickSlideDown;
                }
                else if (syData === 'psu') {
                    this._sy = this.newSy();
                    note.slideOutType = SlideOutType.PickSlideUp;
                }
                else if (syData === 'h') {
                    this._sy = this.newSy();
                    note.isHammerPullOrigin = true;
                }
                else if (syData === 'lht') {
                    this._sy = this.newSy();
                    note.isLeftHandTapped = true;
                }
                else if (syData === 'g') {
                    this._sy = this.newSy();
                    note.isGhost = true;
                }
                else if (syData === 'ac') {
                    this._sy = this.newSy();
                    note.accentuated = AccentuationType.Normal;
                }
                else if (syData === 'hac') {
                    this._sy = this.newSy();
                    note.accentuated = AccentuationType.Heavy;
                }
                else if (syData === 'pm') {
                    this._sy = this.newSy();
                    note.isPalmMute = true;
                }
                else if (syData === 'st') {
                    this._sy = this.newSy();
                    note.isStaccato = true;
                }
                else if (syData === 'lr') {
                    this._sy = this.newSy();
                    note.isLetRing = true;
                }
                else if (syData === 'x') {
                    this._sy = this.newSy();
                    note.fret = 0;
                    note.isDead = true;
                }
                else if (syData === '-' || syData === 't') {
                    this._sy = this.newSy();
                    note.isTieDestination = true;
                }
                else if (syData === 'lf') {
                    this._sy = this.newSy();
                    var finger = Fingers.Thumb;
                    if (this._sy === AlphaTexSymbols.Number) {
                        finger = this.toFinger(this._syData);
                        this._sy = this.newSy();
                    }
                    note.leftHandFinger = finger;
                }
                else if (syData === 'rf') {
                    this._sy = this.newSy();
                    var finger = Fingers.Thumb;
                    if (this._sy === AlphaTexSymbols.Number) {
                        finger = this.toFinger(this._syData);
                        this._sy = this.newSy();
                    }
                    note.rightHandFinger = finger;
                }
                else if (this.applyBeatEffect(note.beat)) ;
                else {
                    this.error(syData, AlphaTexSymbols.String, false);
                }
            }
            if (this._sy !== AlphaTexSymbols.RBrace) {
                this.error('note-effect', AlphaTexSymbols.RBrace, false);
            }
            this._sy = this.newSy();
        };
        AlphaTexImporter.prototype.toFinger = function (syData) {
            switch (syData) {
                case 1:
                    return Fingers.Thumb;
                case 2:
                    return Fingers.IndexFinger;
                case 3:
                    return Fingers.MiddleFinger;
                case 4:
                    return Fingers.AnnularFinger;
                case 5:
                    return Fingers.LittleFinger;
            }
            return Fingers.Thumb;
        };
        AlphaTexImporter.prototype.parseDuration = function (duration) {
            switch (duration) {
                case -4:
                    return Duration.QuadrupleWhole;
                case -2:
                    return Duration.DoubleWhole;
                case 1:
                    return Duration.Whole;
                case 2:
                    return Duration.Half;
                case 4:
                    return Duration.Quarter;
                case 8:
                    return Duration.Eighth;
                case 16:
                    return Duration.Sixteenth;
                case 32:
                    return Duration.ThirtySecond;
                case 64:
                    return Duration.SixtyFourth;
                case 128:
                    return Duration.OneHundredTwentyEighth;
                default:
                    return Duration.Quarter;
            }
        };
        AlphaTexImporter.prototype.barMeta = function (bar) {
            var master = bar.masterBar;
            while (this._sy === AlphaTexSymbols.MetaCommand) {
                var syData = this._syData.toLowerCase();
                if (syData === 'ts') {
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.Number) {
                        this.error('timesignature-numerator', AlphaTexSymbols.Number, true);
                    }
                    master.timeSignatureNumerator = this._syData;
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.Number) {
                        this.error('timesignature-denominator', AlphaTexSymbols.Number, true);
                    }
                    master.timeSignatureDenominator = this._syData;
                    this._sy = this.newSy();
                }
                else if (syData === 'ro') {
                    master.isRepeatStart = true;
                    this._sy = this.newSy();
                }
                else if (syData === 'rc') {
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.Number) {
                        this.error('repeatclose', AlphaTexSymbols.Number, true);
                    }
                    master.repeatCount = this._syData;
                    this._sy = this.newSy();
                }
                else if (syData === 'ks') {
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.String) {
                        this.error('keysignature', AlphaTexSymbols.String, true);
                    }
                    master.keySignature = this.parseKeySignature(this._syData.toLowerCase());
                    this._sy = this.newSy();
                }
                else if (syData === 'clef') {
                    this._sy = this.newSy();
                    switch (this._sy) {
                        case AlphaTexSymbols.String:
                            bar.clef = this.parseClefFromString(this._syData.toLowerCase());
                            break;
                        case AlphaTexSymbols.Number:
                            bar.clef = this.parseClefFromInt(this._syData);
                            break;
                        case AlphaTexSymbols.Tuning:
                            var parseResult = this._syData;
                            bar.clef = this.parseClefFromInt(parseResult.realValue);
                            break;
                        default:
                            this.error('clef', AlphaTexSymbols.String, true);
                            break;
                    }
                    this._sy = this.newSy();
                }
                else if (syData === 'tempo') {
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.Number) {
                        this.error('tempo', AlphaTexSymbols.Number, true);
                    }
                    var tempoAutomation = new Automation();
                    tempoAutomation.isLinear = true;
                    tempoAutomation.type = AutomationType.Tempo;
                    tempoAutomation.value = this._syData;
                    master.tempoAutomation = tempoAutomation;
                    this._sy = this.newSy();
                }
                else if (syData === 'section') {
                    this._sy = this.newSy();
                    if (this._sy !== AlphaTexSymbols.String) {
                        this.error('section', AlphaTexSymbols.String, true);
                    }
                    var text = this._syData;
                    this._sy = this.newSy();
                    var marker = '';
                    if (this._sy === AlphaTexSymbols.String) {
                        marker = text;
                        text = this._syData;
                        this._sy = this.newSy();
                    }
                    var section = new Section();
                    section.marker = marker;
                    section.text = text;
                    master.section = section;
                }
                else if (syData === 'tf') {
                    this._allowTuning = false;
                    this._sy = this.newSy();
                    this._allowTuning = true;
                    switch (this._sy) {
                        case AlphaTexSymbols.String:
                            master.tripletFeel = this.parseTripletFeelFromString(this._syData.toLowerCase());
                            break;
                        case AlphaTexSymbols.Number:
                            master.tripletFeel = this.parseTripletFeelFromInt(this._syData);
                            break;
                        default:
                            this.error('triplet-feel', AlphaTexSymbols.String, true);
                            break;
                    }
                    this._sy = this.newSy();
                }
                else if (syData === 'ac') {
                    master.isAnacrusis = true;
                    this._sy = this.newSy();
                }
                else {
                    if (bar.index === 0 && !this.handleStaffMeta()) {
                        this.error('measure-effects', AlphaTexSymbols.String, false);
                    }
                }
            }
        };
        AlphaTexImporter.Eof = 0;
        return AlphaTexImporter;
    }(ScoreImporter));

    var TypeConversions = /** @class */ (function () {
        function TypeConversions() {
        }
        TypeConversions.uint16ToInt16 = function (v) {
            TypeConversions._dataView.setUint16(0, v, true);
            return TypeConversions._dataView.getInt16(0, true);
        };
        TypeConversions.int16ToUint32 = function (v) {
            TypeConversions._dataView.setInt16(0, v, true);
            return TypeConversions._dataView.getUint32(0, true);
        };
        TypeConversions.int32ToUint16 = function (v) {
            TypeConversions._dataView.setInt32(0, v, true);
            return TypeConversions._dataView.getUint16(0, true);
        };
        TypeConversions.int32ToInt16 = function (v) {
            TypeConversions._dataView.setInt32(0, v, true);
            return TypeConversions._dataView.getInt16(0, true);
        };
        TypeConversions.int32ToUint32 = function (v) {
            TypeConversions._dataView.setInt32(0, v, true);
            return TypeConversions._dataView.getUint32(0, true);
        };
        TypeConversions.uint8ToInt8 = function (v) {
            TypeConversions._dataView.setUint8(0, v);
            return TypeConversions._dataView.getInt8(0);
        };
        TypeConversions._conversionBuffer = new ArrayBuffer(8);
        TypeConversions._dataView = new DataView(TypeConversions._conversionBuffer);
        return TypeConversions;
    }());

    var IOHelper = /** @class */ (function () {
        function IOHelper() {
        }
        IOHelper.readInt32BE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            var ch3 = input.readByte();
            var ch4 = input.readByte();
            return (ch1 << 24) | (ch2 << 16) | (ch3 << 8) | ch4;
        };
        IOHelper.readInt32LE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            var ch3 = input.readByte();
            var ch4 = input.readByte();
            return (ch4 << 24) | (ch3 << 16) | (ch2 << 8) | ch1;
        };
        IOHelper.readUInt32LE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            var ch3 = input.readByte();
            var ch4 = input.readByte();
            return (ch4 << 24) | (ch3 << 16) | (ch2 << 8) | ch1;
        };
        IOHelper.readUInt16LE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            return TypeConversions.int32ToUint16((ch2 << 8) | ch1);
        };
        IOHelper.readInt16LE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            return TypeConversions.int32ToInt16((ch2 << 8) | ch1);
        };
        IOHelper.readUInt32BE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            var ch3 = input.readByte();
            var ch4 = input.readByte();
            return TypeConversions.int32ToUint32((ch1 << 24) | (ch2 << 16) | (ch3 << 8) | ch4);
        };
        IOHelper.readUInt16BE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            return TypeConversions.int32ToInt16((ch1 << 8) | ch2);
        };
        IOHelper.readInt16BE = function (input) {
            var ch1 = input.readByte();
            var ch2 = input.readByte();
            return TypeConversions.int32ToInt16((ch1 << 8) | ch2);
        };
        IOHelper.readByteArray = function (input, length) {
            var v = new Uint8Array(length);
            input.read(v, 0, length);
            return v;
        };
        IOHelper.read8BitChars = function (input, length) {
            var b = new Uint8Array(length);
            input.read(b, 0, b.length);
            return IOHelper.toString(b, 'utf-8');
        };
        IOHelper.read8BitString = function (input) {
            var s = '';
            var c = input.readByte();
            while (c !== 0) {
                s += String.fromCharCode(c);
                c = input.readByte();
            }
            return s;
        };
        IOHelper.read8BitStringLength = function (input, length) {
            var s = '';
            var z = -1;
            for (var i = 0; i < length; i++) {
                var c = input.readByte();
                if (c === 0 && z === -1) {
                    z = i;
                }
                s += String.fromCharCode(c);
            }
            var t = s;
            if (z >= 0) {
                return t.substr(0, z);
            }
            return t;
        };
        IOHelper.readSInt8 = function (input) {
            var v = input.readByte();
            return ((v & 255) >> 7) * -256 + (v & 255);
        };
        IOHelper.readInt24 = function (input, index) {
            var i = input[index] | (input[index + 1] << 8) | (input[index + 2] << 16);
            if ((i & 0x800000) === 0x800000) {
                i = i | (0xff << 24);
            }
            return i;
        };
        IOHelper.readInt16 = function (input, index) {
            return TypeConversions.int32ToInt16(input[index] | (input[index + 1] << 8));
        };
        IOHelper.toString = function (data, encoding) {
            if (Environment.supportsTextDecoder) {
                var detectedEncoding = IOHelper.detectEncoding(data);
                if (detectedEncoding) {
                    encoding = detectedEncoding;
                }
                if (!encoding) {
                    encoding = 'utf-8';
                }
                var decoder = new TextDecoder(encoding);
                return decoder.decode(data.buffer);
            }
            else {
                // manual UTF8 decoding for older browsers
                var s = '';
                var i = 0;
                while (i < data.length) {
                    var c = data[i++];
                    if (c < 0x80) {
                        if (c === 0) {
                            break;
                        }
                        s += String.fromCharCode(c);
                    }
                    else if (c < 0xe0) {
                        s += String.fromCharCode(((c & 0x3f) << 6) | (data[i++] & 0x7f));
                    }
                    else if (c < 0xf0) {
                        s += String.fromCharCode(((c & 0x1f) << 12) | ((data[i++] & 0x7f) << 6) | (data[i++] & 0x7f));
                    }
                    else {
                        var u = ((c & 0x0f) << 18) |
                            ((data[i++] & 0x7f) << 12) |
                            ((data[i++] & 0x7f) << 6) |
                            (data[i++] & 0x7f);
                        s += String.fromCharCode((u >> 18) + 0xd7c0);
                        s += String.fromCharCode((u & 0x3ff) | 0xdc00);
                    }
                }
                return s;
            }
        };
        IOHelper.detectEncoding = function (data) {
            if (data.length > 2 && data[0] === 0xfe && data[1] === 0xff) {
                return 'utf-16be';
            }
            if (data.length > 2 && data[0] === 0xff && data[1] === 0xfe) {
                return 'utf-16le';
            }
            if (data.length > 4 && data[0] === 0x00 && data[1] === 0x00 && data[2] === 0xfe && data[3] === 0xff) {
                return 'utf-32be';
            }
            if (data.length > 4 && data[0] === 0xff && data[1] === 0xfe && data[2] === 0x00 && data[3] === 0x00) {
                return 'utf-32le';
            }
            return null;
        };
        return IOHelper;
    }());

    var __extends$4 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var Gp3To5Importer = /** @class */ (function (_super) {
        __extends$4(Gp3To5Importer, _super);
        function Gp3To5Importer() {
            var _this = _super.call(this) || this;
            _this._versionNumber = 0;
            _this._globalTripletFeel = TripletFeel.NoTripletFeel;
            _this._lyricsTrack = 0;
            _this._lyrics = [];
            _this._barCount = 0;
            _this._trackCount = 0;
            _this._playbackInfos = [];
            return _this;
        }
        Object.defineProperty(Gp3To5Importer.prototype, "name", {
            get: function () {
                return 'Guitar Pro 3-5';
            },
            enumerable: false,
            configurable: true
        });
        Gp3To5Importer.prototype.readScore = function () {
            this.readVersion();
            this._score = new Score();
            // basic song info
            this.readScoreInformation();
            // triplet feel before Gp5
            if (this._versionNumber < 500) {
                this._globalTripletFeel = GpBinaryHelpers.gpReadBool(this.data)
                    ? TripletFeel.Triplet8th
                    : TripletFeel.NoTripletFeel;
            }
            // beat lyrics
            if (this._versionNumber >= 400) {
                this.readLyrics();
            }
            // rse master settings since GP5.1
            if (this._versionNumber >= 510) {
                // master volume (4)
                // master effect (4)
                // master equalizer (10)
                // master equalizer preset (1)
                this.data.skip(19);
            }
            // page setup since GP5
            if (this._versionNumber >= 500) {
                this.readPageSetup();
                this._score.tempoLabel = GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
            }
            // tempo stuff
            this._score.tempo = IOHelper.readInt32LE(this.data);
            if (this._versionNumber >= 510) {
                GpBinaryHelpers.gpReadBool(this.data); // hide tempo?
            }
            // keysignature and octave
            IOHelper.readInt32LE(this.data);
            if (this._versionNumber >= 400) {
                this.data.readByte();
            }
            this.readPlaybackInfos();
            // repetition stuff
            if (this._versionNumber >= 500) {
                // "Coda" bar index (2)
                // "Double Coda" bar index (2)
                // "Segno" bar index (2)
                // "Segno Segno" bar index (2)
                // "Fine" bar index (2)
                // "Da Capo" bar index (2)
                // "Da Capo al Coda" bar index (2)
                // "Da Capo al Double Coda" bar index (2)
                // "Da Capo al Fine" bar index (2)
                // "Da Segno" bar index (2)
                // "Da Segno al Coda" bar index (2)
                // "Da Segno al Double Coda" bar index (2)
                // "Da Segno al Fine "bar index (2)
                // "Da Segno Segno" bar index (2)
                // "Da Segno Segno al Coda" bar index (2)
                // "Da Segno Segno al Double Coda" bar index (2)
                // "Da Segno Segno al Fine" bar index (2)
                // "Da Coda" bar index (2)
                // "Da Double Coda" bar index (2)
                this.data.skip(38);
                // unknown (4)
                this.data.skip(4);
            }
            // contents
            this._barCount = IOHelper.readInt32LE(this.data);
            this._trackCount = IOHelper.readInt32LE(this.data);
            this.readMasterBars();
            this.readTracks();
            this.readBars();
            this._score.finish(this.settings);
            if (this._lyrics && this._lyricsTrack >= 0) {
                this._score.tracks[this._lyricsTrack].applyLyrics(this._lyrics);
            }
            return this._score;
        };
        Gp3To5Importer.prototype.readVersion = function () {
            var version = GpBinaryHelpers.gpReadStringByteLength(this.data, 30, this.settings.importer.encoding);
            if (!version.startsWith(Gp3To5Importer.VersionString)) {
                throw new UnsupportedFormatError('Unsupported format');
            }
            version = version.substr(Gp3To5Importer.VersionString.length + 1);
            var dot = version.indexOf(String.fromCharCode(46));
            this._versionNumber = 100 * parseInt(version.substr(0, dot)) + parseInt(version.substr(dot + 1));
            Logger.debug(this.name, 'Guitar Pro version ' + version + ' detected');
        };
        Gp3To5Importer.prototype.readScoreInformation = function () {
            var _a;
            this._score.title = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.subTitle = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.artist = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.album = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.words = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.music =
                this._versionNumber >= 500
                    ? GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding)
                    : this._score.words;
            this._score.copyright = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.tab = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            this._score.instructions = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            var noticeLines = IOHelper.readInt32LE(this.data);
            var notice = '';
            for (var i = 0; i < noticeLines; i++) {
                if (i > 0) {
                    notice += '\r\n';
                }
                notice += (_a = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding)) === null || _a === void 0 ? void 0 : _a.toString();
            }
            this._score.notices = notice;
        };
        Gp3To5Importer.prototype.readLyrics = function () {
            this._lyrics = [];
            this._lyricsTrack = IOHelper.readInt32LE(this.data) - 1;
            for (var i = 0; i < 5; i++) {
                var lyrics = new Lyrics();
                lyrics.startBar = IOHelper.readInt32LE(this.data) - 1;
                lyrics.text = GpBinaryHelpers.gpReadStringInt(this.data, this.settings.importer.encoding);
                this._lyrics.push(lyrics);
            }
        };
        Gp3To5Importer.prototype.readPageSetup = function () {
            // Page Width (4)
            // Page Heigth (4)
            // Padding Left (4)
            // Padding Right (4)
            // Padding Top (4)
            // Padding Bottom (4)
            // Size Proportion(4)
            // Header and Footer display flags (2)
            this.data.skip(30);
            // title format
            // subtitle format
            // artist format
            // album format
            // words format
            // music format
            // words and music format
            // copyright format
            // pagpublic enumber format
            for (var i = 0; i < 10; i++) {
                GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
            }
        };
        Gp3To5Importer.prototype.readPlaybackInfos = function () {
            this._playbackInfos = [];
            for (var i = 0; i < 64; i++) {
                var info = new PlaybackInformation();
                info.primaryChannel = i;
                info.secondaryChannel = i;
                info.program = IOHelper.readInt32LE(this.data);
                info.volume = this.data.readByte();
                info.balance = this.data.readByte();
                this.data.skip(6);
                this._playbackInfos.push(info);
            }
        };
        Gp3To5Importer.prototype.readMasterBars = function () {
            for (var i = 0; i < this._barCount; i++) {
                this.readMasterBar();
            }
        };
        Gp3To5Importer.prototype.readMasterBar = function () {
            var previousMasterBar = null;
            if (this._score.masterBars.length > 0) {
                previousMasterBar = this._score.masterBars[this._score.masterBars.length - 1];
            }
            var newMasterBar = new MasterBar();
            var flags = this.data.readByte();
            // time signature
            if ((flags & 0x01) !== 0) {
                newMasterBar.timeSignatureNumerator = this.data.readByte();
            }
            else if (previousMasterBar) {
                newMasterBar.timeSignatureNumerator = previousMasterBar.timeSignatureNumerator;
            }
            if ((flags & 0x02) !== 0) {
                newMasterBar.timeSignatureDenominator = this.data.readByte();
            }
            else if (previousMasterBar) {
                newMasterBar.timeSignatureDenominator = previousMasterBar.timeSignatureDenominator;
            }
            // repeatings
            newMasterBar.isRepeatStart = (flags & 0x04) !== 0;
            if ((flags & 0x08) !== 0) {
                newMasterBar.repeatCount = this.data.readByte() + (this._versionNumber >= 500 ? 0 : 1);
            }
            // alternate endings
            if ((flags & 0x10) !== 0) {
                if (this._versionNumber < 500) {
                    var currentMasterBar = previousMasterBar;
                    // get the already existing alternatives to ignore them
                    var existentAlternatives = 0;
                    while (currentMasterBar) {
                        // found another repeat ending?
                        if (currentMasterBar.isRepeatEnd && currentMasterBar !== previousMasterBar) {
                            break;
                        }
                        // found the opening?
                        if (currentMasterBar.isRepeatStart) {
                            break;
                        }
                        existentAlternatives = existentAlternatives | currentMasterBar.alternateEndings;
                        currentMasterBar = currentMasterBar.previousMasterBar;
                    }
                    // now calculate the alternative for this bar
                    var repeatAlternative = 0;
                    var repeatMask = this.data.readByte();
                    for (var i = 0; i < 8; i++) {
                        // only add the repeating if it is not existing
                        var repeating = 1 << i;
                        if (repeatMask > i && (existentAlternatives & repeating) === 0) {
                            repeatAlternative = repeatAlternative | repeating;
                        }
                    }
                    newMasterBar.alternateEndings = repeatAlternative;
                }
                else {
                    newMasterBar.alternateEndings = this.data.readByte();
                }
            }
            // marker
            if ((flags & 0x20) !== 0) {
                var section = new Section();
                section.text = GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
                section.marker = '';
                GpBinaryHelpers.gpReadColor(this.data, false);
                newMasterBar.section = section;
            }
            // keysignature
            if ((flags & 0x40) !== 0) {
                newMasterBar.keySignature = IOHelper.readSInt8(this.data);
                newMasterBar.keySignatureType = this.data.readByte();
            }
            else if (previousMasterBar) {
                newMasterBar.keySignature = previousMasterBar.keySignature;
                newMasterBar.keySignatureType = previousMasterBar.keySignatureType;
            }
            if (this._versionNumber >= 500 && (flags & 0x03) !== 0) {
                this.data.skip(4);
            }
            // better alternate ending mask in GP5
            if (this._versionNumber >= 500 && (flags & 0x10) === 0) {
                newMasterBar.alternateEndings = this.data.readByte();
            }
            // tripletfeel
            if (this._versionNumber >= 500) {
                var tripletFeel = this.data.readByte();
                switch (tripletFeel) {
                    case 1:
                        newMasterBar.tripletFeel = TripletFeel.Triplet8th;
                        break;
                    case 2:
                        newMasterBar.tripletFeel = TripletFeel.Triplet16th;
                        break;
                }
                this.data.readByte();
            }
            else {
                newMasterBar.tripletFeel = this._globalTripletFeel;
            }
            newMasterBar.isDoubleBar = (flags & 0x80) !== 0;
            this._score.addMasterBar(newMasterBar);
        };
        Gp3To5Importer.prototype.readTracks = function () {
            for (var i = 0; i < this._trackCount; i++) {
                this.readTrack();
            }
        };
        Gp3To5Importer.prototype.readTrack = function () {
            var newTrack = new Track();
            newTrack.ensureStaveCount(1);
            this._score.addTrack(newTrack);
            var mainStaff = newTrack.staves[0];
            var flags = this.data.readByte();
            newTrack.name = GpBinaryHelpers.gpReadStringByteLength(this.data, 40, this.settings.importer.encoding);
            if ((flags & 0x01) !== 0) {
                mainStaff.isPercussion = true;
            }
            var stringCount = IOHelper.readInt32LE(this.data);
            var tuning = [];
            for (var i = 0; i < 7; i++) {
                var stringTuning = IOHelper.readInt32LE(this.data);
                if (stringCount > i) {
                    tuning.push(stringTuning);
                }
            }
            mainStaff.tuning = tuning;
            var port = IOHelper.readInt32LE(this.data);
            var index = IOHelper.readInt32LE(this.data) - 1;
            var effectChannel = IOHelper.readInt32LE(this.data) - 1;
            this.data.skip(4); // Fretcount
            if (index >= 0 && index < this._playbackInfos.length) {
                var info = this._playbackInfos[index];
                info.port = port;
                info.isSolo = (flags & 0x10) !== 0;
                info.isMute = (flags & 0x20) !== 0;
                info.secondaryChannel = effectChannel;
                if (GeneralMidi.isGuitar(info.program)) {
                    mainStaff.displayTranspositionPitch = -12;
                }
                newTrack.playbackInfo = info;
            }
            mainStaff.capo = IOHelper.readInt32LE(this.data);
            newTrack.color = GpBinaryHelpers.gpReadColor(this.data, false);
            if (this._versionNumber >= 500) {
                // flags for
                //  0x01 -> show tablature
                //  0x02 -> show standard notation
                this.data.readByte();
                // flags for
                //  0x02 -> auto let ring
                //  0x04 -> auto brush
                this.data.readByte();
                // unknown
                this.data.skip(43);
            }
            // unknown
            if (this._versionNumber >= 510) {
                this.data.skip(4);
                GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
                GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
            }
        };
        Gp3To5Importer.prototype.readBars = function () {
            for (var i = 0; i < this._barCount; i++) {
                for (var t = 0; t < this._trackCount; t++) {
                    this.readBar(this._score.tracks[t]);
                }
            }
        };
        Gp3To5Importer.prototype.readBar = function (track) {
            var newBar = new Bar();
            var mainStaff = track.staves[0];
            if (mainStaff.isPercussion) {
                newBar.clef = Clef.Neutral;
            }
            mainStaff.addBar(newBar);
            var voiceCount = 1;
            if (this._versionNumber >= 500) {
                this.data.readByte();
                voiceCount = 2;
            }
            for (var v = 0; v < voiceCount; v++) {
                this.readVoice(track, newBar);
            }
        };
        Gp3To5Importer.prototype.readVoice = function (track, bar) {
            var beatCount = IOHelper.readInt32LE(this.data);
            if (beatCount === 0) {
                return;
            }
            var newVoice = new Voice();
            bar.addVoice(newVoice);
            for (var i = 0; i < beatCount; i++) {
                this.readBeat(track, bar, newVoice);
            }
        };
        Gp3To5Importer.prototype.readBeat = function (track, bar, voice) {
            var newBeat = new Beat();
            var flags = this.data.readByte();
            if ((flags & 0x01) !== 0) {
                newBeat.dots = 1;
            }
            if ((flags & 0x40) !== 0) {
                var type = this.data.readByte();
                newBeat.isEmpty = (type & 0x02) === 0;
            }
            voice.addBeat(newBeat);
            var duration = IOHelper.readSInt8(this.data);
            switch (duration) {
                case -2:
                    newBeat.duration = Duration.Whole;
                    break;
                case -1:
                    newBeat.duration = Duration.Half;
                    break;
                case 0:
                    newBeat.duration = Duration.Quarter;
                    break;
                case 1:
                    newBeat.duration = Duration.Eighth;
                    break;
                case 2:
                    newBeat.duration = Duration.Sixteenth;
                    break;
                case 3:
                    newBeat.duration = Duration.ThirtySecond;
                    break;
                case 4:
                    newBeat.duration = Duration.SixtyFourth;
                    break;
                default:
                    newBeat.duration = Duration.Quarter;
                    break;
            }
            if ((flags & 0x20) !== 0) {
                newBeat.tupletNumerator = IOHelper.readInt32LE(this.data);
                switch (newBeat.tupletNumerator) {
                    case 1:
                        newBeat.tupletDenominator = 1;
                        break;
                    case 3:
                        newBeat.tupletDenominator = 2;
                        break;
                    case 5:
                    case 6:
                    case 7:
                        newBeat.tupletDenominator = 4;
                        break;
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                        newBeat.tupletDenominator = 8;
                        break;
                    case 2:
                    case 4:
                    case 8:
                        break;
                    default:
                        newBeat.tupletNumerator = 1;
                        newBeat.tupletDenominator = 1;
                        break;
                }
            }
            if ((flags & 0x02) !== 0) {
                this.readChord(newBeat);
            }
            if ((flags & 0x04) !== 0) {
                newBeat.text = GpBinaryHelpers.gpReadStringIntUnused(this.data, this.settings.importer.encoding);
            }
            var allNoteHarmonicType = HarmonicType.None;
            if ((flags & 0x08) !== 0) {
                allNoteHarmonicType = this.readBeatEffects(newBeat);
            }
            if ((flags & 0x10) !== 0) {
                this.readMixTableChange(newBeat);
            }
            var stringFlags = this.data.readByte();
            for (var i = 6; i >= 0; i--) {
                if ((stringFlags & (1 << i)) !== 0 && 6 - i < bar.staff.tuning.length) {
                    var note = this.readNote(track, bar, voice, newBeat, 6 - i);
                    if (allNoteHarmonicType !== HarmonicType.None) {
                        note.harmonicType = allNoteHarmonicType;
                        if (note.harmonicType === HarmonicType.Natural) {
                            note.harmonicValue = this.deltaFretToHarmonicValue(note.fret);
                        }
                    }
                }
            }
            if (this._versionNumber >= 500) {
                this.data.readByte();
                var flag = this.data.readByte();
                if ((flag & 0x08) !== 0) {
                    this.data.readByte();
                }
            }
        };
        Gp3To5Importer.prototype.readChord = function (beat) {
            var chord = new Chord();
            var chordId = ModelUtils.newGuid();
            if (this._versionNumber >= 500) {
                this.data.skip(17);
                chord.name = GpBinaryHelpers.gpReadStringByteLength(this.data, 21, this.settings.importer.encoding);
                this.data.skip(4);
                chord.firstFret = IOHelper.readInt32LE(this.data);
                for (var i = 0; i < 7; i++) {
                    var fret = IOHelper.readInt32LE(this.data);
                    if (i < beat.voice.bar.staff.tuning.length) {
                        chord.strings.push(fret);
                    }
                }
                var numberOfBarres = this.data.readByte();
                var barreFrets = new Uint8Array(5);
                this.data.read(barreFrets, 0, barreFrets.length);
                for (var i = 0; i < numberOfBarres; i++) {
                    chord.barreFrets.push(barreFrets[i]);
                }
                this.data.skip(26);
            }
            else {
                if (this.data.readByte() !== 0) {
                    // gp4
                    if (this._versionNumber >= 400) {
                        // Sharp (1)
                        // Unused (3)
                        // Root (1)
                        // Major/Minor (1)
                        // Nin,Eleven or Thirteen (1)
                        // Bass (4)
                        // Diminished/Augmented (4)
                        // Add (1)
                        this.data.skip(16);
                        chord.name = GpBinaryHelpers.gpReadStringByteLength(this.data, 21, this.settings.importer.encoding);
                        // Unused (2)
                        // Fifth (1)
                        // Ninth (1)
                        // Eleventh (1)
                        this.data.skip(4);
                        chord.firstFret = IOHelper.readInt32LE(this.data);
                        for (var i = 0; i < 7; i++) {
                            var fret = IOHelper.readInt32LE(this.data);
                            if (i < beat.voice.bar.staff.tuning.length) {
                                chord.strings.push(fret);
                            }
                        }
                        var numberOfBarres = this.data.readByte();
                        var barreFrets = new Uint8Array(5);
                        this.data.read(barreFrets, 0, barreFrets.length);
                        for (var i = 0; i < numberOfBarres; i++) {
                            chord.barreFrets.push(barreFrets[i]);
                        }
                        // Barree end (5)
                        // Omission1,3,5,7,9,11,13 (7)
                        // Unused (1)
                        // Fingering (7)
                        // Show Diagram Fingering (1)
                        // ??
                        this.data.skip(26);
                    }
                    else {
                        // unknown
                        this.data.skip(25);
                        chord.name = GpBinaryHelpers.gpReadStringByteLength(this.data, 34, this.settings.importer.encoding);
                        chord.firstFret = IOHelper.readInt32LE(this.data);
                        for (var i = 0; i < 6; i++) {
                            var fret = IOHelper.readInt32LE(this.data);
                            if (i < beat.voice.bar.staff.tuning.length) {
                                chord.strings.push(fret);
                            }
                        }
                        // unknown
                        this.data.skip(36);
                    }
                }
                else {
                    var strings = this._versionNumber >= 406 ? 7 : 6;
                    chord.name = GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
                    chord.firstFret = IOHelper.readInt32LE(this.data);
                    if (chord.firstFret > 0) {
                        for (var i = 0; i < strings; i++) {
                            var fret = IOHelper.readInt32LE(this.data);
                            if (i < beat.voice.bar.staff.tuning.length) {
                                chord.strings.push(fret);
                            }
                        }
                    }
                }
            }
            if (chord.name) {
                beat.chordId = chordId;
                beat.voice.bar.staff.addChord(beat.chordId, chord);
            }
        };
        Gp3To5Importer.prototype.readBeatEffects = function (beat) {
            var flags = this.data.readByte();
            var flags2 = 0;
            if (this._versionNumber >= 400) {
                flags2 = this.data.readByte();
            }
            beat.fadeIn = (flags & 0x10) !== 0;
            if ((this._versionNumber < 400 && (flags & 0x01) !== 0) || (flags & 0x02) !== 0) {
                beat.vibrato = VibratoType.Slight;
            }
            beat.hasRasgueado = (flags2 & 0x01) !== 0;
            if ((flags & 0x20) !== 0 && this._versionNumber >= 400) {
                var slapPop = IOHelper.readSInt8(this.data);
                switch (slapPop) {
                    case 1:
                        beat.tap = true;
                        break;
                    case 2:
                        beat.slap = true;
                        break;
                    case 3:
                        beat.pop = true;
                        break;
                }
            }
            else if ((flags & 0x20) !== 0) {
                var slapPop = IOHelper.readSInt8(this.data);
                switch (slapPop) {
                    case 1:
                        beat.tap = true;
                        break;
                    case 2:
                        beat.slap = true;
                        break;
                    case 3:
                        beat.pop = true;
                        break;
                }
                this.data.skip(4);
            }
            if ((flags2 & 0x04) !== 0) {
                this.readTremoloBarEffect(beat);
            }
            if ((flags & 0x40) !== 0) {
                var strokeUp = 0;
                var strokeDown = 0;
                if (this._versionNumber < 500) {
                    strokeDown = this.data.readByte();
                    strokeUp = this.data.readByte();
                }
                else {
                    strokeUp = this.data.readByte();
                    strokeDown = this.data.readByte();
                }
                if (strokeUp > 0) {
                    beat.brushType = BrushType.BrushUp;
                    beat.brushDuration = Gp3To5Importer.toStrokeValue(strokeUp);
                }
                else if (strokeDown > 0) {
                    beat.brushType = BrushType.BrushDown;
                    beat.brushDuration = Gp3To5Importer.toStrokeValue(strokeDown);
                }
            }
            if ((flags2 & 0x02) !== 0) {
                switch (IOHelper.readSInt8(this.data)) {
                    case 0:
                        beat.pickStroke = PickStroke.None;
                        break;
                    case 1:
                        beat.pickStroke = PickStroke.Up;
                        break;
                    case 2:
                        beat.pickStroke = PickStroke.Down;
                        break;
                }
            }
            if (this._versionNumber < 400) {
                if ((flags & 0x04) !== 0) {
                    return HarmonicType.Natural;
                }
                else if ((flags & 0x08) !== 0) {
                    return HarmonicType.Artificial;
                }
            }
            return HarmonicType.None;
        };
        Gp3To5Importer.prototype.readTremoloBarEffect = function (beat) {
            this.data.readByte(); // type
            IOHelper.readInt32LE(this.data); // value
            var pointCount = IOHelper.readInt32LE(this.data);
            if (pointCount > 0) {
                for (var i = 0; i < pointCount; i++) {
                    var point = new BendPoint(0, 0);
                    point.offset = IOHelper.readInt32LE(this.data); // 0...60
                    point.value = (IOHelper.readInt32LE(this.data) / Gp3To5Importer.BendStep) | 0; // 0..12 (amount of quarters)
                    GpBinaryHelpers.gpReadBool(this.data); // vibrato
                    beat.addWhammyBarPoint(point);
                }
            }
        };
        Gp3To5Importer.toStrokeValue = function (value) {
            switch (value) {
                case 1:
                    return 30;
                case 2:
                    return 30;
                case 3:
                    return 60;
                case 4:
                    return 120;
                case 5:
                    return 240;
                case 6:
                    return 480;
                default:
                    return 0;
            }
        };
        Gp3To5Importer.prototype.readMixTableChange = function (beat) {
            var tableChange = new MixTableChange();
            tableChange.instrument = IOHelper.readSInt8(this.data);
            if (this._versionNumber >= 500) {
                this.data.skip(16); // Rse Info
            }
            tableChange.volume = IOHelper.readSInt8(this.data);
            tableChange.balance = IOHelper.readSInt8(this.data);
            var chorus = IOHelper.readSInt8(this.data);
            var reverb = IOHelper.readSInt8(this.data);
            var phaser = IOHelper.readSInt8(this.data);
            var tremolo = IOHelper.readSInt8(this.data);
            if (this._versionNumber >= 500) {
                tableChange.tempoName = GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
            }
            tableChange.tempo = IOHelper.readInt32LE(this.data);
            // durations
            if (tableChange.volume >= 0) {
                this.data.readByte();
            }
            if (tableChange.balance >= 0) {
                this.data.readByte();
            }
            if (chorus >= 0) {
                this.data.readByte();
            }
            if (reverb >= 0) {
                this.data.readByte();
            }
            if (phaser >= 0) {
                this.data.readByte();
            }
            if (tremolo >= 0) {
                this.data.readByte();
            }
            if (tableChange.tempo >= 0) {
                tableChange.duration = IOHelper.readSInt8(this.data);
                if (this._versionNumber >= 510) {
                    this.data.readByte(); // hideTempo (bool)
                }
            }
            if (this._versionNumber >= 400) {
                this.data.readByte(); // all tracks flag
            }
            // unknown
            if (this._versionNumber >= 500) {
                this.data.readByte();
            }
            // unknown
            if (this._versionNumber >= 510) {
                GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
                GpBinaryHelpers.gpReadStringIntByte(this.data, this.settings.importer.encoding);
            }
            if (tableChange.volume >= 0) {
                var volumeAutomation = new Automation();
                volumeAutomation.isLinear = true;
                volumeAutomation.type = AutomationType.Volume;
                volumeAutomation.value = tableChange.volume;
                beat.automations.push(volumeAutomation);
            }
            if (tableChange.balance >= 0) {
                var balanceAutomation = new Automation();
                balanceAutomation.isLinear = true;
                balanceAutomation.type = AutomationType.Balance;
                balanceAutomation.value = tableChange.balance;
                beat.automations.push(balanceAutomation);
            }
            if (tableChange.instrument >= 0) {
                var instrumentAutomation = new Automation();
                instrumentAutomation.isLinear = true;
                instrumentAutomation.type = AutomationType.Instrument;
                instrumentAutomation.value = tableChange.instrument;
                beat.automations.push(instrumentAutomation);
            }
            if (tableChange.tempo >= 0) {
                var tempoAutomation = new Automation();
                tempoAutomation.isLinear = true;
                tempoAutomation.type = AutomationType.Tempo;
                tempoAutomation.value = tableChange.tempo;
                beat.automations.push(tempoAutomation);
                beat.voice.bar.masterBar.tempoAutomation = tempoAutomation;
            }
        };
        Gp3To5Importer.prototype.readNote = function (track, bar, voice, beat, stringIndex) {
            var newNote = new Note();
            newNote.string = bar.staff.tuning.length - stringIndex;
            var flags = this.data.readByte();
            if ((flags & 0x02) !== 0) {
                newNote.accentuated = AccentuationType.Heavy;
            }
            else if ((flags & 0x40) !== 0) {
                newNote.accentuated = AccentuationType.Normal;
            }
            newNote.isGhost = (flags & 0x04) !== 0;
            if ((flags & 0x20) !== 0) {
                var noteType = this.data.readByte();
                if (noteType === 3) {
                    newNote.isDead = true;
                }
                else if (noteType === 2) {
                    newNote.isTieDestination = true;
                }
            }
            if ((flags & 0x01) !== 0 && this._versionNumber < 500) {
                this.data.readByte(); // duration
                this.data.readByte(); // tuplet
            }
            if ((flags & 0x10) !== 0) {
                var dynamicNumber = IOHelper.readSInt8(this.data);
                newNote.dynamics = this.toDynamicValue(dynamicNumber);
                beat.dynamics = newNote.dynamics;
            }
            if ((flags & 0x20) !== 0) {
                newNote.fret = IOHelper.readSInt8(this.data);
            }
            if ((flags & 0x80) !== 0) {
                newNote.leftHandFinger = IOHelper.readSInt8(this.data);
                newNote.rightHandFinger = IOHelper.readSInt8(this.data);
                newNote.isFingering = true;
            }
            if (this._versionNumber >= 500) {
                if ((flags & 0x01) !== 0) {
                    newNote.durationPercent = GpBinaryHelpers.gpReadDouble(this.data);
                }
                var flags2 = this.data.readByte();
                newNote.accidentalMode =
                    (flags2 & 0x02) !== 0 ? NoteAccidentalMode.SwapAccidentals : NoteAccidentalMode.Default;
            }
            beat.addNote(newNote);
            if ((flags & 0x08) !== 0) {
                this.readNoteEffects(track, voice, beat, newNote);
            }
            if (bar.staff.isPercussion) {
                newNote.percussionArticulation = newNote.fret;
                newNote.string = -1;
                newNote.fret = -1;
            }
            return newNote;
        };
        Gp3To5Importer.prototype.toDynamicValue = function (value) {
            switch (value) {
                case 1:
                    return DynamicValue.PPP;
                case 2:
                    return DynamicValue.PP;
                case 3:
                    return DynamicValue.P;
                case 4:
                    return DynamicValue.MP;
                case 5:
                    return DynamicValue.MF;
                case 6:
                    return DynamicValue.F;
                case 7:
                    return DynamicValue.FF;
                case 8:
                    return DynamicValue.FFF;
                default:
                    return DynamicValue.F;
            }
        };
        Gp3To5Importer.prototype.readNoteEffects = function (track, voice, beat, note) {
            var flags = this.data.readByte();
            var flags2 = 0;
            if (this._versionNumber >= 400) {
                flags2 = this.data.readByte();
            }
            if ((flags & 0x01) !== 0) {
                this.readBend(note);
            }
            if ((flags & 0x10) !== 0) {
                this.readGrace(voice, note);
            }
            if ((flags2 & 0x04) !== 0) {
                this.readTremoloPicking(beat);
            }
            if ((flags2 & 0x08) !== 0) {
                this.readSlide(note);
            }
            else if (this._versionNumber < 400) {
                if ((flags & 0x04) !== 0) {
                    note.slideOutType = SlideOutType.Shift;
                }
            }
            if ((flags2 & 0x10) !== 0) {
                this.readArtificialHarmonic(note);
            }
            if ((flags2 & 0x20) !== 0) {
                this.readTrill(note);
            }
            note.isLetRing = (flags & 0x08) !== 0;
            note.isHammerPullOrigin = (flags & 0x02) !== 0;
            if ((flags2 & 0x40) !== 0) {
                note.vibrato = VibratoType.Slight;
            }
            note.isPalmMute = (flags2 & 0x02) !== 0;
            note.isStaccato = (flags2 & 0x01) !== 0;
        };
        Gp3To5Importer.prototype.readBend = function (note) {
            this.data.readByte(); // type
            IOHelper.readInt32LE(this.data); // value
            var pointCount = IOHelper.readInt32LE(this.data);
            if (pointCount > 0) {
                for (var i = 0; i < pointCount; i++) {
                    var point = new BendPoint(0, 0);
                    point.offset = IOHelper.readInt32LE(this.data); // 0...60
                    point.value = (IOHelper.readInt32LE(this.data) / Gp3To5Importer.BendStep) | 0; // 0..12 (amount of quarters)
                    GpBinaryHelpers.gpReadBool(this.data); // vibrato
                    note.addBendPoint(point);
                }
            }
        };
        Gp3To5Importer.prototype.readGrace = function (voice, note) {
            var graceBeat = new Beat();
            var graceNote = new Note();
            graceNote.string = note.string;
            graceNote.fret = IOHelper.readSInt8(this.data);
            graceBeat.duration = Duration.ThirtySecond;
            graceBeat.dynamics = this.toDynamicValue(IOHelper.readSInt8(this.data));
            var transition = IOHelper.readSInt8(this.data);
            switch (transition) {
                case 0:
                    break;
                case 1:
                    graceNote.slideOutType = SlideOutType.Legato;
                    graceNote.slideTarget = note;
                    break;
                case 2:
                    break;
                case 3:
                    graceNote.isHammerPullOrigin = true;
                    break;
            }
            graceNote.dynamics = graceBeat.dynamics;
            this.data.skip(1); // duration
            if (this._versionNumber < 500) {
                graceBeat.graceType = GraceType.BeforeBeat;
            }
            else {
                var flags = this.data.readByte();
                graceNote.isDead = (flags & 0x01) !== 0;
                graceBeat.graceType = (flags & 0x02) !== 0 ? GraceType.OnBeat : GraceType.BeforeBeat;
            }
            voice.addGraceBeat(graceBeat);
            graceBeat.addNote(graceNote);
        };
        Gp3To5Importer.prototype.readTremoloPicking = function (beat) {
            var speed = this.data.readByte();
            switch (speed) {
                case 1:
                    beat.tremoloSpeed = Duration.Eighth;
                    break;
                case 2:
                    beat.tremoloSpeed = Duration.Sixteenth;
                    break;
                case 3:
                    beat.tremoloSpeed = Duration.ThirtySecond;
                    break;
            }
        };
        Gp3To5Importer.prototype.readSlide = function (note) {
            if (this._versionNumber >= 500) {
                var type = IOHelper.readSInt8(this.data);
                if ((type & 1) !== 0) {
                    note.slideOutType = SlideOutType.Shift;
                }
                else if ((type & 2) !== 0) {
                    note.slideOutType = SlideOutType.Legato;
                }
                else if ((type & 4) !== 0) {
                    note.slideOutType = SlideOutType.OutDown;
                }
                else if ((type & 8) !== 0) {
                    note.slideOutType = SlideOutType.OutUp;
                }
                if ((type & 16) !== 0) {
                    note.slideInType = SlideInType.IntoFromBelow;
                }
                else if ((type & 32) !== 0) {
                    note.slideInType = SlideInType.IntoFromAbove;
                }
            }
            else {
                var type = IOHelper.readSInt8(this.data);
                switch (type) {
                    case 1:
                        note.slideOutType = SlideOutType.Shift;
                        break;
                    case 2:
                        note.slideOutType = SlideOutType.Legato;
                        break;
                    case 3:
                        note.slideOutType = SlideOutType.OutDown;
                        break;
                    case 4:
                        note.slideOutType = SlideOutType.OutUp;
                        break;
                    case -1:
                        note.slideInType = SlideInType.IntoFromBelow;
                        break;
                    case -2:
                        note.slideInType = SlideInType.IntoFromAbove;
                        break;
                }
            }
        };
        Gp3To5Importer.prototype.readArtificialHarmonic = function (note) {
            var type = this.data.readByte();
            if (this._versionNumber >= 500) {
                switch (type) {
                    case 1:
                        note.harmonicType = HarmonicType.Natural;
                        note.harmonicValue = this.deltaFretToHarmonicValue(note.fret);
                        break;
                    case 2:
                        /*let _harmonicTone: number = */ this.data.readByte();
                        /*let _harmonicKey: number =  */ this.data.readByte();
                        /*let _harmonicOctaveOffset: number = */ this.data.readByte();
                        note.harmonicType = HarmonicType.Artificial;
                        break;
                    case 3:
                        note.harmonicType = HarmonicType.Tap;
                        note.harmonicValue = this.deltaFretToHarmonicValue(this.data.readByte());
                        break;
                    case 4:
                        note.harmonicType = HarmonicType.Pinch;
                        note.harmonicValue = 12;
                        break;
                    case 5:
                        note.harmonicType = HarmonicType.Semi;
                        note.harmonicValue = 12;
                        break;
                }
            }
            else if (this._versionNumber >= 400) {
                switch (type) {
                    case 1:
                        note.harmonicType = HarmonicType.Natural;
                        break;
                    case 3:
                        note.harmonicType = HarmonicType.Tap;
                        break;
                    case 4:
                        note.harmonicType = HarmonicType.Pinch;
                        break;
                    case 5:
                        note.harmonicType = HarmonicType.Semi;
                        break;
                    case 15:
                        note.harmonicType = HarmonicType.Artificial;
                        break;
                    case 17:
                        note.harmonicType = HarmonicType.Artificial;
                        break;
                    case 22:
                        note.harmonicType = HarmonicType.Artificial;
                        break;
                }
            }
        };
        Gp3To5Importer.prototype.deltaFretToHarmonicValue = function (deltaFret) {
            switch (deltaFret) {
                case 2:
                    return 2.4;
                case 3:
                    return 3.2;
                case 4:
                case 5:
                case 7:
                case 9:
                case 12:
                case 16:
                case 17:
                case 19:
                case 24:
                    return deltaFret;
                case 8:
                    return 8.2;
                case 10:
                    return 9.6;
                case 14:
                case 15:
                    return 14.7;
                case 21:
                case 22:
                    return 21.7;
                default:
                    return 12;
            }
        };
        Gp3To5Importer.prototype.readTrill = function (note) {
            note.trillValue = this.data.readByte() + note.stringTuning;
            switch (this.data.readByte()) {
                case 1:
                    note.trillSpeed = Duration.Sixteenth;
                    break;
                case 2:
                    note.trillSpeed = Duration.ThirtySecond;
                    break;
                case 3:
                    note.trillSpeed = Duration.SixtyFourth;
                    break;
            }
        };
        Gp3To5Importer.VersionString = 'FICHIER GUITAR PRO ';
        Gp3To5Importer.BendStep = 25;
        return Gp3To5Importer;
    }(ScoreImporter));
    var GpBinaryHelpers = /** @class */ (function () {
        function GpBinaryHelpers() {
        }
        GpBinaryHelpers.gpReadDouble = function (data) {
            var bytes = new Uint8Array(8);
            data.read(bytes, 0, bytes.length);
            var array = new Float64Array(bytes.buffer);
            return array[0];
        };
        GpBinaryHelpers.gpReadFloat = function (data) {
            var bytes = new Uint8Array(4);
            bytes[3] = data.readByte();
            bytes[2] = data.readByte();
            bytes[2] = data.readByte();
            bytes[1] = data.readByte();
            var array = new Float32Array(bytes.buffer);
            return array[0];
        };
        GpBinaryHelpers.gpReadColor = function (data, readAlpha) {
            if (readAlpha === void 0) { readAlpha = false; }
            var r = data.readByte();
            var g = data.readByte();
            var b = data.readByte();
            var a = 255;
            if (readAlpha) {
                a = data.readByte();
            }
            else {
                data.skip(1);
            }
            return new Color(r, g, b, a);
        };
        GpBinaryHelpers.gpReadBool = function (data) {
            return data.readByte() !== 0;
        };
        /**
         * Skips an integer (4byte) and reads a string using
         * a bytesize
         */
        GpBinaryHelpers.gpReadStringIntUnused = function (data, encoding) {
            data.skip(4);
            return GpBinaryHelpers.gpReadString(data, data.readByte(), encoding);
        };
        /**
         * Reads an integer as size, and then the string itself
         */
        GpBinaryHelpers.gpReadStringInt = function (data, encoding) {
            return GpBinaryHelpers.gpReadString(data, IOHelper.readInt32LE(data), encoding);
        };
        /**
         * Reads an integer as size, skips a byte and reads the string itself
         */
        GpBinaryHelpers.gpReadStringIntByte = function (data, encoding) {
            var length = IOHelper.readInt32LE(data) - 1;
            data.readByte();
            return GpBinaryHelpers.gpReadString(data, length, encoding);
        };
        GpBinaryHelpers.gpReadString = function (data, length, encoding) {
            var b = new Uint8Array(length);
            data.read(b, 0, b.length);
            return IOHelper.toString(b, encoding);
        };
        /**
         * Reads a byte as size and the string itself.
         * Additionally it is ensured the specified amount of bytes is read.
         * @param data the data to read from.
         * @param length the amount of bytes to read
         * @param encoding The encoding to use to decode the byte into a string
         * @returns
         */
        GpBinaryHelpers.gpReadStringByteLength = function (data, length, encoding) {
            var stringLength = data.readByte();
            var s = GpBinaryHelpers.gpReadString(data, stringLength, encoding);
            if (stringLength < length) {
                data.skip(length - stringLength);
            }
            return s;
        };
        return GpBinaryHelpers;
    }());
    /**
     * A mixtablechange describes several track changes.
     */
    var MixTableChange = /** @class */ (function () {
        function MixTableChange() {
            this.volume = -1;
            this.balance = -1;
            this.instrument = -1;
            this.tempoName = "";
            this.tempo = -1;
            this.duration = -1;
        }
        return MixTableChange;
    }());

    var ByteBuffer = /** @class */ (function () {
        function ByteBuffer() {
            this._capacity = 0;
            this.length = 0;
            this.position = 0;
        }
        ByteBuffer.prototype.getBuffer = function () {
            return this._buffer;
        };
        ByteBuffer.empty = function () {
            return ByteBuffer.withCapactiy(0);
        };
        ByteBuffer.withCapactiy = function (capacity) {
            var buffer = new ByteBuffer();
            buffer._buffer = new Uint8Array(capacity);
            buffer._capacity = capacity;
            return buffer;
        };
        ByteBuffer.fromBuffer = function (data) {
            var buffer = new ByteBuffer();
            buffer._buffer = data;
            buffer._capacity = buffer.length = data.length;
            return buffer;
        };
        ByteBuffer.fromString = function (contents) {
            var byteArray = new Uint8Array(contents.length);
            for (var i = 0; i < contents.length; i++) {
                byteArray[i] = contents.charCodeAt(i);
            }
            return ByteBuffer.fromBuffer(byteArray);
        };
        ByteBuffer.prototype.reset = function () {
            this.position = 0;
        };
        ByteBuffer.prototype.skip = function (offset) {
            this.position += offset;
        };
        ByteBuffer.prototype.setCapacity = function (value) {
            if (value !== this._capacity) {
                if (value > 0) {
                    var newBuffer = new Uint8Array(value);
                    if (this.length > 0) {
                        newBuffer.set(this._buffer.subarray(0, 0 + this.length), 0);
                    }
                    this._buffer = newBuffer;
                }
                this._capacity = value;
            }
        };
        ByteBuffer.prototype.readByte = function () {
            var n = this.length - this.position;
            if (n <= 0) {
                return -1;
            }
            return this._buffer[this.position++];
        };
        ByteBuffer.prototype.read = function (buffer, offset, count) {
            var n = this.length - this.position;
            if (n > count) {
                n = count;
            }
            if (n <= 0) {
                return 0;
            }
            if (n <= 8) {
                var byteCount = n;
                while (--byteCount >= 0) {
                    buffer[offset + byteCount] = this._buffer[this.position + byteCount];
                }
            }
            else {
                buffer.set(this._buffer.subarray(this.position, this.position + n), offset);
            }
            this.position += n;
            return n;
        };
        ByteBuffer.prototype.writeByte = function (value) {
            var buffer = new Uint8Array(1);
            buffer[0] = value;
            this.write(buffer, 0, 1);
        };
        ByteBuffer.prototype.write = function (buffer, offset, count) {
            var i = this.position + count;
            if (i > this.length) {
                if (i > this._capacity) {
                    this.ensureCapacity(i);
                }
                this.length = i;
            }
            if (count <= 8 && buffer !== this._buffer) {
                var byteCount = count;
                while (--byteCount >= 0) {
                    this._buffer[this.position + byteCount] = buffer[offset + byteCount];
                }
            }
            else {
                var count1 = Math.min(count, buffer.length - offset);
                this._buffer.set(buffer.subarray(offset, offset + count1), this.position);
            }
            this.position = i;
        };
        ByteBuffer.prototype.ensureCapacity = function (value) {
            if (value > this._capacity) {
                var newCapacity = value;
                if (newCapacity < 256) {
                    newCapacity = 256;
                }
                if (newCapacity < this._capacity * 2) {
                    newCapacity = this._capacity * 2;
                }
                this.setCapacity(newCapacity);
            }
        };
        ByteBuffer.prototype.readAll = function () {
            return this.toArray();
        };
        ByteBuffer.prototype.toArray = function () {
            var copy = new Uint8Array(this.length);
            copy.set(this._buffer.subarray(0, 0 + this.length), 0);
            return copy;
        };
        return ByteBuffer;
    }());

    /**
     * Represents a rectangular area within the renderer music notation.
     */
    var Bounds = /** @class */ (function () {
        function Bounds() {
            /**
             * Gets or sets the X-position of the rectangle within the music notation.
             */
            this.x = 0;
            /**
             * Gets or sets the Y-position of the rectangle within the music notation.
             */
            this.y = 0;
            /**
             * Gets or sets the width of the rectangle.
             */
            this.w = 0;
            /**
             * Gets or sets the height of the rectangle.
             */
            this.h = 0;
        }
        return Bounds;
    }());

    var DataType;
    (function (DataType) {
        DataType[DataType["Boolean"] = 0] = "Boolean";
        DataType[DataType["Integer"] = 1] = "Integer";
        DataType[DataType["Float"] = 2] = "Float";
        DataType[DataType["String"] = 3] = "String";
        DataType[DataType["Point"] = 4] = "Point";
        DataType[DataType["Size"] = 5] = "Size";
        DataType[DataType["Rectangle"] = 6] = "Rectangle";
        DataType[DataType["Color"] = 7] = "Color";
    })(DataType || (DataType = {}));
    /**
     * A BinaryStylesheet from Guitar Pro 6 and 7 files.
     * The BinaryStylesheet is a simple binary key-value store for additional settings
     * related to the display of the music sheet.
     *
     * File:
     *     int32 (big endian) | Number of KeyValuePairs
     *     KeyValuePair[]     | The raw records
     *
     * KeyValuePair:
     *     1 Byte  | length of the key
     *     n Bytes | key as utf8 encoded string
     *     1 Byte  | Data Type
     *     n Bytes | Value
     *
     * Values based on Data Type:
     *     0 = bool
     *         0===false
     *     1 = int32 (big endian)
     *     2 = float (big endian, IEEE)
     *     3 = string
     *       int16 (big endian) | length of string
     *       n bytes            | utf-8 encoded string
     *     4 = point
     *       int32 (big endian) | X-coordinate
     *       int32 (big endian) | Y-coordinate
     *     5 = size
     *       int32 (big endian) | Width
     *       int32 (big endian) | Height
     *     6 = rectangle
     *       int32 (big endian) | X-coordinate
     *       int32 (big endian) | Y-coordinate
     *       int32 (big endian) | Width
     *       int32 (big endian) | Height
     *     7 = color
     *       1 byte | Red
     *       1 byte | Green
     *       1 byte | Blue
     *       1 byte | Alpha
     */
    var BinaryStylesheet = /** @class */ (function () {
        function BinaryStylesheet(data) {
            this.raw = new Map();
            // BinaryStylesheet apears to be big-endien
            var readable = ByteBuffer.fromBuffer(data);
            var entryCount = IOHelper.readInt32BE(readable);
            for (var i = 0; i < entryCount; i++) {
                var key = GpBinaryHelpers.gpReadString(readable, readable.readByte(), 'utf-8');
                var type = readable.readByte();
                switch (type) {
                    case DataType.Boolean:
                        var flag = readable.readByte() === 1;
                        this.addValue(key, flag);
                        break;
                    case DataType.Integer:
                        var ivalue = IOHelper.readInt32BE(readable);
                        this.addValue(key, ivalue);
                        break;
                    case DataType.Float:
                        var fvalue = GpBinaryHelpers.gpReadFloat(readable);
                        this.addValue(key, fvalue);
                        break;
                    case DataType.String:
                        var s = GpBinaryHelpers.gpReadString(readable, IOHelper.readInt16BE(readable), 'utf-8');
                        this.addValue(key, s);
                        break;
                    case DataType.Point:
                        var x = IOHelper.readInt32BE(readable);
                        var y = IOHelper.readInt32BE(readable);
                        this.addValue(key, new BendPoint(x, y));
                        break;
                    case DataType.Size:
                        var width = IOHelper.readInt32BE(readable);
                        var height = IOHelper.readInt32BE(readable);
                        this.addValue(key, new BendPoint(width, height));
                        break;
                    case DataType.Rectangle:
                        var rect = new Bounds();
                        rect.x = IOHelper.readInt32BE(readable);
                        rect.y = IOHelper.readInt32BE(readable);
                        rect.w = IOHelper.readInt32BE(readable);
                        rect.h = IOHelper.readInt32BE(readable);
                        this.addValue(key, rect);
                        break;
                    case DataType.Color:
                        var color = GpBinaryHelpers.gpReadColor(readable, true);
                        this.addValue(key, color);
                        break;
                }
            }
        }
        BinaryStylesheet.prototype.apply = function (score) {
            this.raw.forEach(function (value, key) {
                switch (key) {
                    case 'StandardNotation/hideDynamics':
                        score.stylesheet.hideDynamics = value;
                        break;
                }
            });
        };
        BinaryStylesheet.prototype.addValue = function (key, value) {
            this.raw.set(key, value);
        };
        return BinaryStylesheet;
    }());

    /**
     * Lists all types of fermatas
     */
    var FermataType;
    (function (FermataType) {
        /**
         * A short fermata (triangle symbol)
         */
        FermataType[FermataType["Short"] = 0] = "Short";
        /**
         * A medium fermata (round symbol)
         */
        FermataType[FermataType["Medium"] = 1] = "Medium";
        /**
         * A long fermata (rectangular symbol)
         */
        FermataType[FermataType["Long"] = 2] = "Long";
    })(FermataType || (FermataType = {}));
    /**
     * Represents a fermata.
     */
    var Fermata = /** @class */ (function () {
        function Fermata() {
            /**
             * Gets or sets the type of fermata.
             */
            this.type = FermataType.Short;
            /**
             * Gets or sets the actual lenght of the fermata.
             */
            this.length = 0;
        }
        Fermata.copyTo = function (src, dst) {
            dst.type = src.type;
            dst.length = src.length;
        };
        return Fermata;
    }());

    // This XML parser is based on the XML Parser of the Haxe Standard Library (MIT)
    /*
     * Copyright (C)2005-2019 Haxe Foundation
     *
     * Permission is hereby granted, free of charge, to any person obtaining a
     * copy of this software and associated documentation files (the "Software"),
     * to deal in the Software without restriction, including without limitation
     * the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons to whom the
     * Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     * DEALINGS IN THE SOFTWARE.
     */
    var XmlNodeType;
    (function (XmlNodeType) {
        XmlNodeType[XmlNodeType["None"] = 0] = "None";
        XmlNodeType[XmlNodeType["Element"] = 1] = "Element";
        XmlNodeType[XmlNodeType["Attribute"] = 2] = "Attribute";
        XmlNodeType[XmlNodeType["Text"] = 3] = "Text";
        XmlNodeType[XmlNodeType["CDATA"] = 4] = "CDATA";
        XmlNodeType[XmlNodeType["EntityReference"] = 5] = "EntityReference";
        XmlNodeType[XmlNodeType["Entity"] = 6] = "Entity";
        XmlNodeType[XmlNodeType["ProcessingInstruction"] = 7] = "ProcessingInstruction";
        XmlNodeType[XmlNodeType["Comment"] = 8] = "Comment";
        XmlNodeType[XmlNodeType["Document"] = 9] = "Document";
        XmlNodeType[XmlNodeType["DocumentType"] = 10] = "DocumentType";
        XmlNodeType[XmlNodeType["DocumentFragment"] = 11] = "DocumentFragment";
        XmlNodeType[XmlNodeType["Notation"] = 12] = "Notation";
        XmlNodeType[XmlNodeType["Whitespace"] = 13] = "Whitespace";
        XmlNodeType[XmlNodeType["SignificantWhitespace"] = 14] = "SignificantWhitespace";
        XmlNodeType[XmlNodeType["EndElement"] = 15] = "EndElement";
        XmlNodeType[XmlNodeType["EndEntity"] = 16] = "EndEntity";
        XmlNodeType[XmlNodeType["XmlDeclaration"] = 17] = "XmlDeclaration";
    })(XmlNodeType || (XmlNodeType = {}));
    var XmlNode = /** @class */ (function () {
        function XmlNode() {
            this.nodeType = XmlNodeType.None;
            this.localName = null;
            this.value = null;
            this.childNodes = [];
            this.attributes = new Map();
            this.firstChild = null;
            this.firstElement = null;
        }
        XmlNode.prototype.addChild = function (node) {
            this.childNodes.push(node);
            this.firstChild = node;
            if (node.nodeType === XmlNodeType.Element) {
                this.firstElement = node;
            }
        };
        XmlNode.prototype.getAttribute = function (name) {
            if (this.attributes.has(name)) {
                return this.attributes.get(name);
            }
            return '';
        };
        XmlNode.prototype.getElementsByTagName = function (name, recursive) {
            if (recursive === void 0) { recursive = false; }
            var tags = [];
            this.searchElementsByTagName(this.childNodes, tags, name, recursive);
            return tags;
        };
        XmlNode.prototype.searchElementsByTagName = function (all, result, name, recursive) {
            if (recursive === void 0) { recursive = false; }
            for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
                var c = all_1[_i];
                if (c && c.nodeType === XmlNodeType.Element && c.localName === name) {
                    result.push(c);
                }
                if (recursive) {
                    this.searchElementsByTagName(c.childNodes, result, name, true);
                }
            }
        };
        XmlNode.prototype.findChildElement = function (name) {
            for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c && c.nodeType === XmlNodeType.Element && c.localName === name) {
                    return c;
                }
            }
            return null;
        };
        Object.defineProperty(XmlNode.prototype, "innerText", {
            get: function () {
                var _a, _b;
                if (this.nodeType === XmlNodeType.Element || this.nodeType === XmlNodeType.Document) {
                    var txt = '';
                    for (var _i = 0, _c = this.childNodes; _i < _c.length; _i++) {
                        var c = _c[_i];
                        txt += (_a = c.innerText) === null || _a === void 0 ? void 0 : _a.toString();
                    }
                    var s = txt;
                    return s.trim();
                }
                return (_b = this.value) !== null && _b !== void 0 ? _b : '';
            },
            enumerable: false,
            configurable: true
        });
        return XmlNode;
    }());

    // This XML parser is based on the XML Parser of the Haxe Standard Library (MIT)
    /*
     * Copyright (C)2005-2019 Haxe Foundation
     *
     * Permission is hereby granted, free of charge, to any person obtaining a
     * copy of this software and associated documentation files (the "Software"),
     * to deal in the Software without restriction, including without limitation
     * the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons to whom the
     * Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     * DEALINGS IN THE SOFTWARE.
     */
    var __extends$5 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var XmlError = /** @class */ (function (_super) {
        __extends$5(XmlError, _super);
        function XmlError(message, xml, pos) {
            var _this = _super.call(this, exports.AlphaTabErrorType.Format, message) || this;
            _this.pos = 0;
            _this.xml = xml;
            _this.pos = pos;
            Object.setPrototypeOf(_this, XmlError.prototype);
            return _this;
        }
        return XmlError;
    }(AlphaTabError));

    // This XML parser is based on the XML Parser of the Haxe Standard Library (MIT)
    var XmlState;
    (function (XmlState) {
        XmlState[XmlState["IgnoreSpaces"] = 0] = "IgnoreSpaces";
        XmlState[XmlState["Begin"] = 1] = "Begin";
        XmlState[XmlState["BeginNode"] = 2] = "BeginNode";
        XmlState[XmlState["TagName"] = 3] = "TagName";
        XmlState[XmlState["Body"] = 4] = "Body";
        XmlState[XmlState["AttribName"] = 5] = "AttribName";
        XmlState[XmlState["Equals"] = 6] = "Equals";
        XmlState[XmlState["AttvalBegin"] = 7] = "AttvalBegin";
        XmlState[XmlState["AttribVal"] = 8] = "AttribVal";
        XmlState[XmlState["Childs"] = 9] = "Childs";
        XmlState[XmlState["Close"] = 10] = "Close";
        XmlState[XmlState["WaitEnd"] = 11] = "WaitEnd";
        XmlState[XmlState["WaitEndRet"] = 12] = "WaitEndRet";
        XmlState[XmlState["Pcdata"] = 13] = "Pcdata";
        XmlState[XmlState["Header"] = 14] = "Header";
        XmlState[XmlState["Comment"] = 15] = "Comment";
        XmlState[XmlState["Doctype"] = 16] = "Doctype";
        XmlState[XmlState["Cdata"] = 17] = "Cdata";
        XmlState[XmlState["Escape"] = 18] = "Escape";
    })(XmlState || (XmlState = {}));
    var XmlParser = /** @class */ (function () {
        function XmlParser() {
        }
        XmlParser.parse = function (str, p, parent) {
            var _a;
            var c = str.charCodeAt(p);
            var state = XmlState.Begin;
            var next = XmlState.Begin;
            var start = 0;
            var buf = '';
            var escapeNext = XmlState.Begin;
            var xml = null;
            var aname = null;
            var nbrackets = 0;
            var attrValQuote = 0;
            while (p < str.length) {
                c = str.charCodeAt(p);
                switch (state) {
                    case XmlState.IgnoreSpaces:
                        switch (c) {
                            case XmlParser.CharCodeLF:
                            case XmlParser.CharCodeCR:
                            case XmlParser.CharCodeTab:
                            case XmlParser.CharCodeSpace:
                                break;
                            default:
                                state = next;
                                continue;
                        }
                        break;
                    case XmlState.Begin:
                        switch (c) {
                            case XmlParser.CharCodeLowerThan:
                                state = XmlState.IgnoreSpaces;
                                next = XmlState.BeginNode;
                                break;
                            default:
                                start = p;
                                state = XmlState.Pcdata;
                                continue;
                        }
                        break;
                    case XmlState.Pcdata:
                        if (c === XmlParser.CharCodeLowerThan) {
                            buf += str.substr(start, p - start);
                            var child = new XmlNode();
                            child.nodeType = XmlNodeType.Text;
                            child.value = buf;
                            buf = '';
                            parent.addChild(child);
                            state = XmlState.IgnoreSpaces;
                            next = XmlState.BeginNode;
                        }
                        else if (c === XmlParser.CharCodeAmp) {
                            buf += str.substr(start, p - start);
                            state = XmlState.Escape;
                            escapeNext = XmlState.Pcdata;
                            start = p + 1;
                        }
                        break;
                    case XmlState.Cdata:
                        if (c === XmlParser.CharCodeBrackedClose &&
                            str.charCodeAt(p + 1) === XmlParser.CharCodeBrackedClose &&
                            str.charCodeAt(p + 2) === XmlParser.CharCodeGreaterThan) {
                            // ]]>
                            var child = new XmlNode();
                            child.nodeType = XmlNodeType.CDATA;
                            child.value = str.substr(start, p - start);
                            parent.addChild(child);
                            p += 2;
                            state = XmlState.Begin;
                        }
                        break;
                    case XmlState.BeginNode:
                        switch (c) {
                            case XmlParser.CharCodeExclamation:
                                if (str.charCodeAt(p + 1) === XmlParser.CharCodeBrackedOpen) {
                                    p += 2;
                                    if (str.substr(p, 6).toUpperCase() !== 'CDATA[') {
                                        throw new XmlError('Expected <![CDATA[', str, p);
                                    }
                                    p += 5;
                                    state = XmlState.Cdata;
                                    start = p + 1;
                                }
                                else if (str.charCodeAt(p + 1) === XmlParser.CharCodeUpperD ||
                                    str.charCodeAt(p + 1) === XmlParser.CharCodeLowerD) {
                                    if (str.substr(p + 2, 6).toUpperCase() !== 'OCTYPE') {
                                        throw new XmlError('Expected <!DOCTYPE', str, p);
                                    }
                                    p += 8;
                                    state = XmlState.Doctype;
                                    start = p + 1;
                                }
                                else if (str.charCodeAt(p + 1) !== XmlParser.CharCodeMinus ||
                                    str.charCodeAt(p + 2) !== XmlParser.CharCodeMinus) {
                                    throw new XmlError('Expected <!--', str, p);
                                }
                                else {
                                    p += 2;
                                    state = XmlState.Comment;
                                    start = p + 1;
                                }
                                break;
                            case XmlParser.CharCodeQuestion:
                                state = XmlState.Header;
                                start = p;
                                break;
                            case XmlParser.CharCodeSlash:
                                if (!parent) {
                                    throw new XmlError('Expected node name', str, p);
                                }
                                start = p + 1;
                                state = XmlState.IgnoreSpaces;
                                next = XmlState.Close;
                                break;
                            default:
                                state = XmlState.TagName;
                                start = p;
                                continue;
                        }
                        break;
                    case XmlState.TagName:
                        if (!XmlParser.isValidChar(c)) {
                            if (p === start) {
                                throw new XmlError('Expected node name', str, p);
                            }
                            xml = new XmlNode();
                            xml.nodeType = XmlNodeType.Element;
                            xml.localName = str.substr(start, p - start);
                            parent.addChild(xml);
                            state = XmlState.IgnoreSpaces;
                            next = XmlState.Body;
                            continue;
                        }
                        break;
                    case XmlState.Body:
                        switch (c) {
                            case XmlParser.CharCodeSlash:
                                state = XmlState.WaitEnd;
                                break;
                            case XmlParser.CharCodeGreaterThan:
                                state = XmlState.Childs;
                                break;
                            default:
                                state = XmlState.AttribName;
                                start = p;
                                continue;
                        }
                        break;
                    case XmlState.AttribName:
                        if (!XmlParser.isValidChar(c)) {
                            if (start === p) {
                                throw new XmlError('Expected attribute name', str, p);
                            }
                            var tmp = str.substr(start, p - start);
                            aname = tmp;
                            if (xml.attributes.has(aname)) {
                                throw new XmlError("Duplicate attribute [" + aname + "]", str, p);
                            }
                            state = XmlState.IgnoreSpaces;
                            next = XmlState.Equals;
                            continue;
                        }
                        break;
                    case XmlState.Equals:
                        switch (c) {
                            case XmlParser.CharCodeEquals:
                                state = XmlState.IgnoreSpaces;
                                next = XmlState.AttvalBegin;
                                break;
                            default:
                                throw new XmlError('Expected =', str, p);
                        }
                        break;
                    case XmlState.AttvalBegin:
                        switch (c) {
                            case XmlParser.CharCodeDoubleQuote:
                            case XmlParser.CharCodeSingleQuote:
                                buf = '';
                                state = XmlState.AttribVal;
                                start = p + 1;
                                attrValQuote = c;
                                break;
                        }
                        break;
                    case XmlState.AttribVal:
                        switch (c) {
                            case XmlParser.CharCodeAmp:
                                buf += str.substr(start, p - start);
                                state = XmlState.Escape;
                                escapeNext = XmlState.AttribVal;
                                start = p + 1;
                                break;
                            default:
                                if (c === attrValQuote) {
                                    buf += str.substr(start, p - start);
                                    var val = buf;
                                    buf = '';
                                    xml.attributes.set(aname, val);
                                    state = XmlState.IgnoreSpaces;
                                    next = XmlState.Body;
                                }
                                break;
                        }
                        break;
                    case XmlState.Childs:
                        p = XmlParser.parse(str, p, xml);
                        start = p;
                        state = XmlState.Begin;
                        break;
                    case XmlState.WaitEnd:
                        switch (c) {
                            case XmlParser.CharCodeGreaterThan:
                                state = XmlState.Begin;
                                break;
                            default:
                                throw new XmlError('Expected >', str, p);
                        }
                        break;
                    case XmlState.WaitEndRet:
                        switch (c) {
                            case XmlParser.CharCodeGreaterThan:
                                return p;
                            default:
                                throw new XmlError('Expected >', str, p);
                        }
                    case XmlState.Close:
                        if (!XmlParser.isValidChar(c)) {
                            if (start === p) {
                                throw new XmlError('Expected node name', str, p);
                            }
                            var v = str.substr(start, p - start);
                            if (v !== parent.localName) {
                                throw new XmlError('Expected </' + parent.localName + '>', str, p);
                            }
                            state = XmlState.IgnoreSpaces;
                            next = XmlState.WaitEndRet;
                            continue;
                        }
                        break;
                    case XmlState.Comment:
                        if (c === XmlParser.CharCodeMinus &&
                            str.charCodeAt(p + 1) === XmlParser.CharCodeMinus &&
                            str.charCodeAt(p + 2) === XmlParser.CharCodeGreaterThan) {
                            p += 2;
                            state = XmlState.Begin;
                        }
                        break;
                    case XmlState.Doctype:
                        if (c === XmlParser.CharCodeBrackedOpen) {
                            nbrackets++;
                        }
                        else if (c === XmlParser.CharCodeBrackedClose) {
                            nbrackets--;
                        }
                        else if (c === XmlParser.CharCodeGreaterThan && nbrackets === 0) {
                            // >
                            var node = new XmlNode();
                            node.nodeType = XmlNodeType.DocumentType;
                            node.value = str.substr(start, p - start);
                            parent.addChild(node);
                            state = XmlState.Begin;
                        }
                        break;
                    case XmlState.Header:
                        if (c === XmlParser.CharCodeQuestion && str.charCodeAt(p + 1) === XmlParser.CharCodeGreaterThan) {
                            p++;
                            state = XmlState.Begin;
                        }
                        break;
                    case XmlState.Escape:
                        if (c === XmlParser.CharCodeSemi) {
                            var s = str.substr(start, p - start);
                            if (s.charCodeAt(0) === XmlParser.CharCodeSharp) {
                                var code = s.charCodeAt(1) === XmlParser.CharCodeLowerX
                                    ? parseInt('0' + s.substr(1, s.length - 1))
                                    : parseInt(s.substr(1, s.length - 1));
                                buf += String.fromCharCode(code);
                            }
                            else if (XmlParser.Escapes.has(s)) {
                                buf += XmlParser.Escapes.get(s);
                            }
                            else {
                                buf += (_a = ('&' + s + ';')) === null || _a === void 0 ? void 0 : _a.toString();
                            }
                            start = p + 1;
                            state = escapeNext;
                        }
                        else if (!XmlParser.isValidChar(c) && c !== XmlParser.CharCodeSharp) {
                            buf += '&';
                            buf += str.substr(start, p - start);
                            p--;
                            start = p + 1;
                            state = escapeNext;
                        }
                        break;
                }
                p++;
            }
            if (state === XmlState.Begin) {
                start = p;
                state = XmlState.Pcdata;
            }
            if (state === XmlState.Pcdata) {
                if (p !== start) {
                    buf += str.substr(start, p - start);
                    var node = new XmlNode();
                    node.nodeType = XmlNodeType.Text;
                    node.value = buf;
                    parent.addChild(node);
                }
                return p;
            }
            if (state === XmlState.Escape && escapeNext === XmlState.Pcdata) {
                buf += '&';
                buf += str.substr(start, p - start);
                var node = new XmlNode();
                node.nodeType = XmlNodeType.Text;
                node.value = buf;
                parent.addChild(node);
                return p;
            }
            throw new XmlError('Unexpected end', str, p);
        };
        XmlParser.isValidChar = function (c) {
            return ((c >= XmlParser.CharCodeLowerA && c <= XmlParser.CharCodeLowerZ) ||
                (c >= XmlParser.CharCodeUpperA && c <= XmlParser.CharCodeUpperZ) ||
                (c >= XmlParser.CharCode0 && c <= XmlParser.CharCode9) ||
                c === XmlParser.CharCodeColon ||
                c === XmlParser.CharCodeDot ||
                c === XmlParser.CharCodeUnderscore ||
                c === XmlParser.CharCodeMinus);
        };
        XmlParser.CharCodeLF = 10;
        XmlParser.CharCodeTab = 9;
        XmlParser.CharCodeCR = 13;
        XmlParser.CharCodeSpace = 32;
        XmlParser.CharCodeLowerThan = 60;
        XmlParser.CharCodeAmp = 38;
        XmlParser.CharCodeBrackedClose = 93;
        XmlParser.CharCodeBrackedOpen = 91;
        XmlParser.CharCodeGreaterThan = 62;
        XmlParser.CharCodeExclamation = 33;
        XmlParser.CharCodeUpperD = 68;
        XmlParser.CharCodeLowerD = 100;
        XmlParser.CharCodeMinus = 45;
        XmlParser.CharCodeQuestion = 63;
        XmlParser.CharCodeSlash = 47;
        XmlParser.CharCodeEquals = 61;
        XmlParser.CharCodeDoubleQuote = 34;
        XmlParser.CharCodeSingleQuote = 39;
        XmlParser.CharCodeSharp = 35;
        XmlParser.CharCodeLowerX = 120;
        XmlParser.CharCodeLowerA = 97;
        XmlParser.CharCodeLowerZ = 122;
        XmlParser.CharCodeUpperA = 65;
        XmlParser.CharCodeUpperZ = 90;
        XmlParser.CharCode0 = 48;
        XmlParser.CharCode9 = 57;
        XmlParser.CharCodeColon = 58;
        XmlParser.CharCodeDot = 46;
        XmlParser.CharCodeUnderscore = 95;
        XmlParser.CharCodeSemi = 59;
        XmlParser.Escapes = new Map([
            ['lt', '<'],
            ['gt', '>'],
            ['amp', '&'],
            ['quot', '"'],
            ['apos', "'"]
        ]);
        return XmlParser;
    }());

    // This XML parser is based on the XML Parser of the Haxe Standard Library (MIT)
    /*
     * Copyright (C)2005-2019 Haxe Foundation
     *
     * Permission is hereby granted, free of charge, to any person obtaining a
     * copy of this software and associated documentation files (the "Software"),
     * to deal in the Software without restriction, including without limitation
     * the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons to whom the
     * Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     * DEALINGS IN THE SOFTWARE.
     */
    var __extends$6 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var XmlDocument = /** @class */ (function (_super) {
        __extends$6(XmlDocument, _super);
        function XmlDocument(xml) {
            var _this = _super.call(this) || this;
            _this.documentElement = null;
            _this.nodeType = XmlNodeType.Document;
            XmlParser.parse(xml, 0, _this);
            for (var _i = 0, _a = _this.childNodes; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.nodeType === XmlNodeType.Element) {
                    _this.documentElement = child;
                    break;
                }
            }
            return _this;
        }
        return XmlDocument;
    }(XmlNode));

    var BeamDirection;
    (function (BeamDirection) {
        BeamDirection[BeamDirection["Up"] = 0] = "Up";
        BeamDirection[BeamDirection["Down"] = 1] = "Down";
    })(BeamDirection || (BeamDirection = {}));

    /**
     * This structure represents a duration within a gpif
     */
    var GpifRhythm = /** @class */ (function () {
        function GpifRhythm() {
            this.dots = 0;
            this.tupletDenominator = -1;
            this.tupletNumerator = -1;
            this.value = Duration.Quarter;
        }
        return GpifRhythm;
    }());
    /**
     * This public class can parse a score.gpif xml file into the model structure
     */
    var GpifParser = /** @class */ (function () {
        function GpifParser() {
            this._hasAnacrusis = false;
            this._skipApplyLyrics = false;
        }
        GpifParser.prototype.parseXml = function (xml, settings) {
            var _this = this;
            this._masterTrackAutomations = new Map();
            this._tracksMapping = [];
            this._tracksById = new Map();
            this._masterBars = [];
            this._barsOfMasterBar = [];
            this._voicesOfBar = new Map();
            this._barsById = new Map();
            this._voiceById = new Map();
            this._beatsOfVoice = new Map();
            this._beatById = new Map();
            this._rhythmOfBeat = new Map();
            this._rhythmById = new Map();
            this._notesOfBeat = new Map();
            this._noteById = new Map();
            this._tappedNotes = new Map();
            this._lyricsByTrack = new Map();
            this._skipApplyLyrics = false;
            var dom;
            try {
                dom = new XmlDocument(xml);
            }
            catch (e) {
                throw new UnsupportedFormatError('Could not parse XML', e);
            }
            this.parseDom(dom);
            this.buildModel();
            this.score.finish(settings);
            if (!this._skipApplyLyrics && this._lyricsByTrack.size > 0) {
                this._lyricsByTrack.forEach(function (lyrics, t) {
                    var track = _this._tracksById.get(t);
                    track.applyLyrics(lyrics);
                });
            }
        };
        GpifParser.prototype.parseDom = function (dom) {
            var root = dom.documentElement;
            if (!root) {
                return;
            }
            // the XML uses IDs for referring elements within the
            //  Therefore we do the parsing in 2 steps:
            // - at first we read all model elements and store them by ID in a lookup table
            // - after that we need to join up the information.
            if (root.localName === 'GPIF') {
                this.score = new Score();
                // parse all children
                for (var _i = 0, _a = root.childNodes; _i < _a.length; _i++) {
                    var n = _a[_i];
                    if (n.nodeType === XmlNodeType.Element) {
                        switch (n.localName) {
                            case 'Score':
                                this.parseScoreNode(n);
                                break;
                            case 'MasterTrack':
                                this.parseMasterTrackNode(n);
                                break;
                            case 'Tracks':
                                this.parseTracksNode(n);
                                break;
                            case 'MasterBars':
                                this.parseMasterBarsNode(n);
                                break;
                            case 'Bars':
                                this.parseBars(n);
                                break;
                            case 'Voices':
                                this.parseVoices(n);
                                break;
                            case 'Beats':
                                this.parseBeats(n);
                                break;
                            case 'Notes':
                                this.parseNotes(n);
                                break;
                            case 'Rhythms':
                                this.parseRhythms(n);
                                break;
                        }
                    }
                }
            }
            else {
                throw new UnsupportedFormatError('Root node of XML was not GPIF');
            }
        };
        //
        // <Score>...</Score>
        //
        GpifParser.prototype.parseScoreNode = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Title':
                            this.score.title = c.firstChild.innerText;
                            break;
                        case 'SubTitle':
                            this.score.subTitle = c.firstChild.innerText;
                            break;
                        case 'Artist':
                            this.score.artist = c.firstChild.innerText;
                            break;
                        case 'Album':
                            this.score.album = c.firstChild.innerText;
                            break;
                        case 'Words':
                            this.score.words = c.firstChild.innerText;
                            break;
                        case 'Music':
                            this.score.music = c.firstChild.innerText;
                            break;
                        case 'WordsAndMusic':
                            if (c.firstChild && c.firstChild.innerText !== '') {
                                var wordsAndMusic = c.firstChild.innerText;
                                if (wordsAndMusic && !this.score.words) {
                                    this.score.words = wordsAndMusic;
                                }
                                if (wordsAndMusic && !this.score.music) {
                                    this.score.music = wordsAndMusic;
                                }
                            }
                            break;
                        case 'Copyright':
                            this.score.copyright = c.firstChild.innerText;
                            break;
                        case 'Tabber':
                            this.score.tab = c.firstChild.innerText;
                            break;
                        case 'Instructions':
                            this.score.instructions = c.firstChild.innerText;
                            break;
                        case 'Notices':
                            this.score.notices = c.firstChild.innerText;
                            break;
                    }
                }
            }
        };
        //
        // <MasterTrack>...</MasterTrack>
        //
        GpifParser.prototype.parseMasterTrackNode = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Automations':
                            this.parseAutomations(c, this._masterTrackAutomations);
                            break;
                        case 'Tracks':
                            this._tracksMapping = c.innerText.split(' ');
                            break;
                        case 'Anacrusis':
                            this._hasAnacrusis = true;
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseAutomations = function (node, automations) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Automation':
                            this.parseAutomation(c, automations);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseAutomation = function (node, automations) {
            var type = null;
            var isLinear = false;
            var barId = null;
            var ratioPosition = 0;
            var value = 0;
            var reference = 0;
            var text = null;
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Type':
                            type = c.innerText;
                            break;
                        case 'Linear':
                            isLinear = c.innerText.toLowerCase() === 'true';
                            break;
                        case 'Bar':
                            barId = c.innerText;
                            break;
                        case 'Position':
                            ratioPosition = parseFloat(c.innerText);
                            break;
                        case 'Value':
                            var parts = c.innerText.split(' ');
                            // Issue 391: Some GPX files might have 
                            // single floating point value. 
                            if (parts.length === 1) {
                                value = parseFloat(parts[0]);
                                reference = 1;
                            }
                            else {
                                value = parseFloat(parts[0]);
                                reference = parseInt(parts[1]);
                            }
                            break;
                        case 'Text':
                            text = c.innerText;
                            break;
                    }
                }
            }
            if (!type) {
                return;
            }
            var automation = null;
            switch (type) {
                case 'Tempo':
                    automation = Automation.buildTempoAutomation(isLinear, ratioPosition, value, reference);
                    break;
            }
            if (automation) {
                if (text) {
                    automation.text = text;
                }
                if (barId) {
                    if (!automations.has(barId)) {
                        automations.set(barId, []);
                    }
                    automations.get(barId).push(automation);
                }
            }
        };
        //
        // <Tracks>...</Tracks>
        //
        GpifParser.prototype.parseTracksNode = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Track':
                            this.parseTrack(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseTrack = function (node) {
            this._articulationByName = new Map();
            var track = new Track();
            track.ensureStaveCount(1);
            var staff = track.staves[0];
            staff.showStandardNotation = true;
            var trackId = node.getAttribute('id');
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Name':
                            track.name = c.innerText;
                            break;
                        case 'Color':
                            var parts = c.innerText.split(' ');
                            if (parts.length >= 3) {
                                var r = parseInt(parts[0]);
                                var g = parseInt(parts[1]);
                                var b = parseInt(parts[2]);
                                track.color = new Color(r, g, b, 0xff);
                            }
                            break;
                        case 'Instrument':
                            var instrumentName = c.getAttribute('ref');
                            if (instrumentName.endsWith('-gs') || instrumentName.endsWith('GrandStaff')) {
                                track.ensureStaveCount(2);
                                track.staves[1].showStandardNotation = true;
                            }
                            break;
                        case 'InstrumentSet':
                            this.parseInstrumentSet(track, c);
                            break;
                        case 'NotationPatch':
                            this.parseNotationPatch(track, c);
                            break;
                        case 'ShortName':
                            track.shortName = c.innerText;
                            break;
                        case 'Lyrics':
                            this.parseLyrics(trackId, c);
                            break;
                        case 'Properties':
                            this.parseTrackProperties(track, c);
                            break;
                        case 'GeneralMidi':
                        case 'MidiConnection':
                        case 'MIDISettings':
                            this.parseGeneralMidi(track, c);
                            break;
                        case 'Sounds':
                            this.parseSounds(track, c);
                            break;
                        case 'PlaybackState':
                            var state = c.innerText;
                            track.playbackInfo.isSolo = state === 'Solo';
                            track.playbackInfo.isMute = state === 'Mute';
                            break;
                        case 'PartSounding':
                            this.parsePartSounding(track, c);
                            break;
                        case 'Staves':
                            this.parseStaves(track, c);
                            break;
                        case 'Transpose':
                            this.parseTranspose(track, c);
                            break;
                    }
                }
            }
            this._tracksById.set(trackId, track);
        };
        GpifParser.prototype.parseNotationPatch = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'LineCount':
                            var lineCount = parseInt(c.innerText);
                            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                                var staff = _c[_b];
                                staff.standardNotationLineCount = lineCount;
                            }
                            break;
                        case 'Elements':
                            this.parseElements(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseInstrumentSet = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Type':
                            switch (c.innerText) {
                                case 'drumKit':
                                    for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                                        var staff = _c[_b];
                                        staff.isPercussion = true;
                                    }
                                    break;
                            }
                            if (c.innerText === 'drumKit') {
                                for (var _d = 0, _e = track.staves; _d < _e.length; _d++) {
                                    var staff = _e[_d];
                                    staff.isPercussion = true;
                                }
                            }
                            break;
                        case 'Elements':
                            this.parseElements(track, c);
                            break;
                        case 'LineCount':
                            var lineCount = parseInt(c.innerText);
                            for (var _f = 0, _g = track.staves; _f < _g.length; _f++) {
                                var staff = _g[_f];
                                staff.standardNotationLineCount = lineCount;
                            }
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseElements = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Element':
                            this.parseElement(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseElement = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Articulations':
                            this.parseArticulations(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseArticulations = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Articulation':
                            this.parseArticulation(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseArticulation = function (track, node) {
            var articulation = new InstrumentArticulation();
            articulation.outputMidiNumber = -1;
            var name = "";
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    var txt = c.innerText;
                    switch (c.localName) {
                        case 'Name':
                            name = c.innerText;
                            break;
                        case 'OutputMidiNumber':
                            if (txt.length > 0) {
                                articulation.outputMidiNumber = parseInt(txt);
                            }
                            break;
                        case 'TechniqueSymbol':
                            articulation.techniqueSymbol = this.parseTechniqueSymbol(txt);
                            break;
                        case 'TechniquePlacement':
                            switch (txt) {
                                case 'outside':
                                    articulation.techniqueSymbolPlacement = TextBaseline.Bottom;
                                    break;
                                case 'inside':
                                    articulation.techniqueSymbolPlacement = TextBaseline.Middle;
                                    break;
                                case 'above':
                                    articulation.techniqueSymbolPlacement = TextBaseline.Bottom;
                                    break;
                                case 'below':
                                    articulation.techniqueSymbolPlacement = TextBaseline.Top;
                                    break;
                            }
                            break;
                        case 'Noteheads':
                            var noteHeadsTxt = txt.split(' ');
                            if (noteHeadsTxt.length >= 1) {
                                articulation.noteHeadDefault = this.parseNoteHead(noteHeadsTxt[0]);
                            }
                            if (noteHeadsTxt.length >= 2) {
                                articulation.noteHeadHalf = this.parseNoteHead(noteHeadsTxt[1]);
                            }
                            if (noteHeadsTxt.length >= 3) {
                                articulation.noteHeadWhole = this.parseNoteHead(noteHeadsTxt[2]);
                            }
                            if (articulation.noteHeadHalf == MusicFontSymbol.None) {
                                articulation.noteHeadHalf = articulation.noteHeadDefault;
                            }
                            if (articulation.noteHeadWhole == MusicFontSymbol.None) {
                                articulation.noteHeadWhole = articulation.noteHeadDefault;
                            }
                            switch (noteHeadsTxt.length) {
                                                        }
                            break;
                        case 'StaffLine':
                            if (txt.length > 0) {
                                articulation.staffLine = parseInt(txt);
                            }
                            break;
                    }
                }
            }
            if (articulation.outputMidiNumber !== -1) {
                track.percussionArticulations.push(articulation);
                if (name.length > 0) {
                    this._articulationByName.set(name, articulation);
                }
            }
            else if (name.length > 0 && this._articulationByName.has(name)) {
                this._articulationByName.get(name).staffLine = articulation.staffLine;
            }
        };
        GpifParser.prototype.parseTechniqueSymbol = function (txt) {
            switch (txt) {
                case 'pictEdgeOfCymbal': return MusicFontSymbol.PictEdgeOfCymbal;
                case 'articStaccatoAbove': return MusicFontSymbol.ArticStaccatoAbove;
                case 'noteheadParenthesis': return MusicFontSymbol.NoteheadParenthesis;
                case 'stringsUpBow': return MusicFontSymbol.StringsUpBow;
                case 'stringsDownBow': return MusicFontSymbol.StringsDownBow;
                case 'guitarGolpe': return MusicFontSymbol.GuitarGolpe;
                default: return MusicFontSymbol.None;
            }
        };
        GpifParser.prototype.parseNoteHead = function (txt) {
            switch (txt) {
                case 'noteheadDoubleWholeSquare': return MusicFontSymbol.NoteheadDoubleWholeSquare;
                case 'noteheadDoubleWhole': return MusicFontSymbol.NoteheadDoubleWhole;
                case 'noteheadWhole': return MusicFontSymbol.NoteheadWhole;
                case 'noteheadHalf': return MusicFontSymbol.NoteheadHalf;
                case 'noteheadBlack': return MusicFontSymbol.NoteheadBlack;
                case 'noteheadNull': return MusicFontSymbol.NoteheadNull;
                case 'noteheadXOrnate': return MusicFontSymbol.NoteheadXOrnate;
                case 'noteheadTriangleUpWhole': return MusicFontSymbol.NoteheadTriangleUpWhole;
                case 'noteheadTriangleUpHalf': return MusicFontSymbol.NoteheadTriangleUpHalf;
                case 'noteheadTriangleUpBlack': return MusicFontSymbol.NoteheadTriangleUpBlack;
                case 'noteheadDiamondBlackWide': return MusicFontSymbol.NoteheadDiamondBlackWide;
                case 'noteheadDiamondWhite': return MusicFontSymbol.NoteheadDiamondWhite;
                case 'noteheadDiamondWhiteWide': return MusicFontSymbol.NoteheadDiamondWhiteWide;
                case 'noteheadCircleX': return MusicFontSymbol.NoteheadCircleX;
                case 'noteheadXWhole': return MusicFontSymbol.NoteheadXWhole;
                case 'noteheadXHalf': return MusicFontSymbol.NoteheadXHalf;
                case 'noteheadXBlack': return MusicFontSymbol.NoteheadXBlack;
                case 'noteheadParenthesis': return MusicFontSymbol.NoteheadParenthesis;
                case 'noteheadSlashedBlack2': return MusicFontSymbol.NoteheadSlashedBlack2;
                case 'noteheadCircleSlash': return MusicFontSymbol.NoteheadCircleSlash;
                case 'noteheadHeavyX': return MusicFontSymbol.NoteheadHeavyX;
                case 'noteheadHeavyXHat': return MusicFontSymbol.NoteheadHeavyXHat;
                default: return MusicFontSymbol.None;
            }
        };
        GpifParser.prototype.parseStaves = function (track, node) {
            var staffIndex = 0;
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Staff':
                            track.ensureStaveCount(staffIndex + 1);
                            var staff = track.staves[staffIndex];
                            this.parseStaff(staff, c);
                            staffIndex++;
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseStaff = function (staff, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Properties':
                            this.parseStaffProperties(staff, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseStaffProperties = function (staff, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Property':
                            this.parseStaffProperty(staff, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseStaffProperty = function (staff, node) {
            var propertyName = node.getAttribute('name');
            switch (propertyName) {
                case 'Tuning':
                    var tuningParts = node.findChildElement('Pitches').innerText.split(' ');
                    var tuning = new Array(tuningParts.length);
                    for (var i = 0; i < tuning.length; i++) {
                        tuning[tuning.length - 1 - i] = parseInt(tuningParts[i]);
                    }
                    staff.tuning = tuning;
                    if (!staff.isPercussion) {
                        staff.showTablature = true;
                    }
                    break;
                case 'DiagramCollection':
                case 'ChordCollection':
                    this.parseDiagramCollection_Staff_XmlNode(staff, node);
                    break;
                case 'CapoFret':
                    var capo = parseInt(node.findChildElement('Fret').innerText);
                    staff.capo = capo;
                    break;
            }
        };
        GpifParser.prototype.parseLyrics = function (trackId, node) {
            var tracks = [];
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Line':
                            tracks.push(this.parseLyricsLine(c));
                            break;
                    }
                }
            }
            this._lyricsByTrack.set(trackId, tracks);
        };
        GpifParser.prototype.parseLyricsLine = function (node) {
            var lyrics = new Lyrics();
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Offset':
                            lyrics.startBar = parseInt(c.innerText);
                            break;
                        case 'Text':
                            lyrics.text = c.innerText;
                            break;
                    }
                }
            }
            return lyrics;
        };
        GpifParser.prototype.parseDiagramCollection_Track_XmlNode = function (track, node) {
            var items = node.findChildElement('Items');
            for (var _i = 0, _a = items.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Item':
                            this.parseDiagramItem_Track_XmlNode(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseDiagramCollection_Staff_XmlNode = function (staff, node) {
            var items = node.findChildElement('Items');
            for (var _i = 0, _a = items.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Item':
                            this.parseDiagramItem_Staff_XmlNode(staff, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseDiagramItem_Track_XmlNode = function (track, node) {
            var chord = new Chord();
            var chordId = node.getAttribute('id');
            for (var _i = 0, _a = track.staves; _i < _a.length; _i++) {
                var staff = _a[_i];
                staff.addChord(chordId, chord);
            }
            this.parseDiagramItem_Chord_XmlNode(chord, node);
        };
        GpifParser.prototype.parseDiagramItem_Staff_XmlNode = function (staff, node) {
            var chord = new Chord();
            var chordId = node.getAttribute('id');
            staff.addChord(chordId, chord);
            this.parseDiagramItem_Chord_XmlNode(chord, node);
        };
        GpifParser.prototype.parseDiagramItem_Chord_XmlNode = function (chord, node) {
            chord.name = node.getAttribute('name');
            var diagram = node.findChildElement('Diagram');
            var stringCount = parseInt(diagram.getAttribute('stringCount'));
            var baseFret = parseInt(diagram.getAttribute('baseFret'));
            chord.firstFret = baseFret + 1;
            for (var i = 0; i < stringCount; i++) {
                chord.strings.push(-1);
            }
            for (var _i = 0, _a = diagram.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Fret':
                            var guitarString = parseInt(c.getAttribute('string'));
                            chord.strings[stringCount - guitarString - 1] = baseFret + parseInt(c.getAttribute('fret'));
                            break;
                        case 'Fingering':
                            var existingFingers = new Map();
                            for (var _b = 0, _c = c.childNodes; _b < _c.length; _b++) {
                                var p = _c[_b];
                                if (p.nodeType === XmlNodeType.Element) {
                                    switch (p.localName) {
                                        case 'Position':
                                            var finger = Fingers.Unknown;
                                            var fret = baseFret + parseInt(p.getAttribute('fret'));
                                            switch (p.getAttribute('finger')) {
                                                case 'Index':
                                                    finger = Fingers.IndexFinger;
                                                    break;
                                                case 'Middle':
                                                    finger = Fingers.MiddleFinger;
                                                    break;
                                                case 'Rank':
                                                    finger = Fingers.AnnularFinger;
                                                    break;
                                                case 'Pinky':
                                                    finger = Fingers.LittleFinger;
                                                    break;
                                                case 'Thumb':
                                                    finger = Fingers.Thumb;
                                                    break;
                                            }
                                            if (finger !== Fingers.Unknown) {
                                                if (existingFingers.has(finger)) {
                                                    chord.barreFrets.push(fret);
                                                }
                                                else {
                                                    existingFingers.set(finger, true);
                                                }
                                            }
                                            break;
                                    }
                                }
                            }
                            break;
                        case 'Property':
                            switch (c.getAttribute('name')) {
                                case 'ShowName':
                                    chord.showName = c.getAttribute('value') === 'true';
                                    break;
                                case 'ShowDiagram':
                                    chord.showDiagram = c.getAttribute('value') === 'true';
                                    break;
                                case 'ShowFingering':
                                    chord.showFingering = c.getAttribute('value') === 'true';
                                    break;
                            }
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseTrackProperties = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Property':
                            this.parseTrackProperty(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseTrackProperty = function (track, node) {
            var propertyName = node.getAttribute('name');
            switch (propertyName) {
                case 'Tuning':
                    var tuningParts = node.findChildElement('Pitches').innerText.split(' ');
                    var tuning = new Array(tuningParts.length);
                    for (var i = 0; i < tuning.length; i++) {
                        tuning[tuning.length - 1 - i] = parseInt(tuningParts[i]);
                    }
                    for (var _i = 0, _a = track.staves; _i < _a.length; _i++) {
                        var staff = _a[_i];
                        staff.tuning = tuning;
                        staff.showStandardNotation = true;
                        staff.showTablature = true;
                    }
                    break;
                case 'DiagramCollection':
                case 'ChordCollection':
                    this.parseDiagramCollection_Track_XmlNode(track, node);
                    break;
                case 'CapoFret':
                    var capo = parseInt(node.findChildElement('Fret').innerText);
                    for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                        var staff = _c[_b];
                        staff.capo = capo;
                    }
                    break;
            }
        };
        GpifParser.prototype.parseGeneralMidi = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Program':
                            track.playbackInfo.program = parseInt(c.innerText);
                            break;
                        case 'Port':
                            track.playbackInfo.port = parseInt(c.innerText);
                            break;
                        case 'PrimaryChannel':
                            track.playbackInfo.primaryChannel = parseInt(c.innerText);
                            break;
                        case 'SecondaryChannel':
                            track.playbackInfo.secondaryChannel = parseInt(c.innerText);
                            break;
                    }
                }
            }
            var isPercussion = node.getAttribute('table') === 'Percussion';
            if (isPercussion) {
                for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                    var staff = _c[_b];
                    staff.isPercussion = true;
                }
            }
        };
        GpifParser.prototype.parseSounds = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Sound':
                            this.parseSound(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseSound = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'MIDI':
                            this.parseSoundMidi(track, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseSoundMidi = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Program':
                            track.playbackInfo.program = parseInt(c.innerText);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parsePartSounding = function (track, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'TranspositionPitch':
                            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                                var staff = _c[_b];
                                staff.displayTranspositionPitch = parseInt(c.innerText);
                            }
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseTranspose = function (track, node) {
            var octave = 0;
            var chromatic = 0;
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Chromatic':
                            chromatic = parseInt(c.innerText);
                            break;
                        case 'Octave':
                            octave = parseInt(c.innerText);
                            break;
                    }
                }
            }
            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                var staff = _c[_b];
                staff.displayTranspositionPitch = octave * 12 + chromatic;
            }
        };
        //
        // <MasterBars>...</MasterBars>
        //
        GpifParser.prototype.parseMasterBarsNode = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'MasterBar':
                            this.parseMasterBar(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseMasterBar = function (node) {
            var masterBar = new MasterBar();
            if (this._masterBars.length === 0 && this._hasAnacrusis) {
                masterBar.isAnacrusis = true;
            }
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Time':
                            var timeParts = c.innerText.split('/');
                            masterBar.timeSignatureNumerator = parseInt(timeParts[0]);
                            masterBar.timeSignatureDenominator = parseInt(timeParts[1]);
                            break;
                        case 'DoubleBar':
                            masterBar.isDoubleBar = true;
                            break;
                        case 'Section':
                            masterBar.section = new Section();
                            masterBar.section.marker = c.findChildElement('Letter').innerText;
                            masterBar.section.text = c.findChildElement('Text').innerText;
                            break;
                        case 'Repeat':
                            if (c.getAttribute('start').toLowerCase() === 'true') {
                                masterBar.isRepeatStart = true;
                            }
                            if (c.getAttribute('end').toLowerCase() === 'true' && c.getAttribute('count')) {
                                masterBar.repeatCount = parseInt(c.getAttribute('count'));
                            }
                            break;
                        case 'AlternateEndings':
                            var alternateEndings = c.innerText.split(' ');
                            var i = 0;
                            for (var k = 0; k < alternateEndings.length; k++) {
                                i = i | (1 << (-1 + parseInt(alternateEndings[k])));
                            }
                            masterBar.alternateEndings = i;
                            break;
                        case 'Bars':
                            this._barsOfMasterBar.push(c.innerText.split(' '));
                            break;
                        case 'TripletFeel':
                            switch (c.innerText) {
                                case 'NoTripletFeel':
                                    masterBar.tripletFeel = TripletFeel.NoTripletFeel;
                                    break;
                                case 'Triplet8th':
                                    masterBar.tripletFeel = TripletFeel.Triplet8th;
                                    break;
                                case 'Triplet16th':
                                    masterBar.tripletFeel = TripletFeel.Triplet16th;
                                    break;
                                case 'Dotted8th':
                                    masterBar.tripletFeel = TripletFeel.Dotted8th;
                                    break;
                                case 'Dotted16th':
                                    masterBar.tripletFeel = TripletFeel.Dotted16th;
                                    break;
                                case 'Scottish8th':
                                    masterBar.tripletFeel = TripletFeel.Scottish8th;
                                    break;
                                case 'Scottish16th':
                                    masterBar.tripletFeel = TripletFeel.Scottish16th;
                                    break;
                            }
                            break;
                        case 'Key':
                            masterBar.keySignature = parseInt(c.findChildElement('AccidentalCount').innerText);
                            var mode = c.findChildElement('Mode');
                            if (mode) {
                                switch (mode.innerText.toLowerCase()) {
                                    case 'major':
                                        masterBar.keySignatureType = KeySignatureType.Major;
                                        break;
                                    case 'minor':
                                        masterBar.keySignatureType = KeySignatureType.Minor;
                                        break;
                                }
                            }
                            break;
                        case 'Fermatas':
                            this.parseFermatas(masterBar, c);
                            break;
                    }
                }
            }
            this._masterBars.push(masterBar);
        };
        GpifParser.prototype.parseFermatas = function (masterBar, node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Fermata':
                            this.parseFermata(masterBar, c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseFermata = function (masterBar, node) {
            var offset = 0;
            var fermata = new Fermata();
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Type':
                            switch (c.innerText) {
                                case 'Short':
                                    fermata.type = FermataType.Short;
                                    break;
                                case 'Medium':
                                    fermata.type = FermataType.Medium;
                                    break;
                                case 'Long':
                                    fermata.type = FermataType.Long;
                                    break;
                            }
                            break;
                        case 'Length':
                            fermata.length = parseFloat(c.innerText);
                            break;
                        case 'Offset':
                            var parts = c.innerText.split('/');
                            if (parts.length === 2) {
                                var numerator = parseInt(parts[0]);
                                var denominator = parseInt(parts[1]);
                                offset = ((numerator / denominator) * MidiUtils.QuarterTime) | 0;
                            }
                            break;
                    }
                }
            }
            masterBar.addFermata(offset, fermata);
        };
        //
        // <Bars>...</Bars>
        //
        GpifParser.prototype.parseBars = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Bar':
                            this.parseBar(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseBar = function (node) {
            var bar = new Bar();
            var barId = node.getAttribute('id');
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Voices':
                            this._voicesOfBar.set(barId, c.innerText.split(' '));
                            break;
                        case 'Clef':
                            switch (c.innerText) {
                                case 'Neutral':
                                    bar.clef = Clef.Neutral;
                                    break;
                                case 'G2':
                                    bar.clef = Clef.G2;
                                    break;
                                case 'F4':
                                    bar.clef = Clef.F4;
                                    break;
                                case 'C4':
                                    bar.clef = Clef.C4;
                                    break;
                                case 'C3':
                                    bar.clef = Clef.C3;
                                    break;
                            }
                            break;
                        case 'Ottavia':
                            switch (c.innerText) {
                                case '8va':
                                    bar.clefOttava = Ottavia._8va;
                                    break;
                                case '15ma':
                                    bar.clefOttava = Ottavia._15ma;
                                    break;
                                case '8vb':
                                    bar.clefOttava = Ottavia._8vb;
                                    break;
                                case '15mb':
                                    bar.clefOttava = Ottavia._15mb;
                                    break;
                            }
                            break;
                        case 'SimileMark':
                            switch (c.innerText) {
                                case 'Simple':
                                    bar.simileMark = SimileMark.Simple;
                                    break;
                                case 'FirstOfDouble':
                                    bar.simileMark = SimileMark.FirstOfDouble;
                                    break;
                                case 'SecondOfDouble':
                                    bar.simileMark = SimileMark.SecondOfDouble;
                                    break;
                            }
                            break;
                    }
                }
            }
            this._barsById.set(barId, bar);
        };
        //
        // <Voices>...</Voices>
        //
        GpifParser.prototype.parseVoices = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Voice':
                            this.parseVoice(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseVoice = function (node) {
            var voice = new Voice();
            var voiceId = node.getAttribute('id');
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Beats':
                            this._beatsOfVoice.set(voiceId, c.innerText.split(' '));
                            break;
                    }
                }
            }
            this._voiceById.set(voiceId, voice);
        };
        //
        // <Beats>...</Beats>
        //
        GpifParser.prototype.parseBeats = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Beat':
                            this.parseBeat(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseBeat = function (node) {
            var beat = new Beat();
            var beatId = node.getAttribute('id');
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Notes':
                            this._notesOfBeat.set(beatId, c.innerText.split(' '));
                            break;
                        case 'Rhythm':
                            this._rhythmOfBeat.set(beatId, c.getAttribute('ref'));
                            break;
                        case 'Fadding':
                            if (c.innerText === 'FadeIn') {
                                beat.fadeIn = true;
                            }
                            break;
                        case 'Tremolo':
                            switch (c.innerText) {
                                case '1/2':
                                    beat.tremoloSpeed = Duration.Eighth;
                                    break;
                                case '1/4':
                                    beat.tremoloSpeed = Duration.Sixteenth;
                                    break;
                                case '1/8':
                                    beat.tremoloSpeed = Duration.ThirtySecond;
                                    break;
                            }
                            break;
                        case 'Chord':
                            beat.chordId = c.innerText;
                            break;
                        case 'Hairpin':
                            switch (c.innerText) {
                                case 'Crescendo':
                                    beat.crescendo = CrescendoType.Crescendo;
                                    break;
                                case 'Decrescendo':
                                    beat.crescendo = CrescendoType.Decrescendo;
                                    break;
                            }
                            break;
                        case 'Arpeggio':
                            if (c.innerText === 'Up') {
                                beat.brushType = BrushType.ArpeggioUp;
                            }
                            else {
                                beat.brushType = BrushType.ArpeggioDown;
                            }
                            break;
                        case 'Properties':
                            this.parseBeatProperties(c, beat);
                            break;
                        case 'XProperties':
                            this.parseBeatXProperties(c, beat);
                            break;
                        case 'FreeText':
                            beat.text = c.innerText;
                            break;
                        case 'TransposedPitchStemOrientation':
                            switch (c.innerText) {
                                case 'Upward':
                                    beat.preferredBeamDirection = BeamDirection.Up;
                                    break;
                                case 'Downward':
                                    beat.preferredBeamDirection = BeamDirection.Down;
                                    break;
                            }
                            break;
                        case 'Dynamic':
                            switch (c.innerText) {
                                case 'PPP':
                                    beat.dynamics = DynamicValue.PPP;
                                    break;
                                case 'PP':
                                    beat.dynamics = DynamicValue.PP;
                                    break;
                                case 'P':
                                    beat.dynamics = DynamicValue.P;
                                    break;
                                case 'MP':
                                    beat.dynamics = DynamicValue.MP;
                                    break;
                                case 'MF':
                                    beat.dynamics = DynamicValue.MF;
                                    break;
                                case 'F':
                                    beat.dynamics = DynamicValue.F;
                                    break;
                                case 'FF':
                                    beat.dynamics = DynamicValue.FF;
                                    break;
                                case 'FFF':
                                    beat.dynamics = DynamicValue.FFF;
                                    break;
                            }
                            break;
                        case 'GraceNotes':
                            switch (c.innerText) {
                                case 'OnBeat':
                                    beat.graceType = GraceType.OnBeat;
                                    break;
                                case 'BeforeBeat':
                                    beat.graceType = GraceType.BeforeBeat;
                                    break;
                            }
                            break;
                        case 'Legato':
                            if (c.getAttribute('origin') === 'true') {
                                beat.isLegatoOrigin = true;
                            }
                            break;
                        case 'Whammy':
                            var whammyOrigin = new BendPoint(0, 0);
                            whammyOrigin.value = this.toBendValue(parseFloat(c.getAttribute('originValue')));
                            whammyOrigin.offset = this.toBendOffset(parseFloat(c.getAttribute('originOffset')));
                            beat.addWhammyBarPoint(whammyOrigin);
                            var whammyMiddle1 = new BendPoint(0, 0);
                            whammyMiddle1.value = this.toBendValue(parseFloat(c.getAttribute('middleValue')));
                            whammyMiddle1.offset = this.toBendOffset(parseFloat(c.getAttribute('middleOffset1')));
                            beat.addWhammyBarPoint(whammyMiddle1);
                            var whammyMiddle2 = new BendPoint(0, 0);
                            whammyMiddle2.value = this.toBendValue(parseFloat(c.getAttribute('middleValue')));
                            whammyMiddle2.offset = this.toBendOffset(parseFloat(c.getAttribute('middleOffset2')));
                            beat.addWhammyBarPoint(whammyMiddle2);
                            var whammyDestination = new BendPoint(0, 0);
                            whammyDestination.value = this.toBendValue(parseFloat(c.getAttribute('destinationValue')));
                            whammyDestination.offset = this.toBendOffset(parseFloat(c.getAttribute('destinationOffset')));
                            beat.addWhammyBarPoint(whammyDestination);
                            break;
                        case 'Ottavia':
                            switch (c.innerText) {
                                case '8va':
                                    beat.ottava = Ottavia._8va;
                                    break;
                                case '8vb':
                                    beat.ottava = Ottavia._8vb;
                                    break;
                                case '15ma':
                                    beat.ottava = Ottavia._15ma;
                                    break;
                                case '15mb':
                                    beat.ottava = Ottavia._15mb;
                                    break;
                            }
                            break;
                        case 'Lyrics':
                            beat.lyrics = this.parseBeatLyrics(c);
                            this._skipApplyLyrics = true;
                            break;
                    }
                }
            }
            this._beatById.set(beatId, beat);
        };
        GpifParser.prototype.parseBeatLyrics = function (node) {
            var lines = [];
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Line':
                            lines.push(c.innerText);
                            break;
                    }
                }
            }
            return lines;
        };
        GpifParser.prototype.parseBeatXProperties = function (node, beat) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'XProperty':
                            var id = c.getAttribute('id');
                            var val = 0;
                            switch (id) {
                                case '1124204545':
                                    val = parseInt(c.findChildElement('Int').innerText);
                                    beat.invertBeamDirection = val === 1;
                                    break;
                                case '687935489':
                                    val = parseInt(c.findChildElement('Int').innerText);
                                    beat.brushDuration = val;
                                    break;
                            }
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseBeatProperties = function (node, beat) {
            var isWhammy = false;
            var whammyOrigin = null;
            var whammyMiddleValue = null;
            var whammyMiddleOffset1 = null;
            var whammyMiddleOffset2 = null;
            var whammyDestination = null;
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Property':
                            var name_1 = c.getAttribute('name');
                            switch (name_1) {
                                case 'Brush':
                                    if (c.findChildElement('Direction').innerText === 'Up') {
                                        beat.brushType = BrushType.BrushUp;
                                    }
                                    else {
                                        beat.brushType = BrushType.BrushDown;
                                    }
                                    break;
                                case 'PickStroke':
                                    if (c.findChildElement('Direction').innerText === 'Up') {
                                        beat.pickStroke = PickStroke.Up;
                                    }
                                    else {
                                        beat.pickStroke = PickStroke.Down;
                                    }
                                    break;
                                case 'Slapped':
                                    if (c.findChildElement('Enable')) {
                                        beat.slap = true;
                                    }
                                    break;
                                case 'Popped':
                                    if (c.findChildElement('Enable')) {
                                        beat.pop = true;
                                    }
                                    break;
                                case 'VibratoWTremBar':
                                    switch (c.findChildElement('Strength').innerText) {
                                        case 'Wide':
                                            beat.vibrato = VibratoType.Wide;
                                            break;
                                        case 'Slight':
                                            beat.vibrato = VibratoType.Slight;
                                            break;
                                    }
                                    break;
                                case 'WhammyBar':
                                    isWhammy = true;
                                    break;
                                case 'WhammyBarExtend':
                                    // not clear what this is used for
                                    break;
                                case 'WhammyBarOriginValue':
                                    if (!whammyOrigin) {
                                        whammyOrigin = new BendPoint(0, 0);
                                    }
                                    whammyOrigin.value = this.toBendValue(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'WhammyBarOriginOffset':
                                    if (!whammyOrigin) {
                                        whammyOrigin = new BendPoint(0, 0);
                                    }
                                    whammyOrigin.offset = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'WhammyBarMiddleValue':
                                    whammyMiddleValue = this.toBendValue(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'WhammyBarMiddleOffset1':
                                    whammyMiddleOffset1 = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'WhammyBarMiddleOffset2':
                                    whammyMiddleOffset2 = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'WhammyBarDestinationValue':
                                    if (!whammyDestination) {
                                        whammyDestination = new BendPoint(BendPoint.MaxPosition, 0);
                                    }
                                    whammyDestination.value = this.toBendValue(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'WhammyBarDestinationOffset':
                                    if (!whammyDestination) {
                                        whammyDestination = new BendPoint(0, 0);
                                    }
                                    whammyDestination.offset = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                            }
                            break;
                    }
                }
            }
            if (isWhammy) {
                if (!whammyOrigin) {
                    whammyOrigin = new BendPoint(0, 0);
                }
                if (!whammyDestination) {
                    whammyDestination = new BendPoint(BendPoint.MaxPosition, 0);
                }
                beat.addWhammyBarPoint(whammyOrigin);
                if (whammyMiddleOffset1 && whammyMiddleValue) {
                    beat.addWhammyBarPoint(new BendPoint(whammyMiddleOffset1, whammyMiddleValue));
                }
                if (whammyMiddleOffset2 && whammyMiddleValue) {
                    beat.addWhammyBarPoint(new BendPoint(whammyMiddleOffset2, whammyMiddleValue));
                }
                if (!whammyMiddleOffset1 && !whammyMiddleOffset2 && whammyMiddleValue) {
                    beat.addWhammyBarPoint(new BendPoint((BendPoint.MaxPosition / 2) | 0, whammyMiddleValue));
                }
                beat.addWhammyBarPoint(whammyDestination);
            }
        };
        //
        // <Notes>...</Notes>
        //
        GpifParser.prototype.parseNotes = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Note':
                            this.parseNote(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseNote = function (node) {
            var note = new Note();
            var noteId = node.getAttribute('id');
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Properties':
                            this.parseNoteProperties(c, note, noteId);
                            break;
                        case 'AntiAccent':
                            if (c.innerText.toLowerCase() === 'normal') {
                                note.isGhost = true;
                            }
                            break;
                        case 'LetRing':
                            note.isLetRing = true;
                            break;
                        case 'Trill':
                            note.trillValue = parseInt(c.innerText);
                            note.trillSpeed = Duration.Sixteenth;
                            break;
                        case 'Accent':
                            var accentFlags = parseInt(c.innerText);
                            if ((accentFlags & 0x01) !== 0) {
                                note.isStaccato = true;
                            }
                            if ((accentFlags & 0x04) !== 0) {
                                note.accentuated = AccentuationType.Heavy;
                            }
                            if ((accentFlags & 0x08) !== 0) {
                                note.accentuated = AccentuationType.Normal;
                            }
                            break;
                        case 'Tie':
                            if (c.getAttribute('destination').toLowerCase() === 'true') {
                                note.isTieDestination = true;
                            }
                            break;
                        case 'Vibrato':
                            switch (c.innerText) {
                                case 'Slight':
                                    note.vibrato = VibratoType.Slight;
                                    break;
                                case 'Wide':
                                    note.vibrato = VibratoType.Wide;
                                    break;
                            }
                            break;
                        case 'LeftFingering':
                            note.isFingering = true;
                            switch (c.innerText) {
                                case 'P':
                                    note.leftHandFinger = Fingers.Thumb;
                                    break;
                                case 'I':
                                    note.leftHandFinger = Fingers.IndexFinger;
                                    break;
                                case 'M':
                                    note.leftHandFinger = Fingers.MiddleFinger;
                                    break;
                                case 'A':
                                    note.leftHandFinger = Fingers.AnnularFinger;
                                    break;
                                case 'C':
                                    note.leftHandFinger = Fingers.LittleFinger;
                                    break;
                            }
                            break;
                        case 'RightFingering':
                            note.isFingering = true;
                            switch (c.innerText) {
                                case 'P':
                                    note.rightHandFinger = Fingers.Thumb;
                                    break;
                                case 'I':
                                    note.rightHandFinger = Fingers.IndexFinger;
                                    break;
                                case 'M':
                                    note.rightHandFinger = Fingers.MiddleFinger;
                                    break;
                                case 'A':
                                    note.rightHandFinger = Fingers.AnnularFinger;
                                    break;
                                case 'C':
                                    note.rightHandFinger = Fingers.LittleFinger;
                                    break;
                            }
                            break;
                        case 'InstrumentArticulation':
                            note.percussionArticulation = parseInt(c.innerText);
                            break;
                    }
                }
            }
            this._noteById.set(noteId, note);
        };
        GpifParser.prototype.parseNoteProperties = function (node, note, noteId) {
            var isBended = false;
            var bendOrigin = null;
            var bendMiddleValue = null;
            var bendMiddleOffset1 = null;
            var bendMiddleOffset2 = null;
            var bendDestination = null;
            // GP6 had percussion as element+variation
            var element = -1;
            var variation = -1;
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Property':
                            var name_2 = c.getAttribute('name');
                            switch (name_2) {
                                case 'String':
                                    note.string = parseInt(c.findChildElement('String').innerText) + 1;
                                    break;
                                case 'Fret':
                                    note.fret = parseInt(c.findChildElement('Fret').innerText);
                                    break;
                                case 'Element':
                                    element = parseInt(c.findChildElement('Element').innerText);
                                    break;
                                case 'Variation':
                                    variation = parseInt(c.findChildElement('Variation').innerText);
                                    break;
                                case 'Tapped':
                                    this._tappedNotes.set(noteId, true);
                                    break;
                                case 'HarmonicType':
                                    var htype = c.findChildElement('HType');
                                    if (htype) {
                                        switch (htype.innerText) {
                                            case 'NoHarmonic':
                                                note.harmonicType = HarmonicType.None;
                                                break;
                                            case 'Natural':
                                                note.harmonicType = HarmonicType.Natural;
                                                break;
                                            case 'Artificial':
                                                note.harmonicType = HarmonicType.Artificial;
                                                break;
                                            case 'Pinch':
                                                note.harmonicType = HarmonicType.Pinch;
                                                break;
                                            case 'Tap':
                                                note.harmonicType = HarmonicType.Tap;
                                                break;
                                            case 'Semi':
                                                note.harmonicType = HarmonicType.Semi;
                                                break;
                                            case 'Feedback':
                                                note.harmonicType = HarmonicType.Feedback;
                                                break;
                                        }
                                    }
                                    break;
                                case 'HarmonicFret':
                                    var hfret = c.findChildElement('HFret');
                                    if (hfret) {
                                        note.harmonicValue = parseFloat(hfret.innerText);
                                    }
                                    break;
                                case 'Muted':
                                    if (c.findChildElement('Enable')) {
                                        note.isDead = true;
                                    }
                                    break;
                                case 'PalmMuted':
                                    if (c.findChildElement('Enable')) {
                                        note.isPalmMute = true;
                                    }
                                    break;
                                case 'Octave':
                                    note.octave = parseInt(c.findChildElement('Number').innerText);
                                    break;
                                case 'Tone':
                                    note.tone = parseInt(c.findChildElement('Step').innerText);
                                    break;
                                case 'ConcertPitch':
                                    this.parseConcertPitch(c, note);
                                    break;
                                case 'Bended':
                                    isBended = true;
                                    break;
                                case 'BendOriginValue':
                                    if (!bendOrigin) {
                                        bendOrigin = new BendPoint(0, 0);
                                    }
                                    bendOrigin.value = this.toBendValue(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'BendOriginOffset':
                                    if (!bendOrigin) {
                                        bendOrigin = new BendPoint(0, 0);
                                    }
                                    bendOrigin.offset = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'BendMiddleValue':
                                    bendMiddleValue = this.toBendValue(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'BendMiddleOffset1':
                                    bendMiddleOffset1 = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'BendMiddleOffset2':
                                    bendMiddleOffset2 = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'BendDestinationValue':
                                    if (!bendDestination) {
                                        bendDestination = new BendPoint(BendPoint.MaxPosition, 0);
                                    }
                                    bendDestination.value = this.toBendValue(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'BendDestinationOffset':
                                    if (!bendDestination) {
                                        bendDestination = new BendPoint(0, 0);
                                    }
                                    bendDestination.offset = this.toBendOffset(parseFloat(c.findChildElement('Float').innerText));
                                    break;
                                case 'HopoOrigin':
                                    if (c.findChildElement('Enable')) {
                                        note.isHammerPullOrigin = true;
                                    }
                                    break;
                                case 'HopoDestination':
                                    // NOTE: gets automatically calculated
                                    // if (FindChildElement(node, "Enable"))
                                    //     note.isHammerPullDestination = true;
                                    break;
                                case 'LeftHandTapped':
                                    note.isLeftHandTapped = true;
                                    break;
                                case 'Slide':
                                    var slideFlags = parseInt(c.findChildElement('Flags').innerText);
                                    if ((slideFlags & 1) !== 0) {
                                        note.slideOutType = SlideOutType.Shift;
                                    }
                                    else if ((slideFlags & 2) !== 0) {
                                        note.slideOutType = SlideOutType.Legato;
                                    }
                                    else if ((slideFlags & 4) !== 0) {
                                        note.slideOutType = SlideOutType.OutDown;
                                    }
                                    else if ((slideFlags & 8) !== 0) {
                                        note.slideOutType = SlideOutType.OutUp;
                                    }
                                    if ((slideFlags & 16) !== 0) {
                                        note.slideInType = SlideInType.IntoFromBelow;
                                    }
                                    else if ((slideFlags & 32) !== 0) {
                                        note.slideInType = SlideInType.IntoFromAbove;
                                    }
                                    if ((slideFlags & 64) !== 0) {
                                        note.slideOutType = SlideOutType.PickSlideDown;
                                    }
                                    else if ((slideFlags & 128) !== 0) {
                                        note.slideOutType = SlideOutType.PickSlideUp;
                                    }
                                    break;
                            }
                            break;
                    }
                }
            }
            if (isBended) {
                if (!bendOrigin) {
                    bendOrigin = new BendPoint(0, 0);
                }
                if (!bendDestination) {
                    bendDestination = new BendPoint(BendPoint.MaxPosition, 0);
                }
                note.addBendPoint(bendOrigin);
                if (bendMiddleOffset1 && bendMiddleValue) {
                    note.addBendPoint(new BendPoint(bendMiddleOffset1, bendMiddleValue));
                }
                if (bendMiddleOffset2 && bendMiddleValue) {
                    note.addBendPoint(new BendPoint(bendMiddleOffset2, bendMiddleValue));
                }
                if (!bendMiddleOffset1 && !bendMiddleOffset2 && bendMiddleValue) {
                    note.addBendPoint(new BendPoint((BendPoint.MaxPosition / 2) | 0, bendMiddleValue));
                }
                note.addBendPoint(bendDestination);
            }
            // map GP6 element and variation combos to midi numbers
            if (element !== -1 && variation !== -1) {
                note.percussionArticulation = PercussionMapper.articulationFromElementVariation(element, variation);
            }
        };
        GpifParser.prototype.parseConcertPitch = function (node, note) {
            var pitch = node.findChildElement('Pitch');
            if (pitch) {
                for (var _i = 0, _a = pitch.childNodes; _i < _a.length; _i++) {
                    var c = _a[_i];
                    if (c.nodeType === XmlNodeType.Element) {
                        switch (c.localName) {
                            case 'Accidental':
                                switch (c.innerText) {
                                    case 'x':
                                        note.accidentalMode = NoteAccidentalMode.ForceDoubleSharp;
                                        break;
                                    case '#':
                                        note.accidentalMode = NoteAccidentalMode.ForceSharp;
                                        break;
                                    case 'b':
                                        note.accidentalMode = NoteAccidentalMode.ForceFlat;
                                        break;
                                    case 'bb':
                                        note.accidentalMode = NoteAccidentalMode.ForceDoubleFlat;
                                        break;
                                }
                                break;
                        }
                    }
                }
            }
        };
        GpifParser.prototype.toBendValue = function (gpxValue) {
            return (gpxValue * GpifParser.BendPointValueFactor) | 0;
        };
        GpifParser.prototype.toBendOffset = function (gpxOffset) {
            return (gpxOffset * GpifParser.BendPointPositionFactor) | 0;
        };
        GpifParser.prototype.parseRhythms = function (node) {
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'Rhythm':
                            this.parseRhythm(c);
                            break;
                    }
                }
            }
        };
        GpifParser.prototype.parseRhythm = function (node) {
            var rhythm = new GpifRhythm();
            var rhythmId = node.getAttribute('id');
            for (var _i = 0, _a = node.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'NoteValue':
                            switch (c.innerText) {
                                case 'Long':
                                    rhythm.value = Duration.QuadrupleWhole;
                                    break;
                                case 'DoubleWhole':
                                    rhythm.value = Duration.DoubleWhole;
                                    break;
                                case 'Whole':
                                    rhythm.value = Duration.Whole;
                                    break;
                                case 'Half':
                                    rhythm.value = Duration.Half;
                                    break;
                                case 'Quarter':
                                    rhythm.value = Duration.Quarter;
                                    break;
                                case 'Eighth':
                                    rhythm.value = Duration.Eighth;
                                    break;
                                case '16th':
                                    rhythm.value = Duration.Sixteenth;
                                    break;
                                case '32nd':
                                    rhythm.value = Duration.ThirtySecond;
                                    break;
                                case '64th':
                                    rhythm.value = Duration.SixtyFourth;
                                    break;
                                case '128th':
                                    rhythm.value = Duration.OneHundredTwentyEighth;
                                    break;
                                case '256th':
                                    rhythm.value = Duration.TwoHundredFiftySixth;
                                    break;
                            }
                            break;
                        case 'PrimaryTuplet':
                            rhythm.tupletNumerator = parseInt(c.getAttribute('num'));
                            rhythm.tupletDenominator = parseInt(c.getAttribute('den'));
                            break;
                        case 'AugmentationDot':
                            rhythm.dots = parseInt(c.getAttribute('count'));
                            break;
                    }
                }
            }
            this._rhythmById.set(rhythmId, rhythm);
        };
        GpifParser.prototype.buildModel = function () {
            var _this = this;
            // build score
            for (var i = 0, j = this._masterBars.length; i < j; i++) {
                var masterBar = this._masterBars[i];
                this.score.addMasterBar(masterBar);
            }
            // add tracks to score
            for (var _i = 0, _a = this._tracksMapping; _i < _a.length; _i++) {
                var trackId = _a[_i];
                if (!trackId) {
                    continue;
                }
                var track = this._tracksById.get(trackId);
                this.score.addTrack(track);
            }
            // process all masterbars
            for (var _b = 0, _c = this._barsOfMasterBar; _b < _c.length; _b++) {
                var barIds = _c[_b];
                // add all bars of masterbar vertically to all tracks
                var staffIndex = 0;
                for (var barIndex = 0, trackIndex = 0; barIndex < barIds.length && trackIndex < this.score.tracks.length; barIndex++) {
                    var barId = barIds[barIndex];
                    if (barId !== GpifParser.InvalidId) {
                        var bar = this._barsById.get(barId);
                        var track = this.score.tracks[trackIndex];
                        var staff = track.staves[staffIndex];
                        staff.addBar(bar);
                        if (this._voicesOfBar.has(barId)) {
                            // add voices to bars
                            for (var _d = 0, _e = this._voicesOfBar.get(barId); _d < _e.length; _d++) {
                                var voiceId = _e[_d];
                                if (voiceId !== GpifParser.InvalidId) {
                                    var voice = this._voiceById.get(voiceId);
                                    bar.addVoice(voice);
                                    if (this._beatsOfVoice.has(voiceId)) {
                                        // add beats to voices
                                        for (var _f = 0, _g = this._beatsOfVoice.get(voiceId); _f < _g.length; _f++) {
                                            var beatId = _g[_f];
                                            if (beatId !== GpifParser.InvalidId) {
                                                // important! we clone the beat because beats get reused
                                                // in gp6, our model needs to have unique beats.
                                                var beat = this._beatById.get(beatId).clone();
                                                voice.addBeat(beat);
                                                var rhythmId = this._rhythmOfBeat.get(beatId);
                                                var rhythm = this._rhythmById.get(rhythmId);
                                                // set beat duration
                                                beat.duration = rhythm.value;
                                                beat.dots = rhythm.dots;
                                                beat.tupletNumerator = rhythm.tupletNumerator;
                                                beat.tupletDenominator = rhythm.tupletDenominator;
                                                // add notes to beat
                                                if (this._notesOfBeat.has(beatId)) {
                                                    for (var _h = 0, _j = this._notesOfBeat.get(beatId); _h < _j.length; _h++) {
                                                        var noteId = _j[_h];
                                                        if (noteId !== GpifParser.InvalidId) {
                                                            var note = this._noteById.get(noteId).clone();
                                                            // reset midi value for non-percussion staves
                                                            if (staff.isPercussion) {
                                                                note.fret = -1;
                                                                note.string = -1;
                                                            }
                                                            else {
                                                                note.percussionArticulation = -1;
                                                            }
                                                            beat.addNote(note);
                                                            if (this._tappedNotes.has(noteId)) {
                                                                beat.tap = true;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else {
                                    // invalid voice -> empty voice
                                    var voice = new Voice();
                                    bar.addVoice(voice);
                                    var beat = new Beat();
                                    beat.isEmpty = true;
                                    beat.duration = Duration.Quarter;
                                    voice.addBeat(beat);
                                }
                            }
                        }
                        // stave is full? -> next track
                        if (staffIndex === track.staves.length - 1) {
                            trackIndex++;
                            staffIndex = 0;
                        }
                        else {
                            staffIndex++;
                        }
                    }
                    else {
                        // no bar for track
                        trackIndex++;
                    }
                }
            }
            // build masterbar automations
            this._masterTrackAutomations.forEach(function (automations, barIndex) {
                var masterBar = _this.score.masterBars[parseInt(barIndex)];
                for (var i = 0, j = automations.length; i < j; i++) {
                    var automation = automations[i];
                    if (automation.type === AutomationType.Tempo) {
                        if (barIndex === '0') {
                            _this.score.tempo = automation.value | 0;
                            if (automation.text) {
                                _this.score.tempoLabel = automation.text;
                            }
                        }
                        masterBar.tempoAutomation = automation;
                    }
                }
            });
        };
        GpifParser.InvalidId = '-1';
        /**
         * GPX range: 0-100
         * Internal range: 0 - 60
         */
        GpifParser.BendPointPositionFactor = BendPoint.MaxPosition / 100.0;
        /**
         * GPIF: 25 per quarternote
         * Internal Range: 1 per quarter note
         */
        GpifParser.BendPointValueFactor = 1 / 25.0;
        return GpifParser;
    }());

    var TrackConfiguration = /** @class */ (function () {
        function TrackConfiguration() {
            this.isVisible = false;
            this.showSlash = false;
            this.showStandardNotation = false;
            this.showTablature = false;
        }
        return TrackConfiguration;
    }());
    var Part = /** @class */ (function () {
        function Part() {
            this.isMultiRest = false;
            this.tracks = [];
        }
        return Part;
    }());
    var PartConfiguration = /** @class */ (function () {
        function PartConfiguration(partConfigurationData) {
            this.parts = [];
            this.zoomLevel = 0;
            this.layout = 0;
            var readable = ByteBuffer.fromBuffer(partConfigurationData);
            var entryCount = IOHelper.readInt32BE(readable);
            for (var i = 0; i < entryCount; i++) {
                var part = new Part();
                this.parts.push(part);
                part.isMultiRest = GpBinaryHelpers.gpReadBool(readable);
                var groupCount = IOHelper.readInt32BE(readable);
                for (var j = 0; j < groupCount; j++) {
                    var flags = readable.readByte();
                    // enable at least standard notation
                    if (flags === 0) {
                        flags = 1;
                    }
                    var trackConfiguration = new TrackConfiguration();
                    trackConfiguration.showStandardNotation = (flags & 0x01) !== 0;
                    trackConfiguration.showTablature = (flags & 0x02) !== 0;
                    trackConfiguration.showSlash = (flags & 0x04) !== 0;
                    part.tracks.push(trackConfiguration);
                }
            }
        }
        PartConfiguration.prototype.apply = function (score) {
            var staffIndex = 0;
            var trackIndex = 0;
            // the PartConfiguration is really twisted compared to how the score structure looks like.
            // the first part typically contains the settings for the first staff of all tracks.
            // but then there is 1 part with 1 track for each other staff of the tracks.
            // So the structure in the PartConfig appears to be:
            // Parts[0].Tracks = { Track1-Staff1, Track2-Staff1, Track3-Staff1, Track4-Staff1, .. }
            // Parts[1].Tracks = { Track1-Staff2 }
            // Parts[2].Tracks = { Track2-Staff2 }
            // Parts[3].Tracks = { Track3-Staff2 }
            // Parts[4].Tracks = { Track4-Staff2 }
            //
            // even if a track has only 1 staff, there are 2 staff configurations stored.
            // I hope Arobas never changes this in the format as the PartConfiguration is not versionized.
            for (var _i = 0, _a = this.parts; _i < _a.length; _i++) {
                var part = _a[_i];
                for (var _b = 0, _c = part.tracks; _b < _c.length; _b++) {
                    var trackConfig = _c[_b];
                    if (trackIndex < score.tracks.length) {
                        var track = score.tracks[trackIndex];
                        if (staffIndex < track.staves.length) {
                            var staff = track.staves[staffIndex];
                            staff.showTablature = trackConfig.showTablature;
                            staff.showStandardNotation = trackConfig.showStandardNotation;
                        }
                    }
                    trackIndex++;
                    if (trackIndex >= score.tracks.length) {
                        staffIndex++;
                        trackIndex = 0;
                    }
                }
            }
        };
        return PartConfiguration;
    }());

    // This Inflate algorithm is based on the Inflate class of the Haxe Standard Library (MIT)
    /*
     * Copyright (C)2005-2019 Haxe Foundation
     *
     * Permission is hereby granted, free of charge, to any person obtaining a
     * copy of this software and associated documentation files (the "Software"),
     * to deal in the Software without restriction, including without limitation
     * the rights to use, copy, modify, merge, publish, distribute, sublicense,
     * and/or sell copies of the Software, and to permit persons to whom the
     * Software is furnished to do so, subject to the following conditions:
     *
     * The above copyright notice and this permission notice shall be included in
     * all copies or substantial portions of the Software.
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     * DEALINGS IN THE SOFTWARE.
     */
    var __extends$7 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var Huffman = /** @class */ (function () {
        function Huffman() {
        }
        return Huffman;
    }());
    var Found = /** @class */ (function (_super) {
        __extends$7(Found, _super);
        function Found(n) {
            var _this = _super.call(this) || this;
            _this.n = n;
            return _this;
        }
        return Found;
    }(Huffman));
    var NeedBit = /** @class */ (function (_super) {
        __extends$7(NeedBit, _super);
        function NeedBit(left, right) {
            var _this = _super.call(this) || this;
            _this.left = left;
            _this.right = right;
            return _this;
        }
        return NeedBit;
    }(Huffman));
    var NeedBits = /** @class */ (function (_super) {
        __extends$7(NeedBits, _super);
        function NeedBits(n, table) {
            var _this = _super.call(this) || this;
            _this.n = n;
            _this.table = table;
            return _this;
        }
        return NeedBits;
    }(Huffman));

    // This Inflate algorithm is based on the Inflate class of the Haxe Standard Library (MIT)
    // This Inflater is based on the Zip Reader of the Haxe Standard Library (MIT)
    var HuffTools = /** @class */ (function () {
        function HuffTools() {
        }
        HuffTools.make = function (lengths, pos, nlengths, maxbits) {
            var counts = [];
            var tmp = [];
            if (maxbits > 32) {
                throw new FormatError('Invalid huffman');
            }
            for (var i = 0; i < maxbits; i++) {
                counts.push(0);
                tmp.push(0);
            }
            for (var i = 0; i < nlengths; i++) {
                var p = lengths[i + pos];
                if (p >= maxbits) {
                    throw new FormatError('Invalid huffman');
                }
                counts[p]++;
            }
            var code = 0;
            for (var i = 1; i < maxbits - 1; i++) {
                code = (code + counts[i]) << 1;
                tmp[i] = code;
            }
            var bits = new Map();
            for (var i = 0; i < nlengths; i++) {
                var l = lengths[i + pos];
                if (l !== 0) {
                    var n = tmp[l - 1];
                    tmp[l - 1] = n + 1;
                    bits.set((n << 5) | l, i);
                }
            }
            return HuffTools.treeCompress(new NeedBit(HuffTools.treeMake(bits, maxbits, 0, 1), HuffTools.treeMake(bits, maxbits, 1, 1)));
        };
        HuffTools.treeMake = function (bits, maxbits, v, len) {
            if (len > maxbits) {
                throw new FormatError('Invalid huffman');
            }
            var idx = (v << 5) | len;
            if (bits.has(idx)) {
                return new Found(bits.get(idx));
            }
            v = v << 1;
            len += 1;
            return new NeedBit(HuffTools.treeMake(bits, maxbits, v, len), HuffTools.treeMake(bits, maxbits, v | 1, len));
        };
        HuffTools.treeCompress = function (t) {
            var d = HuffTools.treeDepth(t);
            if (d === 0) {
                return t;
            }
            if (d === 1) {
                if (t instanceof NeedBit) {
                    return new NeedBit(HuffTools.treeCompress(t.left), HuffTools.treeCompress(t.right));
                }
                else {
                    throw new FormatError('assert');
                }
            }
            var size = 1 << d;
            var table = [];
            for (var i = 0; i < size; i++) {
                table.push(new Found(-1));
            }
            HuffTools.treeWalk(table, 0, 0, d, t);
            return new NeedBits(d, table);
        };
        HuffTools.treeWalk = function (table, p, cd, d, t) {
            if (t instanceof NeedBit) {
                if (d > 0) {
                    HuffTools.treeWalk(table, p, cd + 1, d - 1, t.left);
                    HuffTools.treeWalk(table, p | (1 << cd), cd + 1, d - 1, t.right);
                }
                else {
                    table[p] = HuffTools.treeCompress(t);
                }
            }
            else {
                table[p] = HuffTools.treeCompress(t);
            }
        };
        HuffTools.treeDepth = function (t) {
            if (t instanceof Found) {
                return 0;
            }
            if (t instanceof NeedBits) {
                throw new FormatError('assert');
            }
            if (t instanceof NeedBit) {
                var da = HuffTools.treeDepth(t.left);
                var db = HuffTools.treeDepth(t.right);
                return 1 + (da < db ? da : db);
            }
            return 0;
        };
        return HuffTools;
    }());

    // This Inflate algorithm is based on the Inflate class of the Haxe Standard Library (MIT)
    var InflateState;
    (function (InflateState) {
        InflateState[InflateState["Head"] = 0] = "Head";
        InflateState[InflateState["Block"] = 1] = "Block";
        InflateState[InflateState["CData"] = 2] = "CData";
        InflateState[InflateState["Flat"] = 3] = "Flat";
        InflateState[InflateState["Crc"] = 4] = "Crc";
        InflateState[InflateState["Dist"] = 5] = "Dist";
        InflateState[InflateState["DistOne"] = 6] = "DistOne";
        InflateState[InflateState["Done"] = 7] = "Done";
    })(InflateState || (InflateState = {}));
    var InflateWindow = /** @class */ (function () {
        function InflateWindow() {
            this.buffer = new Uint8Array(InflateWindow.BufferSize);
            this.pos = 0;
        }
        InflateWindow.prototype.slide = function () {
            var b = new Uint8Array(InflateWindow.BufferSize);
            this.pos -= InflateWindow.Size;
            b.set(this.buffer.subarray(InflateWindow.Size, InflateWindow.Size + this.pos), 0);
            this.buffer = b;
        };
        InflateWindow.prototype.addBytes = function (b, p, len) {
            if (this.pos + len > InflateWindow.BufferSize) {
                this.slide();
            }
            this.buffer.set(b.subarray(p, p + len), this.pos);
            this.pos += len;
        };
        InflateWindow.prototype.addByte = function (c) {
            if (this.pos === InflateWindow.BufferSize) {
                this.slide();
            }
            this.buffer[this.pos] = c;
            this.pos++;
        };
        InflateWindow.prototype.getLastChar = function () {
            return this.buffer[this.pos - 1];
        };
        InflateWindow.prototype.available = function () {
            return this.pos;
        };
        InflateWindow.Size = 1 << 15;
        InflateWindow.BufferSize = 1 << 16;
        return InflateWindow;
    }());
    var Inflate = /** @class */ (function () {
        function Inflate(readable) {
            this._nbits = 0;
            this._bits = 0;
            this._state = InflateState.Block;
            this._isFinal = false;
            this._huffman = Inflate._fixedHuffman;
            this._huffdist = null;
            this._len = 0;
            this._dist = 0;
            this._needed = 0;
            this._output = null;
            this._outpos = 0;
            this._lengths = [];
            this._window = new InflateWindow();
            this._input = readable;
            for (var i = 0; i < 19; i++) {
                this._lengths.push(-1);
            }
        }
        Inflate.buildFixedHuffman = function () {
            var a = [];
            for (var n = 0; n < 288; n++) {
                a.push(n <= 143 ? 8 : n <= 255 ? 9 : n <= 279 ? 7 : 8);
            }
            return HuffTools.make(a, 0, 288, 10);
        };
        Inflate.prototype.readBytes = function (b, pos, len) {
            this._needed = len;
            this._outpos = pos;
            this._output = b;
            if (len > 0) {
                while (this.inflateLoop()) {
                    // inflating...
                }
            }
            return len - this._needed;
        };
        Inflate.prototype.inflateLoop = function () {
            switch (this._state) {
                case InflateState.Head:
                    var cmf = this._input.readByte();
                    var cm = cmf & 15;
                    if (cm !== 8) {
                        throw new FormatError('Invalid data');
                    }
                    var flg = this._input.readByte();
                    // var fcheck = flg & 31;
                    var fdict = (flg & 32) !== 0;
                    // var flevel = flg >> 6;
                    if (((cmf << 8) + flg) % 31 !== 0) {
                        throw new FormatError('Invalid data');
                    }
                    if (fdict) {
                        throw new FormatError('Unsupported dictionary');
                    }
                    this._state = InflateState.Block;
                    return true;
                case InflateState.Crc:
                    this._state = InflateState.Done;
                    return true;
                case InflateState.Done:
                    // nothing
                    return false;
                case InflateState.Block:
                    this._isFinal = this.getBit();
                    switch (this.getBits(2)) {
                        case 0:
                            this._len = IOHelper.readUInt16LE(this._input);
                            var nlen = IOHelper.readUInt16LE(this._input);
                            if (nlen !== 0xffff - this._len) {
                                throw new FormatError('Invalid data');
                            }
                            this._state = InflateState.Flat;
                            var r = this.inflateLoop();
                            this.resetBits();
                            return r;
                        case 1:
                            this._huffman = Inflate._fixedHuffman;
                            this._huffdist = null;
                            this._state = InflateState.CData;
                            return true;
                        case 2:
                            var hlit = this.getBits(5) + 257;
                            var hdist = this.getBits(5) + 1;
                            var hclen = this.getBits(4) + 4;
                            for (var i = 0; i < hclen; i++) {
                                this._lengths[Inflate.CodeLengthsPos[i]] = this.getBits(3);
                            }
                            for (var i = hclen; i < 19; i++) {
                                this._lengths[Inflate.CodeLengthsPos[i]] = 0;
                            }
                            this._huffman = HuffTools.make(this._lengths, 0, 19, 8);
                            var xlengths = [];
                            for (var i = 0; i < hlit + hdist; i++) {
                                xlengths.push(0);
                            }
                            this.inflateLengths(xlengths, hlit + hdist);
                            this._huffdist = HuffTools.make(xlengths, hlit, hdist, 16);
                            this._huffman = HuffTools.make(xlengths, 0, hlit, 16);
                            this._state = InflateState.CData;
                            return true;
                        default:
                            throw new FormatError('Invalid data');
                    }
                case InflateState.Flat: {
                    var rlen = this._len < this._needed ? this._len : this._needed;
                    var bytes = IOHelper.readByteArray(this._input, rlen);
                    this._len -= rlen;
                    this.addBytes(bytes, 0, rlen);
                    if (this._len === 0)
                        this._state = this._isFinal ? InflateState.Crc : InflateState.Block;
                    return this._needed > 0;
                }
                case InflateState.DistOne: {
                    var rlen = this._len < this._needed ? this._len : this._needed;
                    this.addDistOne(rlen);
                    this._len -= rlen;
                    if (this._len === 0) {
                        this._state = InflateState.CData;
                    }
                    return this._needed > 0;
                }
                case InflateState.Dist:
                    while (this._len > 0 && this._needed > 0) {
                        var rdist = this._len < this._dist ? this._len : this._dist;
                        var rlen = this._needed < rdist ? this._needed : rdist;
                        this.addDist(this._dist, rlen);
                        this._len -= rlen;
                    }
                    if (this._len === 0) {
                        this._state = InflateState.CData;
                    }
                    return this._needed > 0;
                case InflateState.CData:
                    var n = this.applyHuffman(this._huffman);
                    if (n < 256) {
                        this.addByte(n);
                        return this._needed > 0;
                    }
                    else if (n === 256) {
                        this._state = this._isFinal ? InflateState.Crc : InflateState.Block;
                        return true;
                    }
                    else {
                        n = (n - 257) & 0xff;
                        var extraBits = Inflate.LenExtraBitsTbl[n];
                        if (extraBits === -1) {
                            throw new FormatError('Invalid data');
                        }
                        this._len = Inflate.LenBaseValTbl[n] + this.getBits(extraBits);
                        var huffdist = this._huffdist;
                        var distCode = !huffdist ? this.getRevBits(5) : this.applyHuffman(huffdist);
                        extraBits = Inflate.DistExtraBitsTbl[distCode];
                        if (extraBits === -1) {
                            throw new FormatError('Invalid data');
                        }
                        this._dist = Inflate.DistBaseValTbl[distCode] + this.getBits(extraBits);
                        if (this._dist > this._window.available()) {
                            throw new FormatError('Invalid data');
                        }
                        this._state = this._dist === 1 ? InflateState.DistOne : InflateState.Dist;
                        return true;
                    }
            }
            return false;
        };
        Inflate.prototype.addDistOne = function (n) {
            var c = this._window.getLastChar();
            for (var i = 0; i < n; i++) {
                this.addByte(c);
            }
        };
        Inflate.prototype.addByte = function (b) {
            this._window.addByte(b);
            this._output[this._outpos] = b;
            this._needed--;
            this._outpos++;
        };
        Inflate.prototype.addDist = function (d, len) {
            this.addBytes(this._window.buffer, this._window.pos - d, len);
        };
        Inflate.prototype.getBit = function () {
            if (this._nbits === 0) {
                this._nbits = 8;
                this._bits = this._input.readByte();
            }
            var b = (this._bits & 1) === 1;
            this._nbits--;
            this._bits = this._bits >> 1;
            return b;
        };
        Inflate.prototype.getBits = function (n) {
            while (this._nbits < n) {
                this._bits = this._bits | (this._input.readByte() << this._nbits);
                this._nbits += 8;
            }
            var b = this._bits & ((1 << n) - 1);
            this._nbits -= n;
            this._bits = this._bits >> n;
            return b;
        };
        Inflate.prototype.getRevBits = function (n) {
            return n === 0 ? 0 : this.getBit() ? (1 << (n - 1)) | this.getRevBits(n - 1) : this.getRevBits(n - 1);
        };
        Inflate.prototype.resetBits = function () {
            this._bits = 0;
            this._nbits = 0;
        };
        Inflate.prototype.addBytes = function (b, p, len) {
            this._window.addBytes(b, p, len);
            this._output.set(b.subarray(p, p + len), this._outpos);
            this._needed -= len;
            this._outpos += len;
        };
        Inflate.prototype.inflateLengths = function (a, max) {
            var i = 0;
            var prev = 0;
            while (i < max) {
                var n = this.applyHuffman(this._huffman);
                switch (n) {
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                        prev = n;
                        a[i] = n;
                        i++;
                        break;
                    case 16:
                        var end = i + 3 + this.getBits(2);
                        if (end > max) {
                            throw new FormatError('Invalid data');
                        }
                        while (i < end) {
                            a[i] = prev;
                            i++;
                        }
                        break;
                    case 17:
                        i += 3 + this.getBits(3);
                        if (i > max) {
                            throw new FormatError('Invalid data');
                        }
                        break;
                    case 18:
                        i += 11 + this.getBits(7);
                        if (i > max) {
                            throw new FormatError('Invalid data');
                        }
                        break;
                    default: {
                        throw new FormatError('Invalid data');
                    }
                }
            }
        };
        Inflate.prototype.applyHuffman = function (h) {
            if (h instanceof Found) {
                return h.n;
            }
            if (h instanceof NeedBit) {
                return this.applyHuffman(this.getBit() ? h.right : h.left);
            }
            if (h instanceof NeedBits) {
                return this.applyHuffman(h.table[this.getBits(h.n)]);
            }
            throw new FormatError('Invalid data');
        };
        // prettier-ignore
        Inflate.LenExtraBitsTbl = [
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1,
            -1
        ];
        // prettier-ignore
        Inflate.LenBaseValTbl = [
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115,
            131, 163, 195, 227, 258
        ];
        // prettier-ignore
        Inflate.DistExtraBitsTbl = [
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12,
            13, 13, -1, -1
        ];
        // prettier-ignore
        Inflate.DistBaseValTbl = [
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537,
            2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577
        ];
        // prettier-ignore
        Inflate.CodeLengthsPos = [
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
        ];
        Inflate._fixedHuffman = Inflate.buildFixedHuffman();
        return Inflate;
    }());

    var ZipEntry = /** @class */ (function () {
        function ZipEntry(fullName, data) {
            this.fullName = fullName;
            var i = fullName.lastIndexOf('/');
            this.fileName = i === -1 || i === fullName.length - 1 ? this.fullName : fullName.substr(i + 1);
            this.data = data;
        }
        return ZipEntry;
    }());
    var ZipReader = /** @class */ (function () {
        function ZipReader(readable) {
            this._readable = readable;
        }
        ZipReader.prototype.read = function () {
            var entries = [];
            while (true) {
                var e = this.readEntry();
                if (!e) {
                    break;
                }
                entries.push(e);
            }
            return entries;
        };
        ZipReader.prototype.readEntry = function () {
            var readable = this._readable;
            var h = IOHelper.readInt32LE(readable);
            if (h !== ZipReader.LocalFileHeaderSignature) {
                return null;
            }
            // 4.3.7 local file header
            IOHelper.readUInt16LE(readable); // version
            var flags = IOHelper.readUInt16LE(readable);
            var compressionMethod = IOHelper.readUInt16LE(readable);
            var compressed = compressionMethod !== 0;
            if (compressed && compressionMethod !== ZipReader.CompressionMethodDeflate) {
                return null;
            }
            IOHelper.readInt16LE(this._readable); // lastModFileTime
            IOHelper.readInt16LE(this._readable); // lastModFileDate
            IOHelper.readInt32LE(readable); // crc32
            IOHelper.readInt32LE(readable); // compressed size
            var uncompressedSize = IOHelper.readInt32LE(readable);
            var fileNameLength = IOHelper.readInt16LE(readable);
            var extraFieldLength = IOHelper.readInt16LE(readable);
            var fname = IOHelper.toString(IOHelper.readByteArray(readable, fileNameLength), 'utf-8');
            readable.skip(extraFieldLength);
            // 4.3.8 File Data
            var data;
            if (compressed) {
                var target = ByteBuffer.empty();
                var z = new Inflate(this._readable);
                var buffer = new Uint8Array(65536);
                while (true) {
                    var bytes = z.readBytes(buffer, 0, buffer.length);
                    target.write(buffer, 0, bytes);
                    if (bytes < buffer.length) {
                        break;
                    }
                }
                data = target.toArray();
            }
            else {
                data = IOHelper.readByteArray(this._readable, uncompressedSize);
            }
            // 4.3.9 Data Descriptor
            // 4.3.9.1
            if ((flags & 8) !== 0) {
                var crc32 = IOHelper.readInt32LE(this._readable);
                // 4.3.9.3
                if (crc32 === ZipReader.OptionalDataDescriptorSignature) {
                    IOHelper.readInt32LE(this._readable); // real crc
                }
                IOHelper.readInt32LE(this._readable); // compressed size
                IOHelper.readInt32LE(this._readable); // uncompressed size
            }
            return new ZipEntry(fname, data);
        };
        ZipReader.OptionalDataDescriptorSignature = 0x08074b50;
        ZipReader.CompressionMethodDeflate = 8;
        ZipReader.LocalFileHeaderSignature = 0x04034b50;
        return ZipReader;
    }());

    var __extends$8 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This ScoreImporter can read Guitar Pro 7 (gp) files.
     */
    var Gp7Importer = /** @class */ (function (_super) {
        __extends$8(Gp7Importer, _super);
        function Gp7Importer() {
            return _super.call(this) || this;
        }
        Object.defineProperty(Gp7Importer.prototype, "name", {
            get: function () {
                return 'Guitar Pro 7';
            },
            enumerable: false,
            configurable: true
        });
        Gp7Importer.prototype.readScore = function () {
            // at first we need to load the binary file system
            // from the GPX container
            Logger.debug(this.name, 'Loading ZIP entries');
            var fileSystem = new ZipReader(this.data);
            var entries;
            try {
                entries = fileSystem.read();
            }
            catch (e) {
                throw new UnsupportedFormatError('No Zip archive', e);
            }
            Logger.debug(this.name, 'Zip entries loaded');
            var xml = null;
            var binaryStylesheetData = null;
            var partConfigurationData = null;
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                switch (entry.fileName) {
                    case 'score.gpif':
                        xml = IOHelper.toString(entry.data, this.settings.importer.encoding);
                        break;
                    case 'BinaryStylesheet':
                        binaryStylesheetData = entry.data;
                        break;
                    case 'PartConfiguration':
                        partConfigurationData = entry.data;
                        break;
                }
            }
            if (!xml) {
                throw new UnsupportedFormatError('No score.gpif found in zip archive');
            }
            // the score.gpif file within this filesystem stores
            // the score information as XML we need to parse.
            Logger.debug(this.name, 'Start Parsing score.gpif');
            var gpifParser = new GpifParser();
            gpifParser.parseXml(xml, this.settings);
            Logger.debug(this.name, 'score.gpif parsed');
            var score = gpifParser.score;
            if (binaryStylesheetData) {
                Logger.debug(this.name, 'Start Parsing BinaryStylesheet');
                var stylesheet = new BinaryStylesheet(binaryStylesheetData);
                stylesheet.apply(score);
                Logger.debug(this.name, 'BinaryStylesheet parsed');
            }
            if (partConfigurationData) {
                Logger.debug(this.name, 'Start Parsing Part Configuration');
                var partConfigurationParser = new PartConfiguration(partConfigurationData);
                partConfigurationParser.apply(score);
                Logger.debug(this.name, 'Part Configuration parsed');
            }
            return score;
        };
        return Gp7Importer;
    }(ScoreImporter));

    var __extends$9 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var EndOfReaderError = /** @class */ (function (_super) {
        __extends$9(EndOfReaderError, _super);
        function EndOfReaderError() {
            var _this = _super.call(this, exports.AlphaTabErrorType.Format, 'Unexpected end of data within reader') || this;
            Object.setPrototypeOf(_this, EndOfReaderError.prototype);
            return _this;
        }
        return EndOfReaderError;
    }(AlphaTabError));
    /**
     * This utility public class allows bitwise reading of a stream
     */
    var BitReader = /** @class */ (function () {
        function BitReader(source) {
            this._currentByte = 0;
            this._position = BitReader.ByteSize;
            this._source = source;
        }
        BitReader.prototype.readByte = function () {
            return this.readBits(8);
        };
        BitReader.prototype.readBytes = function (count) {
            var bytes = new Uint8Array(count);
            for (var i = 0; i < count; i++) {
                bytes[i] = this.readByte() & 0xff;
            }
            return bytes;
        };
        BitReader.prototype.readBits = function (count) {
            var bits = 0;
            var i = count - 1;
            while (i >= 0) {
                bits = bits | (this.readBit() << i);
                i--;
            }
            return bits;
        };
        BitReader.prototype.readBitsReversed = function (count) {
            var bits = 0;
            for (var i = 0; i < count; i++) {
                bits = bits | (this.readBit() << i);
            }
            return bits;
        };
        BitReader.prototype.readBit = function () {
            // need a new byte?
            if (this._position >= 8) {
                this._currentByte = this._source.readByte();
                if (this._currentByte === -1) {
                    throw new EndOfReaderError();
                }
                this._position = 0;
            }
            // shift the desired byte to the least significant bit and
            // get the value using masking
            var value = (this._currentByte >> (BitReader.ByteSize - this._position - 1)) & 0x01;
            this._position++;
            return value;
        };
        BitReader.prototype.readAll = function () {
            var all = ByteBuffer.empty();
            try {
                while (true) {
                    all.writeByte(this.readByte() & 0xff);
                }
            }
            catch (e) {
                if (!(e instanceof EndOfReaderError)) {
                    throw e;
                }
            }
            return all.toArray();
        };
        BitReader.ByteSize = 8;
        return BitReader;
    }());

    /**
     * this public class represents a file within the GpxFileSystem
     */
    var GpxFile = /** @class */ (function () {
        function GpxFile() {
            this.fileName = '';
            this.fileSize = 0;
            this.data = null;
        }
        return GpxFile;
    }());
    /**
     * This public class represents the file system structure
     * stored within a GPX container file.
     */
    var GpxFileSystem = /** @class */ (function () {
        /**
         * Creates a new GpxFileSystem instance
         */
        function GpxFileSystem() {
            /**
             * Gets the list of files stored in this FileSystem.
             */
            this.files = [];
            this.files = [];
            this.fileFilter = function (s) {
                return true;
            };
        }
        /**
         * Load a complete FileSystem to the memory.
         * @param s the binary source to read from.
         * @returns
         */
        GpxFileSystem.prototype.load = function (s) {
            var src = new BitReader(s);
            this.readBlock(src);
        };
        /**
         * Reads the 4 byte header as a string.
         * @param src the BitInput to read from
         * @returns a string with 4 characters representing the header.
         */
        GpxFileSystem.prototype.readHeader = function (src) {
            return this.getString(src.readBytes(4), 0, 4);
        };
        /**
         * Decompresses the given bitinput using the GPX compression format. Only use this method
         * if you are sure the binary data is compressed using the GPX format. Otherwise unexpected
         * behavior can occure.
         * @param src the bitInput to read the data from
         * @param skipHeader true if the header should NOT be included in the result byteset, otherwise false
         * @returns the decompressed byte data. if skipHeader is set to false the BCFS header is included.
         */
        GpxFileSystem.prototype.decompress = function (src, skipHeader) {
            if (skipHeader === void 0) { skipHeader = false; }
            var uncompressed = ByteBuffer.empty();
            var buffer;
            var expectedLength = this.getInteger(src.readBytes(4), 0);
            try {
                // as long we reach our expected length we try to decompress, a EOF might occure.
                while (uncompressed.length < expectedLength) {
                    // compression flag
                    var flag = src.readBits(1);
                    if (flag === 1) {
                        // get offset and size of the content we need to read.
                        // compressed does mean we already have read the data and need
                        // to copy it from our uncompressed buffer to the end
                        var wordSize = src.readBits(4);
                        var offset = src.readBitsReversed(wordSize);
                        var size = src.readBitsReversed(wordSize);
                        // the offset is relative to the end
                        var sourcePosition = uncompressed.length - offset;
                        var toRead = Math.min(offset, size);
                        // get the subbuffer storing the data and add it again to the end
                        buffer = uncompressed.getBuffer();
                        uncompressed.write(buffer, sourcePosition, toRead);
                    }
                    else {
                        // on raw content we need to read the data from the source buffer
                        var size = src.readBitsReversed(2);
                        for (var i = 0; i < size; i++) {
                            uncompressed.writeByte(src.readByte());
                        }
                    }
                }
            }
            catch (e) {
                if (!(e instanceof EndOfReaderError)) {
                    throw e;
                }
            }
            buffer = uncompressed.getBuffer();
            var resultOffset = skipHeader ? 4 : 0;
            var resultSize = uncompressed.length - resultOffset;
            var result = new Uint8Array(resultSize);
            var count = resultSize;
            result.set(buffer.subarray(resultOffset, resultOffset + count), 0);
            return result;
        };
        /**
         * Reads a block from the given data source.
         * @param data the data source
         * @returns
         */
        GpxFileSystem.prototype.readBlock = function (data) {
            var header = this.readHeader(data);
            if (header === 'BCFZ') {
                // decompress the data and use this
                // we will skip the header
                this.readUncompressedBlock(this.decompress(data, true));
            }
            else if (header === 'BCFS') {
                this.readUncompressedBlock(data.readAll());
            }
            else {
                throw new UnsupportedFormatError('Unsupported format');
            }
        };
        /**
         * Reads an uncompressed data block into the model.
         * @param data the data store to read from.
         */
        GpxFileSystem.prototype.readUncompressedBlock = function (data) {
            // the uncompressed block contains a list of filesystem entires
            // as long we have data we will try to read more entries
            // the first sector (0x1000 bytes) is empty (filled with 0xFF)
            // so the first sector starts at 0x1000
            // (we already skipped the 4 byte header so we don't have to take care of this)
            var sectorSize = 0x1000;
            var offset = sectorSize;
            // we always need 4 bytes (+3 including offset) to read the type
            while (offset + 3 < data.length) {
                var entryType = this.getInteger(data, offset);
                if (entryType === 2) {
                    // file structure:
                    //   offset |   type   |   size   | what
                    //  --------+----------+----------+------
                    //    0x04  |  string  |  127byte | FileName (zero terminated)
                    //    0x83  |    ?     |    9byte | Unknown
                    //    0x8c  |   int    |    4byte | FileSize
                    //    0x90  |    ?     |    4byte | Unknown
                    //    0x94  |   int[]  |  n*4byte | Indices of the sector containing the data (end is marked with 0)
                    // The sectors marked at 0x94 are absolutely positioned ( 1*0x1000 is sector 1, 2*0x1000 is sector 2,...)
                    var file = new GpxFile();
                    file.fileName = this.getString(data, offset + 0x04, 127);
                    file.fileSize = this.getInteger(data, offset + 0x8c);
                    // store file if needed
                    var storeFile = !this.fileFilter || this.fileFilter(file.fileName);
                    if (storeFile) {
                        this.files.push(file);
                    }
                    // we need to iterate the blocks because we need to move after the last datasector
                    var dataPointerOffset = offset + 0x94;
                    var sector = 0;
                    // this var is storing the sector index
                    var sectorCount = 0;
                    // we're keeping count so we can calculate the offset of the array item
                    // as long we have data blocks we need to iterate them,
                    var fileData = storeFile ? ByteBuffer.withCapactiy(file.fileSize) : null;
                    // tslint:disable-next-line: no-conditional-assignment
                    while ((sector = this.getInteger(data, dataPointerOffset + 4 * sectorCount++)) !== 0) {
                        // the next file entry starts after the last data sector so we
                        // move the offset along
                        offset = sector * sectorSize;
                        // write data only if needed
                        if (storeFile) {
                            fileData.write(data, offset, sectorSize);
                        }
                    }
                    if (storeFile) {
                        // trim data to filesize if needed
                        file.data = new Uint8Array(Math.min(file.fileSize, fileData.length));
                        // we can use the getBuffer here because we are intelligent and know not to read the empty data.
                        var raw = fileData.toArray();
                        file.data.set(raw.subarray(0, 0 + file.data.length), 0);
                    }
                }
                // let's move to the next sector
                offset += sectorSize;
            }
        };
        /**
         * Reads a zeroterminated ascii string from the given source
         * @param data the data source to read from
         * @param offset the offset to start reading from
         * @param length the max length to read
         * @returns the ascii string read from the datasource.
         */
        GpxFileSystem.prototype.getString = function (data, offset, length) {
            var buf = '';
            for (var i = 0; i < length; i++) {
                var code = data[offset + i] & 0xff;
                if (code === 0) {
                    break;
                    // zero terminated string
                }
                buf += String.fromCharCode(code);
            }
            return buf;
        };
        /**
         * Reads an 4 byte signed integer from the given source
         * @param data the data source to read from
         * @param offset offset the offset to start reading from
         * @returns
         */
        GpxFileSystem.prototype.getInteger = function (data, offset) {
            return (data[offset + 3] << 24) | (data[offset + 2] << 16) | (data[offset + 1] << 8) | data[offset];
        };
        GpxFileSystem.HeaderBcFs = 'BCFS';
        GpxFileSystem.HeaderBcFz = 'BCFZ';
        GpxFileSystem.ScoreGpif = 'score.gpif';
        GpxFileSystem.BinaryStylesheet = 'BinaryStylesheet';
        GpxFileSystem.PartConfiguration = 'PartConfiguration';
        return GpxFileSystem;
    }());

    var __extends$a = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This ScoreImporter can read Guitar Pro 6 (gpx) files.
     */
    var GpxImporter = /** @class */ (function (_super) {
        __extends$a(GpxImporter, _super);
        function GpxImporter() {
            return _super.call(this) || this;
        }
        Object.defineProperty(GpxImporter.prototype, "name", {
            get: function () {
                return 'Guitar Pro 6';
            },
            enumerable: false,
            configurable: true
        });
        GpxImporter.prototype.readScore = function () {
            // at first we need to load the binary file system
            // from the GPX container
            Logger.debug(this.name, 'Loading GPX filesystem');
            var fileSystem = new GpxFileSystem();
            fileSystem.fileFilter = function (s) {
                return s.endsWith('score.gpif') || s.endsWith('BinaryStylesheet') || s.endsWith('PartConfiguration');
            };
            fileSystem.load(this.data);
            Logger.debug(this.name, 'GPX filesystem loaded');
            var xml = null;
            var binaryStylesheetData = null;
            var partConfigurationData = null;
            for (var _i = 0, _a = fileSystem.files; _i < _a.length; _i++) {
                var entry = _a[_i];
                switch (entry.fileName) {
                    case 'score.gpif':
                        xml = IOHelper.toString(entry.data, this.settings.importer.encoding);
                        break;
                    case 'BinaryStylesheet':
                        binaryStylesheetData = entry.data;
                        break;
                    case 'PartConfiguration':
                        partConfigurationData = entry.data;
                        break;
                }
            }
            if (!xml) {
                throw new UnsupportedFormatError('No score.gpif found in GPX');
            }
            // the score.gpif file within this filesystem stores
            // the score information as XML we need to parse.
            Logger.debug(this.name, 'Start Parsing score.gpif');
            var gpifParser = new GpifParser();
            gpifParser.parseXml(xml, this.settings);
            Logger.debug(this.name, 'score.gpif parsed');
            var score = gpifParser.score;
            if (binaryStylesheetData) {
                Logger.debug(this.name, 'Start Parsing BinaryStylesheet');
                var binaryStylesheet = new BinaryStylesheet(binaryStylesheetData);
                binaryStylesheet.apply(score);
                Logger.debug(this.name, 'BinaryStylesheet parsed');
            }
            if (partConfigurationData) {
                Logger.debug(this.name, 'Start Parsing Part Configuration');
                var partConfiguration = new PartConfiguration(partConfigurationData);
                partConfiguration.apply(score);
                Logger.debug(this.name, 'Part Configuration parsed');
            }
            return score;
        };
        return GpxImporter;
    }(ScoreImporter));

    var __extends$b = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MusicXmlImporter = /** @class */ (function (_super) {
        __extends$b(MusicXmlImporter, _super);
        function MusicXmlImporter() {
            var _this = _super.call(this) || this;
            _this._currentPartGroup = null;
            _this._trackFirstMeasureNumber = 0;
            _this._maxVoices = 0;
            _this._currentDirection = null;
            _this._currentChord = null;
            _this._divisionsPerQuarterNote = 0;
            _this._voiceOfStaff = new Map();
            _this._isBeamContinue = false;
            _this._previousBeatWasPulled = false;
            _this._previousBeat = null;
            return _this;
        }
        Object.defineProperty(MusicXmlImporter.prototype, "name", {
            get: function () {
                return 'MusicXML';
            },
            enumerable: false,
            configurable: true
        });
        MusicXmlImporter.prototype.readScore = function () {
            this._trackById = new Map();
            this._partGroups = new Map();
            this._tieStarts = [];
            this._tieStartIds = new Map();
            this._slurStarts = new Map();
            var xml = IOHelper.toString(this.data.readAll(), this.settings.importer.encoding);
            var dom;
            try {
                dom = new XmlDocument(xml);
            }
            catch (e) {
                throw new UnsupportedFormatError('Unsupported format');
            }
            this._score = new Score();
            this._score.tempo = 120;
            this.parseDom(dom);
            // merge partgroups into a single track with multiple staves
            if (this.settings.importer.mergePartGroupsInMusicXml) {
                this.mergePartGroups();
            }
            this._score.finish(this.settings);
            // the structure of MusicXML does not allow live creation of the groups,
            this._score.rebuildRepeatGroups();
            return this._score;
        };
        MusicXmlImporter.prototype.mergePartGroups = function () {
            var _this = this;
            var anyMerged = false;
            this._partGroups.forEach(function (tracks) {
                if (tracks.length > 1) {
                    _this.mergeGroup(tracks);
                    anyMerged = true;
                }
            });
            // if any groups were merged, we need to rebuild the indexes
            if (anyMerged) {
                for (var i = 0; i < this._score.tracks.length; i++) {
                    this._score.tracks[i].index = i;
                }
            }
        };
        MusicXmlImporter.prototype.mergeGroup = function (partGroup) {
            var primaryTrack = partGroup[0];
            for (var i = 1; i < partGroup.length; i++) {
                // merge staves over to primary track
                var secondaryTrack = partGroup[i];
                for (var _i = 0, _a = secondaryTrack.staves; _i < _a.length; _i++) {
                    var staff = _a[_i];
                    primaryTrack.addStaff(staff);
                }
                // remove track from score
                var trackIndex = this._score.tracks.indexOf(secondaryTrack);
                this._score.tracks.splice(trackIndex, 1);
            }
        };
        MusicXmlImporter.prototype.parseDom = function (dom) {
            var root = dom.documentElement;
            if (!root) {
                throw new UnsupportedFormatError('Unsupported format');
            }
            switch (root.localName) {
                case 'score-partwise':
                    this.parsePartwise(root);
                    break;
                case 'score-timewise':
                    // ParseTimewise(root);
                    break;
                default:
                    throw new UnsupportedFormatError('Unsupported format');
            }
        };
        MusicXmlImporter.prototype.parsePartwise = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'work':
                            this.parseWork(c);
                            break;
                        case 'movement-title':
                            this._score.title = c.innerText;
                            break;
                        case 'identification':
                            this.parseIdentification(c);
                            break;
                        case 'part-list':
                            this.parsePartList(c);
                            break;
                        case 'part':
                            this.parsePart(c);
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseWork = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'work-title':
                            this._score.title = c.innerText;
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parsePart = function (element) {
            var id = element.getAttribute('id');
            if (!this._trackById.has(id)) {
                if (this._trackById.size === 1) {
                    this._trackById.forEach(function (t, x) {
                        if (t.staves.length === 0 || t.staves[0].bars.length === 0) {
                            id = x;
                        }
                    });
                    if (!this._trackById.has(id)) {
                        return;
                    }
                }
                else {
                    return;
                }
            }
            var track = this._trackById.get(id);
            var isFirstMeasure = true;
            this._maxVoices = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'measure':
                            if (this.parseMeasure(c, track, isFirstMeasure)) {
                                isFirstMeasure = false;
                            }
                            break;
                    }
                }
            }
            // ensure voices for all bars
            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                var staff = _c[_b];
                for (var _d = 0, _e = staff.bars; _d < _e.length; _d++) {
                    var bar = _e[_d];
                    this.ensureVoices(bar);
                }
            }
        };
        MusicXmlImporter.prototype.parseMeasure = function (element, track, isFirstMeasure) {
            if (element.getAttribute('implicit') === 'yes' && element.getElementsByTagName('note', false).length === 0) {
                return false;
            }
            var barIndex = 0;
            if (isFirstMeasure) {
                this._divisionsPerQuarterNote = 0;
                this._trackFirstMeasureNumber = parseInt(element.getAttribute('number'));
                if (!this._trackFirstMeasureNumber) {
                    this._trackFirstMeasureNumber = 0;
                }
                barIndex = 0;
            }
            else {
                barIndex = parseInt(element.getAttribute('number'));
                if (!barIndex) {
                    return false;
                }
                barIndex -= this._trackFirstMeasureNumber;
            }
            // try to find out the number of staffs required
            if (isFirstMeasure) {
                var attributes = element.getElementsByTagName('attributes', false);
                if (attributes.length > 0) {
                    var stavesElements = attributes[0].getElementsByTagName('staves', false);
                    if (stavesElements.length > 0) {
                        var staves = parseInt(stavesElements[0].innerText);
                        track.ensureStaveCount(staves);
                    }
                }
            }
            // create empty bars to the current index
            var bars = new Array(track.staves.length);
            var masterBar = null;
            for (var b = track.staves[0].bars.length; b <= barIndex; b++) {
                for (var s = 0; s < track.staves.length; s++) {
                    var bar = (bars[s] = new Bar());
                    if (track.staves[s].bars.length > 0) {
                        var previousBar = track.staves[s].bars[track.staves[s].bars.length - 1];
                        bar.clef = previousBar.clef;
                    }
                    masterBar = this.getOrCreateMasterBar(barIndex);
                    track.staves[s].addBar(bar);
                    this.ensureVoices(bar);
                }
            }
            var attributesParsed = false;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'note':
                            this.parseNoteBeat(c, bars);
                            break;
                        case 'forward':
                            this.parseForward(c, bars);
                            break;
                        case 'direction':
                            this.parseDirection(c, masterBar);
                            break;
                        case 'attributes':
                            if (!attributesParsed) {
                                this.parseAttributes(c, bars, masterBar, track);
                                attributesParsed = true;
                            }
                            break;
                        case 'harmony':
                            this.parseHarmony(c, track);
                            break;
                        case 'sound':
                            // TODO
                            break;
                        case 'barline':
                            this.parseBarline(c, masterBar);
                            break;
                    }
                }
            }
            return true;
        };
        MusicXmlImporter.prototype.ensureVoices = function (bar) {
            while (bar.voices.length < this._maxVoices) {
                var emptyVoice = new Voice();
                bar.addVoice(emptyVoice);
                var emptyBeat = new Beat();
                emptyBeat.isEmpty = true;
                emptyBeat.chordId = this._currentChord;
                emptyVoice.addBeat(emptyBeat);
            }
        };
        MusicXmlImporter.prototype.getOrCreateBeat = function (element, bars, chord) {
            var voiceIndex = 0;
            var voiceNodes = element.getElementsByTagName('voice', false);
            if (voiceNodes.length > 0) {
                voiceIndex = parseInt(voiceNodes[0].innerText) - 1;
            }
            var previousBeatWasPulled = this._previousBeatWasPulled;
            this._previousBeatWasPulled = false;
            var staffElement = element.getElementsByTagName('staff', false);
            var staff = 1;
            if (staffElement.length > 0) {
                staff = parseInt(staffElement[0].innerText);
                // in case we have a beam with a staff-jump we pull the note to the previous staff
                if ((this._isBeamContinue || previousBeatWasPulled) &&
                    this._previousBeat.voice.bar.staff.index !== staff - 1) {
                    staff = this._previousBeat.voice.bar.staff.index + 1;
                    this._previousBeatWasPulled = true;
                }
                var staffId = bars[0].staff.track.index + '-' + staff;
                if (!this._voiceOfStaff.has(staffId)) {
                    this._voiceOfStaff.set(staffId, voiceIndex);
                }
            }
            staff--;
            var bar;
            if (staff < 0) {
                bar = bars[0];
            }
            else if (staff >= bars.length) {
                bar = bars[bars.length - 1];
            }
            else {
                bar = bars[staff];
            }
            var beat;
            var voice = this.getOrCreateVoice(bar, voiceIndex);
            if ((chord && voice.beats.length > 0) || (voice.beats.length === 1 && voice.isEmpty)) {
                beat = voice.beats[voice.beats.length - 1];
            }
            else {
                beat = new Beat();
                beat.isEmpty = false;
                voice.addBeat(beat);
            }
            this._isBeamContinue = false;
            this._previousBeat = beat;
            return beat;
        };
        MusicXmlImporter.prototype.parseForward = function (element, bars) {
            var beat = this.getOrCreateBeat(element, bars, false);
            var durationInDivisions = parseInt(element.findChildElement('duration').innerText);
            var duration = (durationInDivisions * Duration.Quarter) / this._divisionsPerQuarterNote;
            var durations = [
                Duration.SixtyFourth,
                Duration.ThirtySecond,
                Duration.Sixteenth,
                Duration.Eighth,
                Duration.Quarter,
                Duration.Half,
                Duration.Whole
            ];
            for (var _i = 0, durations_1 = durations; _i < durations_1.length; _i++) {
                var d = durations_1[_i];
                if (duration >= d) {
                    beat.duration = d;
                    duration -= d;
                    break;
                }
            }
            beat.isEmpty = false;
        };
        MusicXmlImporter.prototype.parseStaffDetails = function (element, track) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'staff-lines':
                            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                                var staff = _c[_b];
                                staff.tuning = new Array(parseInt(c.innerText)).fill(0);
                            }
                            break;
                        case 'staff-tuning':
                            this.parseStaffTuning(c, track);
                            break;
                    }
                }
            }
            for (var _d = 0, _e = track.staves; _d < _e.length; _d++) {
                var staff = _e[_d];
                if (this.isEmptyTuning(staff.tuning)) {
                    staff.tuning = [];
                }
            }
        };
        MusicXmlImporter.prototype.parseStaffTuning = function (element, track) {
            var line = parseInt(element.getAttribute('line'));
            var tuningStep = 'C';
            var tuningOctave = '';
            var tuningAlter = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'tuning-step':
                            tuningStep = c.innerText;
                            break;
                        case 'tuning-alter':
                            tuningAlter = parseInt(c.innerText);
                            break;
                        case 'tuning-octave':
                            tuningOctave = c.innerText;
                            break;
                    }
                }
            }
            var tuning = ModelUtils.getTuningForText(tuningStep + tuningOctave) + tuningAlter;
            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                var staff = _c[_b];
                staff.tuning[staff.tuning.length - line] = tuning;
            }
        };
        MusicXmlImporter.prototype.parseHarmony = function (element, track) {
            var rootStep = null;
            var rootAlter = '';
            // let kind: string | null = null;
            // let kindText: string | null = null;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'root':
                            for (var _b = 0, _c = c.childNodes; _b < _c.length; _b++) {
                                var rootChild = _c[_b];
                                if (rootChild.nodeType === XmlNodeType.Element) {
                                    switch (rootChild.localName) {
                                        case 'root-step':
                                            rootStep = rootChild.innerText;
                                            break;
                                        case 'root-alter':
                                            switch (parseInt(c.innerText)) {
                                                case -2:
                                                    rootAlter = ' bb';
                                                    break;
                                                case -1:
                                                    rootAlter = ' b';
                                                    break;
                                                case 0:
                                                    rootAlter = '';
                                                    break;
                                                case 1:
                                                    rootAlter = ' #';
                                                    break;
                                                case 2:
                                                    rootAlter = ' ##';
                                                    break;
                                            }
                                            break;
                                    }
                                }
                            }
                            break;
                    }
                }
            }
            var chord = new Chord();
            chord.name = rootStep + rootAlter;
            // TODO: find proper names for the rest
            // switch (kind)
            // {
            //    // triads
            //    case "major":
            //        break;
            //    case "minor":
            //        chord.Name += "m";
            //        break;
            //    // Sevenths
            //    case "augmented":
            //        break;
            //    case "diminished":
            //        break;
            //    case "dominant":
            //        break;
            //    case "major-seventh":
            //        chord.Name += "7M";
            //        break;
            //    case "minor-seventh":
            //        chord.Name += "m7";
            //        break;
            //    case "diminished-seventh":
            //        break;
            //    case "augmented-seventh":
            //        break;
            //    case "half-diminished":
            //        break;
            //    case "major-minor":
            //        break;
            //    // Sixths
            //    case "major-sixth":
            //        break;
            //    case "minor-sixth":
            //        break;
            //    // Ninths
            //    case "dominant-ninth":
            //        break;
            //    case "major-ninth":
            //        break;
            //    case "minor-ninth":
            //        break;
            //    // 11ths
            //    case "dominant-11th":
            //        break;
            //    case "major-11th":
            //        break;
            //    case "minor-11th":
            //        break;
            //    // 13ths
            //    case "dominant-13th":
            //        break;
            //    case "major-13th":
            //        break;
            //    case "minor-13th":
            //        break;
            //    // Suspended
            //    case "suspended-second":
            //        break;
            //    case "suspended-fourth":
            //        break;
            //    // Functional sixths
            //    case "Neapolitan":
            //        break;
            //    case "Italian":
            //        break;
            //    case "French":
            //        break;
            //    case "German":
            //        break;
            //    // Other
            //    case "pedal":
            //        break;
            //    case "power":
            //        break;
            //    case "Tristan":
            //        break;
            // }
            // var degree = element.GetElementsByTagName("degree");
            // if (degree.Length > 0)
            // {
            //    var degreeValue = Platform.GetNodeValue(degree[0].GetElementsByTagName("degree-value")[0]);
            //    var degreeAlter = Platform.GetNodeValue(degree[0].GetElementsByTagName("degree-alter")[0]);
            //    var degreeType = Platform.GetNodeValue(degree[0].GetElementsByTagName("degree-type")[0]);
            //    if (!string.IsNullOrEmpty(degreeType))
            //    {
            //        chord.Name += degreeType;
            //    }
            //    if (!string.IsNullOrEmpty(degreeValue))
            //    {
            //        chord.Name += "#" + degreeValue;
            //    }
            // }
            this._currentChord = ModelUtils.newGuid();
            for (var _d = 0, _e = track.staves; _d < _e.length; _d++) {
                var staff = _e[_d];
                staff.addChord(this._currentChord, chord);
            }
        };
        MusicXmlImporter.prototype.parseBarline = function (element, masterBar) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'repeat':
                            this.parseRepeat(c, masterBar);
                            break;
                        case 'ending':
                            this.parseEnding(c, masterBar);
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseEnding = function (element, masterBar) {
            var num = parseInt(element.getAttribute('number'));
            if (num > 0) {
                --num;
                masterBar.alternateEndings |= (0x01 << num) & 0xff;
            }
        };
        MusicXmlImporter.prototype.parseRepeat = function (element, masterBar) {
            var direction = element.getAttribute('direction');
            var times = parseInt(element.getAttribute('times'));
            if (times < 0 || isNaN(times)) {
                times = 2;
            }
            if (direction === 'backward') {
                masterBar.repeatCount = times;
            }
            else if (direction === 'forward') {
                masterBar.isRepeatStart = true;
            }
        };
        MusicXmlImporter.prototype.parseNoteBeat = function (element, bars) {
            var chord = element.getElementsByTagName('chord', false).length > 0;
            var beat = this.getOrCreateBeat(element, bars, chord);
            if (!beat.chordId && this._currentChord) {
                beat.chordId = this._currentChord;
                this._currentChord = null;
            }
            if (this._currentDirection) {
                beat.text = this._currentDirection;
                this._currentDirection = null;
            }
            var note = new Note();
            beat.voice.isEmpty = false;
            beat.isEmpty = false;
            beat.addNote(note);
            beat.dots = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'grace':
                            // var slash = e.GetAttribute("slash");
                            // var makeTime = Platform.ParseInt(e.GetAttribute("make-time"));
                            // var stealTimePrevious = Platform.ParseInt(e.GetAttribute("steal-time-previous"));
                            // var stealTimeFollowing = Platform.ParseInt(e.GetAttribute("steal-time-following"));
                            beat.graceType = GraceType.BeforeBeat;
                            beat.duration = Duration.ThirtySecond;
                            break;
                        case 'duration':
                            if (beat.isRest) {
                                // unit: divisions per quarter note
                                var duration = parseInt(c.innerText);
                                switch (duration) {
                                    case 1:
                                        beat.duration = Duration.Whole;
                                        break;
                                    case 2:
                                        beat.duration = Duration.Half;
                                        break;
                                    case 4:
                                        beat.duration = Duration.Quarter;
                                        break;
                                    case 8:
                                        beat.duration = Duration.Eighth;
                                        break;
                                    case 16:
                                        beat.duration = Duration.Sixteenth;
                                        break;
                                    case 32:
                                        beat.duration = Duration.ThirtySecond;
                                        break;
                                    case 64:
                                        beat.duration = Duration.SixtyFourth;
                                        break;
                                    default:
                                        beat.duration = Duration.Quarter;
                                        break;
                                }
                            }
                            break;
                        case 'tie':
                            this.parseTied(c, note);
                            break;
                        case 'cue':
                            // not supported
                            break;
                        case 'instrument':
                            // not supported
                            break;
                        case 'type':
                            beat.duration = this.getDuration(c.innerText);
                            if (beat.graceType !== GraceType.None && beat.duration < Duration.Sixteenth) {
                                beat.duration = Duration.Eighth;
                            }
                            break;
                        case 'dot':
                            beat.dots++;
                            break;
                        case 'accidental':
                            this.parseAccidental(c, note);
                            break;
                        case 'time-modification':
                            this.parseTimeModification(c, beat);
                            break;
                        case 'stem':
                            // not supported
                            break;
                        case 'notehead':
                            if (c.getAttribute('parentheses') === 'yes') {
                                note.isGhost = true;
                            }
                            break;
                        case 'beam':
                            var beamMode = c.innerText;
                            if (beamMode === 'continue') {
                                this._isBeamContinue = true;
                            }
                            break;
                        case 'notations':
                            this.parseNotations(c, beat, note);
                            break;
                        case 'lyric':
                            this.parseLyric(c, beat);
                            break;
                        case 'pitch':
                            this.parsePitch(c, note);
                            break;
                        case 'unpitched':
                            this.parseUnpitched(c, note);
                            break;
                        case 'rest':
                            beat.isEmpty = false;
                            beat.notes = [];
                            break;
                    }
                }
            }
            // check if new note is duplicate on string
            if (note.isStringed) {
                for (var i = 0; i < beat.notes.length; i++) {
                    if (beat.notes[i].string === note.string && beat.notes[i] !== note) {
                        beat.removeNote(note);
                        break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.getDuration = function (text) {
            switch (text) {
                case '256th':
                case '128th':
                case '64th':
                    return Duration.SixtyFourth;
                case '32nd':
                    return Duration.ThirtySecond;
                case '16th':
                    return Duration.Sixteenth;
                case 'eighth':
                    return Duration.Eighth;
                case 'quarter':
                    return Duration.Quarter;
                case 'half':
                    return Duration.Half;
                case 'long':
                case 'breve':
                case 'whole':
                    return Duration.Whole;
            }
            return Duration.Quarter;
        };
        MusicXmlImporter.prototype.parseLyric = function (element, beat) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'text':
                            if (beat.text) {
                                beat.text += ' ' + c.innerText;
                            }
                            else {
                                beat.text = c.innerText;
                            }
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseAccidental = function (element, note) {
            switch (element.innerText) {
                case 'sharp':
                    note.accidentalMode = NoteAccidentalMode.ForceSharp;
                    break;
                case 'natural':
                    note.accidentalMode = NoteAccidentalMode.ForceNatural;
                    break;
                case 'flat':
                    note.accidentalMode = NoteAccidentalMode.ForceFlat;
                    break;
            }
        };
        MusicXmlImporter.prototype.parseTied = function (element, note) {
            if (element.getAttribute('type') === 'start') {
                if (!this._tieStartIds.has(note.id)) {
                    this._tieStartIds.set(note.id, true);
                    this._tieStarts.push(note);
                }
            }
            else if (element.getAttribute('type') === 'stop' && this._tieStarts.length > 0 && !note.isTieDestination) {
                note.isTieDestination = true;
                note.tieOrigin = this._tieStarts[0];
                this._tieStarts.splice(0, 1);
                this._tieStartIds.delete(note.id);
            }
        };
        MusicXmlImporter.prototype.parseNotations = function (element, beat, note) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'articulations':
                            this.parseArticulations(c, note);
                            break;
                        case 'tied':
                            this.parseTied(c, note);
                            break;
                        case 'slide':
                        case 'glissando':
                            if (c.getAttribute('type') === 'start') {
                                note.slideOutType = SlideOutType.Shift;
                            }
                            break;
                        case 'dynamics':
                            this.parseDynamics(c, beat);
                            break;
                        case 'technical':
                            this.parseTechnical(c, note);
                            break;
                        case 'ornaments':
                            this.parseOrnaments(c, note);
                            break;
                        case 'slur':
                            var slurNumber = c.getAttribute('number');
                            if (!slurNumber) {
                                slurNumber = '1';
                            }
                            switch (c.getAttribute('type')) {
                                case 'start':
                                    this._slurStarts.set(slurNumber, note);
                                    break;
                                case 'stop':
                                    if (this._slurStarts.has(slurNumber)) {
                                        note.isSlurDestination = true;
                                        var slurStart = this._slurStarts.get(slurNumber);
                                        slurStart.slurDestination = note;
                                        note.slurOrigin = note;
                                    }
                                    break;
                            }
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseOrnaments = function (element, note) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'tremolo':
                            var tremoloSpeed = parseInt(c.innerText);
                            switch (tremoloSpeed) {
                                case 1:
                                    note.beat.tremoloSpeed = Duration.Eighth;
                                    break;
                                case 2:
                                    note.beat.tremoloSpeed = Duration.Sixteenth;
                                    break;
                                case 3:
                                    note.beat.tremoloSpeed = Duration.ThirtySecond;
                                    break;
                            }
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseTechnical = function (element, note) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'string':
                            note.string = parseInt(c.innerText);
                            if (note.string !== -2147483648) {
                                note.string = note.beat.voice.bar.staff.tuning.length - note.string + 1;
                            }
                            break;
                        case 'fret':
                            note.fret = parseInt(c.innerText);
                            break;
                        case 'down-bow':
                            note.beat.pickStroke = PickStroke.Down;
                            break;
                        case 'up-bow':
                            note.beat.pickStroke = PickStroke.Up;
                            break;
                    }
                }
            }
            if (note.string === -2147483648 || note.fret === -2147483648) {
                note.string = -1;
                note.fret = -1;
            }
        };
        MusicXmlImporter.prototype.parseArticulations = function (element, note) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                switch (c.localName) {
                    case 'accent':
                        note.accentuated = AccentuationType.Normal;
                        break;
                    case 'strong-accent':
                        note.accentuated = AccentuationType.Heavy;
                        break;
                    case 'staccato':
                    case 'detached-legato':
                        note.isStaccato = true;
                        break;
                }
            }
        };
        MusicXmlImporter.prototype.parseDynamics = function (element, beat) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'p':
                            beat.dynamics = DynamicValue.P;
                            break;
                        case 'pp':
                            beat.dynamics = DynamicValue.PP;
                            break;
                        case 'ppp':
                            beat.dynamics = DynamicValue.PPP;
                            break;
                        case 'f':
                            beat.dynamics = DynamicValue.F;
                            break;
                        case 'ff':
                            beat.dynamics = DynamicValue.FF;
                            break;
                        case 'fff':
                            beat.dynamics = DynamicValue.FFF;
                            break;
                        case 'mp':
                            beat.dynamics = DynamicValue.MP;
                            break;
                        case 'mf':
                            beat.dynamics = DynamicValue.MF;
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseTimeModification = function (element, beat) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'actual-notes':
                            beat.tupletNumerator = parseInt(c.innerText);
                            break;
                        case 'normal-notes':
                            beat.tupletDenominator = parseInt(c.innerText);
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseUnpitched = function (element, note) {
            var step = '';
            var semitones = 0;
            var octave = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'display-step':
                            step = c.innerText;
                            break;
                        case 'display-alter':
                            semitones = parseInt(c.innerText);
                            break;
                        case 'display-octave':
                            // 0-9, 4 for middle C
                            octave = parseInt(c.innerText);
                            break;
                    }
                }
            }
            var value = octave * 12 + ModelUtils.getToneForText(step) + semitones;
            note.octave = (value / 12) | 0;
            note.tone = value - note.octave * 12;
        };
        MusicXmlImporter.prototype.parsePitch = function (element, note) {
            var step = '';
            var semitones = 0;
            var octave = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'step':
                            step = c.innerText;
                            break;
                        case 'alter':
                            semitones = parseFloat(c.innerText);
                            if (isNaN(semitones)) {
                                semitones = 0;
                            }
                            break;
                        case 'octave':
                            // 0-9, 4 for middle C
                            octave = parseInt(c.innerText) + 1;
                            break;
                    }
                }
            }
            var value = octave * 12 + ModelUtils.getToneForText(step) + (semitones | 0);
            note.octave = (value / 12) | 0;
            note.tone = value - note.octave * 12;
        };
        MusicXmlImporter.prototype.getOrCreateVoice = function (bar, index) {
            if (index < bar.voices.length) {
                return bar.voices[index];
            }
            for (var i = bar.voices.length; i <= index; i++) {
                bar.addVoice(new Voice());
            }
            this._maxVoices = Math.max(this._maxVoices, bar.voices.length);
            return bar.voices[index];
        };
        MusicXmlImporter.prototype.parseDirection = function (element, masterBar) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'sound':
                            var tempo = c.getAttribute('tempo');
                            if (tempo) {
                                var tempoAutomation = new Automation();
                                tempoAutomation.isLinear = true;
                                tempoAutomation.type = AutomationType.Tempo;
                                tempoAutomation.value = parseInt(tempo);
                                masterBar.tempoAutomation = tempoAutomation;
                            }
                            break;
                        case 'direction-type':
                            var directionType = c.firstElement;
                            switch (directionType.localName) {
                                case 'words':
                                    this._currentDirection = directionType.innerText;
                                    break;
                                case 'metronome':
                                    this.parseMetronome(directionType, masterBar);
                                    break;
                            }
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseMetronome = function (element, masterBar) {
            var unit = Duration.Quarter;
            var perMinute = 120;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'beat-unit':
                            unit = this.getDuration(c.innerText);
                            break;
                        case 'per-minute':
                            perMinute = parseInt(c.innerText);
                            break;
                    }
                }
            }
            var tempoAutomation = (masterBar.tempoAutomation = new Automation());
            tempoAutomation.type = AutomationType.Tempo;
            tempoAutomation.value = perMinute * ((unit / 4) | 0);
        };
        MusicXmlImporter.prototype.parseAttributes = function (element, bars, masterBar, track) {
            var num = 0;
            var hasTime = false;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'divisions':
                            this._divisionsPerQuarterNote = parseInt(c.innerText);
                            break;
                        case 'key':
                            this.parseKey(c, masterBar);
                            break;
                        case 'time':
                            this.parseTime(c, masterBar);
                            hasTime = true;
                            break;
                        case 'clef':
                            num = parseInt(c.getAttribute('number'));
                            if (isNaN(num)) {
                                num = 1;
                            }
                            this.parseClef(c, bars[num - 1]);
                            break;
                        case 'staff-details':
                            this.parseStaffDetails(c, track);
                            break;
                        case 'transpose':
                            this.parseTranspose(c, track);
                            break;
                    }
                }
            }
            if (!hasTime) {
                masterBar.timeSignatureCommon = true;
            }
        };
        MusicXmlImporter.prototype.parseTranspose = function (element, track) {
            var semitones = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'chromatic':
                            semitones += parseInt(c.innerText);
                            break;
                        case 'octave-change':
                            semitones += parseInt(c.innerText) * 12;
                            break;
                    }
                }
            }
            for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                var staff = _c[_b];
                staff.transpositionPitch = semitones;
            }
        };
        MusicXmlImporter.prototype.parseClef = function (element, bar) {
            var sign = 's';
            var line = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'sign':
                            sign = c.innerText.toLowerCase();
                            break;
                        case 'line':
                            line = parseInt(c.innerText);
                            break;
                        case 'clef-octave-change':
                            switch (parseInt(c.innerText)) {
                                case -2:
                                    bar.clefOttava = Ottavia._15mb;
                                    break;
                                case -1:
                                    bar.clefOttava = Ottavia._8vb;
                                    break;
                                case 1:
                                    bar.clefOttava = Ottavia._8va;
                                    break;
                                case 2:
                                    bar.clefOttava = Ottavia._15mb;
                                    break;
                            }
                            break;
                    }
                }
            }
            switch (sign) {
                case 'g':
                    bar.clef = Clef.G2;
                    break;
                case 'f':
                    bar.clef = Clef.F4;
                    break;
                case 'c':
                    if (line === 3) {
                        bar.clef = Clef.C3;
                    }
                    else {
                        bar.clef = Clef.C4;
                    }
                    break;
                case 'percussion':
                    bar.clef = Clef.Neutral;
                    bar.staff.isPercussion = true;
                    break;
                case 'tab':
                    bar.clef = Clef.G2;
                    bar.staff.showTablature = true;
                    break;
                default:
                    bar.clef = Clef.G2;
                    break;
            }
        };
        MusicXmlImporter.prototype.parseTime = function (element, masterBar) {
            if (element.getAttribute('symbol') === 'common') {
                masterBar.timeSignatureCommon = true;
            }
            var beatsParsed = false;
            var beatTypeParsed = false;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    var v = c.innerText;
                    switch (c.localName) {
                        case 'beats':
                            if (!beatsParsed) {
                                if (v.indexOf('+') === -1) {
                                    masterBar.timeSignatureNumerator = parseInt(v);
                                }
                                else {
                                    masterBar.timeSignatureNumerator = 4;
                                }
                                beatsParsed = true;
                            }
                            break;
                        case 'beat-type':
                            if (!beatTypeParsed) {
                                if (v.indexOf('+') === -1) {
                                    masterBar.timeSignatureDenominator = parseInt(v);
                                }
                                else {
                                    masterBar.timeSignatureDenominator = 4;
                                }
                                beatTypeParsed = true;
                            }
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parseKey = function (element, masterBar) {
            var fifths = -2147483648;
            //let keyStep: number = -2147483648;
            //let keyAlter: number = -2147483648;
            var mode = '';
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'fifths':
                            fifths = parseInt(c.innerText);
                            break;
                        case 'key-step':
                            //keyStep = parseInt(c.innerText);
                            break;
                        case 'key-alter':
                            //keyAlter = parseInt(c.innerText);
                            break;
                        case 'mode':
                            mode = c.innerText;
                            break;
                    }
                }
            }
            if (-7 <= fifths && fifths <= 7) {
                // TODO: check if this is conrrect
                masterBar.keySignature = fifths;
            }
            else {
                masterBar.keySignature = KeySignature.C;
                // TODO: map keyStep/keyAlter to internal keysignature
            }
            if (mode === 'minor') {
                masterBar.keySignatureType = KeySignatureType.Minor;
            }
            else {
                masterBar.keySignatureType = KeySignatureType.Major;
            }
        };
        MusicXmlImporter.prototype.getOrCreateMasterBar = function (index) {
            if (index < this._score.masterBars.length) {
                return this._score.masterBars[index];
            }
            for (var i = this._score.masterBars.length; i <= index; i++) {
                var mb = new MasterBar();
                if (this._score.masterBars.length > 0) {
                    var prev = this._score.masterBars[this._score.masterBars.length - 1];
                    mb.timeSignatureDenominator = prev.timeSignatureDenominator;
                    mb.timeSignatureNumerator = prev.timeSignatureNumerator;
                    mb.keySignature = prev.keySignature;
                    mb.keySignatureType = prev.keySignatureType;
                }
                this._score.addMasterBar(mb);
            }
            return this._score.masterBars[index];
        };
        MusicXmlImporter.prototype.parseIdentification = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'creator':
                            if (c.getAttribute('type') === 'composer') {
                                this._score.music = c.innerText;
                            }
                            break;
                        case 'rights':
                            if (this._score.copyright) {
                                this._score.copyright += '\n';
                            }
                            this._score.copyright += c.innerText;
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parsePartList = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'part-group':
                            this.parsePartGroup(c);
                            break;
                        case 'score-part':
                            this.parseScorePart(c);
                            break;
                    }
                }
            }
        };
        MusicXmlImporter.prototype.parsePartGroup = function (element) {
            var type = element.getAttribute('type');
            switch (type) {
                case 'start':
                    this._currentPartGroup = element.getAttribute('number');
                    this._partGroups.set(this._currentPartGroup, []);
                    break;
                case 'stop':
                    this._currentPartGroup = null;
                    break;
            }
        };
        MusicXmlImporter.prototype.parseScorePart = function (element) {
            var id = element.getAttribute('id');
            var track = new Track();
            track.ensureStaveCount(1);
            var staff = track.staves[0];
            staff.showStandardNotation = true;
            this._trackById.set(id, track);
            this._score.addTrack(track);
            if (this._currentPartGroup) {
                this._partGroups.get(this._currentPartGroup).push(track);
            }
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'part-name':
                            track.name = c.innerText;
                            break;
                        case 'part-abbreviation':
                            track.shortName = c.innerText;
                            break;
                        case 'midi-instrument':
                            this.parseMidiInstrument(c, track);
                            break;
                    }
                }
            }
            if (this.isEmptyTuning(track.staves[0].tuning)) {
                track.staves[0].tuning = [];
            }
        };
        MusicXmlImporter.prototype.isEmptyTuning = function (tuning) {
            if (!tuning) {
                return true;
            }
            for (var i = 0; i < tuning.length; i++) {
                if (tuning[i] !== 0) {
                    return false;
                }
            }
            return true;
        };
        MusicXmlImporter.prototype.parseMidiInstrument = function (element, track) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'midi-channel':
                            track.playbackInfo.primaryChannel = parseInt(c.innerText);
                            break;
                        case 'midi-program':
                            track.playbackInfo.program = parseInt(c.innerText);
                            break;
                        case 'midi-volume':
                            track.playbackInfo.volume = parseInt(c.innerText);
                            break;
                    }
                }
            }
        };
        return MusicXmlImporter;
    }(ScoreImporter));

    /**
     * Lists all midi events.
     */
    var MidiEventType;
    (function (MidiEventType) {
        /**
         * A per note pitch bend. (Midi 2.0)
         */
        MidiEventType[MidiEventType["PerNotePitchBend"] = 96] = "PerNotePitchBend";
        /**
         * A note is released.
         */
        MidiEventType[MidiEventType["NoteOff"] = 128] = "NoteOff";
        /**
         * A note is started.
         */
        MidiEventType[MidiEventType["NoteOn"] = 144] = "NoteOn";
        /**
         * The pressure that was used to play the note.
         */
        MidiEventType[MidiEventType["NoteAftertouch"] = 160] = "NoteAftertouch";
        /**
         * Change of a midi controller
         */
        MidiEventType[MidiEventType["Controller"] = 176] = "Controller";
        /**
         * Change of a midi program
         */
        MidiEventType[MidiEventType["ProgramChange"] = 192] = "ProgramChange";
        /**
         * The pressure that should be applied to the whole channel.
         */
        MidiEventType[MidiEventType["ChannelAftertouch"] = 208] = "ChannelAftertouch";
        /**
         * A change of the audio pitch.
         */
        MidiEventType[MidiEventType["PitchBend"] = 224] = "PitchBend";
        /**
         * A meta event. See <see cref="MetaEventTypeEnum"/> for details.
         */
        MidiEventType[MidiEventType["Meta"] = 255] = "Meta";
    })(MidiEventType || (MidiEventType = {}));
    /**
     * Represents a midi event.
     */
    var MidiEvent = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link MidiEvent} class.
         * @param tick The absolute midi ticks of this event..
         * @param status The status information of this event.
         * @param data1 The first data component of this midi event.
         * @param data2 The second data component of this midi event.
         */
        function MidiEvent(tick, status, data1, data2) {
            this.tick = tick;
            this.message = status | (data1 << 8) | (data2 << 16);
        }
        Object.defineProperty(MidiEvent.prototype, "channel", {
            get: function () {
                return this.message & 0x000000f;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiEvent.prototype, "command", {
            get: function () {
                return (this.message & 0x00000f0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiEvent.prototype, "data1", {
            get: function () {
                return (this.message & 0x000ff00) >> 8;
            },
            set: function (value) {
                this.message &= ~0x000ff00;
                this.message |= value << 8;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiEvent.prototype, "data2", {
            get: function () {
                return (this.message & 0x0ff0000) >> 16;
            },
            set: function (value) {
                this.message &= ~0x0ff0000;
                this.message |= value << 16;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Writes the midi event as binary into the given stream.
         * @param s The stream to write to.
         */
        MidiEvent.prototype.writeTo = function (s) {
            var b = new Uint8Array([
                (this.message >> 24) & 0xff,
                (this.message >> 16) & 0xff,
                (this.message >> 8) & 0xff,
                this.message & 0xff
            ]);
            s.write(b, 0, b.length);
        };
        return MidiEvent;
    }());

    var __extends$c = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MetaEventType;
    (function (MetaEventType) {
        MetaEventType[MetaEventType["SequenceNumber"] = 0] = "SequenceNumber";
        MetaEventType[MetaEventType["TextEvent"] = 1] = "TextEvent";
        MetaEventType[MetaEventType["CopyrightNotice"] = 2] = "CopyrightNotice";
        MetaEventType[MetaEventType["SequenceOrTrackName"] = 3] = "SequenceOrTrackName";
        MetaEventType[MetaEventType["InstrumentName"] = 4] = "InstrumentName";
        MetaEventType[MetaEventType["LyricText"] = 5] = "LyricText";
        MetaEventType[MetaEventType["MarkerText"] = 6] = "MarkerText";
        MetaEventType[MetaEventType["CuePoint"] = 7] = "CuePoint";
        MetaEventType[MetaEventType["PatchName"] = 8] = "PatchName";
        MetaEventType[MetaEventType["PortName"] = 9] = "PortName";
        MetaEventType[MetaEventType["MidiChannel"] = 32] = "MidiChannel";
        MetaEventType[MetaEventType["MidiPort"] = 33] = "MidiPort";
        MetaEventType[MetaEventType["EndOfTrack"] = 47] = "EndOfTrack";
        MetaEventType[MetaEventType["Tempo"] = 81] = "Tempo";
        MetaEventType[MetaEventType["SmpteOffset"] = 84] = "SmpteOffset";
        MetaEventType[MetaEventType["TimeSignature"] = 88] = "TimeSignature";
        MetaEventType[MetaEventType["KeySignature"] = 89] = "KeySignature";
        MetaEventType[MetaEventType["SequencerSpecific"] = 127] = "SequencerSpecific";
    })(MetaEventType || (MetaEventType = {}));
    var MetaEvent = /** @class */ (function (_super) {
        __extends$c(MetaEvent, _super);
        function MetaEvent(delta, status, data1, data2) {
            return _super.call(this, delta, status, data1, data2) || this;
        }
        Object.defineProperty(MetaEvent.prototype, "channel", {
            get: function () {
                return -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MetaEvent.prototype, "command", {
            get: function () {
                return (this.message & 0x00000ff);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MetaEvent.prototype, "metaStatus", {
            get: function () {
                return this.data1;
            },
            enumerable: false,
            configurable: true
        });
        return MetaEvent;
    }(MidiEvent));

    var SynthEvent = /** @class */ (function () {
        function SynthEvent(eventIndex, e) {
            this.isMetronome = false;
            this.time = 0;
            this.eventIndex = eventIndex;
            this.event = e;
        }
        SynthEvent.newMetronomeEvent = function (eventIndex) {
            var x = new SynthEvent(eventIndex, null);
            x.isMetronome = true;
            return x;
        };
        return SynthEvent;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    var SynthConstants = /** @class */ (function () {
        function SynthConstants() {
        }
        SynthConstants.DefaultChannelCount = 16 + 1;
        SynthConstants.MetronomeChannel = SynthConstants.DefaultChannelCount - 1;
        SynthConstants.AudioChannels = 2;
        SynthConstants.MinVolume = 0;
        SynthConstants.MaxVolume = 1;
        SynthConstants.MinProgram = 0;
        SynthConstants.MaxProgram = 127;
        SynthConstants.MinPlaybackSpeed = 0.125;
        SynthConstants.MaxPlaybackSpeed = 8;
        /**
         * The Midi Pitch bend message is a 15-bit value
         */
        SynthConstants.MaxPitchWheel = 0x4000;
        /**
         * The Midi 2.0 Pitch bend message is a 32-bit value
         */
        SynthConstants.MaxPitchWheel20 = 0x100000000;
        /**
         * The pitch wheel value for no pitch change at all.
         */
        SynthConstants.DefaultPitchWheel = SynthConstants.MaxPitchWheel / 2;
        SynthConstants.MicroBufferCount = 32;
        SynthConstants.MicroBufferSize = 64;
        return SynthConstants;
    }());

    var MidiFileSequencerTempoChange = /** @class */ (function () {
        function MidiFileSequencerTempoChange(bpm, ticks, time) {
            this.bpm = bpm;
            this.ticks = ticks;
            this.time = time;
        }
        return MidiFileSequencerTempoChange;
    }());
    var MidiSequencerState = /** @class */ (function () {
        function MidiSequencerState() {
            this.tempoChanges = [];
            this.firstProgramEventPerChannel = new Map();
            this.firstTimeSignatureNumerator = 0;
            this.firstTimeSignatureDenominator = 0;
            this.synthData = [];
            this.division = 0;
            this.eventIndex = 0;
            this.currentTime = 0;
            this.playbackRange = null;
            this.playbackRangeStartTime = 0;
            this.playbackRangeEndTime = 0;
            this.endTick = 0;
            this.endTime = 0;
        }
        return MidiSequencerState;
    }());
    /**
     * This sequencer dispatches midi events to the synthesizer based on the current
     * synthesize position. The sequencer does not consider the playback speed.
     */
    var MidiFileSequencer = /** @class */ (function () {
        function MidiFileSequencer(synthesizer) {
            this._oneTimeState = null;
            this._countInState = null;
            this.isLooping = false;
            /**
             * Gets or sets the playback speed.
             */
            this.playbackSpeed = 1;
            this._synthesizer = synthesizer;
            this._mainState = new MidiSequencerState();
            this._currentState = this._mainState;
        }
        Object.defineProperty(MidiFileSequencer.prototype, "isPlayingOneTimeMidi", {
            get: function () {
                return this._currentState == this._oneTimeState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiFileSequencer.prototype, "isPlayingCountIn", {
            get: function () {
                return this._currentState == this._countInState;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiFileSequencer.prototype, "playbackRange", {
            get: function () {
                return this._currentState.playbackRange;
            },
            set: function (value) {
                this._currentState.playbackRange = value;
                if (value) {
                    this._currentState.playbackRangeStartTime = this.tickPositionToTimePositionWithSpeed(value.startTick, 1);
                    this._currentState.playbackRangeEndTime = this.tickPositionToTimePositionWithSpeed(value.endTick, 1);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiFileSequencer.prototype, "currentTime", {
            get: function () {
                return this._currentState.currentTime;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiFileSequencer.prototype, "endTick", {
            /**
             * Gets the duration of the song in ticks.
             */
            get: function () {
                return this._currentState.endTick;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiFileSequencer.prototype, "endTime", {
            get: function () {
                return this._currentState.endTime / this.playbackSpeed;
            },
            enumerable: false,
            configurable: true
        });
        MidiFileSequencer.prototype.seek = function (timePosition) {
            // map to speed=1
            timePosition *= this.playbackSpeed;
            // ensure playback range
            if (this.playbackRange) {
                if (timePosition < this._currentState.playbackRangeStartTime) {
                    timePosition = this._currentState.playbackRangeStartTime;
                }
                else if (timePosition > this._currentState.playbackRangeEndTime) {
                    timePosition = this._currentState.playbackRangeEndTime;
                }
            }
            if (timePosition > this._currentState.currentTime) {
                this.silentProcess(timePosition - this._currentState.currentTime);
            }
            else if (timePosition < this._currentState.currentTime) {
                // we have to restart the midi to make sure we get the right state: instruments, volume, pan, etc
                this._currentState.currentTime = 0;
                this._currentState.eventIndex = 0;
                var metronomeVolume = this._synthesizer.metronomeVolume;
                this._synthesizer.noteOffAll(true);
                this._synthesizer.resetSoft();
                this._synthesizer.setupMetronomeChannel(metronomeVolume);
                this.silentProcess(timePosition);
            }
        };
        MidiFileSequencer.prototype.silentProcess = function (milliseconds) {
            if (milliseconds <= 0) {
                return;
            }
            var start = Date.now();
            var finalTime = this._currentState.currentTime + milliseconds;
            while (this._currentState.currentTime < finalTime) {
                if (this.fillMidiEventQueueLimited(finalTime - this._currentState.currentTime)) {
                    this._synthesizer.synthesizeSilent(SynthConstants.MicroBufferSize);
                }
            }
            this._currentState.currentTime = finalTime;
            var duration = Date.now() - start;
            Logger.debug('Sequencer', 'Silent seek finished in ' + duration + 'ms');
        };
        MidiFileSequencer.prototype.loadOneTimeMidi = function (midiFile) {
            this._oneTimeState = this.createStateFromFile(midiFile);
            this._currentState = this._oneTimeState;
        };
        MidiFileSequencer.prototype.loadMidi = function (midiFile) {
            this._mainState = this.createStateFromFile(midiFile);
            this._currentState = this._mainState;
        };
        MidiFileSequencer.prototype.createStateFromFile = function (midiFile) {
            var state = new MidiSequencerState();
            state.tempoChanges = [];
            state.division = midiFile.division;
            state.eventIndex = 0;
            state.currentTime = 0;
            // build synth events.
            state.synthData = [];
            // Converts midi to milliseconds for easy sequencing
            var bpm = 120;
            var absTick = 0;
            var absTime = 0.0;
            var metronomeLength = 0;
            var metronomeTick = 0;
            var metronomeTime = 0.0;
            var previousTick = 0;
            for (var _i = 0, _a = midiFile.events; _i < _a.length; _i++) {
                var mEvent = _a[_i];
                var synthData = new SynthEvent(state.synthData.length, mEvent);
                state.synthData.push(synthData);
                var deltaTick = mEvent.tick - previousTick;
                absTick += deltaTick;
                absTime += deltaTick * (60000.0 / (bpm * midiFile.division));
                synthData.time = absTime;
                previousTick = mEvent.tick;
                if (metronomeLength > 0) {
                    while (metronomeTick < absTick) {
                        var metronome = SynthEvent.newMetronomeEvent(state.synthData.length);
                        state.synthData.push(metronome);
                        metronome.time = metronomeTime;
                        metronomeTick += metronomeLength;
                        metronomeTime += metronomeLength * (60000.0 / (bpm * midiFile.division));
                    }
                }
                if (mEvent.command === MidiEventType.Meta && mEvent.data1 === MetaEventType.Tempo) {
                    var meta = mEvent;
                    bpm = 60000000 / meta.value;
                    state.tempoChanges.push(new MidiFileSequencerTempoChange(bpm, absTick, absTime));
                }
                else if (mEvent.command === MidiEventType.Meta && mEvent.data1 === MetaEventType.TimeSignature) {
                    var meta = mEvent;
                    var timeSignatureDenominator = Math.pow(2, meta.data[1]);
                    metronomeLength = (state.division * (4.0 / timeSignatureDenominator)) | 0;
                    if (state.firstTimeSignatureDenominator === 0) {
                        state.firstTimeSignatureNumerator = meta.data[0];
                        state.firstTimeSignatureDenominator = timeSignatureDenominator;
                    }
                }
                else if (mEvent.command === MidiEventType.ProgramChange) {
                    var channel = mEvent.channel;
                    if (!state.firstProgramEventPerChannel.has(channel)) {
                        state.firstProgramEventPerChannel.set(channel, synthData);
                    }
                }
            }
            state.synthData.sort(function (a, b) {
                if (a.time > b.time) {
                    return 1;
                }
                if (a.time < b.time) {
                    return -1;
                }
                return a.eventIndex - b.eventIndex;
            });
            state.endTime = absTime;
            state.endTick = absTick;
            return state;
        };
        MidiFileSequencer.prototype.fillMidiEventQueue = function () {
            return this.fillMidiEventQueueLimited(-1);
        };
        MidiFileSequencer.prototype.fillMidiEventQueueLimited = function (maxMilliseconds) {
            var millisecondsPerBuffer = (SynthConstants.MicroBufferSize / this._synthesizer.outSampleRate) * 1000 * this.playbackSpeed;
            var endTime = this.internalEndTime;
            if (maxMilliseconds > 0) {
                // ensure that first microbuffer does not already exceed max time
                if (maxMilliseconds < millisecondsPerBuffer) {
                    millisecondsPerBuffer = maxMilliseconds;
                }
                endTime = Math.min(this.internalEndTime, this._currentState.currentTime + maxMilliseconds);
            }
            var anyEventsDispatched = false;
            this._currentState.currentTime += millisecondsPerBuffer;
            while (this._currentState.eventIndex < this._currentState.synthData.length &&
                this._currentState.synthData[this._currentState.eventIndex].time < this._currentState.currentTime &&
                this._currentState.currentTime < endTime) {
                this._synthesizer.dispatchEvent(this._currentState.synthData[this._currentState.eventIndex]);
                this._currentState.eventIndex++;
                anyEventsDispatched = true;
            }
            return anyEventsDispatched;
        };
        MidiFileSequencer.prototype.tickPositionToTimePosition = function (tickPosition) {
            return this.tickPositionToTimePositionWithSpeed(tickPosition, this.playbackSpeed);
        };
        MidiFileSequencer.prototype.timePositionToTickPosition = function (timePosition) {
            return this.timePositionToTickPositionWithSpeed(timePosition, this.playbackSpeed);
        };
        MidiFileSequencer.prototype.tickPositionToTimePositionWithSpeed = function (tickPosition, playbackSpeed) {
            var timePosition = 0.0;
            var bpm = 120.0;
            var lastChange = 0;
            // find start and bpm of last tempo change before time
            for (var _i = 0, _a = this._currentState.tempoChanges; _i < _a.length; _i++) {
                var c = _a[_i];
                if (tickPosition < c.ticks) {
                    break;
                }
                timePosition = c.time;
                bpm = c.bpm;
                lastChange = c.ticks;
            }
            // add the missing millis
            tickPosition -= lastChange;
            timePosition += tickPosition * (60000.0 / (bpm * this._currentState.division));
            return timePosition / playbackSpeed;
        };
        MidiFileSequencer.prototype.timePositionToTickPositionWithSpeed = function (timePosition, playbackSpeed) {
            timePosition *= playbackSpeed;
            var ticks = 0;
            var bpm = 120.0;
            var lastChange = 0;
            // find start and bpm of last tempo change before time
            for (var _i = 0, _a = this._currentState.tempoChanges; _i < _a.length; _i++) {
                var c = _a[_i];
                if (timePosition < c.time) {
                    break;
                }
                ticks = c.ticks;
                bpm = c.bpm;
                lastChange = c.time;
            }
            // add the missing ticks
            timePosition -= lastChange;
            ticks += (timePosition / (60000.0 / (bpm * this._currentState.division))) | 0;
            // we add 1 for possible rounding errors.(floating point issuses)
            return ticks + 1;
        };
        Object.defineProperty(MidiFileSequencer.prototype, "internalEndTime", {
            get: function () {
                return !this.playbackRange ? this._currentState.endTime : this._currentState.playbackRangeEndTime;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MidiFileSequencer.prototype, "isFinished", {
            get: function () {
                return this._currentState.currentTime >= this.internalEndTime;
            },
            enumerable: false,
            configurable: true
        });
        MidiFileSequencer.prototype.stop = function () {
            if (!this.playbackRange) {
                this._currentState.currentTime = 0;
                this._currentState.eventIndex = 0;
            }
            else if (this.playbackRange) {
                this._currentState.currentTime = this.playbackRange.startTick;
                this._currentState.eventIndex = 0;
            }
        };
        MidiFileSequencer.prototype.resetOneTimeMidi = function () {
            this._oneTimeState = null;
            this._currentState = this._mainState;
        };
        MidiFileSequencer.prototype.resetCountIn = function () {
            this._countInState = null;
            this._currentState = this._mainState;
        };
        MidiFileSequencer.prototype.startCountIn = function () {
            this.generateCountInMidi();
            this._currentState = this._countInState;
            this.stop();
            this._synthesizer.noteOffAll(true);
        };
        MidiFileSequencer.prototype.generateCountInMidi = function () {
            var state = new MidiSequencerState();
            state.division = this._mainState.division;
            var bpm = 120;
            var timeSignatureNumerator = 4;
            var timeSignatureDenominator = 4;
            if (this._mainState.eventIndex === 0) {
                bpm = this._mainState.tempoChanges[0].bpm;
                timeSignatureNumerator = this._mainState.firstTimeSignatureNumerator;
                timeSignatureDenominator = this._mainState.firstTimeSignatureDenominator;
            }
            else {
                bpm = this._synthesizer.currentTempo;
                timeSignatureNumerator = this._synthesizer.timeSignatureNumerator;
                timeSignatureDenominator = this._synthesizer.timeSignatureDenominator;
            }
            state.tempoChanges.push(new MidiFileSequencerTempoChange(bpm, 0, 0));
            var metronomeLength = (state.division * (4.0 / timeSignatureDenominator)) | 0;
            var metronomeTick = 0;
            var metronomeTime = 0.0;
            for (var i = 0; i < timeSignatureNumerator; i++) {
                var metronome = SynthEvent.newMetronomeEvent(state.synthData.length);
                state.synthData.push(metronome);
                metronome.time = metronomeTime;
                metronomeTick += metronomeLength;
                metronomeTime += metronomeLength * (60000.0 / (bpm * this._mainState.division));
            }
            state.synthData.sort(function (a, b) {
                if (a.time > b.time) {
                    return 1;
                }
                if (a.time < b.time) {
                    return -1;
                }
                return a.eventIndex - b.eventIndex;
            });
            state.endTime = metronomeTime;
            state.endTick = metronomeTick;
            this._countInState = state;
        };
        return MidiFileSequencer;
    }());

    /**
     * Lists the different states of the player
     */
    var PlayerState;
    (function (PlayerState) {
        /**
         * Player is paused
         */
        PlayerState[PlayerState["Paused"] = 0] = "Paused";
        /**
         * Player is playing
         */
        PlayerState[PlayerState["Playing"] = 1] = "Playing";
    })(PlayerState || (PlayerState = {}));

    /**
     * Represents the info when the player state changes.
     */
    var PlayerStateChangedEventArgs = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link PlayerStateChangedEventArgs} class.
         * @param state The state.
         */
        function PlayerStateChangedEventArgs(state, stopped) {
            this.state = state;
            this.stopped = stopped;
        }
        return PlayerStateChangedEventArgs;
    }());

    /**
     * Represents the info when the time in the synthesizer changes.
     */
    var PositionChangedEventArgs = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link PositionChangedEventArgs} class.
         * @param currentTime The current time.
         * @param endTime The end time.
         * @param currentTick The current tick.
         * @param endTick The end tick.
         */
        function PositionChangedEventArgs(currentTime, endTime, currentTick, endTick) {
            this.currentTime = currentTime;
            this.endTime = endTime;
            this.currentTick = currentTick;
            this.endTick = endTick;
        }
        return PositionChangedEventArgs;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    var RiffChunk = /** @class */ (function () {
        function RiffChunk() {
            this.id = '';
            this.size = 0;
        }
        RiffChunk.load = function (parent, chunk, stream) {
            if (parent && RiffChunk.HeaderSize > parent.size) {
                return false;
            }
            if (stream.position + RiffChunk.HeaderSize >= stream.length) {
                return false;
            }
            chunk.id = IOHelper.read8BitStringLength(stream, 4);
            if (chunk.id.charCodeAt(0) <= 32 || chunk.id.charCodeAt(0) >= 122) {
                return false;
            }
            chunk.size = IOHelper.readUInt32LE(stream);
            if (parent && RiffChunk.HeaderSize + chunk.size > parent.size) {
                return false;
            }
            if (parent) {
                parent.size -= RiffChunk.HeaderSize + chunk.size;
            }
            var isRiff = chunk.id === 'RIFF';
            var isList = chunk.id === 'LIST';
            if (isRiff && parent) {
                // not allowed
                return false;
            }
            if (!isRiff && !isList) {
                // custom type without sub type
                return true;
            }
            // for lists unwrap the list type
            chunk.id = IOHelper.read8BitStringLength(stream, 4);
            if (chunk.id.charCodeAt(0) <= 32 || chunk.id.charCodeAt(0) >= 122) {
                return false;
            }
            chunk.size -= 4;
            return true;
        };
        RiffChunk.HeaderSize = 4 /*FourCC*/ + 4 /*Size*/;
        return RiffChunk;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    var Hydra = /** @class */ (function () {
        function Hydra() {
            this.phdrs = [];
            this.pbags = [];
            this.pmods = [];
            this.pgens = [];
            this.insts = [];
            this.ibags = [];
            this.imods = [];
            this.igens = [];
            this.sHdrs = [];
            this.fontSamples = new Float32Array(0);
        }
        Hydra.prototype.load = function (readable) {
            var chunkHead = new RiffChunk();
            var chunkFastList = new RiffChunk();
            if (!RiffChunk.load(null, chunkHead, readable) || chunkHead.id !== 'sfbk') {
                throw new FormatError("Soundfont is not a valid Soundfont2 file");
            }
            while (RiffChunk.load(chunkHead, chunkFastList, readable)) {
                var chunk = new RiffChunk();
                if (chunkFastList.id === 'pdta') {
                    while (RiffChunk.load(chunkFastList, chunk, readable)) {
                        switch (chunk.id) {
                            case 'phdr':
                                for (var i = 0, count = (chunk.size / HydraPhdr.SizeInFile) | 0; i < count; i++) {
                                    this.phdrs.push(new HydraPhdr(readable));
                                }
                                break;
                            case 'pbag':
                                for (var i = 0, count = (chunk.size / HydraPbag.SizeInFile) | 0; i < count; i++) {
                                    this.pbags.push(new HydraPbag(readable));
                                }
                                break;
                            case 'pmod':
                                for (var i = 0, count = (chunk.size / HydraPmod.SizeInFile) | 0; i < count; i++) {
                                    this.pmods.push(new HydraPmod(readable));
                                }
                                break;
                            case 'pgen':
                                for (var i = 0, count = (chunk.size / HydraPgen.SizeInFile) | 0; i < count; i++) {
                                    this.pgens.push(new HydraPgen(readable));
                                }
                                break;
                            case 'inst':
                                for (var i = 0, count = (chunk.size / HydraInst.SizeInFile) | 0; i < count; i++) {
                                    this.insts.push(new HydraInst(readable));
                                }
                                break;
                            case 'ibag':
                                for (var i = 0, count = (chunk.size / HydraIbag.SizeInFile) | 0; i < count; i++) {
                                    this.ibags.push(new HydraIbag(readable));
                                }
                                break;
                            case 'imod':
                                for (var i = 0, count = (chunk.size / HydraImod.SizeInFile) | 0; i < count; i++) {
                                    this.imods.push(new HydraImod(readable));
                                }
                                break;
                            case 'igen':
                                for (var i = 0, count = (chunk.size / HydraIgen.SizeInFile) | 0; i < count; i++) {
                                    this.igens.push(new HydraIgen(readable));
                                }
                                break;
                            case 'shdr':
                                for (var i = 0, count = (chunk.size / HydraShdr.SizeInFile) | 0; i < count; i++) {
                                    this.sHdrs.push(new HydraShdr(readable));
                                }
                                break;
                            default:
                                readable.position += chunk.size;
                                break;
                        }
                    }
                }
                else if (chunkFastList.id === 'sdta') {
                    while (RiffChunk.load(chunkFastList, chunk, readable)) {
                        switch (chunk.id) {
                            case 'smpl':
                                this.fontSamples = Hydra.loadSamples(chunk, readable);
                                break;
                            default:
                                readable.position += chunk.size;
                                break;
                        }
                    }
                }
                else {
                    readable.position += chunkFastList.size;
                }
            }
        };
        Hydra.loadSamples = function (chunk, reader) {
            var samplesLeft = (chunk.size / 2) | 0;
            var samples = new Float32Array(samplesLeft);
            var samplesPos = 0;
            var sampleBuffer = new Uint8Array(2048);
            var testBuffer = new Int16Array((sampleBuffer.length / 2) | 0);
            while (samplesLeft > 0) {
                var samplesToRead = Math.min(samplesLeft, (sampleBuffer.length / 2) | 0);
                reader.read(sampleBuffer, 0, samplesToRead * 2);
                for (var i = 0; i < samplesToRead; i++) {
                    testBuffer[i] = (sampleBuffer[i * 2 + 1] << 8) | sampleBuffer[i * 2];
                    samples[samplesPos + i] = testBuffer[i] / 32767;
                }
                samplesLeft -= samplesToRead;
                samplesPos += samplesToRead;
            }
            return samples;
        };
        return Hydra;
    }());
    var HydraIbag = /** @class */ (function () {
        function HydraIbag(reader) {
            this.instGenNdx = IOHelper.readUInt16LE(reader);
            this.instModNdx = IOHelper.readUInt16LE(reader);
        }
        HydraIbag.SizeInFile = 4;
        return HydraIbag;
    }());
    var HydraImod = /** @class */ (function () {
        function HydraImod(reader) {
            this.modSrcOper = IOHelper.readUInt16LE(reader);
            this.modDestOper = IOHelper.readUInt16LE(reader);
            this.modAmount = IOHelper.readInt16LE(reader);
            this.modAmtSrcOper = IOHelper.readUInt16LE(reader);
            this.modTransOper = IOHelper.readUInt16LE(reader);
        }
        HydraImod.SizeInFile = 10;
        return HydraImod;
    }());
    var HydraIgen = /** @class */ (function () {
        function HydraIgen(reader) {
            this.genOper = IOHelper.readUInt16LE(reader);
            this.genAmount = new HydraGenAmount(reader);
        }
        HydraIgen.SizeInFile = 4;
        return HydraIgen;
    }());
    var HydraInst = /** @class */ (function () {
        function HydraInst(reader) {
            this.instName = IOHelper.read8BitStringLength(reader, 20);
            this.instBagNdx = IOHelper.readUInt16LE(reader);
        }
        HydraInst.SizeInFile = 22;
        return HydraInst;
    }());
    var HydraPbag = /** @class */ (function () {
        function HydraPbag(reader) {
            this.genNdx = IOHelper.readUInt16LE(reader);
            this.modNdx = IOHelper.readUInt16LE(reader);
        }
        HydraPbag.SizeInFile = 4;
        return HydraPbag;
    }());
    var HydraPgen = /** @class */ (function () {
        function HydraPgen(reader) {
            this.genOper = IOHelper.readUInt16LE(reader);
            this.genAmount = new HydraGenAmount(reader);
        }
        HydraPgen.SizeInFile = 4;
        HydraPgen.GenInstrument = 41;
        HydraPgen.GenKeyRange = 43;
        HydraPgen.GenVelRange = 44;
        HydraPgen.GenSampleId = 53;
        return HydraPgen;
    }());
    var HydraPhdr = /** @class */ (function () {
        function HydraPhdr(reader) {
            this.presetName = IOHelper.read8BitStringLength(reader, 20);
            this.preset = IOHelper.readUInt16LE(reader);
            this.bank = IOHelper.readUInt16LE(reader);
            this.presetBagNdx = IOHelper.readUInt16LE(reader);
            this.library = IOHelper.readUInt32LE(reader);
            this.genre = IOHelper.readUInt32LE(reader);
            this.morphology = IOHelper.readUInt32LE(reader);
        }
        HydraPhdr.SizeInFile = 38;
        return HydraPhdr;
    }());
    var HydraPmod = /** @class */ (function () {
        function HydraPmod(reader) {
            this.modSrcOper = IOHelper.readUInt16LE(reader);
            this.modDestOper = IOHelper.readUInt16LE(reader);
            this.modAmount = IOHelper.readUInt16LE(reader);
            this.modAmtSrcOper = IOHelper.readUInt16LE(reader);
            this.modTransOper = IOHelper.readUInt16LE(reader);
        }
        HydraPmod.SizeInFile = 10;
        return HydraPmod;
    }());
    var HydraShdr = /** @class */ (function () {
        function HydraShdr(reader) {
            this.sampleName = IOHelper.read8BitStringLength(reader, 20);
            this.start = IOHelper.readUInt32LE(reader);
            this.end = IOHelper.readUInt32LE(reader);
            this.startLoop = IOHelper.readUInt32LE(reader);
            this.endLoop = IOHelper.readUInt32LE(reader);
            this.sampleRate = IOHelper.readUInt32LE(reader);
            this.originalPitch = reader.readByte();
            this.pitchCorrection = IOHelper.readSInt8(reader);
            this.sampleLink = IOHelper.readUInt16LE(reader);
            this.sampleType = IOHelper.readUInt16LE(reader);
        }
        HydraShdr.SizeInFile = 46;
        return HydraShdr;
    }());
    var HydraGenAmount = /** @class */ (function () {
        function HydraGenAmount(reader) {
            this.wordAmount = IOHelper.readUInt16LE(reader);
        }
        Object.defineProperty(HydraGenAmount.prototype, "shortAmount", {
            get: function () {
                return TypeConversions.uint16ToInt16(this.wordAmount);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HydraGenAmount.prototype, "lowByteAmount", {
            get: function () {
                return this.wordAmount & 0x00ff;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HydraGenAmount.prototype, "highByteAmount", {
            get: function () {
                return ((this.wordAmount & 0xff00) >> 8) & 0xff;
            },
            enumerable: false,
            configurable: true
        });
        return HydraGenAmount;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    var Channel = /** @class */ (function () {
        function Channel() {
            this.presetIndex = 0;
            this.bank = 0;
            this.pitchWheel = 0;
            this.perNotePitchWheel = new Map();
            this.midiPan = 0;
            this.midiVolume = 0;
            this.midiExpression = 0;
            this.midiRpn = 0;
            this.midiData = 0;
            this.panOffset = 0;
            this.gainDb = 0;
            this.pitchRange = 0;
            this.tuning = 0;
            this.mixVolume = 0;
            this.mute = false;
            this.solo = false;
        }
        return Channel;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    var Channels = /** @class */ (function () {
        function Channels() {
            this.activeChannel = 0;
            this.channelList = [];
        }
        Channels.prototype.setupVoice = function (tinySoundFont, voice) {
            var c = this.channelList[this.activeChannel];
            var newpan = voice.region.pan + c.panOffset;
            voice.playingChannel = this.activeChannel;
            voice.mixVolume = c.mixVolume;
            voice.noteGainDb += c.gainDb;
            voice.updatePitchRatio(c, tinySoundFont.outSampleRate);
            if (newpan <= -0.5) {
                voice.panFactorLeft = 1.0;
                voice.panFactorRight = 0.0;
            }
            else if (newpan >= 0.5) {
                voice.panFactorLeft = 0.0;
                voice.panFactorRight = 1.0;
            }
            else {
                voice.panFactorLeft = Math.sqrt(0.5 - newpan);
                voice.panFactorRight = Math.sqrt(0.5 + newpan);
            }
        };
        return Channels;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    var LoopMode;
    (function (LoopMode) {
        LoopMode[LoopMode["None"] = 0] = "None";
        LoopMode[LoopMode["Continuous"] = 1] = "Continuous";
        LoopMode[LoopMode["Sustain"] = 2] = "Sustain";
    })(LoopMode || (LoopMode = {}));

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    /**
     * Supported output modes by the render methods
     */
    var OutputMode;
    (function (OutputMode) {
        /**
         * Two channels with single left/right samples one after another
         */
        OutputMode[OutputMode["StereoInterleaved"] = 0] = "StereoInterleaved";
        /**
         * Two channels with all samples for the left channel first then right
         */
        OutputMode[OutputMode["StereoUnweaved"] = 1] = "StereoUnweaved";
        /**
         * A single channel (stereo instruments are mixed into center)
         */
        OutputMode[OutputMode["Mono"] = 2] = "Mono";
    })(OutputMode || (OutputMode = {}));

    var Preset = /** @class */ (function () {
        function Preset() {
            this.name = "";
            this.presetNumber = 0;
            this.bank = 0;
            this.regions = null;
            this.fontSamples = null;
        }
        return Preset;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    var SynthHelper = /** @class */ (function () {
        function SynthHelper() {
        }
        SynthHelper.timecents2Secs = function (timecents) {
            return Math.pow(2, timecents / 1200.0);
        };
        SynthHelper.decibelsToGain = function (db) {
            return db > -100 ? Math.pow(10.0, db * 0.05) : 0;
        };
        SynthHelper.gainToDecibels = function (gain) {
            return gain <= 0.00001 ? -100 : 20.0 * Math.log10(gain);
        };
        SynthHelper.cents2Hertz = function (cents) {
            return 8.176 * Math.pow(2.0, cents / 1200.0);
        };
        SynthHelper.clamp = function (value, min, max) {
            if (value <= min) {
                return min;
            }
            if (value >= max) {
                return max;
            }
            return value;
        };
        return SynthHelper;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    var Envelope = /** @class */ (function () {
        function Envelope(other) {
            this.delay = 0;
            this.attack = 0;
            this.hold = 0;
            this.decay = 0;
            this.sustain = 0;
            this.release = 0;
            this.keynumToHold = 0;
            this.keynumToDecay = 0;
            if (other) {
                this.delay = other.delay;
                this.attack = other.attack;
                this.hold = other.hold;
                this.decay = other.decay;
                this.sustain = other.sustain;
                this.release = other.release;
                this.keynumToHold = other.keynumToHold;
                this.keynumToDecay = other.keynumToDecay;
            }
        }
        Envelope.prototype.clear = function () {
            this.delay = 0;
            this.attack = 0;
            this.hold = 0;
            this.decay = 0;
            this.sustain = 0;
            this.release = 0;
            this.keynumToHold = 0;
            this.keynumToDecay = 0;
        };
        Envelope.prototype.envToSecs = function (sustainIsGain) {
            // EG times need to be converted from timecents to seconds.
            // Pin very short EG segments.  Timecents don't get to zero, and our EG is
            // happier with zero values.
            this.delay = this.delay < -11950.0 ? 0.0 : SynthHelper.timecents2Secs(this.delay);
            this.attack = this.attack < -11950.0 ? 0.0 : SynthHelper.timecents2Secs(this.attack);
            this.release = this.release < -11950.0 ? 0.0 : SynthHelper.timecents2Secs(this.release);
            // If we have dynamic hold or decay times depending on key number we need
            // to keep the values in timecents so we can calculate it during startNote
            if (this.keynumToHold === 0) {
                this.hold = this.hold < -11950.0 ? 0.0 : SynthHelper.timecents2Secs(this.hold);
            }
            if (this.keynumToDecay === 0) {
                this.decay = this.decay < -11950.0 ? 0.0 : SynthHelper.timecents2Secs(this.decay);
            }
            if (this.sustain < 0.0) {
                this.sustain = 0.0;
            }
            else if (sustainIsGain) {
                this.sustain = SynthHelper.decibelsToGain(-this.sustain / 10.0);
            }
            else {
                this.sustain = 1.0 - this.sustain / 1000.0;
            }
        };
        return Envelope;
    }());

    var GenOperators;
    (function (GenOperators) {
        GenOperators[GenOperators["StartAddrsOffset"] = 0] = "StartAddrsOffset";
        GenOperators[GenOperators["EndAddrsOffset"] = 1] = "EndAddrsOffset";
        GenOperators[GenOperators["StartloopAddrsOffset"] = 2] = "StartloopAddrsOffset";
        GenOperators[GenOperators["EndloopAddrsOffset"] = 3] = "EndloopAddrsOffset";
        GenOperators[GenOperators["StartAddrsCoarseOffset"] = 4] = "StartAddrsCoarseOffset";
        GenOperators[GenOperators["ModLfoToPitch"] = 5] = "ModLfoToPitch";
        GenOperators[GenOperators["VibLfoToPitch"] = 6] = "VibLfoToPitch";
        GenOperators[GenOperators["ModEnvToPitch"] = 7] = "ModEnvToPitch";
        GenOperators[GenOperators["InitialFilterFc"] = 8] = "InitialFilterFc";
        GenOperators[GenOperators["InitialFilterQ"] = 9] = "InitialFilterQ";
        GenOperators[GenOperators["ModLfoToFilterFc"] = 10] = "ModLfoToFilterFc";
        GenOperators[GenOperators["ModEnvToFilterFc"] = 11] = "ModEnvToFilterFc";
        GenOperators[GenOperators["EndAddrsCoarseOffset"] = 12] = "EndAddrsCoarseOffset";
        GenOperators[GenOperators["ModLfoToVolume"] = 13] = "ModLfoToVolume";
        GenOperators[GenOperators["Unused1"] = 14] = "Unused1";
        GenOperators[GenOperators["ChorusEffectsSend"] = 15] = "ChorusEffectsSend";
        GenOperators[GenOperators["ReverbEffectsSend"] = 16] = "ReverbEffectsSend";
        GenOperators[GenOperators["Pan"] = 17] = "Pan";
        GenOperators[GenOperators["Unused2"] = 18] = "Unused2";
        GenOperators[GenOperators["Unused3"] = 19] = "Unused3";
        GenOperators[GenOperators["Unused4"] = 20] = "Unused4";
        GenOperators[GenOperators["DelayModLFO"] = 21] = "DelayModLFO";
        GenOperators[GenOperators["FreqModLFO"] = 22] = "FreqModLFO";
        GenOperators[GenOperators["DelayVibLFO"] = 23] = "DelayVibLFO";
        GenOperators[GenOperators["FreqVibLFO"] = 24] = "FreqVibLFO";
        GenOperators[GenOperators["DelayModEnv"] = 25] = "DelayModEnv";
        GenOperators[GenOperators["AttackModEnv"] = 26] = "AttackModEnv";
        GenOperators[GenOperators["HoldModEnv"] = 27] = "HoldModEnv";
        GenOperators[GenOperators["DecayModEnv"] = 28] = "DecayModEnv";
        GenOperators[GenOperators["SustainModEnv"] = 29] = "SustainModEnv";
        GenOperators[GenOperators["ReleaseModEnv"] = 30] = "ReleaseModEnv";
        GenOperators[GenOperators["KeynumToModEnvHold"] = 31] = "KeynumToModEnvHold";
        GenOperators[GenOperators["KeynumToModEnvDecay"] = 32] = "KeynumToModEnvDecay";
        GenOperators[GenOperators["DelayVolEnv"] = 33] = "DelayVolEnv";
        GenOperators[GenOperators["AttackVolEnv"] = 34] = "AttackVolEnv";
        GenOperators[GenOperators["HoldVolEnv"] = 35] = "HoldVolEnv";
        GenOperators[GenOperators["DecayVolEnv"] = 36] = "DecayVolEnv";
        GenOperators[GenOperators["SustainVolEnv"] = 37] = "SustainVolEnv";
        GenOperators[GenOperators["ReleaseVolEnv"] = 38] = "ReleaseVolEnv";
        GenOperators[GenOperators["KeynumToVolEnvHold"] = 39] = "KeynumToVolEnvHold";
        GenOperators[GenOperators["KeynumToVolEnvDecay"] = 40] = "KeynumToVolEnvDecay";
        GenOperators[GenOperators["Instrument"] = 41] = "Instrument";
        GenOperators[GenOperators["Reserved1"] = 42] = "Reserved1";
        GenOperators[GenOperators["KeyRange"] = 43] = "KeyRange";
        GenOperators[GenOperators["VelRange"] = 44] = "VelRange";
        GenOperators[GenOperators["StartloopAddrsCoarseOffset"] = 45] = "StartloopAddrsCoarseOffset";
        GenOperators[GenOperators["Keynum"] = 46] = "Keynum";
        GenOperators[GenOperators["Velocity"] = 47] = "Velocity";
        GenOperators[GenOperators["InitialAttenuation"] = 48] = "InitialAttenuation";
        GenOperators[GenOperators["Reserved2"] = 49] = "Reserved2";
        GenOperators[GenOperators["EndloopAddrsCoarseOffset"] = 50] = "EndloopAddrsCoarseOffset";
        GenOperators[GenOperators["CoarseTune"] = 51] = "CoarseTune";
        GenOperators[GenOperators["FineTune"] = 52] = "FineTune";
        GenOperators[GenOperators["SampleID"] = 53] = "SampleID";
        GenOperators[GenOperators["SampleModes"] = 54] = "SampleModes";
        GenOperators[GenOperators["Reserved3"] = 55] = "Reserved3";
        GenOperators[GenOperators["ScaleTuning"] = 56] = "ScaleTuning";
        GenOperators[GenOperators["ExclusiveClass"] = 57] = "ExclusiveClass";
        GenOperators[GenOperators["OverridingRootKey"] = 58] = "OverridingRootKey";
        GenOperators[GenOperators["Unused5"] = 59] = "Unused5";
        GenOperators[GenOperators["EndOper"] = 60] = "EndOper";
    })(GenOperators || (GenOperators = {}));
    var Region = /** @class */ (function () {
        function Region(other) {
            this.loopMode = LoopMode.None;
            this.sampleRate = 0;
            this.loKey = 0;
            this.hiKey = 0;
            this.loVel = 0;
            this.hiVel = 0;
            this.group = 0;
            this.offset = 0;
            this.end = 0;
            this.loopStart = 0;
            this.loopEnd = 0;
            this.transpose = 0;
            this.tune = 0;
            this.pitchKeyCenter = 0;
            this.pitchKeyTrack = 0;
            this.attenuation = 0;
            this.pan = 0;
            this.ampEnv = new Envelope();
            this.modEnv = new Envelope();
            this.initialFilterQ = 0;
            this.initialFilterFc = 0;
            this.modEnvToPitch = 0;
            this.modEnvToFilterFc = 0;
            this.modLfoToFilterFc = 0;
            this.modLfoToVolume = 0;
            this.delayModLFO = 0;
            this.freqModLFO = 0;
            this.modLfoToPitch = 0;
            this.delayVibLFO = 0;
            this.freqVibLFO = 0;
            this.vibLfoToPitch = 0;
            if (other) {
                this.loopMode = other.loopMode;
                this.sampleRate = other.sampleRate;
                this.loKey = other.loKey;
                this.hiKey = other.hiKey;
                this.loVel = other.loVel;
                this.hiVel = other.hiVel;
                this.group = other.group;
                this.offset = other.offset;
                this.end = other.end;
                this.loopStart = other.loopStart;
                this.loopEnd = other.loopEnd;
                this.transpose = other.transpose;
                this.tune = other.tune;
                this.pitchKeyCenter = other.pitchKeyCenter;
                this.pitchKeyTrack = other.pitchKeyTrack;
                this.attenuation = other.attenuation;
                this.pan = other.pan;
                this.ampEnv = new Envelope(other.ampEnv);
                this.modEnv = new Envelope(other.modEnv);
                this.initialFilterQ = other.initialFilterQ;
                this.initialFilterFc = other.initialFilterFc;
                this.modEnvToPitch = other.modEnvToPitch;
                this.modEnvToFilterFc = other.modEnvToFilterFc;
                this.modLfoToFilterFc = other.modLfoToFilterFc;
                this.modLfoToVolume = other.modLfoToVolume;
                this.delayModLFO = other.delayModLFO;
                this.freqModLFO = other.freqModLFO;
                this.modLfoToPitch = other.modLfoToPitch;
                this.delayVibLFO = other.delayVibLFO;
                this.freqVibLFO = other.freqVibLFO;
                this.vibLfoToPitch = other.vibLfoToPitch;
            }
        }
        Region.prototype.clear = function (forRelative) {
            this.loopMode = 0;
            this.sampleRate = 0;
            this.loKey = 0;
            this.hiKey = 0;
            this.loVel = 0;
            this.hiVel = 0;
            this.group = 0;
            this.offset = 0;
            this.end = 0;
            this.loopStart = 0;
            this.loopEnd = 0;
            this.transpose = 0;
            this.tune = 0;
            this.pitchKeyCenter = 0;
            this.pitchKeyTrack = 0;
            this.attenuation = 0;
            this.pan = 0;
            this.ampEnv.clear();
            this.modEnv.clear();
            this.initialFilterQ = 0;
            this.initialFilterFc = 0;
            this.modEnvToPitch = 0;
            this.modEnvToFilterFc = 0;
            this.modLfoToFilterFc = 0;
            this.modLfoToVolume = 0;
            this.delayModLFO = 0;
            this.freqModLFO = 0;
            this.modLfoToPitch = 0;
            this.delayVibLFO = 0;
            this.freqVibLFO = 0;
            this.vibLfoToPitch = 0;
            this.hiKey = this.hiVel = 127;
            this.pitchKeyCenter = 60; // C4
            if (forRelative) {
                return;
            }
            this.pitchKeyTrack = 100;
            this.pitchKeyCenter = -1;
            // SF2 defaults in timecents.
            this.ampEnv.delay = this.ampEnv.attack = this.ampEnv.hold = this.ampEnv.decay = this.ampEnv.release = -12000.0;
            this.modEnv.delay = this.modEnv.attack = this.modEnv.hold = this.modEnv.decay = this.modEnv.release = -12000.0;
            this.initialFilterFc = 13500;
            this.delayModLFO = -12000.0;
            this.delayVibLFO = -12000.0;
        };
        Region.prototype.operator = function (genOper, amount) {
            switch (genOper) {
                case GenOperators.StartAddrsOffset:
                    this.offset += TypeConversions.int16ToUint32(amount.shortAmount);
                    break;
                case GenOperators.EndAddrsOffset:
                    this.end += TypeConversions.int16ToUint32(amount.shortAmount);
                    break;
                case GenOperators.StartloopAddrsOffset:
                    this.loopStart += TypeConversions.int16ToUint32(amount.shortAmount);
                    break;
                case GenOperators.EndloopAddrsOffset:
                    this.loopEnd += TypeConversions.int16ToUint32(amount.shortAmount);
                    break;
                case GenOperators.StartAddrsCoarseOffset:
                    this.offset += TypeConversions.int16ToUint32(amount.shortAmount) * 32768;
                    break;
                case GenOperators.ModLfoToPitch:
                    this.modLfoToPitch = amount.shortAmount;
                    break;
                case GenOperators.VibLfoToPitch:
                    this.vibLfoToPitch = amount.shortAmount;
                    break;
                case GenOperators.ModEnvToPitch:
                    this.modEnvToPitch = amount.shortAmount;
                    break;
                case GenOperators.InitialFilterFc:
                    this.initialFilterFc = amount.shortAmount;
                    break;
                case GenOperators.InitialFilterQ:
                    this.initialFilterQ = amount.shortAmount;
                    break;
                case GenOperators.ModLfoToFilterFc:
                    this.modLfoToFilterFc = amount.shortAmount;
                    break;
                case GenOperators.ModEnvToFilterFc:
                    this.modEnvToFilterFc = amount.shortAmount;
                    break;
                case GenOperators.EndAddrsCoarseOffset:
                    this.end += TypeConversions.int16ToUint32(amount.shortAmount) * 32768;
                    break;
                case GenOperators.ModLfoToVolume:
                    this.modLfoToVolume = amount.shortAmount;
                    break;
                case GenOperators.Pan:
                    this.pan = amount.shortAmount / 1000.0;
                    break;
                case GenOperators.DelayModLFO:
                    this.delayModLFO = amount.shortAmount;
                    break;
                case GenOperators.FreqModLFO:
                    this.freqModLFO = amount.shortAmount;
                    break;
                case GenOperators.DelayVibLFO:
                    this.delayVibLFO = amount.shortAmount;
                    break;
                case GenOperators.FreqVibLFO:
                    this.freqVibLFO = amount.shortAmount;
                    break;
                case GenOperators.DelayModEnv:
                    this.modEnv.delay = amount.shortAmount;
                    break;
                case GenOperators.AttackModEnv:
                    this.modEnv.attack = amount.shortAmount;
                    break;
                case GenOperators.HoldModEnv:
                    this.modEnv.hold = amount.shortAmount;
                    break;
                case GenOperators.DecayModEnv:
                    this.modEnv.decay = amount.shortAmount;
                    break;
                case GenOperators.SustainModEnv:
                    this.modEnv.sustain = amount.shortAmount;
                    break;
                case GenOperators.ReleaseModEnv:
                    this.modEnv.release = amount.shortAmount;
                    break;
                case GenOperators.KeynumToModEnvHold:
                    this.modEnv.keynumToHold = amount.shortAmount;
                    break;
                case GenOperators.KeynumToModEnvDecay:
                    this.modEnv.keynumToDecay = amount.shortAmount;
                    break;
                case GenOperators.DelayVolEnv:
                    this.ampEnv.delay = amount.shortAmount;
                    break;
                case GenOperators.AttackVolEnv:
                    this.ampEnv.attack = amount.shortAmount;
                    break;
                case GenOperators.HoldVolEnv:
                    this.ampEnv.hold = amount.shortAmount;
                    break;
                case GenOperators.DecayVolEnv:
                    this.ampEnv.decay = amount.shortAmount;
                    break;
                case GenOperators.SustainVolEnv:
                    this.ampEnv.sustain = amount.shortAmount;
                    break;
                case GenOperators.ReleaseVolEnv:
                    this.ampEnv.release = amount.shortAmount;
                    break;
                case GenOperators.KeynumToVolEnvHold:
                    this.ampEnv.keynumToHold = amount.shortAmount;
                    break;
                case GenOperators.KeynumToVolEnvDecay:
                    this.ampEnv.keynumToDecay = amount.shortAmount;
                    break;
                case GenOperators.KeyRange:
                    this.loKey = amount.lowByteAmount;
                    this.hiKey = amount.highByteAmount;
                    break;
                case GenOperators.VelRange:
                    this.loVel = amount.lowByteAmount;
                    this.hiVel = amount.highByteAmount;
                    break;
                case GenOperators.StartloopAddrsCoarseOffset:
                    this.loopStart += TypeConversions.int16ToUint32(amount.shortAmount) * 32768;
                    break;
                case GenOperators.InitialAttenuation:
                    this.attenuation += amount.shortAmount * 0.1;
                    break;
                case GenOperators.EndloopAddrsCoarseOffset:
                    this.loopEnd += TypeConversions.int16ToUint32(amount.shortAmount) * 32768;
                    break;
                case GenOperators.CoarseTune:
                    this.transpose += amount.shortAmount;
                    break;
                case GenOperators.FineTune:
                    this.tune += amount.shortAmount;
                    break;
                case GenOperators.SampleModes:
                    this.loopMode =
                        (amount.wordAmount & 3) === 3
                            ? LoopMode.Sustain
                            : (amount.wordAmount & 3) === 1
                                ? LoopMode.Continuous
                                : LoopMode.None;
                    break;
                case GenOperators.ScaleTuning:
                    this.pitchKeyTrack = amount.shortAmount;
                    break;
                case GenOperators.ExclusiveClass:
                    this.group = amount.wordAmount;
                    break;
                case GenOperators.OverridingRootKey:
                    this.pitchKeyCenter = amount.shortAmount;
                    break;
            }
        };
        return Region;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    var VoiceEnvelopeSegment;
    (function (VoiceEnvelopeSegment) {
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["None"] = 0] = "None";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Delay"] = 1] = "Delay";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Attack"] = 2] = "Attack";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Hold"] = 3] = "Hold";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Decay"] = 4] = "Decay";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Sustain"] = 5] = "Sustain";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Release"] = 6] = "Release";
        VoiceEnvelopeSegment[VoiceEnvelopeSegment["Done"] = 7] = "Done";
    })(VoiceEnvelopeSegment || (VoiceEnvelopeSegment = {}));
    var VoiceEnvelope = /** @class */ (function () {
        function VoiceEnvelope() {
            this.level = 0;
            this.slope = 0;
            this.samplesUntilNextSegment = 0;
            this.segment = VoiceEnvelopeSegment.None;
            this.midiVelocity = 0;
            this.parameters = null;
            this.segmentIsExponential = false;
            this.isAmpEnv = false;
        }
        VoiceEnvelope.prototype.nextSegment = function (activeSegment, outSampleRate) {
            if (!this.parameters) {
                return;
            }
            while (true) {
                switch (activeSegment) {
                    case VoiceEnvelopeSegment.None:
                        this.samplesUntilNextSegment = (this.parameters.delay * outSampleRate) | 0;
                        if (this.samplesUntilNextSegment > 0) {
                            this.segment = VoiceEnvelopeSegment.Delay;
                            this.segmentIsExponential = false;
                            this.level = 0.0;
                            this.slope = 0.0;
                            return;
                        }
                        activeSegment = VoiceEnvelopeSegment.Delay;
                        break;
                    case VoiceEnvelopeSegment.Delay:
                        this.samplesUntilNextSegment = (this.parameters.attack * outSampleRate) | 0;
                        if (this.samplesUntilNextSegment > 0) {
                            if (!this.isAmpEnv) {
                                // mod env attack duration scales with velocity (velocity of 1 is full duration, max velocity is 0.125 times duration)
                                this.samplesUntilNextSegment =
                                    (this.parameters.attack * ((145 - this.midiVelocity) / 144.0) * outSampleRate) | 0;
                            }
                            this.segment = VoiceEnvelopeSegment.Attack;
                            this.segmentIsExponential = false;
                            this.level = 0.0;
                            this.slope = 1.0 / this.samplesUntilNextSegment;
                            return;
                        }
                        activeSegment = VoiceEnvelopeSegment.Attack;
                        break;
                    case VoiceEnvelopeSegment.Attack:
                        this.samplesUntilNextSegment = (this.parameters.hold * outSampleRate) | 0;
                        if (this.samplesUntilNextSegment > 0) {
                            this.segment = VoiceEnvelopeSegment.Hold;
                            this.segmentIsExponential = false;
                            this.level = 1.0;
                            this.slope = 0.0;
                            return;
                        }
                        activeSegment = VoiceEnvelopeSegment.Hold;
                        break;
                    case VoiceEnvelopeSegment.Hold:
                        this.samplesUntilNextSegment = (this.parameters.decay * outSampleRate) | 0;
                        if (this.samplesUntilNextSegment > 0) {
                            this.segment = VoiceEnvelopeSegment.Decay;
                            this.level = 1.0;
                            if (this.isAmpEnv) {
                                // I don't truly understand this; just following what LinuxSampler does.
                                var mysterySlope = -9.226 / this.samplesUntilNextSegment;
                                this.slope = Math.exp(mysterySlope);
                                this.segmentIsExponential = true;
                                if (this.parameters.sustain > 0.0) {
                                    // Again, this is following LinuxSampler's example, which is similar to
                                    // SF2-style decay, where "decay" specifies the time it would take to
                                    // get to zero, not to the sustain level.  The SFZ spec is not that
                                    // specific about what "decay" means, so perhaps it's really supposed
                                    // to specify the time to reach the sustain level.
                                    this.samplesUntilNextSegment = (Math.log(this.parameters.sustain) / mysterySlope) | 0;
                                }
                            }
                            else {
                                this.slope = -1.0 / this.samplesUntilNextSegment;
                                this.samplesUntilNextSegment =
                                    (this.parameters.decay * (1.0 - this.parameters.sustain) * outSampleRate) | 0;
                                this.segmentIsExponential = false;
                            }
                            return;
                        }
                        activeSegment = VoiceEnvelopeSegment.Decay;
                        break;
                    case VoiceEnvelopeSegment.Decay:
                        this.segment = VoiceEnvelopeSegment.Sustain;
                        this.level = this.parameters.sustain;
                        this.slope = 0.0;
                        this.samplesUntilNextSegment = 0x7fffffff;
                        this.segmentIsExponential = false;
                        return;
                    case VoiceEnvelopeSegment.Sustain:
                        this.segment = VoiceEnvelopeSegment.Release;
                        this.samplesUntilNextSegment =
                            ((this.parameters.release <= 0 ? VoiceEnvelope.FastReleaseTime : this.parameters.release) *
                                outSampleRate) | 0;
                        if (this.isAmpEnv) {
                            // I don't truly understand this; just following what LinuxSampler does.
                            var mysterySlope = -9.226 / this.samplesUntilNextSegment;
                            this.slope = Math.exp(mysterySlope);
                            this.segmentIsExponential = true;
                        }
                        else {
                            this.slope = -this.level / this.samplesUntilNextSegment;
                            this.segmentIsExponential = false;
                        }
                        return;
                    case VoiceEnvelopeSegment.Release:
                    default:
                        this.segment = VoiceEnvelopeSegment.Done;
                        this.segmentIsExponential = false;
                        this.level = this.slope = 0.0;
                        this.samplesUntilNextSegment = 0x7ffffff;
                        return;
                }
            }
        };
        VoiceEnvelope.prototype.setup = function (newParameters, midiNoteNumber, midiVelocity, isAmpEnv, outSampleRate) {
            this.parameters = new Envelope(newParameters);
            if (this.parameters.keynumToHold > 0) {
                this.parameters.hold += this.parameters.keynumToHold * (60.0 - midiNoteNumber);
                this.parameters.hold =
                    this.parameters.hold < -10000.0 ? 0.0 : SynthHelper.timecents2Secs(this.parameters.hold);
            }
            if (this.parameters.keynumToDecay > 0) {
                this.parameters.decay += this.parameters.keynumToDecay * (60.0 - midiNoteNumber);
                this.parameters.decay =
                    this.parameters.decay < -10000.0 ? 0.0 : SynthHelper.timecents2Secs(this.parameters.decay);
            }
            this.midiVelocity = midiVelocity | 0;
            this.isAmpEnv = isAmpEnv;
            this.nextSegment(VoiceEnvelopeSegment.None, outSampleRate);
        };
        VoiceEnvelope.prototype.process = function (numSamples, outSampleRate) {
            if (this.slope > 0) {
                if (this.segmentIsExponential) {
                    this.level *= Math.pow(this.slope, numSamples);
                }
                else {
                    this.level += this.slope * numSamples;
                }
            }
            // tslint:disable-next-line: no-conditional-assignment
            if ((this.samplesUntilNextSegment -= numSamples) <= 0) {
                this.nextSegment(this.segment, outSampleRate);
            }
        };
        VoiceEnvelope.FastReleaseTime = 0.01;
        return VoiceEnvelope;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    var VoiceLfo = /** @class */ (function () {
        function VoiceLfo() {
            this.samplesUntil = 0;
            this.level = 0;
            this.delta = 0;
        }
        VoiceLfo.prototype.setup = function (delay, freqCents, outSampleRate) {
            this.samplesUntil = (delay * outSampleRate) | 0;
            this.delta = (4.0 * SynthHelper.cents2Hertz(freqCents)) / outSampleRate;
            this.level = 0;
        };
        VoiceLfo.prototype.process = function (blockSamples) {
            if (this.samplesUntil > blockSamples) {
                this.samplesUntil -= blockSamples;
                return;
            }
            this.level += this.delta * blockSamples;
            if (this.level > 1.0) {
                this.delta = -this.delta;
                this.level = 2.0 - this.level;
            }
            else if (this.level < -1.0) {
                this.delta = -this.delta;
                this.level = -2.0 - this.level;
            }
        };
        return VoiceLfo;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    // developed by Bernhard Schelling (https://github.com/schellingb/TinySoundFont)
    // TypeScript port for alphaTab: (C) 2020 by Daniel Kuschny
    // Licensed under: MPL-2.0
    var VoiceLowPass = /** @class */ (function () {
        function VoiceLowPass(other) {
            this.qInv = 0;
            this.a0 = 0;
            this.a1 = 0;
            this.b1 = 0;
            this.b2 = 0;
            this.z1 = 0;
            this.z2 = 0;
            this.active = false;
            if (other) {
                this.qInv = other.qInv;
                this.a0 = other.a0;
                this.a1 = other.a1;
                this.b1 = other.b1;
                this.b2 = other.b2;
                this.z1 = other.z1;
                this.z2 = other.z2;
                this.active = other.active;
            }
        }
        VoiceLowPass.prototype.setup = function (fc) {
            // Lowpass filter from http://www.earlevel.com/main/2012/11/26/biquad-c-source-code/
            var k = Math.tan(Math.PI * fc);
            var KK = k * k;
            var norm = 1 / (1 + k * this.qInv + KK);
            this.a0 = KK * norm;
            this.a1 = 2 * this.a0;
            this.b1 = 2 * (KK - 1) * norm;
            this.b2 = (1 - k * this.qInv + KK) * norm;
        };
        VoiceLowPass.prototype.process = function (input) {
            var output = input * this.a0 + this.z1;
            this.z1 = input * this.a1 + this.z2 - this.b1 * output;
            this.z2 = input * this.a0 - this.b2 * output;
            return output;
        };
        return VoiceLowPass;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    var Voice$1 = /** @class */ (function () {
        function Voice() {
            this.playingPreset = 0;
            this.playingKey = 0;
            this.playingChannel = 0;
            this.region = null;
            this.pitchInputTimecents = 0;
            this.pitchOutputFactor = 0;
            this.sourceSamplePosition = 0;
            this.noteGainDb = 0;
            this.panFactorLeft = 0;
            this.panFactorRight = 0;
            this.playIndex = 0;
            this.loopStart = 0;
            this.loopEnd = 0;
            this.ampEnv = new VoiceEnvelope();
            this.modEnv = new VoiceEnvelope();
            this.lowPass = new VoiceLowPass();
            this.modLfo = new VoiceLfo();
            this.vibLfo = new VoiceLfo();
            this.mixVolume = 0;
            this.mute = false;
        }
        Voice.prototype.updatePitchRatio = function (c, outSampleRate) {
            var pitchWheel = c.pitchWheel;
            // add additional note pitch
            if (c.perNotePitchWheel.has(this.playingKey)) {
                pitchWheel += (c.perNotePitchWheel.get(this.playingKey) - 8192);
            }
            var pitchShift = pitchWheel === 8192
                ? c.tuning
                : (pitchWheel / 16383.0 * c.pitchRange * 2) - c.pitchRange + c.tuning;
            this.calcPitchRatio(pitchShift, outSampleRate);
        };
        Voice.prototype.calcPitchRatio = function (pitchShift, outSampleRate) {
            if (!this.region) {
                return;
            }
            var note = this.playingKey + this.region.transpose + this.region.tune / 100.0;
            var adjustedPitch = this.region.pitchKeyCenter + (note - this.region.pitchKeyCenter) * (this.region.pitchKeyTrack / 100.0);
            if (pitchShift !== 0)
                adjustedPitch += pitchShift;
            this.pitchInputTimecents = adjustedPitch * 100.0;
            this.pitchOutputFactor =
                this.region.sampleRate / (SynthHelper.timecents2Secs(this.region.pitchKeyCenter * 100.0) * outSampleRate);
        };
        Voice.prototype.end = function (outSampleRate) {
            if (!this.region) {
                return;
            }
            this.ampEnv.nextSegment(VoiceEnvelopeSegment.Sustain, outSampleRate);
            this.modEnv.nextSegment(VoiceEnvelopeSegment.Sustain, outSampleRate);
            if (this.region.loopMode === LoopMode.Sustain) {
                // Continue playing, but stop looping.
                this.loopEnd = this.loopStart;
            }
        };
        Voice.prototype.endQuick = function (outSampleRate) {
            this.ampEnv.parameters.release = 0.0;
            this.ampEnv.nextSegment(VoiceEnvelopeSegment.Sustain, outSampleRate);
            this.modEnv.parameters.release = 0.0;
            this.modEnv.nextSegment(VoiceEnvelopeSegment.Sustain, outSampleRate);
        };
        Voice.prototype.render = function (f, outputBuffer, offset, numSamples, isMuted) {
            if (!this.region) {
                return;
            }
            var region = this.region;
            var preset = f.presets[this.playingPreset];
            var input = preset.fontSamples;
            var outL = 0;
            var outR = f.outputMode === OutputMode.StereoUnweaved ? numSamples : -1;
            // Cache some values, to give them at least some chance of ending up in registers.
            var updateModEnv = region.modEnvToPitch !== 0 || region.modEnvToFilterFc !== 0;
            var updateModLFO = this.modLfo.delta > 0 &&
                (region.modLfoToPitch !== 0 || region.modLfoToFilterFc !== 0 || region.modLfoToVolume !== 0);
            var updateVibLFO = this.vibLfo.delta > 0 && region.vibLfoToPitch !== 0;
            var isLooping = this.loopStart < this.loopEnd;
            var tmpLoopStart = this.loopStart;
            var tmpLoopEnd = this.loopEnd;
            var tmpSampleEndDbl = region.end;
            var tmpLoopEndDbl = tmpLoopEnd + 1.0;
            var tmpSourceSamplePosition = this.sourceSamplePosition;
            var tmpLowpass = new VoiceLowPass(this.lowPass);
            var dynamicLowpass = region.modLfoToFilterFc !== 0 || region.modEnvToFilterFc !== 0;
            var tmpSampleRate = 0;
            var tmpInitialFilterFc = 0;
            var tmpModLfoToFilterFc = 0;
            var tmpModEnvToFilterFc = 0;
            var dynamicPitchRatio = region.modLfoToPitch !== 0 || region.modEnvToPitch !== 0 || region.vibLfoToPitch !== 0;
            var pitchRatio = 0;
            var tmpModLfoToPitch = 0;
            var tmpVibLfoToPitch = 0;
            var tmpModEnvToPitch = 0;
            var dynamicGain = region.modLfoToVolume !== 0;
            var noteGain = 0;
            var tmpModLfoToVolume = 0;
            if (dynamicLowpass) {
                tmpSampleRate = f.outSampleRate;
                tmpInitialFilterFc = region.initialFilterFc;
                tmpModLfoToFilterFc = region.modLfoToFilterFc;
                tmpModEnvToFilterFc = region.modEnvToFilterFc;
            }
            else {
                tmpSampleRate = 0;
                tmpInitialFilterFc = 0;
                tmpModLfoToFilterFc = 0;
                tmpModEnvToFilterFc = 0;
            }
            if (dynamicPitchRatio) {
                pitchRatio = 0;
                tmpModLfoToPitch = region.modLfoToPitch;
                tmpVibLfoToPitch = region.vibLfoToPitch;
                tmpModEnvToPitch = region.modEnvToPitch;
            }
            else {
                pitchRatio = SynthHelper.timecents2Secs(this.pitchInputTimecents) * this.pitchOutputFactor;
                tmpModLfoToPitch = 0;
                tmpVibLfoToPitch = 0;
                tmpModEnvToPitch = 0;
            }
            if (dynamicGain) {
                tmpModLfoToVolume = region.modLfoToVolume * 0.1;
            }
            else {
                noteGain = SynthHelper.decibelsToGain(this.noteGainDb);
                tmpModLfoToVolume = 0;
            }
            while (numSamples > 0) {
                var gainMono = void 0;
                var gainLeft = void 0;
                var gainRight = 0;
                var blockSamples = numSamples > Voice.RenderEffectSampleBlock ? Voice.RenderEffectSampleBlock : numSamples;
                numSamples -= blockSamples;
                if (dynamicLowpass) {
                    var fres = tmpInitialFilterFc +
                        this.modLfo.level * tmpModLfoToFilterFc +
                        this.modEnv.level * tmpModEnvToFilterFc;
                    tmpLowpass.active = fres <= 13500.0;
                    if (tmpLowpass.active) {
                        tmpLowpass.setup(SynthHelper.cents2Hertz(fres) / tmpSampleRate);
                    }
                }
                if (dynamicPitchRatio) {
                    pitchRatio =
                        SynthHelper.timecents2Secs(this.pitchInputTimecents +
                            (this.modLfo.level * tmpModLfoToPitch +
                                this.vibLfo.level * tmpVibLfoToPitch +
                                this.modEnv.level * tmpModEnvToPitch)) * this.pitchOutputFactor;
                }
                if (dynamicGain) {
                    noteGain = SynthHelper.decibelsToGain(this.noteGainDb + this.modLfo.level * tmpModLfoToVolume);
                }
                gainMono = noteGain * this.ampEnv.level;
                if (isMuted) {
                    gainMono = 0;
                }
                else {
                    gainMono *= this.mixVolume;
                }
                // Update EG.
                this.ampEnv.process(blockSamples, f.outSampleRate);
                if (updateModEnv) {
                    this.modEnv.process(blockSamples, f.outSampleRate);
                }
                // Update LFOs.
                if (updateModLFO) {
                    this.modLfo.process(blockSamples);
                }
                if (updateVibLFO) {
                    this.vibLfo.process(blockSamples);
                }
                switch (f.outputMode) {
                    case OutputMode.StereoInterleaved:
                        gainLeft = gainMono * this.panFactorLeft;
                        gainRight = gainMono * this.panFactorRight;
                        while (blockSamples-- > 0 && tmpSourceSamplePosition < tmpSampleEndDbl) {
                            var pos = tmpSourceSamplePosition | 0;
                            var nextPos = pos >= tmpLoopEnd && isLooping ? tmpLoopStart : pos + 1;
                            // Simple linear interpolation.
                            // TODO: check for interpolation mode on voice
                            var alpha = tmpSourceSamplePosition - pos;
                            var val = input[pos] * (1.0 - alpha) + input[nextPos] * alpha;
                            // Low-pass filter.
                            if (tmpLowpass.active)
                                val = tmpLowpass.process(val);
                            outputBuffer[offset + outL] += val * gainLeft;
                            outL++;
                            outputBuffer[offset + outL] += val * gainRight;
                            outL++;
                            // Next sample.
                            tmpSourceSamplePosition += pitchRatio;
                            if (tmpSourceSamplePosition >= tmpLoopEndDbl && isLooping) {
                                tmpSourceSamplePosition -= tmpLoopEnd - tmpLoopStart + 1.0;
                            }
                        }
                        break;
                    case OutputMode.StereoUnweaved:
                        gainLeft = gainMono * this.panFactorLeft;
                        gainRight = gainMono * this.panFactorRight;
                        while (blockSamples-- > 0 && tmpSourceSamplePosition < tmpSampleEndDbl) {
                            var pos = tmpSourceSamplePosition | 0;
                            var nextPos = pos >= tmpLoopEnd && isLooping ? tmpLoopStart : pos + 1;
                            // Simple linear interpolation.
                            var alpha = tmpSourceSamplePosition - pos;
                            var val = input[pos] * (1.0 - alpha) + input[nextPos] * alpha;
                            // Low-pass filter.
                            if (tmpLowpass.active)
                                val = tmpLowpass.process(val);
                            outputBuffer[offset + outL] += val * gainLeft;
                            outL++;
                            outputBuffer[offset + outR] += val * gainRight;
                            outR++;
                            // Next sample.
                            tmpSourceSamplePosition += pitchRatio;
                            if (tmpSourceSamplePosition >= tmpLoopEndDbl && isLooping) {
                                tmpSourceSamplePosition -= tmpLoopEnd - tmpLoopStart + 1.0;
                            }
                        }
                        break;
                    case OutputMode.Mono:
                        while (blockSamples-- > 0 && tmpSourceSamplePosition < tmpSampleEndDbl) {
                            var pos = tmpSourceSamplePosition | 0;
                            var nextPos = pos >= tmpLoopEnd && isLooping ? tmpLoopStart : pos + 1;
                            // Simple linear interpolation.
                            var alpha = tmpSourceSamplePosition - pos;
                            var val = input[pos] * (1.0 - alpha) + input[nextPos] * alpha;
                            // Low-pass filter.
                            if (tmpLowpass.active)
                                val = tmpLowpass.process(val);
                            outputBuffer[offset + outL] = val * gainMono;
                            outL++;
                            // Next sample.
                            tmpSourceSamplePosition += pitchRatio;
                            if (tmpSourceSamplePosition >= tmpLoopEndDbl && isLooping) {
                                tmpSourceSamplePosition -= tmpLoopEnd - tmpLoopStart + 1.0;
                            }
                        }
                        break;
                }
                if (tmpSourceSamplePosition >= tmpSampleEndDbl || this.ampEnv.segment === VoiceEnvelopeSegment.Done) {
                    this.kill();
                    return;
                }
            }
            this.sourceSamplePosition = tmpSourceSamplePosition;
            if (tmpLowpass.active || dynamicLowpass) {
                this.lowPass = tmpLowpass;
            }
        };
        Voice.prototype.kill = function () {
            this.playingPreset = -1;
        };
        /**
         * The lower this block size is the more accurate the effects are.
         * Increasing the value significantly lowers the CPU usage of the voice rendering.
         * If LFO affects the low-pass filter it can be hearable even as low as 8.
         */
        Voice.RenderEffectSampleBlock = SynthConstants.MicroBufferSize;
        return Voice;
    }());

    // The SoundFont loading and Audio Synthesis is based on TinySoundFont, licensed under MIT,
    /**
     * This is a tiny soundfont based synthesizer.
     * NOT YET IMPLEMENTED
     *   - Support for ChorusEffectsSend and ReverbEffectsSend generators
     *   - Better low-pass filter without lowering performance too much
     *   - Support for modulators
     */
    var TinySoundFont = /** @class */ (function () {
        function TinySoundFont(sampleRate) {
            this._midiEventQueue = [];
            this._midiEventCount = 0;
            this._mutedChannels = new Map();
            this._soloChannels = new Map();
            this._isAnySolo = false;
            this.currentTempo = 0;
            this.timeSignatureNumerator = 0;
            this.timeSignatureDenominator = 0;
            this.presets = null;
            this._voices = [];
            this._channels = null;
            this._voicePlayIndex = 0;
            /**
             * Gets the currently configured output mode.
             */
            this.outputMode = OutputMode.StereoInterleaved;
            /**
             * Gets the currently configured sample rate.
             */
            this.outSampleRate = 0;
            /**
             * Gets the currently configured global gain in DB.
             */
            this.globalGainDb = 0;
            this.outSampleRate = sampleRate;
        }
        TinySoundFont.prototype.synthesize = function (buffer, bufferPos, sampleCount) {
            this.fillWorkingBuffer(buffer, bufferPos, sampleCount);
        };
        TinySoundFont.prototype.synthesizeSilent = function (sampleCount) {
            this.fillWorkingBuffer(null, 0, sampleCount);
        };
        TinySoundFont.prototype.channelGetMixVolume = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].mixVolume
                : 1.0;
        };
        TinySoundFont.prototype.channelSetMixVolume = function (channel, volume) {
            var c = this.channelInit(channel);
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingChannel === channel && v.playingPreset !== -1) {
                    v.mixVolume = volume;
                }
            }
            c.mixVolume = volume;
        };
        TinySoundFont.prototype.channelSetMute = function (channel, mute) {
            if (mute) {
                this._mutedChannels.set(channel, true);
            }
            else {
                this._mutedChannels.delete(channel);
            }
        };
        TinySoundFont.prototype.channelSetSolo = function (channel, solo) {
            if (solo) {
                this._soloChannels.set(channel, true);
            }
            else {
                this._soloChannels.delete(channel);
            }
            this._isAnySolo = this._soloChannels.size > 0;
        };
        TinySoundFont.prototype.resetChannelStates = function () {
            this._mutedChannels = new Map();
            this._soloChannels = new Map();
            this._isAnySolo = false;
        };
        TinySoundFont.prototype.dispatchEvent = function (synthEvent) {
            this._midiEventQueue.unshift(synthEvent);
            this._midiEventCount++;
        };
        TinySoundFont.prototype.fillWorkingBuffer = function (buffer, bufferPos, sampleCount) {
            // Break the process loop into sections representing the smallest timeframe before the midi controls need to be updated
            // the bigger the timeframe the more efficent the process is, but playback quality will be reduced.
            var anySolo = this._isAnySolo;
            // process in micro-buffers
            // process events for first microbuffer
            if (this._midiEventQueue.length > 0) {
                for (var i = 0; i < this._midiEventCount; i++) {
                    var m = this._midiEventQueue.pop();
                    if (m) {
                        if (m.isMetronome && this.metronomeVolume > 0) {
                            this.channelNoteOff(SynthConstants.MetronomeChannel, 33);
                            this.channelNoteOn(SynthConstants.MetronomeChannel, 33, 95 / 127);
                        }
                        else if (m.event) {
                            this.processMidiMessage(m.event);
                        }
                    }
                }
            }
            // voice processing loop
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                if (voice.playingPreset !== -1) {
                    var channel = voice.playingChannel;
                    // channel is muted if it is either explicitley muted, or another channel is set to solo but not this one.
                    // exception. metronome is implicitly added in solo
                    var isChannelMuted = this._mutedChannels.has(channel)
                        || (anySolo && channel != SynthConstants.MetronomeChannel && !this._soloChannels.has(channel));
                    if (!buffer) {
                        voice.kill();
                    }
                    else {
                        voice.render(this, buffer, bufferPos, sampleCount, isChannelMuted);
                    }
                }
            }
            this._midiEventCount = 0;
        };
        TinySoundFont.prototype.processMidiMessage = function (e) {
            Logger.debug('Midi', 'Processing midi ' + e.command);
            var command = e.command;
            var channel = e.channel;
            var data1 = e.data1;
            var data2 = e.data2;
            switch (command) {
                case MidiEventType.NoteOff:
                    this.channelNoteOff(channel, data1);
                    break;
                case MidiEventType.NoteOn:
                    this.channelNoteOn(channel, data1, data2 / 127.0);
                    break;
                case MidiEventType.NoteAftertouch:
                    break;
                case MidiEventType.Controller:
                    this.channelMidiControl(channel, data1, data2);
                    break;
                case MidiEventType.ProgramChange:
                    this.channelSetPresetNumber(channel, data1, channel === 9);
                    break;
                case MidiEventType.ChannelAftertouch:
                    break;
                case MidiEventType.PitchBend:
                    this.channelSetPitchWheel(channel, data1 | (data2 << 7));
                    break;
                case MidiEventType.PerNotePitchBend:
                    var midi20 = e;
                    var perNotePitchWheel = midi20.pitch;
                    // midi 2.0 -> midi 1.0
                    perNotePitchWheel = (perNotePitchWheel * SynthConstants.MaxPitchWheel) / SynthConstants.MaxPitchWheel20;
                    this.channelSetPerNotePitchWheel(channel, midi20.noteKey, perNotePitchWheel);
                    break;
                case MidiEventType.Meta:
                    switch (e.data1) {
                        case MetaEventType.Tempo:
                            this.currentTempo = 60000000 / e.value;
                            break;
                        case MetaEventType.TimeSignature:
                            this.timeSignatureNumerator = e.data[0];
                            this.timeSignatureDenominator = Math.pow(2, e.data[1]);
                            break;
                    }
                    break;
            }
        };
        Object.defineProperty(TinySoundFont.prototype, "metronomeVolume", {
            get: function () {
                return this.channelGetMixVolume(SynthConstants.MetronomeChannel);
            },
            set: function (value) {
                this.setupMetronomeChannel(value);
            },
            enumerable: false,
            configurable: true
        });
        TinySoundFont.prototype.setupMetronomeChannel = function (volume) {
            this.channelSetMixVolume(SynthConstants.MetronomeChannel, volume);
            if (volume > 0) {
                this.channelSetVolume(SynthConstants.MetronomeChannel, 1);
                this.channelSetPresetNumber(SynthConstants.MetronomeChannel, 0, true);
            }
        };
        Object.defineProperty(TinySoundFont.prototype, "masterVolume", {
            get: function () {
                return SynthHelper.decibelsToGain(this.globalGainDb);
            },
            set: function (value) {
                var gainDb = SynthHelper.gainToDecibels(value);
                var gainDBChange = gainDb - this.globalGainDb;
                if (gainDBChange === 0) {
                    return;
                }
                for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    if (v.playingPreset !== -1) {
                        v.noteGainDb += gainDBChange;
                    }
                }
                this.globalGainDb = gainDb;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Stop all playing notes immediatly and reset all channel parameters but keeps user
         * defined settings
         */
        TinySoundFont.prototype.resetSoft = function () {
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingPreset !== -1 &&
                    (v.ampEnv.segment < VoiceEnvelopeSegment.Release || v.ampEnv.parameters.release !== 0)) {
                    v.endQuick(this.outSampleRate);
                }
            }
            if (this._channels) {
                for (var _b = 0, _c = this._channels.channelList; _b < _c.length; _b++) {
                    var c = _c[_b];
                    c.presetIndex = c.bank = 0;
                    c.pitchWheel = c.midiPan = 8192;
                    c.perNotePitchWheel.clear();
                    c.midiVolume = c.midiExpression = 16383;
                    c.midiRpn = 0xffff;
                    c.midiData = 0;
                    c.panOffset = 0.0;
                    c.gainDb = 0.0;
                    c.pitchRange = 2.0;
                    c.tuning = 0.0;
                }
            }
        };
        Object.defineProperty(TinySoundFont.prototype, "presetCount", {
            get: function () {
                var _a, _b;
                return (_b = (_a = this.presets) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Stop all playing notes immediatly and reset all channel parameters
         */
        TinySoundFont.prototype.reset = function () {
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingPreset !== -1 &&
                    (v.ampEnv.segment < VoiceEnvelopeSegment.Release || v.ampEnv.parameters.release !== 0)) {
                    v.endQuick(this.outSampleRate);
                }
            }
            this._channels = null;
        };
        /**
         * Setup the parameters for the voice render methods
         * @param outputMode if mono or stereo and how stereo channel data is ordered
         * @param sampleRate the number of samples per second (output frequency)
         * @param globalGainDb volume gain in decibels (>0 means higher, <0 means lower)
         */
        TinySoundFont.prototype.setOutput = function (outputMode, sampleRate, globalGainDb) {
            this.outputMode = outputMode;
            this.outSampleRate = sampleRate >= 1 ? sampleRate : 44100.0;
            this.globalGainDb = globalGainDb;
        };
        /**
         * Start playing a note
         * @param presetIndex preset index >= 0 and < {@link presetCount}
         * @param key note value between 0 and 127 (60 being middle C)
         * @param vel velocity as a float between 0.0 (equal to note off) and 1.0 (full)
         */
        TinySoundFont.prototype.noteOn = function (presetIndex, key, vel) {
            if (!this.presets) {
                return;
            }
            var midiVelocity = (vel * 127) | 0;
            if (presetIndex < 0 || presetIndex >= this.presets.length) {
                return;
            }
            if (vel <= 0.0) {
                this.noteOff(presetIndex, key);
                return;
            }
            // Play all matching regions.
            var voicePlayIndex = this._voicePlayIndex++;
            for (var _i = 0, _a = this.presets[presetIndex].regions; _i < _a.length; _i++) {
                var region = _a[_i];
                if (key < region.loKey ||
                    key > region.hiKey ||
                    midiVelocity < region.loVel ||
                    midiVelocity > region.hiVel) {
                    continue;
                }
                var voice = null;
                if (region.group !== 0) {
                    for (var _b = 0, _c = this._voices; _b < _c.length; _b++) {
                        var v = _c[_b];
                        if (v.playingPreset === presetIndex && v.region.group === region.group) {
                            v.endQuick(this.outSampleRate);
                        }
                        else if (v.playingPreset === -1 && !voice) {
                            voice = v;
                        }
                    }
                }
                else {
                    for (var _d = 0, _e = this._voices; _d < _e.length; _d++) {
                        var v = _e[_d];
                        if (v.playingPreset === -1) {
                            voice = v;
                        }
                    }
                }
                if (!voice) {
                    for (var i = 0; i < 4; i++) {
                        var newVoice = new Voice$1();
                        newVoice.playingPreset = -1;
                        this._voices.push(newVoice);
                    }
                    voice = this._voices[this._voices.length - 4];
                }
                voice.region = region;
                voice.playingPreset = presetIndex;
                voice.playingKey = key;
                voice.playIndex = voicePlayIndex;
                voice.noteGainDb = this.globalGainDb - region.attenuation - SynthHelper.gainToDecibels(1.0 / vel);
                if (this._channels) {
                    this._channels.setupVoice(this, voice);
                }
                else {
                    voice.calcPitchRatio(0, this.outSampleRate);
                    // The SFZ spec is silent about the pan curve, but a 3dB pan law seems common. This sqrt() curve matches what Dimension LE does; Alchemy Free seems closer to sin(adjustedPan * pi/2).
                    voice.panFactorLeft = Math.sqrt(0.5 - region.pan);
                    voice.panFactorRight = Math.sqrt(0.5 + region.pan);
                }
                // Offset/end.
                voice.sourceSamplePosition = region.offset;
                // Loop.
                var doLoop = region.loopMode !== LoopMode.None && region.loopStart < region.loopEnd;
                voice.loopStart = doLoop ? region.loopStart : 0;
                voice.loopEnd = doLoop ? region.loopEnd : 0;
                // Setup envelopes.
                voice.ampEnv.setup(region.ampEnv, key, midiVelocity, true, this.outSampleRate);
                voice.modEnv.setup(region.modEnv, key, midiVelocity, false, this.outSampleRate);
                // Setup lowpass filter.
                var filterQDB = region.initialFilterQ / 10.0;
                voice.lowPass.qInv = 1.0 / Math.pow(10.0, filterQDB / 20.0);
                voice.lowPass.z1 = voice.lowPass.z2 = 0;
                voice.lowPass.active = region.initialFilterFc <= 13500;
                if (voice.lowPass.active) {
                    voice.lowPass.setup(SynthHelper.cents2Hertz(region.initialFilterFc) / this.outSampleRate);
                }
                // Setup LFO filters.
                voice.modLfo.setup(region.delayModLFO, region.freqModLFO, this.outSampleRate);
                voice.vibLfo.setup(region.delayVibLFO, region.freqVibLFO, this.outSampleRate);
            }
        };
        /**
         * Start playing a note
         * @param bank instrument bank number (alternative to preset_index)
         * @param presetNumber preset number (alternative to preset_index)
         * @param key note value between 0 and 127 (60 being middle C)
         * @param vel velocity as a float between 0.0 (equal to note off) and 1.0 (full)
         * @returns returns false if preset does not exist, otherwise true
         */
        TinySoundFont.prototype.bankNoteOn = function (bank, presetNumber, key, vel) {
            var presetIndex = this.getPresetIndex(bank, presetNumber);
            if (presetIndex === -1) {
                return false;
            }
            this.noteOn(presetIndex, key, vel);
            return true;
        };
        /**
         * Stop playing a note
         */
        TinySoundFont.prototype.noteOff = function (presetIndex, key) {
            var matchFirst = null;
            var matchLast = null;
            var matches = [];
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingPreset !== presetIndex ||
                    v.playingKey !== key ||
                    v.ampEnv.segment >= VoiceEnvelopeSegment.Release) {
                    continue;
                }
                else if (!matchFirst || v.playIndex < matchFirst.playIndex) {
                    matchFirst = v;
                    matchLast = v;
                    matches.push(v);
                }
                else if (v.playIndex === matchFirst.playIndex) {
                    matchLast = v;
                    matches.push(v);
                }
            }
            if (!matchFirst) {
                return;
            }
            for (var _b = 0, matches_1 = matches; _b < matches_1.length; _b++) {
                var v = matches_1[_b];
                if (v !== matchFirst &&
                    v !== matchLast &&
                    (v.playIndex !== matchFirst.playIndex ||
                        v.playingPreset !== presetIndex ||
                        v.playingKey !== key ||
                        v.ampEnv.segment >= VoiceEnvelopeSegment.Release)) {
                    continue;
                }
                v.end(this.outSampleRate);
            }
        };
        /**
         * Stop playing a note
         * @returns returns false if preset does not exist, otherwise true
         */
        TinySoundFont.prototype.bankNoteOff = function (bank, presetNumber, key) {
            var presetIndex = this.getPresetIndex(bank, presetNumber);
            if (presetIndex === -1) {
                return false;
            }
            this.noteOff(presetIndex, key);
            return true;
        };
        /**
         * Stop playing all notes (end with sustain and release)
         */
        TinySoundFont.prototype.noteOffAll = function (immediate) {
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                if (voice.playingPreset !== -1 && voice.ampEnv.segment < VoiceEnvelopeSegment.Release) {
                    if (immediate) {
                        voice.endQuick(this.outSampleRate);
                    }
                    else {
                        voice.end(this.outSampleRate);
                    }
                }
            }
        };
        Object.defineProperty(TinySoundFont.prototype, "activeVoiceCount", {
            get: function () {
                var count = 0;
                for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                    var v = _a[_i];
                    if (v.playingPreset !== -1) {
                        count++;
                    }
                }
                return count;
            },
            enumerable: false,
            configurable: true
        });
        TinySoundFont.prototype.channelInit = function (channel) {
            if (this._channels && channel < this._channels.channelList.length) {
                return this._channels.channelList[channel];
            }
            if (!this._channels) {
                this._channels = new Channels();
            }
            for (var i = this._channels.channelList.length; i <= channel; i++) {
                var c = new Channel();
                c.presetIndex = c.bank = 0;
                c.pitchWheel = c.midiPan = 8192;
                c.midiVolume = c.midiExpression = 16383;
                c.midiRpn = 0xffff;
                c.midiData = 0;
                c.panOffset = 0.0;
                c.gainDb = 0.0;
                c.pitchRange = 2.0;
                c.tuning = 0.0;
                c.mixVolume = 1;
                this._channels.channelList.push(c);
            }
            return this._channels.channelList[channel];
        };
        /**
         * Returns the preset index from a bank and preset number, or -1 if it does not exist in the loaded SoundFont
         */
        TinySoundFont.prototype.getPresetIndex = function (bank, presetNumber) {
            if (!this.presets) {
                return -1;
            }
            // search reverse (last import wins)
            for (var i = this.presets.length - 1; i >= 0; i--) {
                var preset = this.presets[i];
                if (preset.presetNumber === presetNumber && preset.bank === bank) {
                    return i;
                }
            }
            return -1;
        };
        /**
         * Returns the name of a preset index >= 0 and < GetPresetName()
         * @param presetIndex
         */
        TinySoundFont.prototype.getPresetName = function (presetIndex) {
            if (!this.presets) {
                return null;
            }
            return presetIndex < 0 || presetIndex >= this.presets.length ? null : this.presets[presetIndex].name;
        };
        /**
         * Returns the name of a preset by bank and preset number
         */
        TinySoundFont.prototype.bankGetPresetName = function (bank, presetNumber) {
            return this.getPresetName(this.getPresetIndex(bank, presetNumber));
        };
        /**
         * Start playing a note on a channel
         * @param channel channel number
         * @param key note value between 0 and 127 (60 being middle C)
         * @param vel velocity as a float between 0.0 (equal to note off) and 1.0 (full)
         */
        TinySoundFont.prototype.channelNoteOn = function (channel, key, vel) {
            if (!this._channels || channel > this._channels.channelList.length) {
                return;
            }
            this._channels.activeChannel = channel;
            this.noteOn(this._channels.channelList[channel].presetIndex, key, vel);
        };
        /**
         * Stop playing notes on a channel
         * @param channel channel number
         * @param key note value between 0 and 127 (60 being middle C)
         */
        TinySoundFont.prototype.channelNoteOff = function (channel, key) {
            var matches = [];
            var matchFirst = null;
            var matchLast = null;
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                // Find the first and last entry in the voices list with matching channel, key and look up the smallest play index
                if (v.playingPreset === -1 ||
                    v.playingChannel !== channel ||
                    v.playingKey !== key ||
                    v.ampEnv.segment >= VoiceEnvelopeSegment.Release) {
                    continue;
                }
                if (!matchFirst || v.playIndex < matchFirst.playIndex) {
                    matchFirst = matchLast = v;
                    matches.push(v);
                }
                else if (v.playIndex === matchFirst.playIndex) {
                    matchLast = v;
                    matches.push(v);
                }
            }
            var c = this.channelInit(channel);
            c.perNotePitchWheel.delete(key);
            if (!matchFirst) {
                return;
            }
            for (var _b = 0, matches_2 = matches; _b < matches_2.length; _b++) {
                var v = matches_2[_b];
                // Stop all voices with matching channel, key and the smallest play index which was enumerated above
                if (v !== matchFirst &&
                    v !== matchLast &&
                    (v.playIndex !== matchFirst.playIndex ||
                        v.playingPreset === -1 ||
                        v.playingChannel !== channel ||
                        v.playingKey !== key ||
                        v.ampEnv.segment >= VoiceEnvelopeSegment.Release)) {
                    continue;
                }
                v.end(this.outSampleRate);
            }
        };
        /**
         * Stop playing all notes on a channel with sustain and release.
         * @param channel channel number
         */
        TinySoundFont.prototype.channelNoteOffAll = function (channel) {
            var c = this.channelInit(channel);
            c.perNotePitchWheel.clear();
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingPreset !== -1 &&
                    v.playingChannel === channel &&
                    v.ampEnv.segment < VoiceEnvelopeSegment.Release) {
                    v.end(this.outSampleRate);
                }
            }
        };
        /**
         * Stop playing all notes on a channel immediately
         * @param channel channel number
         */
        TinySoundFont.prototype.channelSoundsOffAll = function (channel) {
            var c = this.channelInit(channel);
            c.perNotePitchWheel.clear();
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingPreset !== -1 &&
                    v.playingChannel === channel &&
                    (v.ampEnv.segment < VoiceEnvelopeSegment.Release || v.ampEnv.parameters.release === 0)) {
                    v.endQuick(this.outSampleRate);
                }
            }
        };
        /**
         *
         * @param channel channel number
         * @param presetIndex preset index <= 0 and > {@link presetCount}
         */
        TinySoundFont.prototype.channelSetPresetIndex = function (channel, presetIndex) {
            this.channelInit(channel).presetIndex = TypeConversions.int32ToUint16(presetIndex);
        };
        /**
         * @param channel channel number
         * @param presetNumber preset number (alternative to preset_index)
         * @param midiDrums false for normal channels, otherwise apply MIDI drum channel rules
         * @returns return false if preset does not exist, otherwise true
         */
        TinySoundFont.prototype.channelSetPresetNumber = function (channel, presetNumber, midiDrums) {
            if (midiDrums === void 0) { midiDrums = false; }
            var c = this.channelInit(channel);
            var presetIndex = 0;
            if (midiDrums) {
                presetIndex = this.getPresetIndex(128 | (c.bank & 0x7fff), presetNumber);
                if (presetIndex === -1) {
                    presetIndex = this.getPresetIndex(128, presetNumber);
                }
                if (presetIndex === -1) {
                    presetIndex = this.getPresetIndex(128, 0);
                }
                if (presetIndex === -1) {
                    presetIndex = this.getPresetIndex(c.bank & 0x7ff, presetNumber);
                }
            }
            else {
                presetIndex = this.getPresetIndex(c.bank & 0x7ff, presetNumber);
            }
            c.presetIndex = presetIndex;
            return (presetIndex !== -1);
        };
        /**
         * @param channel channel number
         * @param bank instrument bank number (alternative to preset_index)
         */
        TinySoundFont.prototype.channelSetBank = function (channel, bank) {
            this.channelInit(channel).bank = TypeConversions.int32ToUint16(bank);
        };
        /**
         * @param channel channel number
         * @param bank instrument bank number (alternative to preset_index)
         * @param presetNumber preset number (alternative to preset_index)
         * @returns return false if preset does not exist, otherwise true
         */
        TinySoundFont.prototype.channelSetBankPreset = function (channel, bank, presetNumber) {
            var c = this.channelInit(channel);
            var presetIndex = this.getPresetIndex(bank, presetNumber);
            if (presetIndex === -1) {
                return false;
            }
            c.presetIndex = TypeConversions.int32ToUint16(presetIndex);
            c.bank = TypeConversions.int32ToUint16(bank);
            return true;
        };
        /**
         * @param channel channel number
         * @param pan stereo panning value from 0.0 (left) to 1.0 (right) (default 0.5 center)
         */
        TinySoundFont.prototype.channelSetPan = function (channel, pan) {
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingChannel === channel && v.playingPreset !== -1) {
                    var newPan = v.region.pan + pan - 0.5;
                    if (newPan <= -0.5) {
                        v.panFactorLeft = 1;
                        v.panFactorRight = 0;
                    }
                    else if (newPan >= 0.5) {
                        v.panFactorLeft = 0;
                        v.panFactorRight = 1;
                    }
                    else {
                        v.panFactorLeft = Math.sqrt(0.5 - newPan);
                        v.panFactorRight = Math.sqrt(0.5 + newPan);
                    }
                }
            }
            this.channelInit(channel).panOffset = pan - 0.5;
        };
        /**
         * @param channel channel number
         * @param volume linear volume scale factor (default 1.0 full)
         */
        TinySoundFont.prototype.channelSetVolume = function (channel, volume) {
            var c = this.channelInit(channel);
            var gainDb = SynthHelper.gainToDecibels(volume);
            var gainDBChange = gainDb - c.gainDb;
            if (gainDBChange === 0) {
                return;
            }
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingChannel === channel && v.playingPreset !== -1) {
                    v.noteGainDb += gainDBChange;
                }
            }
            c.gainDb = gainDb;
        };
        /**
         * @param channel channel number
         * @param pitchWheel pitch wheel position 0 to 16383 (default 8192 unpitched)
         */
        TinySoundFont.prototype.channelSetPitchWheel = function (channel, pitchWheel) {
            var c = this.channelInit(channel);
            if (c.pitchWheel === pitchWheel) {
                return;
            }
            c.pitchWheel = TypeConversions.int32ToUint16(pitchWheel);
            this.channelApplyPitch(channel, c);
        };
        /**
         * @param channel channel number
         * @param key note value between 0 and 127
         * @param pitchWheel pitch wheel position 0 to 16383 (default 8192 unpitched)
         */
        TinySoundFont.prototype.channelSetPerNotePitchWheel = function (channel, key, pitchWheel) {
            var c = this.channelInit(channel);
            if (c.perNotePitchWheel.has(key) && c.perNotePitchWheel.get(key) === pitchWheel) {
                return;
            }
            c.perNotePitchWheel.set(key, pitchWheel);
            this.channelApplyPitch(channel, c, key);
        };
        TinySoundFont.prototype.channelApplyPitch = function (channel, c, key) {
            if (key === void 0) { key = -1; }
            for (var _i = 0, _a = this._voices; _i < _a.length; _i++) {
                var v = _a[_i];
                if (v.playingChannel === channel && v.playingPreset !== -1 && (key == -1 || v.playingKey === key)) {
                    v.updatePitchRatio(c, this.outSampleRate);
                }
            }
        };
        /**
         * @param channel channel number
         * @param pitchRange range of the pitch wheel in semitones (default 2.0, total +/- 2 semitones)
         */
        TinySoundFont.prototype.channelSetPitchRange = function (channel, pitchRange) {
            var c = this.channelInit(channel);
            if (c.pitchRange === pitchRange) {
                return;
            }
            c.pitchRange = pitchRange;
            if (c.pitchWheel !== 8192) {
                this.channelApplyPitch(channel, c);
            }
        };
        /**
         * @param channel channel number
         * @param tuning tuning of all playing voices in semitones (default 0.0, standard (A440) tuning)
         */
        TinySoundFont.prototype.channelSetTuning = function (channel, tuning) {
            var c = this.channelInit(channel);
            if (c.tuning === tuning) {
                return;
            }
            c.tuning = tuning;
            this.channelApplyPitch(channel, c);
        };
        /**
         * Apply a MIDI control change to the channel (not all controllers are supported!)
         */
        TinySoundFont.prototype.channelMidiControl = function (channel, controller, controlValue) {
            var c = this.channelInit(channel);
            switch (controller) {
                case 5: /*Portamento_Time_MSB*/
                case 96: /*DATA_BUTTON_INCREMENT*/
                case 97: /*DATA_BUTTON_DECREMENT*/
                case 64: /*HOLD_PEDAL*/
                case 65: /*Portamento*/
                case 66: /*SostenutoPedal */
                case 122: /*LocalKeyboard */
                case 124: /*OmniModeOff */
                case 125: /*OmniModeon */
                case 126: /*MonoMode */
                case 127 /*PolyMode*/:
                    return;
                case 38 /*DATA_ENTRY_LSB*/:
                    c.midiData = TypeConversions.int32ToUint16((c.midiData & 0x3f80) | controlValue);
                    if (c.midiRpn === 0) {
                        this.channelSetPitchRange(channel, (c.midiData >> 7) + 0.01 * (c.midiData & 0x7f));
                    }
                    else if (c.midiRpn === 1) {
                        this.channelSetTuning(channel, (c.tuning | 0) + (c.midiData - 8192.0) / 8192.0); // fine tune
                    }
                    else if (c.midiRpn === 2) {
                        this.channelSetTuning(channel, controlValue - 64.0 + (c.tuning - (c.tuning | 0))); // coarse tune
                    }
                    return;
                case 7 /*VOLUME_MSB*/:
                    c.midiVolume = TypeConversions.int32ToUint16((c.midiVolume & 0x7f) | (controlValue << 7));
                    // Raising to the power of 3 seems to result in a decent sounding volume curve for MIDI
                    this.channelSetVolume(channel, Math.pow((c.midiVolume / 16383.0) * (c.midiExpression / 16383.0), 3.0));
                    return;
                case 39 /*VOLUME_LSB*/:
                    c.midiVolume = TypeConversions.int32ToUint16((c.midiVolume & 0x3f80) | controlValue);
                    // Raising to the power of 3 seems to result in a decent sounding volume curve for MIDI
                    this.channelSetVolume(channel, Math.pow((c.midiVolume / 16383.0) * (c.midiExpression / 16383.0), 3.0));
                    return;
                case 11 /*EXPRESSION_MSB*/:
                    c.midiExpression = TypeConversions.int32ToUint16((c.midiExpression & 0x7f) | (controlValue << 7));
                    // Raising to the power of 3 seems to result in a decent sounding volume curve for MIDI
                    this.channelSetVolume(channel, Math.pow((c.midiVolume / 16383.0) * (c.midiExpression / 16383.0), 3.0));
                    return;
                case 43 /*EXPRESSION_LSB*/:
                    c.midiExpression = TypeConversions.int32ToUint16((c.midiExpression & 0x3f80) | controlValue);
                    // Raising to the power of 3 seems to result in a decent sounding volume curve for MIDI
                    this.channelSetVolume(channel, Math.pow((c.midiVolume / 16383.0) * (c.midiExpression / 16383.0), 3.0));
                    return;
                case 10 /*PAN_MSB*/:
                    c.midiPan = TypeConversions.int32ToUint16((c.midiPan & 0x7f) | (controlValue << 7));
                    this.channelSetPan(channel, c.midiPan / 16383.0);
                    return;
                case 42 /*PAN_LSB*/:
                    c.midiPan = TypeConversions.int32ToUint16((c.midiPan & 0x3f80) | controlValue);
                    this.channelSetPan(channel, c.midiPan / 16383.0);
                    return;
                case 6 /*DATA_ENTRY_MSB*/:
                    c.midiData = TypeConversions.int32ToUint16((c.midiData & 0x7f) | (controlValue << 7));
                    if (c.midiRpn === 0) {
                        this.channelSetPitchRange(channel, (c.midiData >> 7) + 0.01 * (c.midiData & 0x7f));
                    }
                    else if (c.midiRpn === 1) {
                        this.channelSetTuning(channel, (c.tuning | 0) + (c.midiData - 8192.0) / 8192.0); // fine tune
                    }
                    else if (c.midiRpn === 2 && controller === 6) {
                        this.channelSetTuning(channel, controlValue - 64.0 + (c.tuning - (c.tuning | 0))); // coarse tune
                    }
                    return;
                case 0 /*BANK_SELECT_MSB*/:
                    c.bank = TypeConversions.int32ToUint16(0x8000 | controlValue);
                    return;
                // bank select MSB alone acts like LSB
                case 32 /*BANK_SELECT_LSB*/:
                    c.bank = TypeConversions.int32ToUint16(((c.bank & 0x8000) !== 0 ? (c.bank & 0x7f) << 7 : 0) | controlValue);
                    return;
                case 101 /*RPN_MSB*/:
                    c.midiRpn = TypeConversions.int32ToUint16(((c.midiRpn === 0xffff ? 0 : c.midiRpn) & 0x7f) | (controlValue << 7));
                    // TODO
                    return;
                case 100 /*RPN_LSB*/:
                    c.midiRpn = TypeConversions.int32ToUint16(((c.midiRpn === 0xffff ? 0 : c.midiRpn) & 0x3f80) | controlValue);
                    // TODO
                    return;
                case 98 /*NRPN_LSB*/:
                    c.midiRpn = 0xffff;
                    // TODO
                    return;
                case 99 /*NRPN_MSB*/:
                    c.midiRpn = 0xffff;
                    // TODO
                    return;
                case 120 /*ALL_SOUND_OFF*/:
                    this.channelSoundsOffAll(channel);
                    return;
                case 123 /*ALL_NOTES_OFF*/:
                    this.channelNoteOffAll(channel);
                    return;
                case 121 /*ALL_CTRL_OFF*/:
                    c.midiVolume = c.midiExpression = 16383;
                    c.midiPan = 8192;
                    c.bank = 0;
                    this.channelSetVolume(channel, 1);
                    this.channelSetPan(channel, 0.5);
                    this.channelSetPitchRange(channel, 2);
                    // TODO
                    return;
            }
        };
        /**
         * Gets the current preset index of the given channel.
         * @param channel The channel index
         * @returns The current preset index of the given channel.
         */
        TinySoundFont.prototype.channelGetPresetIndex = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].presetIndex
                : 0;
        };
        /**
         * Gets the current bank of the given channel.
         * @param channel The channel index
         * @returns The current bank of the given channel.
         */
        TinySoundFont.prototype.channelGetPresetBank = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].bank & 0x7fff
                : 0;
        };
        /**
         * Gets the current pan of the given channel.
         * @param channel The channel index
         * @returns The current pan of the given channel.
         */
        TinySoundFont.prototype.channelGetPan = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].panOffset - 0.5
                : 0.5;
        };
        /**
         * Gets the current volume of the given channel.
         * @param channel The channel index
         * @returns The current volune of the given channel.
         */
        TinySoundFont.prototype.channelGetVolume = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? SynthHelper.decibelsToGain(this._channels.channelList[channel].gainDb)
                : 1.0;
        };
        /**
         * Gets the current pitch wheel of the given channel.
         * @param channel The channel index
         * @returns The current pitch wheel of the given channel.
         */
        TinySoundFont.prototype.channelGetPitchWheel = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].pitchWheel
                : 8192;
        };
        /**
         * Gets the current pitch range of the given channel.
         * @param channel The channel index
         * @returns The current pitch range of the given channel.
         */
        TinySoundFont.prototype.channelGetPitchRange = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].pitchRange
                : 2.0;
        };
        /**
         * Gets the current tuning of the given channel.
         * @param channel The channel index
         * @returns The current tuning of the given channel.
         */
        TinySoundFont.prototype.channelGetTuning = function (channel) {
            return this._channels && channel < this._channels.channelList.length
                ? this._channels.channelList[channel].tuning
                : 0.0;
        };
        TinySoundFont.prototype.resetPresets = function () {
            this.presets = [];
        };
        TinySoundFont.prototype.loadPresets = function (hydra, append) {
            var newPresets = new Array(hydra.phdrs.length - 1);
            for (var phdrIndex = 0; phdrIndex < hydra.phdrs.length - 1; phdrIndex++) {
                var phdr = hydra.phdrs[phdrIndex];
                var regionIndex = 0;
                var preset = (newPresets[phdrIndex] = new Preset());
                preset.name = phdr.presetName;
                preset.bank = phdr.bank;
                preset.presetNumber = phdr.preset;
                preset.fontSamples = hydra.fontSamples;
                var regionNum = 0;
                for (var pbagIndex = phdr.presetBagNdx; pbagIndex < hydra.phdrs[phdrIndex + 1].presetBagNdx; pbagIndex++) {
                    var pbag = hydra.pbags[pbagIndex];
                    var plokey = 0;
                    var phikey = 127;
                    var plovel = 0;
                    var phivel = 127;
                    for (var pgenIndex = pbag.genNdx; pgenIndex < hydra.pbags[pbagIndex + 1].genNdx; pgenIndex++) {
                        var pgen = hydra.pgens[pgenIndex];
                        if (pgen.genOper === HydraPgen.GenKeyRange) {
                            plokey = pgen.genAmount.lowByteAmount;
                            phikey = pgen.genAmount.highByteAmount;
                            continue;
                        }
                        if (pgen.genOper === HydraPgen.GenVelRange) {
                            plovel = pgen.genAmount.lowByteAmount;
                            phivel = pgen.genAmount.highByteAmount;
                            continue;
                        }
                        if (pgen.genOper !== HydraPgen.GenInstrument) {
                            continue;
                        }
                        if (pgen.genAmount.wordAmount >= hydra.insts.length) {
                            continue;
                        }
                        var pinst = hydra.insts[pgen.genAmount.wordAmount];
                        for (var ibagIndex = pinst.instBagNdx; ibagIndex < hydra.insts[pgen.genAmount.wordAmount + 1].instBagNdx; ibagIndex++) {
                            var ibag = hydra.ibags[ibagIndex];
                            var ilokey = 0;
                            var ihikey = 127;
                            var ilovel = 0;
                            var ihivel = 127;
                            for (var igenIndex = ibag.instGenNdx; igenIndex < hydra.ibags[ibagIndex + 1].instGenNdx; igenIndex++) {
                                var igen = hydra.igens[igenIndex];
                                if (igen.genOper === HydraPgen.GenKeyRange) {
                                    ilokey = igen.genAmount.lowByteAmount;
                                    ihikey = igen.genAmount.highByteAmount;
                                    continue;
                                }
                                if (igen.genOper === HydraPgen.GenVelRange) {
                                    ilovel = igen.genAmount.lowByteAmount;
                                    ihivel = igen.genAmount.highByteAmount;
                                    continue;
                                }
                                if (igen.genOper === 53 &&
                                    ihikey >= plokey &&
                                    ilokey <= phikey &&
                                    ihivel >= plovel &&
                                    ilovel <= phivel) {
                                    regionNum++;
                                }
                            }
                        }
                    }
                }
                preset.regions = new Array(regionNum);
                var globalRegion = new Region();
                globalRegion.clear(true);
                // Zones.
                for (var pbagIndex = phdr.presetBagNdx; pbagIndex < hydra.phdrs[phdrIndex + 1].presetBagNdx; pbagIndex++) {
                    var pbag = hydra.pbags[pbagIndex];
                    var presetRegion = new Region(globalRegion);
                    var hadGenInstrument = false;
                    // Generators.
                    for (var pgenIndex = pbag.genNdx; pgenIndex < hydra.pbags[pbagIndex + 1].genNdx; pgenIndex++) {
                        var pgen = hydra.pgens[pgenIndex];
                        // Instrument.
                        if (pgen.genOper === HydraPgen.GenInstrument) {
                            var whichInst = pgen.genAmount.wordAmount;
                            if (whichInst >= hydra.insts.length) {
                                continue;
                            }
                            var instRegion = new Region();
                            instRegion.clear(false);
                            // Generators
                            var inst = hydra.insts[whichInst];
                            for (var ibagIndex = inst.instBagNdx; ibagIndex < hydra.insts[whichInst + 1].instBagNdx; ibagIndex++) {
                                var ibag = hydra.ibags[ibagIndex];
                                var zoneRegion = new Region(instRegion);
                                var hadSampleId = false;
                                for (var igenIndex = ibag.instGenNdx; igenIndex < hydra.ibags[ibagIndex + 1].instGenNdx; igenIndex++) {
                                    var igen = hydra.igens[igenIndex];
                                    if (igen.genOper === HydraPgen.GenSampleId) {
                                        // preset region key and vel ranges are a filter for the zone regions
                                        if (zoneRegion.hiKey < presetRegion.loKey ||
                                            zoneRegion.loKey > presetRegion.hiKey) {
                                            continue;
                                        }
                                        if (zoneRegion.hiVel < presetRegion.loVel ||
                                            zoneRegion.loVel > presetRegion.hiVel) {
                                            continue;
                                        }
                                        if (presetRegion.loKey > zoneRegion.loKey) {
                                            zoneRegion.loKey = presetRegion.loKey;
                                        }
                                        if (presetRegion.hiKey < zoneRegion.hiKey) {
                                            zoneRegion.hiKey = presetRegion.hiKey;
                                        }
                                        if (presetRegion.loVel > zoneRegion.loVel) {
                                            zoneRegion.loVel = presetRegion.loVel;
                                        }
                                        if (presetRegion.hiVel < zoneRegion.hiVel) {
                                            zoneRegion.hiVel = presetRegion.hiVel;
                                        }
                                        // sum regions
                                        zoneRegion.offset += presetRegion.offset;
                                        zoneRegion.end += presetRegion.end;
                                        zoneRegion.loopStart += presetRegion.loopStart;
                                        zoneRegion.loopEnd += presetRegion.loopEnd;
                                        zoneRegion.transpose += presetRegion.transpose;
                                        zoneRegion.tune += presetRegion.tune;
                                        zoneRegion.pitchKeyTrack += presetRegion.pitchKeyTrack;
                                        zoneRegion.attenuation += presetRegion.attenuation;
                                        zoneRegion.pan += presetRegion.pan;
                                        zoneRegion.ampEnv.delay += presetRegion.ampEnv.delay;
                                        zoneRegion.ampEnv.attack += presetRegion.ampEnv.attack;
                                        zoneRegion.ampEnv.hold += presetRegion.ampEnv.hold;
                                        zoneRegion.ampEnv.decay += presetRegion.ampEnv.decay;
                                        zoneRegion.ampEnv.sustain += presetRegion.ampEnv.sustain;
                                        zoneRegion.ampEnv.release += presetRegion.ampEnv.release;
                                        zoneRegion.modEnv.delay += presetRegion.modEnv.delay;
                                        zoneRegion.modEnv.attack += presetRegion.modEnv.attack;
                                        zoneRegion.modEnv.hold += presetRegion.modEnv.hold;
                                        zoneRegion.modEnv.decay += presetRegion.modEnv.decay;
                                        zoneRegion.modEnv.sustain += presetRegion.modEnv.sustain;
                                        zoneRegion.modEnv.release += presetRegion.modEnv.release;
                                        zoneRegion.initialFilterQ += presetRegion.initialFilterQ;
                                        zoneRegion.initialFilterFc += presetRegion.initialFilterFc;
                                        zoneRegion.modEnvToPitch += presetRegion.modEnvToPitch;
                                        zoneRegion.modEnvToFilterFc += presetRegion.modEnvToFilterFc;
                                        zoneRegion.delayModLFO += presetRegion.delayModLFO;
                                        zoneRegion.freqModLFO += presetRegion.freqModLFO;
                                        zoneRegion.modLfoToPitch += presetRegion.modLfoToPitch;
                                        zoneRegion.modLfoToFilterFc += presetRegion.modLfoToFilterFc;
                                        zoneRegion.modLfoToVolume += presetRegion.modLfoToVolume;
                                        zoneRegion.delayVibLFO += presetRegion.delayVibLFO;
                                        zoneRegion.freqVibLFO += presetRegion.freqVibLFO;
                                        zoneRegion.vibLfoToPitch += presetRegion.vibLfoToPitch;
                                        // EG times need to be converted from timecents to seconds.
                                        zoneRegion.ampEnv.envToSecs(true);
                                        zoneRegion.modEnv.envToSecs(false);
                                        // LFO times need to be converted from timecents to seconds.
                                        zoneRegion.delayModLFO =
                                            zoneRegion.delayModLFO < -11950.0
                                                ? 0.0
                                                : SynthHelper.timecents2Secs(zoneRegion.delayModLFO);
                                        zoneRegion.delayVibLFO =
                                            zoneRegion.delayVibLFO < -11950.0
                                                ? 0.0
                                                : SynthHelper.timecents2Secs(zoneRegion.delayVibLFO);
                                        // Pin values to their ranges.
                                        if (zoneRegion.pan < -0.5) {
                                            zoneRegion.pan = -0.5;
                                        }
                                        else if (zoneRegion.pan > 0.5) {
                                            zoneRegion.pan = 0.5;
                                        }
                                        if (zoneRegion.initialFilterQ < 1500 || zoneRegion.initialFilterQ > 13500) {
                                            zoneRegion.initialFilterQ = 0;
                                        }
                                        var shdr = hydra.sHdrs[igen.genAmount.wordAmount];
                                        zoneRegion.offset += shdr.start;
                                        zoneRegion.end += shdr.end;
                                        zoneRegion.loopStart += shdr.startLoop;
                                        zoneRegion.loopEnd += shdr.endLoop;
                                        if (shdr.endLoop > 0) {
                                            zoneRegion.loopEnd -= 1;
                                        }
                                        if (zoneRegion.pitchKeyCenter === -1) {
                                            zoneRegion.pitchKeyCenter = shdr.originalPitch;
                                        }
                                        zoneRegion.tune += shdr.pitchCorrection;
                                        zoneRegion.sampleRate = shdr.sampleRate;
                                        if (zoneRegion.end !== 0 && zoneRegion.end < preset.fontSamples.length) {
                                            zoneRegion.end++;
                                        }
                                        else {
                                            zoneRegion.end = preset.fontSamples.length;
                                        }
                                        preset.regions[regionIndex] = new Region(zoneRegion);
                                        regionIndex++;
                                        hadSampleId = true;
                                    }
                                    else {
                                        zoneRegion.operator(igen.genOper, igen.genAmount);
                                    }
                                }
                                // Handle instrument's global zone.
                                if (ibag === hydra.ibags[inst.instBagNdx] && !hadSampleId) {
                                    instRegion = new Region(zoneRegion);
                                }
                                // Modulators (TODO)
                                //if (ibag->instModNdx < ibag[1].instModNdx) addUnsupportedOpcode("any modulator");
                            }
                            hadGenInstrument = true;
                        }
                        else {
                            presetRegion.operator(pgen.genOper, pgen.genAmount);
                        }
                    }
                    // Modulators (TODO)
                    // if (pbag->modNdx < pbag[1].modNdx) addUnsupportedOpcode("any modulator");
                    // Handle preset's global zone.
                    if (pbag === hydra.pbags[phdr.presetBagNdx] && !hadGenInstrument) {
                        globalRegion = presetRegion;
                    }
                }
            }
            if (!append || !this.presets) {
                this.presets = newPresets;
            }
            else {
                for (var _i = 0, newPresets_1 = newPresets; _i < newPresets_1.length; _i++) {
                    var preset = newPresets_1[_i];
                    this.presets.push(preset);
                }
            }
        };
        return TinySoundFont;
    }());

    var EventEmitter = /** @class */ (function () {
        function EventEmitter() {
            this._listeners = [];
        }
        EventEmitter.prototype.on = function (value) {
            this._listeners.push(value);
        };
        EventEmitter.prototype.off = function (value) {
            this._listeners = this._listeners.filter(function (l) { return l !== value; });
        };
        EventEmitter.prototype.trigger = function () {
            for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
                var l = _a[_i];
                l();
            }
        };
        return EventEmitter;
    }());
    var EventEmitterOfT = /** @class */ (function () {
        function EventEmitterOfT() {
            this._listeners = [];
        }
        EventEmitterOfT.prototype.on = function (value) {
            this._listeners.push(value);
        };
        EventEmitterOfT.prototype.off = function (value) {
            this._listeners = this._listeners.filter(function (l) { return l !== value; });
        };
        EventEmitterOfT.prototype.trigger = function (arg) {
            for (var _i = 0, _a = this._listeners; _i < _a.length; _i++) {
                var l = _a[_i];
                l(arg);
            }
        };
        return EventEmitterOfT;
    }());

    /**
     * This is the main synthesizer component which can be used to
     * play a {@link MidiFile} via a {@link ISynthOutput}.
     */
    var AlphaSynth = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link AlphaSynth} class.
         * @param output The output to use for playing the generated samples.
         */
        function AlphaSynth(output) {
            var _this = this;
            this._isSoundFontLoaded = false;
            this._isMidiLoaded = false;
            this._tickPosition = 0;
            this._timePosition = 0;
            this._metronomeVolume = 0;
            this._countInVolume = 0;
            this.isReady = false;
            this.state = PlayerState.Paused;
            this.ready = new EventEmitter();
            this.readyForPlayback = new EventEmitter();
            this.finished = new EventEmitter();
            this.soundFontLoaded = new EventEmitter();
            this.soundFontLoadFailed = new EventEmitterOfT();
            this.midiLoaded = new EventEmitter();
            this.midiLoadFailed = new EventEmitterOfT();
            this.stateChanged = new EventEmitterOfT();
            this.positionChanged = new EventEmitterOfT();
            Logger.debug('AlphaSynth', 'Initializing player');
            this.state = PlayerState.Paused;
            Logger.debug('AlphaSynth', 'Creating output');
            this.output = output;
            this.output.ready.on(function () {
                _this.isReady = true;
                _this.ready.trigger();
                _this.checkReadyForPlayback();
            });
            this.output.sampleRequest.on(function () {
                var samples = new Float32Array(SynthConstants.MicroBufferSize * SynthConstants.MicroBufferCount * SynthConstants.AudioChannels);
                var bufferPos = 0;
                for (var i = 0; i < SynthConstants.MicroBufferCount; i++) {
                    // synthesize buffer
                    _this._sequencer.fillMidiEventQueue();
                    _this._synthesizer.synthesize(samples, bufferPos, SynthConstants.MicroBufferSize);
                    bufferPos += SynthConstants.MicroBufferSize * SynthConstants.AudioChannels;
                    // tell sequencer to check whether its work is done
                    if (_this._sequencer.isFinished) {
                        break;
                    }
                }
                // send it to output
                if (bufferPos < samples.length) {
                    samples = samples.subarray(0, bufferPos);
                }
                _this.output.addSamples(samples);
            });
            this.output.samplesPlayed.on(this.onSamplesPlayed.bind(this));
            Logger.debug('AlphaSynth', 'Creating synthesizer');
            this._synthesizer = new TinySoundFont(this.output.sampleRate);
            this._sequencer = new MidiFileSequencer(this._synthesizer);
            Logger.debug('AlphaSynth', 'Opening output');
            this.output.open();
        }
        Object.defineProperty(AlphaSynth.prototype, "isReadyForPlayback", {
            get: function () {
                return this.isReady && this._isSoundFontLoaded && this._isMidiLoaded;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "logLevel", {
            get: function () {
                return Logger.logLevel;
            },
            set: function (value) {
                Logger.logLevel = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "masterVolume", {
            get: function () {
                return this._synthesizer.masterVolume;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinVolume, SynthConstants.MaxVolume);
                this._synthesizer.masterVolume = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "metronomeVolume", {
            get: function () {
                return this._metronomeVolume;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinVolume, SynthConstants.MaxVolume);
                this._metronomeVolume = value;
                this._synthesizer.metronomeVolume = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "countInVolume", {
            get: function () {
                return this._countInVolume;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinVolume, SynthConstants.MaxVolume);
                this._countInVolume = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "playbackSpeed", {
            get: function () {
                return this._sequencer.playbackSpeed;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinPlaybackSpeed, SynthConstants.MaxPlaybackSpeed);
                var oldSpeed = this._sequencer.playbackSpeed;
                this._sequencer.playbackSpeed = value;
                this.updateTimePosition(this._timePosition * (oldSpeed / value));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "tickPosition", {
            get: function () {
                return this._tickPosition;
            },
            set: function (value) {
                this.timePosition = this._sequencer.tickPositionToTimePosition(value);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "timePosition", {
            get: function () {
                return this._timePosition;
            },
            set: function (value) {
                Logger.debug('AlphaSynth', "Seeking to position " + value + "ms");
                // tell the sequencer to jump to the given position
                this._sequencer.seek(value);
                // update the internal position
                this.updateTimePosition(value);
                // tell the output to reset the already synthesized buffers and request data again
                this.output.resetSamples();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "playbackRange", {
            get: function () {
                return this._sequencer.playbackRange;
            },
            set: function (value) {
                this._sequencer.playbackRange = value;
                if (value) {
                    this.tickPosition = value.startTick;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynth.prototype, "isLooping", {
            get: function () {
                return this._sequencer.isLooping;
            },
            set: function (value) {
                this._sequencer.isLooping = value;
            },
            enumerable: false,
            configurable: true
        });
        AlphaSynth.prototype.destroy = function () {
            Logger.debug('AlphaSynth', 'Destroying player');
            this.stop();
        };
        AlphaSynth.prototype.play = function () {
            if (this.state !== PlayerState.Paused || !this._isMidiLoaded) {
                return false;
            }
            this.output.activate();
            this.playInternal();
            if (this._countInVolume > 0) {
                Logger.debug('AlphaSynth', 'Starting countin');
                this._sequencer.startCountIn();
                this._synthesizer.setupMetronomeChannel(this._countInVolume);
                this.tickPosition = 0;
            }
            this.output.play();
            return true;
        };
        AlphaSynth.prototype.playInternal = function () {
            Logger.debug('AlphaSynth', 'Starting playback');
            this._synthesizer.setupMetronomeChannel(this.metronomeVolume);
            this.state = PlayerState.Playing;
            this.stateChanged.trigger(new PlayerStateChangedEventArgs(this.state, false));
        };
        AlphaSynth.prototype.pause = function () {
            if (this.state === PlayerState.Paused || !this._isMidiLoaded) {
                return;
            }
            Logger.debug('AlphaSynth', 'Pausing playback');
            this.state = PlayerState.Paused;
            this.stateChanged.trigger(new PlayerStateChangedEventArgs(this.state, false));
            this.output.pause();
            this._synthesizer.noteOffAll(false);
        };
        AlphaSynth.prototype.playPause = function () {
            if (this.state !== PlayerState.Paused || !this._isMidiLoaded) {
                this.pause();
            }
            else {
                this.play();
            }
        };
        AlphaSynth.prototype.stop = function () {
            if (!this._isMidiLoaded) {
                return;
            }
            Logger.debug('AlphaSynth', 'Stopping playback');
            this.state = PlayerState.Paused;
            this.output.pause();
            this._sequencer.stop();
            this._synthesizer.noteOffAll(true);
            this.tickPosition = this._sequencer.playbackRange ? this._sequencer.playbackRange.startTick : 0;
            this.stateChanged.trigger(new PlayerStateChangedEventArgs(this.state, true));
        };
        AlphaSynth.prototype.playOneTimeMidiFile = function (midi) {
            // pause current playback.
            this.pause();
            this._sequencer.loadOneTimeMidi(midi);
            this._sequencer.stop();
            this._synthesizer.noteOffAll(true);
            this.tickPosition = 0;
            this.output.play();
        };
        AlphaSynth.prototype.resetSoundFonts = function () {
            this.stop();
            this._synthesizer.resetPresets();
            this._isSoundFontLoaded = false;
            this.soundFontLoaded.trigger();
        };
        AlphaSynth.prototype.loadSoundFont = function (data, append) {
            this.pause();
            var input = ByteBuffer.fromBuffer(data);
            try {
                Logger.debug('AlphaSynth', 'Loading soundfont from bytes');
                var soundFont = new Hydra();
                soundFont.load(input);
                this._synthesizer.loadPresets(soundFont, append);
                this._isSoundFontLoaded = true;
                this.soundFontLoaded.trigger();
                Logger.debug('AlphaSynth', 'soundFont successfully loaded');
                this.checkReadyForPlayback();
            }
            catch (e) {
                Logger.error('AlphaSynth', 'Could not load soundfont from bytes ' + e);
                this.soundFontLoadFailed.trigger(e);
            }
        };
        AlphaSynth.prototype.checkReadyForPlayback = function () {
            if (this.isReadyForPlayback) {
                this._synthesizer.setupMetronomeChannel(this.metronomeVolume);
                this.readyForPlayback.trigger();
            }
        };
        /**
         * Loads the given midi file for playback.
         * @param midiFile The midi file to load
         */
        AlphaSynth.prototype.loadMidiFile = function (midiFile) {
            this.stop();
            try {
                Logger.debug('AlphaSynth', 'Loading midi from model');
                this._sequencer.loadMidi(midiFile);
                this._isMidiLoaded = true;
                this.midiLoaded.trigger();
                Logger.debug('AlphaSynth', 'Midi successfully loaded');
                this.checkReadyForPlayback();
                this.tickPosition = 0;
            }
            catch (e) {
                Logger.error('AlphaSynth', 'Could not load midi from model ' + e);
                this.midiLoadFailed.trigger(e);
            }
        };
        AlphaSynth.prototype.setChannelMute = function (channel, mute) {
            this._synthesizer.channelSetMute(channel, mute);
        };
        AlphaSynth.prototype.resetChannelStates = function () {
            this._synthesizer.resetChannelStates();
        };
        AlphaSynth.prototype.setChannelSolo = function (channel, solo) {
            this._synthesizer.channelSetSolo(channel, solo);
        };
        AlphaSynth.prototype.setChannelVolume = function (channel, volume) {
            volume = SynthHelper.clamp(volume, SynthConstants.MinVolume, SynthConstants.MaxVolume);
            this._synthesizer.channelSetMixVolume(channel, volume);
        };
        AlphaSynth.prototype.onSamplesPlayed = function (sampleCount) {
            var playedMillis = (sampleCount / this._synthesizer.outSampleRate) * 1000;
            this.updateTimePosition(this._timePosition + playedMillis);
            this.checkForFinish();
        };
        AlphaSynth.prototype.checkForFinish = function () {
            var startTick = 0;
            var endTick = 0;
            if (this.playbackRange) {
                startTick = this.playbackRange.startTick;
                endTick = this.playbackRange.endTick;
            }
            else {
                endTick = this._sequencer.endTick;
            }
            if (this._tickPosition >= endTick) {
                Logger.debug('AlphaSynth', 'Finished playback');
                if (this._sequencer.isPlayingCountIn) {
                    this._sequencer.resetCountIn();
                    this.timePosition = this._sequencer.currentTime;
                    this.playInternal();
                }
                else if (this._sequencer.isPlayingOneTimeMidi) {
                    this._sequencer.resetOneTimeMidi();
                    this.state = PlayerState.Paused;
                    this.output.pause();
                    this._synthesizer.noteOffAll(false);
                }
                else {
                    this.finished.trigger();
                    if (this.isLooping) {
                        this.tickPosition = startTick;
                    }
                    else {
                        this.stop();
                    }
                }
            }
        };
        AlphaSynth.prototype.updateTimePosition = function (timePosition) {
            // update the real positions
            var currentTime = (this._timePosition = timePosition);
            var currentTick = (this._tickPosition = this._sequencer.timePositionToTickPosition(currentTime));
            var endTime = this._sequencer.endTime;
            var endTick = this._sequencer.endTick;
            if (!this._sequencer.isPlayingOneTimeMidi && !this._sequencer.isPlayingCountIn) {
                Logger.debug('AlphaSynth', "Position changed: (time: " + currentTime + "/" + endTime + ", tick: " + currentTick + "/" + endTick + ", Active Voices: " + this._synthesizer.activeVoiceCount);
                this.positionChanged.trigger(new PositionChangedEventArgs(currentTime, endTime, currentTick, endTick));
            }
        };
        return AlphaSynth;
    }());

    /**
     * Represents a midi file with a single track that can be played via {@link AlphaSynth}
     */
    var MidiFile = /** @class */ (function () {
        function MidiFile() {
            /**
             * Gets or sets the division per quarter notes.
             */
            this.division = MidiUtils.QuarterTime;
            /**
             * Gets a list of midi events sorted by time.
             */
            this.events = [];
        }
        /**
         * Adds the given midi event a the correct time position into the file.
         */
        MidiFile.prototype.addEvent = function (e) {
            if (this.events.length === 0) {
                this.events.push(e);
            }
            else {
                var insertPos = this.events.length;
                while (insertPos > 0) {
                    var prevItem = this.events[insertPos - 1];
                    if (prevItem.tick > e.tick) {
                        insertPos--;
                    }
                    else {
                        break;
                    }
                }
                this.events.splice(insertPos, 0, e);
            }
        };
        /**
         * Writes the midi file into a binary format.
         * @returns The binary midi file.
         */
        MidiFile.prototype.toBinary = function () {
            var data = ByteBuffer.empty();
            this.writeTo(data);
            return data.toArray();
        };
        /**
         * Writes the midi file as binary into the given stream.
         * @returns The stream to write to.
         */
        MidiFile.prototype.writeTo = function (s) {
            // magic number "MThd" (0x4D546864)
            var b = new Uint8Array([0x4d, 0x54, 0x68, 0x64]);
            s.write(b, 0, b.length);
            // Header Length 6 (0x00000006)
            b = new Uint8Array([0x00, 0x00, 0x00, 0x06]);
            s.write(b, 0, b.length);
            // format
            b = new Uint8Array([0x00, 0x00]);
            s.write(b, 0, b.length);
            // number of tracks
            var v = 1;
            b = new Uint8Array([(v >> 8) & 0xff, v & 0xff]);
            s.write(b, 0, b.length);
            v = this.division;
            b = new Uint8Array([(v >> 8) & 0xff, v & 0xff]);
            s.write(b, 0, b.length);
            // build track data first
            var trackData = ByteBuffer.empty();
            var previousTick = 0;
            for (var _i = 0, _a = this.events; _i < _a.length; _i++) {
                var midiEvent = _a[_i];
                var delta = midiEvent.tick - previousTick;
                MidiFile.writeVariableInt(trackData, delta);
                midiEvent.writeTo(trackData);
                previousTick = midiEvent.tick;
            }
            // end of track
            // magic number "MTrk" (0x4D54726B)
            b = new Uint8Array([0x4d, 0x54, 0x72, 0x6b]);
            s.write(b, 0, b.length);
            // size as integer
            var data = trackData.toArray();
            var l = data.length;
            b = new Uint8Array([(l >> 24) & 0xff, (l >> 16) & 0xff, (l >> 8) & 0xff, l & 0xff]);
            s.write(b, 0, b.length);
            s.write(data, 0, data.length);
        };
        MidiFile.writeVariableInt = function (s, value) {
            var array = new Uint8Array(4);
            var n = 0;
            do {
                array[n++] = value & 0x7f;
                value >>= 7;
            } while (value > 0);
            while (n > 0) {
                n--;
                if (n > 0) {
                    s.writeByte(array[n] | 0x80);
                }
                else {
                    s.writeByte(array[n]);
                }
            }
        };
        return MidiFile;
    }());

    var __extends$d = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MetaDataEvent = /** @class */ (function (_super) {
        __extends$d(MetaDataEvent, _super);
        function MetaDataEvent(delta, status, metaId, data) {
            var _this = _super.call(this, delta, status, metaId, 0) || this;
            _this.data = data;
            return _this;
        }
        MetaDataEvent.prototype.writeTo = function (s) {
            s.writeByte(0xff);
            s.writeByte(this.metaStatus);
            var l = this.data.length;
            MidiFile.writeVariableInt(s, l);
            s.write(this.data, 0, this.data.length);
        };
        return MetaDataEvent;
    }(MetaEvent));

    var __extends$e = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MetaNumberEvent = /** @class */ (function (_super) {
        __extends$e(MetaNumberEvent, _super);
        function MetaNumberEvent(delta, status, metaId, value) {
            var _this = _super.call(this, delta, status, metaId, 0) || this;
            _this.value = value;
            return _this;
        }
        MetaNumberEvent.prototype.writeTo = function (s) {
            s.writeByte(0xff);
            s.writeByte(this.metaStatus);
            MidiFile.writeVariableInt(s, 3);
            var b = new Uint8Array([(this.value >> 16) & 0xff, (this.value >> 8) & 0xff, this.value & 0xff]);
            s.write(b, 0, b.length);
        };
        return MetaNumberEvent;
    }(MetaEvent));

    var __extends$f = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var SystemCommonType;
    (function (SystemCommonType) {
        SystemCommonType[SystemCommonType["SystemExclusive"] = 240] = "SystemExclusive";
        SystemCommonType[SystemCommonType["MtcQuarterFrame"] = 241] = "MtcQuarterFrame";
        SystemCommonType[SystemCommonType["SongPosition"] = 242] = "SongPosition";
        SystemCommonType[SystemCommonType["SongSelect"] = 243] = "SongSelect";
        SystemCommonType[SystemCommonType["TuneRequest"] = 246] = "TuneRequest";
        SystemCommonType[SystemCommonType["SystemExclusive2"] = 247] = "SystemExclusive2";
    })(SystemCommonType || (SystemCommonType = {}));
    var SystemCommonEvent = /** @class */ (function (_super) {
        __extends$f(SystemCommonEvent, _super);
        function SystemCommonEvent(delta, status, data1, data2) {
            return _super.call(this, delta, status, data1, data2) || this;
        }
        Object.defineProperty(SystemCommonEvent.prototype, "channel", {
            get: function () {
                return -1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SystemCommonEvent.prototype, "command", {
            get: function () {
                return (this.message & 0x00000ff);
            },
            enumerable: false,
            configurable: true
        });
        return SystemCommonEvent;
    }(MidiEvent));

    var __extends$g = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var SystemExclusiveEvent = /** @class */ (function (_super) {
        __extends$g(SystemExclusiveEvent, _super);
        function SystemExclusiveEvent(delta, status, id, data) {
            var _this = _super.call(this, delta, status, id & 0x00ff, (id >> 8) & 0xff) || this;
            _this.data = data;
            return _this;
        }
        Object.defineProperty(SystemExclusiveEvent.prototype, "manufacturerId", {
            get: function () {
                return this.message >> 8;
            },
            enumerable: false,
            configurable: true
        });
        SystemExclusiveEvent.prototype.writeTo = function (s) {
            s.writeByte(0xf0);
            var l = this.data.length + 2;
            s.writeByte(this.manufacturerId);
            var b = new Uint8Array([(l >> 24) & 0xff, (l >> 16) & 0xff, (l >> 8) & 0xff, l & 0xff]);
            s.write(b, 0, b.length);
            s.writeByte(0xf7);
        };
        return SystemExclusiveEvent;
    }(SystemCommonEvent));

    /**
     * All settings related to importers that decode file formats.
     * @json
     */
    var ImporterSettings = /** @class */ (function () {
        function ImporterSettings() {
            /**
             * The text encoding to use when decoding strings. By default UTF-8 is used.
             */
            this.encoding = 'utf-8';
            /**
             * If part-groups should be merged into a single track.
             */
            this.mergePartGroupsInMusicXml = false;
        }
        ImporterSettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        ImporterSettings.prototype.fillToJson = function (json) { json.encoding = this.encoding; json.mergePartGroupsInMusicXml = this.mergePartGroupsInMusicXml; };
        ImporterSettings.fromJson = function (json) { if (!json)
            return null; var obj = new ImporterSettings(); obj.fillFromJson(json); return obj; };
        ImporterSettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        ImporterSettings.prototype.setProperty = function (property, value) { switch (property) {
            case "encoding":
                this.encoding = value;
                return true;
            case "mergepartgroupsinmusicxml":
                this.mergePartGroupsInMusicXml = value;
                return true;
        } return false; };
        return ImporterSettings;
    }());

    /**
     * Lists all modes how alphaTab can scroll the container during playback.
     */
    (function (ScrollMode) {
        /**
         * Do not scroll automatically
         */
        ScrollMode[ScrollMode["Off"] = 0] = "Off";
        /**
         * Scrolling happens as soon the offsets of the cursors change.
         */
        ScrollMode[ScrollMode["Continuous"] = 1] = "Continuous";
        /**
         * Scrolling happens as soon the cursors exceed the displayed range.
         */
        ScrollMode[ScrollMode["OffScreen"] = 2] = "OffScreen";
    })(exports.ScrollMode || (exports.ScrollMode = {}));
    /**
     * This object defines the details on how to generate the vibrato effects.
     * @json
     */
    var VibratoPlaybackSettings = /** @class */ (function () {
        function VibratoPlaybackSettings() {
            /**
             * Gets or sets the wavelength of the note-wide vibrato in midi ticks.
             */
            this.noteWideLength = 480;
            /**
             * Gets or sets the amplitude for the note-wide vibrato in semitones.
             */
            this.noteWideAmplitude = 2;
            /**
             * Gets or sets the wavelength of the note-slight vibrato in midi ticks.
             */
            this.noteSlightLength = 480;
            /**
             * Gets or sets the amplitude for the note-slight vibrato in semitones.
             */
            this.noteSlightAmplitude = 2;
            /**
             * Gets or sets the wavelength of the beat-wide vibrato in midi ticks.
             */
            this.beatWideLength = 240;
            /**
             * Gets or sets the amplitude for the beat-wide vibrato in semitones.
             */
            this.beatWideAmplitude = 3;
            /**
             * Gets or sets the wavelength of the beat-slight vibrato in midi ticks.
             */
            this.beatSlightLength = 240;
            /**
             * Gets or sets the amplitude for the beat-slight vibrato in semitones.
             */
            this.beatSlightAmplitude = 3;
        }
        VibratoPlaybackSettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        VibratoPlaybackSettings.prototype.fillToJson = function (json) { json.noteWideLength = this.noteWideLength; json.noteWideAmplitude = this.noteWideAmplitude; json.noteSlightLength = this.noteSlightLength; json.noteSlightAmplitude = this.noteSlightAmplitude; json.beatWideLength = this.beatWideLength; json.beatWideAmplitude = this.beatWideAmplitude; json.beatSlightLength = this.beatSlightLength; json.beatSlightAmplitude = this.beatSlightAmplitude; };
        VibratoPlaybackSettings.fromJson = function (json) { if (!json)
            return null; var obj = new VibratoPlaybackSettings(); obj.fillFromJson(json); return obj; };
        VibratoPlaybackSettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        VibratoPlaybackSettings.prototype.setProperty = function (property, value) { switch (property) {
            case "notewidelength":
                this.noteWideLength = value;
                return true;
            case "notewideamplitude":
                this.noteWideAmplitude = value;
                return true;
            case "noteslightlength":
                this.noteSlightLength = value;
                return true;
            case "noteslightamplitude":
                this.noteSlightAmplitude = value;
                return true;
            case "beatwidelength":
                this.beatWideLength = value;
                return true;
            case "beatwideamplitude":
                this.beatWideAmplitude = value;
                return true;
            case "beatslightlength":
                this.beatSlightLength = value;
                return true;
            case "beatslightamplitude":
                this.beatSlightAmplitude = value;
                return true;
        } return false; };
        return VibratoPlaybackSettings;
    }());
    /**
     * This object defines the details on how to generate the slide effects.
     * @json
     */
    var SlidePlaybackSettings = /** @class */ (function () {
        function SlidePlaybackSettings() {
            /**
             * Gets or sets 1/4 tones (bend value) offset that
             * simple slides like slide-out-below or slide-in-above use.
             */
            this.simpleSlidePitchOffset = 6;
            /**
             * Gets or sets the percentage which the simple slides should take up
             * from the whole note. for "slide into" effects the slide will take place
             * from time 0 where the note is plucked to 25% of the overall note duration.
             * For "slide out" effects the slide will start 75% and finish at 100% of the overall
             * note duration.
             */
            this.simpleSlideDurationRatio = 0.25;
            /**
             * Gets or sets the percentage which the legato and shift slides should take up
             * from the whole note. For a value 0.5 the sliding will start at 50% of the overall note duration
             * and finish at 100%
             */
            this.shiftSlideDurationRatio = 0.5;
        }
        SlidePlaybackSettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        SlidePlaybackSettings.prototype.fillToJson = function (json) { json.simpleSlidePitchOffset = this.simpleSlidePitchOffset; json.simpleSlideDurationRatio = this.simpleSlideDurationRatio; json.shiftSlideDurationRatio = this.shiftSlideDurationRatio; };
        SlidePlaybackSettings.fromJson = function (json) { if (!json)
            return null; var obj = new SlidePlaybackSettings(); obj.fillFromJson(json); return obj; };
        SlidePlaybackSettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        SlidePlaybackSettings.prototype.setProperty = function (property, value) { switch (property) {
            case "simpleslidepitchoffset":
                this.simpleSlidePitchOffset = value;
                return true;
            case "simpleslidedurationratio":
                this.simpleSlideDurationRatio = value;
                return true;
            case "shiftslidedurationratio":
                this.shiftSlideDurationRatio = value;
                return true;
        } return false; };
        return SlidePlaybackSettings;
    }());
    /**
     * The player settings control how the audio playback and UI is behaving.
     * @json
     */
    var PlayerSettings = /** @class */ (function () {
        function PlayerSettings() {
            /**
             * Gets or sets the URl of the sound font to be loaded.
             */
            this.soundFont = null;
            /**
             * Gets or sets the element that should be used for scrolling.
             */
            this.scrollElement = 'html,body';
            /**
             * Gets or sets whether the player should be enabled.
             */
            this.enablePlayer = false;
            /**
             * Gets or sets whether playback cursors should be displayed.
             */
            this.enableCursor = true;
            /**
             * Gets or sets alphaTab should provide user interaction features to
             * select playback ranges and jump to the playback position by click (aka. seeking).
             */
            this.enableUserInteraction = true;
            /**
             * Gets or sets the X-offset to add when scrolling.
             */
            this.scrollOffsetX = 0;
            /**
             * Gets or sets the Y-offset to add when scrolling
             */
            this.scrollOffsetY = 0;
            /**
             * Gets or sets the mode how to scroll.
             */
            this.scrollMode = exports.ScrollMode.Continuous;
            /**
             * Gets or sets how fast the scrolling to the new position should happen (in milliseconds)
             */
            this.scrollSpeed = 300;
            /**
             * Gets or sets the bend duration in milliseconds for songbook bends.
             */
            this.songBookBendDuration = 75;
            /**
             * Gets or sets the duration of whammy dips in milliseconds for songbook whammys.
             */
            this.songBookDipDuration = 150;
            /**
             * Gets or sets the settings on how the vibrato audio is generated.
             */
            this.vibrato = new VibratoPlaybackSettings();
            /**
             * Gets or sets the setitngs on how the slide audio is generated.
             */
            this.slide = new SlidePlaybackSettings();
            /**
             * Gets or sets whether the triplet feel should be applied/played during audio playback.
             */
            this.playTripletFeel = true;
        }
        PlayerSettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        PlayerSettings.prototype.fillToJson = function (json) { json.soundFont = this.soundFont; json.scrollElement = this.scrollElement; json.enablePlayer = this.enablePlayer; json.enableCursor = this.enableCursor; json.enableUserInteraction = this.enableUserInteraction; json.scrollOffsetX = this.scrollOffsetX; json.scrollOffsetY = this.scrollOffsetY; json.scrollMode = this.scrollMode; json.scrollSpeed = this.scrollSpeed; json.songBookBendDuration = this.songBookBendDuration; json.songBookDipDuration = this.songBookDipDuration; if (json.vibrato)
            this.vibrato.fillToJson(json.vibrato);
        else
            json.vibrato = (VibratoPlaybackSettings.toJson(this.vibrato)); if (json.slide)
            this.slide.fillToJson(json.slide);
        else
            json.slide = (SlidePlaybackSettings.toJson(this.slide)); json.playTripletFeel = this.playTripletFeel; };
        PlayerSettings.fromJson = function (json) { if (!json)
            return null; var obj = new PlayerSettings(); obj.fillFromJson(json); return obj; };
        PlayerSettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        PlayerSettings.prototype.setProperty = function (property, value) { switch (property) {
            case "soundfont":
                this.soundFont = value;
                return true;
            case "scrollelement":
                this.scrollElement = value;
                return true;
            case "enableplayer":
                this.enablePlayer = value;
                return true;
            case "enablecursor":
                this.enableCursor = value;
                return true;
            case "enableuserinteraction":
                this.enableUserInteraction = value;
                return true;
            case "scrolloffsetx":
                this.scrollOffsetX = value;
                return true;
            case "scrolloffsety":
                this.scrollOffsetY = value;
                return true;
            case "scrollmode":
                this.scrollMode = isNaN(parseInt(value)) ? exports.ScrollMode[Object.keys(exports.ScrollMode).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "scrollspeed":
                this.scrollSpeed = value;
                return true;
            case "songbookbendduration":
                this.songBookBendDuration = value;
                return true;
            case "songbookdipduration":
                this.songBookDipDuration = value;
                return true;
            case "playtripletfeel":
                this.playTripletFeel = value;
                return true;
        } if (["vibrato"].indexOf(property) >= 0) {
            if (this.vibrato)
                this.vibrato.fillFromJson(value);
            else
                this.vibrato = (VibratoPlaybackSettings.fromJson(value));
            return true;
        }
        else {
            for (var _i = 0, _a = ["vibrato"]; _i < _a.length; _i++) {
                var $c = _a[_i];
                if (property.indexOf($c) === 0) {
                    if (!this.vibrato)
                        this.vibrato = new VibratoPlaybackSettings();
                    if (this.vibrato.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } if (["slide"].indexOf(property) >= 0) {
            if (this.slide)
                this.slide.fillFromJson(value);
            else
                this.slide = (SlidePlaybackSettings.fromJson(value));
            return true;
        }
        else {
            for (var _b = 0, _c = ["slide"]; _b < _c.length; _b++) {
                var $c = _c[_b];
                if (property.indexOf($c) === 0) {
                    if (!this.slide)
                        this.slide = new SlidePlaybackSettings();
                    if (this.slide.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } return false; };
        return PlayerSettings;
    }());

    /**
     * This public class contains instance specific settings for alphaTab
     * @json
     */
    var Settings = /** @class */ (function () {
        function Settings() {
            /**
             * The core settings control the general behavior of alphatab like
             * what modules are active.
             * @json_on_parent
             */
            this.core = new CoreSettings();
            /**
             * The display settings control how the general layout and display of alphaTab is done.
             * @json_on_parent
             */
            this.display = new DisplaySettings();
            /**
             * The notation settings control how various music notation elements are shown and behaving.
             */
            this.notation = new NotationSettings();
            /**
             * All settings related to importers that decode file formats.
             */
            this.importer = new ImporterSettings();
            /**
             * Contains all player related settings
             */
            this.player = new PlayerSettings();
        }
        /**
         * @target web
         */
        Settings.prototype.fillFromDataAttributes = function (dataAttributes) {
            var _this = this;
            dataAttributes.forEach(function (v, k) {
                _this.setProperty(k.toLowerCase(), v);
            });
        };
        Settings.prototype.setSongBookModeSettings = function () {
            this.notation.notationMode = exports.NotationMode.SongBook;
            this.notation.smallGraceTabNotes = false;
            this.notation.fingeringMode = exports.FingeringMode.SingleNoteEffectBand;
            this.notation.extendBendArrowsOnTiedNotes = false;
            this.notation.elements.set(NotationElement.ParenthesisOnTiedBends, false);
            this.notation.elements.set(NotationElement.TabNotesOnTiedBends, false);
            this.notation.elements.set(NotationElement.ZerosOnDiveWhammys, true);
        };
        Object.defineProperty(Settings, "songBook", {
            get: function () {
                var settings = new Settings();
                settings.setSongBookModeSettings();
                return settings;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @target web
         */
        Settings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        Settings.prototype.fillToJson = function (json) { if (json.core)
            this.core.fillToJson(json.core);
        else
            json.core = (CoreSettings.toJson(this.core)); if (json.display)
            this.display.fillToJson(json.display);
        else
            json.display = (DisplaySettings.toJson(this.display)); if (json.notation)
            this.notation.fillToJson(json.notation);
        else
            json.notation = (NotationSettings.toJson(this.notation)); if (json.importer)
            this.importer.fillToJson(json.importer);
        else
            json.importer = (ImporterSettings.toJson(this.importer)); if (json.player)
            this.player.fillToJson(json.player);
        else
            json.player = (PlayerSettings.toJson(this.player)); };
        /**
         * @target web
         */
        Settings.fromJson = function (json) { if (!json)
            return null; var obj = new Settings(); obj.fillFromJson(json); return obj; };
        /**
         * @target web
         */
        Settings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        /**
         * @target web
         */
        Settings.prototype.setProperty = function (property, value) { if (["core", ""].indexOf(property) >= 0) {
            if (this.core)
                this.core.fillFromJson(value);
            else
                this.core = (CoreSettings.fromJson(value));
            return true;
        }
        else {
            for (var _i = 0, _a = ["core", ""]; _i < _a.length; _i++) {
                var $c = _a[_i];
                if (property.indexOf($c) === 0) {
                    if (!this.core)
                        this.core = new CoreSettings();
                    if (this.core.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } if (["display", ""].indexOf(property) >= 0) {
            if (this.display)
                this.display.fillFromJson(value);
            else
                this.display = (DisplaySettings.fromJson(value));
            return true;
        }
        else {
            for (var _b = 0, _c = ["display", ""]; _b < _c.length; _b++) {
                var $c = _c[_b];
                if (property.indexOf($c) === 0) {
                    if (!this.display)
                        this.display = new DisplaySettings();
                    if (this.display.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } if (["notation"].indexOf(property) >= 0) {
            if (this.notation)
                this.notation.fillFromJson(value);
            else
                this.notation = (NotationSettings.fromJson(value));
            return true;
        }
        else {
            for (var _d = 0, _e = ["notation"]; _d < _e.length; _d++) {
                var $c = _e[_d];
                if (property.indexOf($c) === 0) {
                    if (!this.notation)
                        this.notation = new NotationSettings();
                    if (this.notation.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } if (["importer"].indexOf(property) >= 0) {
            if (this.importer)
                this.importer.fillFromJson(value);
            else
                this.importer = (ImporterSettings.fromJson(value));
            return true;
        }
        else {
            for (var _f = 0, _g = ["importer"]; _f < _g.length; _f++) {
                var $c = _g[_f];
                if (property.indexOf($c) === 0) {
                    if (!this.importer)
                        this.importer = new ImporterSettings();
                    if (this.importer.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } if (["player"].indexOf(property) >= 0) {
            if (this.player)
                this.player.fillFromJson(value);
            else
                this.player = (PlayerSettings.fromJson(value));
            return true;
        }
        else {
            for (var _h = 0, _j = ["player"]; _h < _j.length; _h++) {
                var $c = _j[_h];
                if (property.indexOf($c) === 0) {
                    if (!this.player)
                        this.player = new PlayerSettings();
                    if (this.player.setProperty(property.substring($c.length), value))
                        return true;
                }
            }
        } return false; };
        return Settings;
    }());

    var __extends$h = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /*
     * Represents a MIDI 2.0 Channel Voice Message.
     */
    var Midi20PerNotePitchBendEvent = /** @class */ (function (_super) {
        __extends$h(Midi20PerNotePitchBendEvent, _super);
        function Midi20PerNotePitchBendEvent(tick, status, noteKey, pitch) {
            var _this = _super.call(this, tick, status, 0, 0) || this;
            _this.noteKey = noteKey;
            _this.pitch = pitch;
            return _this;
        }
        /**
         * Writes the midi event as binary into the given stream.
         * @param s The stream to write to.
         */
        Midi20PerNotePitchBendEvent.prototype.writeTo = function (s) {
            var b = new Uint8Array([
                0x40,
                this.message & 0xff,
                this.noteKey & 0xff,
                0x00 /* reserved */,
                /* 32bit pitch integer */
                (this.pitch >> 24) & 0xff,
                (this.pitch >> 16) & 0xff,
                (this.pitch >> 8) & 0xff,
                this.pitch & 0xff
            ]);
            s.write(b, 0, b.length);
        };
        return Midi20PerNotePitchBendEvent;
    }(MidiEvent));

    /**
     * This class can convert a full {@link Score} instance to a simple JavaScript object and back for further
     * JSON serialization.
     * @target web
     */
    var JsonConverter = /** @class */ (function () {
        function JsonConverter() {
        }
        /**
         * Converts the given score into a JSON encoded string.
         * @param score The score to serialize.
         * @returns A JSON encoded string that can be used togehter with  for conversion.
         */
        JsonConverter.scoreToJson = function (score) {
            var obj = JsonConverter.scoreToJsObject(score);
            return JSON.stringify(obj, function (_, v) {
                // patch arraybuffer to serialize as array
                if (ArrayBuffer.isView(v)) {
                    return Array.apply([], [v]);
                }
                return v;
            });
        };
        /**
         * Converts the score into a JavaScript object without circular dependencies.
         * @param score The score object to serialize
         * @returns A serialized score object without ciruclar dependencies that can be used for further serializations.
         */
        JsonConverter.scoreToJsObject = function (score) {
            var score2 = {};
            Score.copyTo(score, score2);
            score2.masterBars = [];
            score2.tracks = [];
            score2.stylesheet = {};
            RenderStylesheet.copyTo(score.stylesheet, score2.stylesheet);
            JsonConverter.masterBarsToJsObject(score, score2);
            JsonConverter.tracksToJsObject(score, score2);
            return score2;
        };
        JsonConverter.tracksToJsObject = function (score, score2) {
            for (var t = 0; t < score.tracks.length; t++) {
                var track = score.tracks[t];
                var track2 = {};
                track2.color = {};
                Track.copyTo(track, track2);
                track2.playbackInfo = {};
                PlaybackInformation.copyTo(track.playbackInfo, track2.playbackInfo);
                track2.percussionArticulations = [];
                for (var _i = 0, _a = track.percussionArticulations; _i < _a.length; _i++) {
                    var articulation = _a[_i];
                    var articulation2 = {};
                    InstrumentArticulation.copyTo(articulation, articulation2);
                    track2.percussionArticulations.push(articulation2);
                }
                JsonConverter.stavesToJsObject(track, track2);
                score2.tracks.push(track2);
            }
        };
        JsonConverter.stavesToJsObject = function (track, track2) {
            track2.staves = [];
            var _loop_1 = function (s) {
                var staff = track.staves[s];
                var staff2 = {};
                Staff.copyTo(staff, staff2);
                staff2.chords = new Map();
                staff.chords.forEach(function (chord, chordId) {
                    var chord2 = {};
                    Chord.copyTo(chord, chord2);
                    staff2.chords.set(chordId, chord2);
                });
                JsonConverter.barsToJsObject(staff, staff2);
                track2.staves.push(staff2);
            };
            for (var s = 0; s < track.staves.length; s++) {
                _loop_1(s);
            }
        };
        JsonConverter.barsToJsObject = function (staff, staff2) {
            staff2.bars = [];
            for (var b = 0; b < staff.bars.length; b++) {
                var bar = staff.bars[b];
                var bar2 = {};
                Bar.copyTo(bar, bar2);
                JsonConverter.voicesToJsObject(bar, bar2);
                staff2.bars.push(bar2);
            }
        };
        JsonConverter.voicesToJsObject = function (bar, bar2) {
            bar2.voices = [];
            for (var v = 0; v < bar.voices.length; v++) {
                var voice = bar.voices[v];
                var voice2 = {};
                Voice.copyTo(voice, voice2);
                JsonConverter.beatsToJsObject(voice, voice2);
                bar2.voices.push(voice2);
            }
        };
        JsonConverter.beatsToJsObject = function (voice, voice2) {
            voice2.beats = [];
            for (var bb = 0; bb < voice.beats.length; bb++) {
                var beat = voice.beats[bb];
                var dynamicBeat2 = {};
                var beat2 = dynamicBeat2;
                Beat.copyTo(beat, beat2);
                beat2.automations = [];
                for (var a = 0; a < beat.automations.length; a++) {
                    var automation = {};
                    Automation.copyTo(beat.automations[a], automation);
                    beat2.automations.push(automation);
                }
                beat2.whammyBarPoints = [];
                for (var i = 0; i < beat.whammyBarPoints.length; i++) {
                    var point = {};
                    BendPoint.copyTo(beat.whammyBarPoints[i], point);
                    beat2.whammyBarPoints.push(point);
                }
                JsonConverter.notesToJsObject(beat, beat2);
                voice2.beats.push(beat2);
            }
        };
        JsonConverter.notesToJsObject = function (beat, beat2) {
            beat2.notes = [];
            for (var n = 0; n < beat.notes.length; n++) {
                var note = beat.notes[n];
                var dynamicNote2 = {};
                var note2 = dynamicNote2;
                Note.copyTo(note, note2);
                if (note.isTieDestination) {
                    dynamicNote2.tieOriginId = note.tieOrigin.id;
                }
                if (note.isTieOrigin) {
                    dynamicNote2.tieDestinationId = note.tieDestination.id;
                }
                if (note.isSlurDestination) {
                    dynamicNote2.slurOriginId = note.slurOrigin.id;
                }
                if (note.isSlurOrigin) {
                    dynamicNote2.slurDestinationId = note.slurDestination.id;
                }
                if (note.isHammerPullDestination) {
                    dynamicNote2.hammerPullOriginId = note.hammerPullOrigin.id;
                }
                if (note.isHammerPullOrigin) {
                    dynamicNote2.hammerPullDestinationId = note.hammerPullDestination.id;
                }
                note2.bendPoints = [];
                for (var i = 0; i < note.bendPoints.length; i++) {
                    var point = {};
                    BendPoint.copyTo(note.bendPoints[i], point);
                    note2.bendPoints.push(point);
                }
                beat2.notes.push(note2);
            }
        };
        JsonConverter.masterBarsToJsObject = function (score, score2) {
            var _loop_2 = function (i) {
                var masterBar = score.masterBars[i];
                var masterBar2 = {};
                MasterBar.copyTo(masterBar, masterBar2);
                if (masterBar.tempoAutomation) {
                    masterBar2.tempoAutomation = {};
                    Automation.copyTo(masterBar.tempoAutomation, masterBar2.tempoAutomation);
                }
                if (masterBar.section) {
                    masterBar2.section = {};
                    Section.copyTo(masterBar.section, masterBar2.section);
                }
                masterBar2.fermata = new Map();
                masterBar.fermata.forEach(function (fermata, fermataId) {
                    var fermata2 = {};
                    masterBar2.fermata.set(fermataId, fermata2);
                    Fermata.copyTo(fermata, fermata2);
                });
                score2.masterBars.push(masterBar2);
            };
            for (var i = 0; i < score.masterBars.length; i++) {
                _loop_2(i);
            }
        };
        /**
         * Converts the given JSON string back to a {@link Score} object.
         * @param json The JSON string that was created via {@link Score}
         * @param settings The settings to use during conversion.
         * @returns The converted score object.
         */
        JsonConverter.jsonToScore = function (json, settings) {
            return JsonConverter.jsObjectToScore(JsonConverter.jsObjectToScore(JSON.parse(json), settings), settings);
        };
        /**
         * Converts the given JavaScript object into a score object.
         * @param jsObject The javascript object created via {@link Score}
         * @param settings The settings to use during conversion.
         * @returns The converted score object.
         */
        JsonConverter.jsObjectToScore = function (jsObject, settings) {
            var score = jsObject;
            var score2 = new Score();
            Score.copyTo(score, score2);
            RenderStylesheet.copyTo(score.stylesheet, score2.stylesheet);
            var allNotes = new Map();
            var notesToLink = [];
            JsonConverter.jsObjectToMasterBars(score, score2);
            JsonConverter.jsObjectToTracks(score, score2, allNotes, notesToLink);
            for (var _i = 0, notesToLink_1 = notesToLink; _i < notesToLink_1.length; _i++) {
                var note = notesToLink_1[_i];
                var serializedNote = note;
                if (serializedNote.tieOriginId !== undefined) {
                    note.tieOrigin = allNotes.get(serializedNote.tieOriginId);
                }
                if (serializedNote.tieDestinationId !== undefined) {
                    note.tieDestination = allNotes.get(serializedNote.tieDestinationId);
                }
                if (serializedNote.slurOriginId !== undefined) {
                    note.slurOrigin = allNotes.get(serializedNote.slurOriginId);
                }
                if (serializedNote.slurDestinationId !== undefined) {
                    note.slurDestination = allNotes.get(serializedNote.slurDestinationId);
                }
                if (serializedNote.hammerPullOriginId !== undefined) {
                    note.hammerPullOrigin = allNotes.get(serializedNote.hammerPullOriginId);
                }
                if (serializedNote.hammerPullDestinationId !== undefined) {
                    note.hammerPullDestination = allNotes.get(serializedNote.hammerPullDestinationId);
                }
            }
            score2.finish(settings !== null && settings !== void 0 ? settings : new Settings());
            return score2;
        };
        JsonConverter.jsObjectToTracks = function (score, score2, allNotes, notesToLink) {
            for (var t = 0; t < score.tracks.length; t++) {
                var track = score.tracks[t];
                var track2 = new Track();
                track2.ensureStaveCount(track.staves.length);
                Track.copyTo(track, track2);
                score2.addTrack(track2);
                PlaybackInformation.copyTo(track.playbackInfo, track2.playbackInfo);
                for (var _i = 0, _a = track.percussionArticulations; _i < _a.length; _i++) {
                    var articulation = _a[_i];
                    var articulation2 = new InstrumentArticulation();
                    InstrumentArticulation.copyTo(articulation, articulation2);
                    track2.percussionArticulations.push(articulation2);
                }
                JsonConverter.jsObjectToStaves(track, track2, allNotes, notesToLink);
            }
        };
        JsonConverter.jsObjectToStaves = function (track, track2, allNotes, notesToLink) {
            var _loop_3 = function (s) {
                var staff = track.staves[s];
                var staff2 = track2.staves[s];
                Staff.copyTo(staff, staff2);
                JsonConverter.jsObjectMapForEach(staff.chords, function (chord, chordId) {
                    var chord2 = new Chord();
                    Chord.copyTo(chord, chord2);
                    staff2.addChord(chordId, chord2);
                });
                JsonConverter.jsObjectToBars(staff, staff2, allNotes, notesToLink);
            };
            for (var s = 0; s < track.staves.length; s++) {
                _loop_3(s);
            }
        };
        JsonConverter.jsObjectMapForEach = function (obj, callback) {
            if ('forEach' in obj) {
                obj.forEach(callback);
            }
            else {
                for (var x in obj) {
                    if (obj.hasOwnProperty(x)) {
                        callback(obj[x], x);
                    }
                }
            }
        };
        JsonConverter.jsObjectToBars = function (staff, staff2, allNotes, notesToLink) {
            for (var b = 0; b < staff.bars.length; b++) {
                var bar = staff.bars[b];
                var bar2 = new Bar();
                Bar.copyTo(bar, bar2);
                staff2.addBar(bar2);
                JsonConverter.jsObjectToVoices(bar, bar2, allNotes, notesToLink);
            }
        };
        JsonConverter.jsObjectToVoices = function (bar, bar2, allNotes, notesToLink) {
            for (var v = 0; v < bar.voices.length; v++) {
                var voice = bar.voices[v];
                var voice2 = new Voice();
                Voice.copyTo(voice, voice2);
                bar2.addVoice(voice2);
                JsonConverter.jsObjectToBeats(voice, voice2, allNotes, notesToLink);
            }
        };
        JsonConverter.jsObjectToBeats = function (voice, voice2, allNotes, notesToLink) {
            for (var bb = 0; bb < voice.beats.length; bb++) {
                var beat = voice.beats[bb];
                var beat2 = new Beat();
                Beat.copyTo(beat, beat2);
                voice2.addBeat(beat2);
                for (var a = 0; a < beat.automations.length; a++) {
                    var automation = new Automation();
                    Automation.copyTo(beat.automations[a], automation);
                    beat2.automations.push(automation);
                }
                for (var i = 0; i < beat.whammyBarPoints.length; i++) {
                    var point = new BendPoint(0, 0);
                    BendPoint.copyTo(beat.whammyBarPoints[i], point);
                    beat2.addWhammyBarPoint(point);
                }
                JsonConverter.jsObjectToNotes(beat, beat2, allNotes, notesToLink);
            }
        };
        JsonConverter.jsObjectToNotes = function (beat, beat2, allNotes, notesToLink) {
            for (var n = 0; n < beat.notes.length; n++) {
                var note = beat.notes[n];
                var note2 = new Note();
                Note.copyTo(note, note2);
                beat2.addNote(note2);
                allNotes.set(note2.id, note2);
                var serializedNote = note;
                var serializedNote2 = note2;
                if (serializedNote.tieOriginId !== undefined) {
                    serializedNote2.tieOriginId = serializedNote.tieOriginId;
                    notesToLink.push(note2);
                }
                if (serializedNote.tieDestinationId !== undefined) {
                    serializedNote2.tieDestinationId = serializedNote.tieDestinationId;
                    notesToLink.push(note2);
                }
                if (serializedNote.slurOriginId !== undefined) {
                    serializedNote2.slurOriginId = serializedNote.slurOriginId;
                    notesToLink.push(note2);
                }
                if (serializedNote.slurDestinationId !== undefined) {
                    serializedNote2.slurDestinationId = serializedNote.slurDestinationId;
                    notesToLink.push(note2);
                }
                if (serializedNote.hammerPullOriginId !== undefined) {
                    serializedNote2.hammerPullOriginId = serializedNote.hammerPullOriginId;
                    notesToLink.push(note2);
                }
                if (serializedNote.hammerPullDestinationId !== undefined) {
                    serializedNote2.hammerPullDestinationId = serializedNote.hammerPullDestinationId;
                    notesToLink.push(note2);
                }
                for (var i = 0; i < note.bendPoints.length; i++) {
                    var point = new BendPoint(0, 0);
                    BendPoint.copyTo(note.bendPoints[i], point);
                    note2.addBendPoint(point);
                }
            }
        };
        JsonConverter.jsObjectToMasterBars = function (score, score2) {
            var _loop_4 = function (i) {
                var masterBar = score.masterBars[i];
                var masterBar2 = new MasterBar();
                MasterBar.copyTo(masterBar, masterBar2);
                if (masterBar.tempoAutomation) {
                    masterBar2.tempoAutomation = new Automation();
                    Automation.copyTo(masterBar.tempoAutomation, masterBar2.tempoAutomation);
                }
                if (masterBar.section) {
                    masterBar2.section = new Section();
                    Section.copyTo(masterBar.section, masterBar2.section);
                }
                JsonConverter.jsObjectMapForEach(masterBar.fermata, function (fermata, key) {
                    var fermata2 = new Fermata();
                    Fermata.copyTo(fermata, fermata2);
                    masterBar2.addFermata(typeof key === 'string' ? parseInt(key) : key, fermata2);
                });
                score2.addMasterBar(masterBar2);
            };
            for (var i = 0; i < score.masterBars.length; i++) {
                _loop_4(i);
            }
        };
        JsonConverter.jsObjectToMidiFile = function (midi) {
            var midi2 = new MidiFile();
            midi2.division = midi.division;
            var midiEvents = midi.events;
            for (var _i = 0, midiEvents_1 = midiEvents; _i < midiEvents_1.length; _i++) {
                var midiEvent = midiEvents_1[_i];
                var tick = midiEvent.tick;
                var message = midiEvent.message;
                var midiEvent2 = void 0;
                switch (midiEvent.type) {
                    case 'SystemExclusiveEvent':
                        midiEvent2 = new SystemExclusiveEvent(tick, 0, 0, midiEvent.data);
                        midiEvent2.message = message;
                        break;
                    case 'MetaDataEvent':
                        midiEvent2 = new MetaDataEvent(tick, 0, 0, midiEvent.data);
                        midiEvent2.message = message;
                        break;
                    case 'MetaNumberEvent':
                        midiEvent2 = new MetaNumberEvent(tick, 0, 0, midiEvent.value);
                        midiEvent2.message = message;
                        break;
                    case 'Midi20PerNotePitchBendEvent':
                        midiEvent2 = new Midi20PerNotePitchBendEvent(tick, 0, midiEvent.noteKey, midiEvent.pitch);
                        midiEvent2.message = message;
                        break;
                    default:
                        midiEvent2 = new MidiEvent(tick, 0, 0, 0);
                        midiEvent2.message = message;
                        break;
                }
                midi2.events.push(midiEvent2);
            }
            return midi2;
        };
        JsonConverter.midiFileToJsObject = function (midi) {
            var midi2 = {};
            midi2.division = midi.division;
            var midiEvents = [];
            midi2.events = midiEvents;
            for (var _i = 0, _a = midi.events; _i < _a.length; _i++) {
                var midiEvent = _a[_i];
                var midiEvent2 = {};
                midiEvents.push(midiEvent2);
                midiEvent2.tick = midiEvent.tick;
                midiEvent2.message = midiEvent.message;
                if (midiEvent instanceof SystemExclusiveEvent) {
                    midiEvent2.type = 'SystemExclusiveEvent';
                    midiEvent2.data = midiEvent.data;
                }
                else if (midiEvent instanceof MetaDataEvent) {
                    midiEvent2.type = 'MetaDataEvent';
                    midiEvent2.data = midiEvent.data;
                }
                else if (midiEvent instanceof MetaNumberEvent) {
                    midiEvent2.type = 'MetaNumberEvent';
                    midiEvent2.value = midiEvent.value;
                }
                else if (midiEvent instanceof Midi20PerNotePitchBendEvent) {
                    midiEvent2.type = 'Midi20PerNotePitchBendEvent';
                    midiEvent2.noteKey = midiEvent.noteKey;
                    midiEvent2.pitch = midiEvent.pitch;
                }
            }
            return midi2;
        };
        return JsonConverter;
    }());

    /**
     * @target web
     */
    var AlphaSynthWorkerSynthOutput = /** @class */ (function () {
        function AlphaSynthWorkerSynthOutput() {
            this.ready = new EventEmitter();
            this.samplesPlayed = new EventEmitterOfT();
            this.sampleRequest = new EventEmitter();
        }
        Object.defineProperty(AlphaSynthWorkerSynthOutput.prototype, "sampleRate", {
            get: function () {
                return AlphaSynthWorkerSynthOutput.preferredSampleRate;
            },
            enumerable: false,
            configurable: true
        });
        AlphaSynthWorkerSynthOutput.prototype.open = function () {
            Logger.debug('AlphaSynth', 'Initializing webworker worker');
            this._worker = Environment.globalThis;
            this._worker.addEventListener('message', this.handleMessage.bind(this));
            this.ready.trigger();
        };
        AlphaSynthWorkerSynthOutput.prototype.handleMessage = function (e) {
            var data = e.data;
            var cmd = data.cmd;
            switch (cmd) {
                case AlphaSynthWorkerSynthOutput.CmdOutputSampleRequest:
                    this.sampleRequest.trigger();
                    break;
                case AlphaSynthWorkerSynthOutput.CmdOutputSamplesPlayed:
                    this.samplesPlayed.trigger(data.samples);
                    break;
            }
        };
        AlphaSynthWorkerSynthOutput.prototype.addSamples = function (samples) {
            this._worker.postMessage({
                cmd: 'alphaSynth.output.addSamples',
                samples: samples
            });
        };
        AlphaSynthWorkerSynthOutput.prototype.play = function () {
            this._worker.postMessage({
                cmd: 'alphaSynth.output.play'
            });
        };
        AlphaSynthWorkerSynthOutput.prototype.pause = function () {
            this._worker.postMessage({
                cmd: 'alphaSynth.output.pause'
            });
        };
        AlphaSynthWorkerSynthOutput.prototype.resetSamples = function () {
            this._worker.postMessage({
                cmd: 'alphaSynth.output.resetSamples'
            });
        };
        AlphaSynthWorkerSynthOutput.prototype.activate = function () {
            // nothing to do
        };
        AlphaSynthWorkerSynthOutput.CmdOutputPrefix = 'alphaSynth.output.';
        AlphaSynthWorkerSynthOutput.CmdOutputAddSamples = AlphaSynthWorkerSynthOutput.CmdOutputPrefix + 'addSamples';
        AlphaSynthWorkerSynthOutput.CmdOutputPlay = AlphaSynthWorkerSynthOutput.CmdOutputPrefix + 'play';
        AlphaSynthWorkerSynthOutput.CmdOutputPause = AlphaSynthWorkerSynthOutput.CmdOutputPrefix + 'pause';
        AlphaSynthWorkerSynthOutput.CmdOutputResetSamples = AlphaSynthWorkerSynthOutput.CmdOutputPrefix + 'resetSamples';
        AlphaSynthWorkerSynthOutput.CmdOutputSampleRequest = AlphaSynthWorkerSynthOutput.CmdOutputPrefix + 'sampleRequest';
        AlphaSynthWorkerSynthOutput.CmdOutputSamplesPlayed = AlphaSynthWorkerSynthOutput.CmdOutputPrefix + 'samplesPlayed';
        // this value is initialized by the alphaSynth WebWorker wrapper
        // that also includes the alphaSynth library into the worker.
        AlphaSynthWorkerSynthOutput.preferredSampleRate = 0;
        return AlphaSynthWorkerSynthOutput;
    }());

    /**
     * This class implements a HTML5 WebWorker based version of alphaSynth
     * which can be controlled via WebWorker messages.
     * @target web
     */
    var AlphaSynthWebWorker = /** @class */ (function () {
        function AlphaSynthWebWorker(main) {
            this._main = main;
            this._main.addEventListener('message', this.handleMessage.bind(this));
            this._player = new AlphaSynth(new AlphaSynthWorkerSynthOutput());
            this._player.positionChanged.on(this.onPositionChanged.bind(this));
            this._player.stateChanged.on(this.onPlayerStateChanged.bind(this));
            this._player.finished.on(this.onFinished.bind(this));
            this._player.soundFontLoaded.on(this.onSoundFontLoaded.bind(this));
            this._player.soundFontLoadFailed.on(this.onSoundFontLoadFailed.bind(this));
            this._player.soundFontLoadFailed.on(this.onSoundFontLoadFailed.bind(this));
            this._player.midiLoaded.on(this.onMidiLoaded.bind(this));
            this._player.midiLoadFailed.on(this.onMidiLoadFailed.bind(this));
            this._player.readyForPlayback.on(this.onReadyForPlayback.bind(this));
            this._main.postMessage({
                cmd: 'alphaSynth.ready'
            });
        }
        AlphaSynthWebWorker.init = function () {
            var main = Environment.globalThis;
            main.addEventListener('message', function (e) {
                var data = e.data;
                var cmd = data.cmd;
                switch (cmd) {
                    case 'alphaSynth.initialize':
                        AlphaSynthWorkerSynthOutput.preferredSampleRate = data.sampleRate;
                        Logger.logLevel = data.logLevel;
                        Environment.globalThis.alphaSynthWebWorker = new AlphaSynthWebWorker(main);
                        break;
                }
            });
        };
        AlphaSynthWebWorker.prototype.handleMessage = function (e) {
            var data = e.data;
            var cmd = data.cmd;
            switch (cmd) {
                case 'alphaSynth.setLogLevel':
                    Logger.logLevel = data.value;
                    break;
                case 'alphaSynth.setMasterVolume':
                    this._player.masterVolume = data.value;
                    break;
                case 'alphaSynth.setMetronomeVolume':
                    this._player.metronomeVolume = data.value;
                    break;
                case 'alphaSynth.setPlaybackSpeed':
                    this._player.playbackSpeed = data.value;
                    break;
                case 'alphaSynth.setTickPosition':
                    this._player.tickPosition = data.value;
                    break;
                case 'alphaSynth.setTimePosition':
                    this._player.timePosition = data.value;
                    break;
                case 'alphaSynth.setPlaybackRange':
                    this._player.playbackRange = data.value;
                    break;
                case 'alphaSynth.setIsLooping':
                    this._player.isLooping = data.value;
                    break;
                case 'alphaSynth.setCountInVolume':
                    this._player.countInVolume = data.value;
                    break;
                case 'alphaSynth.play':
                    this._player.play();
                    break;
                case 'alphaSynth.pause':
                    this._player.pause();
                    break;
                case 'alphaSynth.playPause':
                    this._player.playPause();
                    break;
                case 'alphaSynth.stop':
                    this._player.stop();
                    break;
                case 'alphaSynth.playOneTimeMidiFile':
                    this._player.playOneTimeMidiFile(JsonConverter.jsObjectToMidiFile(data.midi));
                    break;
                case 'alphaSynth.loadSoundFontBytes':
                    this._player.loadSoundFont(data.data, data.append);
                    break;
                case 'alphaSynth.resetSoundFonts':
                    this._player.resetSoundFonts();
                    break;
                case 'alphaSynth.loadMidi':
                    this._player.loadMidiFile(JsonConverter.jsObjectToMidiFile(data.midi));
                    break;
                case 'alphaSynth.setChannelMute':
                    this._player.setChannelMute(data.channel, data.mute);
                    break;
                case 'alphaSynth.setChannelSolo':
                    this._player.setChannelSolo(data.channel, data.solo);
                    break;
                case 'alphaSynth.setChannelVolume':
                    this._player.setChannelVolume(data.channel, data.volume);
                    break;
                case 'alphaSynth.resetChannelStates':
                    this._player.resetChannelStates();
                    break;
            }
        };
        AlphaSynthWebWorker.prototype.onPositionChanged = function (e) {
            this._main.postMessage({
                cmd: 'alphaSynth.positionChanged',
                currentTime: e.currentTime,
                endTime: e.endTime,
                currentTick: e.currentTick,
                endTick: e.endTick
            });
        };
        AlphaSynthWebWorker.prototype.onPlayerStateChanged = function (e) {
            this._main.postMessage({
                cmd: 'alphaSynth.playerStateChanged',
                state: e.state,
                stopped: e.stopped
            });
        };
        AlphaSynthWebWorker.prototype.onFinished = function () {
            this._main.postMessage({
                cmd: 'alphaSynth.finished'
            });
        };
        AlphaSynthWebWorker.prototype.onSoundFontLoaded = function () {
            this._main.postMessage({
                cmd: 'alphaSynth.soundFontLoaded'
            });
        };
        AlphaSynthWebWorker.prototype.onSoundFontLoadFailed = function (e) {
            this._main.postMessage({
                cmd: 'alphaSynth.soundFontLoadFailed',
                error: this.serializeException(e)
            });
        };
        AlphaSynthWebWorker.prototype.serializeException = function (e) {
            var error = JSON.parse(JSON.stringify(e));
            if (e.message) {
                error.message = e.message;
            }
            if (e.stack) {
                error.stack = e.stack;
            }
            if (e.constructor && e.constructor.name) {
                error.type = e.constructor.name;
            }
            return error;
        };
        AlphaSynthWebWorker.prototype.onMidiLoaded = function () {
            this._main.postMessage({
                cmd: 'alphaSynth.midiLoaded'
            });
        };
        AlphaSynthWebWorker.prototype.onMidiLoadFailed = function (e) {
            this._main.postMessage({
                cmd: 'alphaSynth.midiLoaded',
                error: this.serializeException(e)
            });
        };
        AlphaSynthWebWorker.prototype.onReadyForPlayback = function () {
            this._main.postMessage({
                cmd: 'alphaSynth.readyForPlayback'
            });
        };
        return AlphaSynthWebWorker;
    }());

    /**
     * This public class stores text widths for several fonts and allows width calculation
     * @partial
     */
    var FontSizes = /** @class */ (function () {
        function FontSizes() {
        }
        /**
         * @target web
         */
        FontSizes.generateFontLookup = function (family) {
            if (FontSizes.FontSizeLookupTables.has(family)) {
                return;
            }
            if (!Environment.isRunningInWorker) {
                var canvas = document.createElement('canvas');
                var measureContext = canvas.getContext('2d');
                measureContext.font = "11px " + family;
                var sizes = [];
                for (var i = 0x20; i < 255; i++) {
                    var s = String.fromCharCode(i);
                    sizes.push(measureContext.measureText(s).width);
                }
                var data = new Uint8Array(sizes);
                FontSizes.FontSizeLookupTables.set(family, data);
            }
            else {
                FontSizes.FontSizeLookupTables.set(family, new Uint8Array([8]));
            }
        };
        FontSizes.measureString = function (s, family, size, style) {
            var data;
            var dataSize = 11;
            if (!FontSizes.FontSizeLookupTables.has(family)) {
                FontSizes.generateFontLookup(family);
            }
            data = FontSizes.FontSizeLookupTables.get(family);
            var factor = 1;
            if ((style & FontStyle.Italic) !== 0) {
                factor *= 1.2;
            }
            if ((style & FontStyle.Bold) !== 0) {
                factor *= 1.2;
            }
            var stringSize = 0;
            for (var i = 0; i < s.length; i++) {
                var code = Math.min(data.length - 1, s.charCodeAt(i) - 32);
                if (code >= 0) {
                    stringSize += (data[code] * size) / dataSize;
                }
            }
            return stringSize * factor;
        };
        // prettier-ignore
        FontSizes.Georgia = new Uint8Array([
            3, 4, 5, 7, 7, 9, 8, 2, 4, 4, 5, 7, 3, 4, 3, 5, 7, 5, 6, 6, 6, 6, 6, 6, 7, 6, 3, 3, 7,
            7, 7, 5, 10, 7, 7, 7, 8, 7, 7, 8, 9, 4, 6, 8, 7, 10, 8, 8, 7, 8, 8, 6, 7, 8, 7, 11, 8,
            7, 7, 4, 5, 4, 7, 7, 6, 6, 6, 5, 6, 5, 4, 6, 6, 3, 3, 6, 3, 10, 6, 6, 6, 6, 5, 5, 4, 6,
            5, 8, 6, 5, 5, 5, 4, 5, 7, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
            8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 3, 4, 6, 7, 6, 7, 4, 6, 6, 10, 6, 6, 7, 0, 10, 7,
            5, 7, 6, 6, 6, 6, 6, 3, 6, 6, 6, 6, 12, 12, 12, 5, 7, 7, 7, 7, 7, 7, 11, 7, 7, 7, 7, 7,
            4, 4, 4, 4, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 7, 7, 6, 6, 6, 6, 6, 6, 6, 8, 5, 5,
            5, 5, 5, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 5, 6
        ]);
        // prettier-ignore
        FontSizes.Arial = new Uint8Array([
            3, 3, 4, 6, 6, 10, 7, 2, 4, 4, 4, 6, 3, 4, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 3, 3, 6,
            6, 6, 6, 11, 7, 7, 8, 8, 7, 7, 9, 8, 3, 6, 7, 6, 9, 8, 9, 7, 9, 8, 7, 7, 8, 7, 10, 7, 7,
            7, 3, 3, 3, 5, 6, 4, 6, 6, 6, 6, 6, 3, 6, 6, 2, 2, 6, 2, 9, 6, 6, 6, 6, 4, 6, 3, 6, 6,
            8, 6, 6, 6, 4, 3, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 6, 6, 6, 6, 3, 6, 4, 8, 4, 6, 6, 0, 8, 6, 4,
            6, 4, 4, 4, 6, 6, 4, 4, 4, 4, 6, 9, 9, 9, 7, 7, 7, 7, 7, 7, 7, 11, 8, 7, 7, 7, 7, 3, 3,
            3, 3, 8, 8, 9, 9, 9, 9, 9, 6, 9, 8, 8, 8, 8, 7, 7, 7, 6, 6, 6, 6, 6, 6, 10, 6, 6, 6, 6,
            6, 3, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6
        ]);
        FontSizes.FontSizeLookupTables = new Map([
            ['Arial', FontSizes.Arial],
            ["'Arial'", FontSizes.Arial],
            ['"Arial"', FontSizes.Arial],
            ['Georgia', FontSizes.Georgia],
            ["'Georgia'", FontSizes.Georgia],
            ['"Georgia"', FontSizes.Georgia]
        ]);
        FontSizes.ControlChars = 0x20;
        return FontSizes;
    }());

    /**
     * This eventargs define the details about the rendering and layouting process and are
     * provided whenever a part of of the music sheet is rendered.
     */
    var RenderFinishedEventArgs = /** @class */ (function () {
        function RenderFinishedEventArgs() {
            /**
             * Gets or sets the width of the current rendering result.
             */
            this.width = 0;
            /**
             * Gets or sets the height of the current rendering result.
             */
            this.height = 0;
            /**
             * Gets or sets the currently known total width of the final music sheet.
             */
            this.totalWidth = 0;
            /**
             * Gets or sets the currently known total height of the final music sheet.
             */
            this.totalHeight = 0;
            /**
             * Gets or sets the index of the first masterbar that was rendered in this result.
             */
            this.firstMasterBarIndex = 0;
            /**
             * Gets or sets the index of the last masterbar that was rendered in this result.
             */
            this.lastMasterBarIndex = 0;
            /**
             * Gets or sets the render engine specific result object which contains the rendered music sheet.
             */
            this.renderResult = null;
        }
        return RenderFinishedEventArgs;
    }());

    /**
     * Represents the boundaries of a single bar.
     */
    var BarBounds = /** @class */ (function () {
        function BarBounds() {
            /**
             * Gets or sets a list of the beats contained in this lookup.
             */
            this.beats = [];
        }
        /**
         * Adds a new beat to this lookup.
         * @param bounds The beat bounds to add.
         */
        BarBounds.prototype.addBeat = function (bounds) {
            bounds.barBounds = this;
            this.beats.push(bounds);
            this.masterBarBounds.addBeat(bounds);
        };
        /**
         * Tries to find the beat at the given X-position.
         * @param x The X-position of the beat to find.
         * @returns The beat at the given X-position or null if none was found.
         */
        BarBounds.prototype.findBeatAtPos = function (x) {
            var beat = null;
            for (var _i = 0, _a = this.beats; _i < _a.length; _i++) {
                var t = _a[_i];
                if (!beat || t.realBounds.x < x) {
                    beat = t;
                }
                else if (t.realBounds.x > x) {
                    break;
                }
            }
            return beat;
        };
        return BarBounds;
    }());

    /**
     * Represents the bounds of a single beat.
     */
    var BeatBounds = /** @class */ (function () {
        function BeatBounds() {
            /**
             * Gets or sets the individual note positions of this beat (if {@link CoreSettings.includeNoteBounds} was set to true).
             */
            this.notes = null;
        }
        /**
         * Adds a new note to this bounds.
         * @param bounds The note bounds to add.
         */
        BeatBounds.prototype.addNote = function (bounds) {
            if (!this.notes) {
                this.notes = [];
            }
            bounds.beatBounds = this;
            this.notes.push(bounds);
        };
        /**
         * Tries to find a note at the given position.
         * @param x The X-position of the note to find.
         * @param y The Y-position of the note to find.
         * @returns The note at the given position or null if no note was found, or the note lookup was not enabled before rendering.
         */
        BeatBounds.prototype.findNoteAtPos = function (x, y) {
            if (!this.notes) {
                return null;
            }
            // TODO: can be likely optimized
            // a beat is mostly vertically aligned, we could sort the note bounds by Y
            // and then do a binary search on the Y-axis.
            for (var _i = 0, _a = this.notes; _i < _a.length; _i++) {
                var note = _a[_i];
                var bottom = note.noteHeadBounds.y + note.noteHeadBounds.h;
                var right = note.noteHeadBounds.x + note.noteHeadBounds.w;
                if (note.noteHeadBounds.x >= x && note.noteHeadBounds.y >= y && x <= right && y <= bottom) {
                    return note.note;
                }
            }
            return null;
        };
        return BeatBounds;
    }());

    /**
     * Represents the boundaries of a list of bars related to a single master bar.
     */
    var MasterBarBounds = /** @class */ (function () {
        function MasterBarBounds() {
            /**
             * Gets or sets the index of this bounds relative within the parent lookup.
             */
            this.index = 0;
            /**
             * Gets or sets a value indicating whether this bounds are the first of the line.
             */
            this.isFirstOfLine = false;
            /**
             * Gets or sets the list of individual bars within this lookup.
             */
            this.bars = [];
        }
        /**
         * Adds a new bar to this lookup.
         * @param bounds The bar bounds to add to this lookup.
         */
        MasterBarBounds.prototype.addBar = function (bounds) {
            bounds.masterBarBounds = this;
            this.bars.push(bounds);
        };
        /**
         * Tries to find a beat at the given location.
         * @param x The absolute X position where the beat spans across.
         * @param y The absolute Y position where the beat spans across.
         * @returns The beat that spans across the given point, or null if none of the contained bars had a beat at this position.
         */
        MasterBarBounds.prototype.findBeatAtPos = function (x, y) {
            var beat = null;
            for (var _i = 0, _a = this.bars; _i < _a.length; _i++) {
                var bar = _a[_i];
                var b = bar.findBeatAtPos(x);
                if (b && (!beat || beat.realBounds.x < b.realBounds.x)) {
                    beat = b;
                }
            }
            return !beat ? null : beat.beat;
        };
        /**
         * Finishes the lookup object and optimizes itself for fast access.
         */
        MasterBarBounds.prototype.finish = function () {
            this.bars.sort(function (a, b) {
                if (a.realBounds.y < b.realBounds.y) {
                    return -1;
                }
                if (a.realBounds.y > b.realBounds.y) {
                    return 1;
                }
                if (a.realBounds.x < b.realBounds.x) {
                    return -1;
                }
                if (a.realBounds.x > b.realBounds.x) {
                    return 1;
                }
                return 0;
            });
        };
        /**
         * Adds a new beat to the lookup.
         * @param bounds The beat bounds to add.
         */
        MasterBarBounds.prototype.addBeat = function (bounds) {
            this.staveGroupBounds.boundsLookup.addBeat(bounds);
        };
        return MasterBarBounds;
    }());

    /**
     * Represents the bounds of a single note
     */
    var NoteBounds = /** @class */ (function () {
        function NoteBounds() {
        }
        return NoteBounds;
    }());

    /**
     * Represents the bounds of a stave group.
     */
    var StaveGroupBounds = /** @class */ (function () {
        function StaveGroupBounds() {
            /**
             * Gets or sets the index of the bounds within the parent lookup.
             * This allows fast access of the next/previous groups.
             */
            this.index = 0;
            /**
             * Gets or sets the list of master bar bounds related to this stave group.
             */
            this.bars = [];
        }
        /**
         * Finished the lookup for optimized access.
         */
        StaveGroupBounds.prototype.finish = function () {
            for (var _i = 0, _a = this.bars; _i < _a.length; _i++) {
                var t = _a[_i];
                t.finish();
            }
        };
        /**
         * Adds a new master bar to this lookup.
         * @param bounds The master bar bounds to add.
         */
        StaveGroupBounds.prototype.addBar = function (bounds) {
            this.boundsLookup.addMasterBar(bounds);
            bounds.staveGroupBounds = this;
            this.bars.push(bounds);
        };
        /**
         * Tries to find the master bar bounds that are located at the given X-position.
         * @param x The X-position to find a master bar.
         * @returns The master bounds at the given X-position.
         */
        StaveGroupBounds.prototype.findBarAtPos = function (x) {
            var b = null;
            // move from left to right as long we find bars that start before the clicked position
            for (var _i = 0, _a = this.bars; _i < _a.length; _i++) {
                var bar = _a[_i];
                if (!b || bar.realBounds.x < x) {
                    b = bar;
                }
                else if (x > bar.realBounds.x + bar.realBounds.w) {
                    break;
                }
            }
            return b;
        };
        return StaveGroupBounds;
    }());

    var BoundsLookup = /** @class */ (function () {
        function BoundsLookup() {
            this._beatLookup = new Map();
            this._masterBarLookup = new Map();
            this._currentStaveGroup = null;
            /**
             * Gets a list of all individual stave groups contained in the rendered music notation.
             */
            this.staveGroups = [];
            /**
             * Gets or sets a value indicating whether this lookup was finished already.
             */
            this.isFinished = false;
        }
        /**
         * @target web
         */
        BoundsLookup.prototype.toJson = function () {
            var json = {};
            var staveGroups = [];
            json.staveGroups = staveGroups;
            for (var _i = 0, _a = this.staveGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                var g = {};
                g.visualBounds = this.boundsToJson(group.visualBounds);
                g.realBounds = this.boundsToJson(group.realBounds);
                g.bars = [];
                for (var _b = 0, _c = group.bars; _b < _c.length; _b++) {
                    var masterBar = _c[_b];
                    var mb = {};
                    mb.lineAlignedBounds = this.boundsToJson(masterBar.lineAlignedBounds);
                    mb.visualBounds = this.boundsToJson(masterBar.visualBounds);
                    mb.realBounds = this.boundsToJson(masterBar.realBounds);
                    mb.index = masterBar.index;
                    mb.bars = [];
                    for (var _d = 0, _e = masterBar.bars; _d < _e.length; _d++) {
                        var bar = _e[_d];
                        var b = {};
                        b.visualBounds = this.boundsToJson(bar.visualBounds);
                        b.realBounds = this.boundsToJson(bar.realBounds);
                        b.beats = [];
                        for (var _f = 0, _g = bar.beats; _f < _g.length; _f++) {
                            var beat = _g[_f];
                            var bb = {};
                            bb.visualBounds = this.boundsToJson(beat.visualBounds);
                            bb.realBounds = this.boundsToJson(beat.realBounds);
                            var bbd = bb;
                            bbd.beatIndex = beat.beat.index;
                            bbd.voiceIndex = beat.beat.voice.index;
                            bbd.barIndex = beat.beat.voice.bar.index;
                            bbd.staffIndex = beat.beat.voice.bar.staff.index;
                            bbd.trackIndex = beat.beat.voice.bar.staff.track.index;
                            if (beat.notes) {
                                var notes = (bb.notes = []);
                                for (var _h = 0, _j = beat.notes; _h < _j.length; _h++) {
                                    var note = _j[_h];
                                    var n = {};
                                    var nd = n;
                                    nd.index = note.note.index;
                                    n.noteHeadBounds = this.boundsToJson(note.noteHeadBounds);
                                    notes.push(n);
                                }
                            }
                            b.beats.push(bb);
                        }
                        mb.bars.push(b);
                    }
                    g.bars.push(mb);
                }
                staveGroups.push(g);
            }
            return json;
        };
        /**
         * @target web
         */
        BoundsLookup.fromJson = function (json, score) {
            var lookup = new BoundsLookup();
            var staveGroups = json['staveGroups'];
            for (var _i = 0, staveGroups_1 = staveGroups; _i < staveGroups_1.length; _i++) {
                var staveGroup = staveGroups_1[_i];
                var sg = new StaveGroupBounds();
                sg.visualBounds = staveGroup.visualBounds;
                sg.realBounds = staveGroup.realBounds;
                lookup.addStaveGroup(sg);
                for (var _a = 0, _b = staveGroup.bars; _a < _b.length; _a++) {
                    var masterBar = _b[_a];
                    var mb = new MasterBarBounds();
                    mb.index = masterBar.index;
                    mb.isFirstOfLine = masterBar.isFirstOfLine;
                    mb.lineAlignedBounds = masterBar.lineAlignedBounds;
                    mb.visualBounds = masterBar.visualBounds;
                    mb.realBounds = masterBar.realBounds;
                    sg.addBar(mb);
                    for (var _c = 0, _d = masterBar.bars; _c < _d.length; _c++) {
                        var bar = _d[_c];
                        var b = new BarBounds();
                        b.visualBounds = bar.visualBounds;
                        b.realBounds = bar.realBounds;
                        mb.addBar(b);
                        for (var _e = 0, _f = bar.beats; _e < _f.length; _e++) {
                            var beat = _f[_e];
                            var bb = new BeatBounds();
                            bb.visualBounds = beat.visualBounds;
                            bb.realBounds = beat.realBounds;
                            var bd = beat;
                            bb.beat =
                                score.tracks[bd.trackIndex].staves[bd.staffIndex].bars[bd.barIndex].voices[bd.voiceIndex].beats[bd.beatIndex];
                            if (beat.notes) {
                                bb.notes = [];
                                for (var _g = 0, _h = beat.notes; _g < _h.length; _g++) {
                                    var note = _h[_g];
                                    var n = new NoteBounds();
                                    var nd = note;
                                    n.note = bb.beat.notes[nd.index];
                                    n.noteHeadBounds = note.noteHeadBounds;
                                    bb.addNote(n);
                                }
                            }
                            b.addBeat(bb);
                        }
                    }
                }
            }
            return lookup;
        };
        /**
         * @target web
         */
        BoundsLookup.prototype.boundsToJson = function (bounds) {
            var json = {};
            json.x = bounds.x;
            json.y = bounds.y;
            json.w = bounds.w;
            json.h = bounds.h;
            return json;
        };
        /**
         * Finishes the lookup for optimized access.
         */
        BoundsLookup.prototype.finish = function () {
            for (var _i = 0, _a = this.staveGroups; _i < _a.length; _i++) {
                var t = _a[_i];
                t.finish();
            }
            this.isFinished = true;
        };
        /**
         * Adds a new note to the lookup.
         * @param bounds The note bounds to add.
         */
        BoundsLookup.prototype.addNote = function (bounds) {
            var beat = this.findBeat(bounds.note.beat);
            beat.addNote(bounds);
        };
        /**
         * Adds a new stave group to the lookup.
         * @param bounds The stave group bounds to add.
         */
        BoundsLookup.prototype.addStaveGroup = function (bounds) {
            bounds.index = this.staveGroups.length;
            bounds.boundsLookup = this;
            this.staveGroups.push(bounds);
            this._currentStaveGroup = bounds;
        };
        /**
         * Adds a new master bar to the lookup.
         * @param bounds The master bar bounds to add.
         */
        BoundsLookup.prototype.addMasterBar = function (bounds) {
            if (!bounds.staveGroupBounds) {
                bounds.staveGroupBounds = this._currentStaveGroup;
                this._masterBarLookup.set(bounds.index, bounds);
                this._currentStaveGroup.addBar(bounds);
            }
            else {
                this._masterBarLookup.set(bounds.index, bounds);
            }
        };
        /**
         * Adds a new beat to the lookup.
         * @param bounds The beat bounds to add.
         */
        BoundsLookup.prototype.addBeat = function (bounds) {
            this._beatLookup.set(bounds.beat.id, bounds);
        };
        /**
         * Tries to find the master bar bounds by a given index.
         * @param index The index of the master bar to find.
         * @returns The master bar bounds if it was rendered, or null if no boundary information is available.
         */
        BoundsLookup.prototype.findMasterBarByIndex = function (index) {
            if (this._masterBarLookup.has(index)) {
                return this._masterBarLookup.get(index);
            }
            return null;
        };
        /**
         * Tries to find the master bar bounds by a given master bar.
         * @param bar The master bar to find.
         * @returns The master bar bounds if it was rendered, or null if no boundary information is available.
         */
        BoundsLookup.prototype.findMasterBar = function (bar) {
            var id = bar.index;
            if (this._masterBarLookup.has(id)) {
                return this._masterBarLookup.get(id);
            }
            return null;
        };
        /**
         * Tries to find the bounds of a given beat.
         * @param beat The beat to find.
         * @returns The beat bounds if it was rendered, or null if no boundary information is available.
         */
        BoundsLookup.prototype.findBeat = function (beat) {
            var id = beat.id;
            if (this._beatLookup.has(id)) {
                return this._beatLookup.get(id);
            }
            return null;
        };
        /**
         * Tries to find a beat at the given absolute position.
         * @param x The absolute X-position of the beat to find.
         * @param y The absolute Y-position of the beat to find.
         * @returns The beat found at the given position or null if no beat could be found.
         */
        BoundsLookup.prototype.getBeatAtPos = function (x, y) {
            //
            // find a bar which matches in y-axis
            var bottom = 0;
            var top = this.staveGroups.length - 1;
            var staveGroupIndex = -1;
            while (bottom <= top) {
                var middle = ((top + bottom) / 2) | 0;
                var group = this.staveGroups[middle];
                // found?
                if (y >= group.realBounds.y && y <= group.realBounds.y + group.realBounds.h) {
                    staveGroupIndex = middle;
                    break;
                }
                // search in lower half
                if (y < group.realBounds.y) {
                    top = middle - 1;
                }
                else {
                    bottom = middle + 1;
                }
            }
            // no bar found
            if (staveGroupIndex === -1) {
                return null;
            }
            //
            // Find the matching bar in the row
            var staveGroup = this.staveGroups[staveGroupIndex];
            var bar = staveGroup.findBarAtPos(x);
            if (bar) {
                return bar.findBeatAtPos(x, y);
            }
            return null;
        };
        /**
         * Tries to find the note at the given position using the given beat for fast access.
         * Use {@link findBeat} to find a beat for a given position first.
         * @param beat The beat containing the note.
         * @param x The X-position of the note.
         * @param y The Y-position of the note.
         * @returns The note at the given position within the beat.
         */
        BoundsLookup.prototype.getNoteAtPos = function (beat, x, y) {
            var beatBounds = this.findBeat(beat);
            if (!beatBounds) {
                return null;
            }
            return beatBounds.findNoteAtPos(x, y);
        };
        return BoundsLookup;
    }());

    /**
     * This is the main wrapper of the rendering engine which
     * can render a single track of a score object into a notation sheet.
     */
    var ScoreRenderer = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link ScoreRenderer} class.
         * @param settings The settings to use for rendering.
         */
        function ScoreRenderer(settings) {
            this._currentLayoutMode = exports.LayoutMode.Page;
            this._currentRenderEngine = null;
            this._renderedTracks = null;
            this.canvas = null;
            this.score = null;
            this.tracks = null;
            this.layout = null;
            this.boundsLookup = null;
            this.width = 0;
            this.preRender = new EventEmitterOfT();
            this.renderFinished = new EventEmitterOfT();
            this.partialRenderFinished = new EventEmitterOfT();
            this.postRenderFinished = new EventEmitter();
            this.error = new EventEmitterOfT();
            this.settings = settings;
            this.recreateCanvas();
            this.recreateLayout();
        }
        ScoreRenderer.prototype.destroy = function () {
            this.score = null;
            this.canvas = null;
            this.layout = null;
            this.boundsLookup = null;
            this.tracks = null;
        };
        ScoreRenderer.prototype.recreateCanvas = function () {
            if (this._currentRenderEngine !== this.settings.core.engine) {
                this.canvas = Environment.getRenderEngineFactory(this.settings).createCanvas();
                this._currentRenderEngine = this.settings.core.engine;
                return true;
            }
            return false;
        };
        ScoreRenderer.prototype.recreateLayout = function () {
            if (!this.layout || this._currentLayoutMode !== this.settings.display.layoutMode) {
                this.layout = Environment.getLayoutEngineFactory(this.settings).createLayout(this);
                this._currentLayoutMode = this.settings.display.layoutMode;
                return true;
            }
            return false;
        };
        ScoreRenderer.prototype.renderScore = function (score, trackIndexes) {
            try {
                this.score = score;
                var tracks = void 0;
                if (!trackIndexes) {
                    tracks = score.tracks.slice(0);
                }
                else {
                    tracks = [];
                    for (var _i = 0, trackIndexes_1 = trackIndexes; _i < trackIndexes_1.length; _i++) {
                        var track = trackIndexes_1[_i];
                        if (track >= 0 && track < score.tracks.length) {
                            tracks.push(score.tracks[track]);
                        }
                    }
                }
                if (tracks.length === 0 && score.tracks.length > 0) {
                    tracks.push(score.tracks[0]);
                }
                this.tracks = tracks;
                this.render();
            }
            catch (e) {
                this.error.trigger(e);
            }
        };
        /**
         * Initiates rendering fof the given tracks.
         * @param tracks The tracks to render.
         */
        ScoreRenderer.prototype.renderTracks = function (tracks) {
            if (tracks.length === 0) {
                this.score = null;
            }
            else {
                this.score = tracks[0].score;
            }
            this.tracks = tracks;
            this.render();
        };
        ScoreRenderer.prototype.updateSettings = function (settings) {
            this.settings = settings;
        };
        ScoreRenderer.prototype.render = function () {
            if (this.width === 0) {
                Logger.warning('Rendering', 'AlphaTab skipped rendering because of width=0 (element invisible)', null);
                return;
            }
            this.boundsLookup = new BoundsLookup();
            if (!this.tracks || this.tracks.length === 0) {
                return;
            }
            this.recreateCanvas();
            this.canvas.lineWidth = this.settings.display.scale;
            this.canvas.settings = this.settings;
            Logger.debug('Rendering', 'Rendering ' + this.tracks.length + ' tracks');
            for (var i = 0; i < this.tracks.length; i++) {
                var track = this.tracks[i];
                Logger.debug('Rendering', 'Track ' + i + ': ' + track.name);
            }
            this.preRender.trigger(false);
            this.recreateLayout();
            this.layoutAndRender();
            this._renderedTracks = this.tracks;
            Logger.debug('Rendering', 'Rendering finished');
        };
        ScoreRenderer.prototype.resizeRender = function () {
            if (this.recreateLayout() || this.recreateCanvas() || this._renderedTracks !== this.tracks || !this.tracks) {
                Logger.debug('Rendering', 'Starting full rerendering due to layout or canvas change', null);
                this.render();
            }
            else if (this.layout.supportsResize) {
                Logger.debug('Rendering', 'Starting optimized rerendering for resize');
                this.boundsLookup = new BoundsLookup();
                this.preRender.trigger(true);
                this.canvas.settings = this.settings;
                this.layout.resize();
                this.layout.renderAnnotation();
                this.onRenderFinished();
                this.postRenderFinished.trigger();
            }
            else {
                Logger.warning('Rendering', 'Current layout does not support dynamic resizing, nothing was done', null);
            }
            Logger.debug('Rendering', 'Resize finished');
        };
        ScoreRenderer.prototype.layoutAndRender = function () {
            Logger.debug('Rendering', 'Rendering at scale ' + this.settings.display.scale + ' with layout ' + this.layout.name, null);
            this.layout.layoutAndRender();
            this.layout.renderAnnotation();
            this.onRenderFinished();
            this.postRenderFinished.trigger();
        };
        ScoreRenderer.prototype.onRenderFinished = function () {
            var e = new RenderFinishedEventArgs();
            e.totalHeight = this.layout.height;
            e.totalWidth = this.layout.width;
            e.renderResult = this.canvas.onRenderFinished();
            this.renderFinished.trigger(e);
        };
        return ScoreRenderer;
    }());

    /**
     * @target web
     */
    var AlphaTabWebWorker = /** @class */ (function () {
        function AlphaTabWebWorker(main) {
            this._main = main;
            this._main.addEventListener('message', this.handleMessage.bind(this), false);
        }
        AlphaTabWebWorker.init = function () {
            Environment.globalThis.alphaTabWebWorker = new AlphaTabWebWorker(Environment.globalThis);
        };
        AlphaTabWebWorker.prototype.handleMessage = function (e) {
            var _this = this;
            var data = e.data;
            var cmd = data ? data.cmd : '';
            switch (cmd) {
                case 'alphaTab.initialize':
                    var settings = new Settings();
                    settings.fillFromJson(data.settings);
                    Logger.logLevel = settings.core.logLevel;
                    this._renderer = new ScoreRenderer(settings);
                    this._renderer.partialRenderFinished.on(function (result) {
                        _this._main.postMessage({
                            cmd: 'alphaTab.partialRenderFinished',
                            result: result
                        });
                    });
                    this._renderer.renderFinished.on(function (result) {
                        _this._main.postMessage({
                            cmd: 'alphaTab.renderFinished',
                            result: result
                        });
                    });
                    this._renderer.postRenderFinished.on(function () {
                        var _a, _b;
                        _this._main.postMessage({
                            cmd: 'alphaTab.postRenderFinished',
                            boundsLookup: (_b = (_a = _this._renderer.boundsLookup) === null || _a === void 0 ? void 0 : _a.toJson()) !== null && _b !== void 0 ? _b : null
                        });
                    });
                    this._renderer.preRender.on(function (resize) {
                        _this._main.postMessage({
                            cmd: 'alphaTab.preRender',
                            resize: resize
                        });
                    });
                    this._renderer.error.on(this.error.bind(this));
                    break;
                case 'alphaTab.invalidate':
                    this._renderer.render();
                    break;
                case 'alphaTab.resizeRender':
                    this._renderer.resizeRender();
                    break;
                case 'alphaTab.setWidth':
                    this._renderer.width = data.width;
                    break;
                case 'alphaTab.renderScore':
                    this.updateFontSizes(data.fontSizes);
                    var score = JsonConverter.jsObjectToScore(data.score, this._renderer.settings);
                    this.renderMultiple(score, data.trackIndexes);
                    break;
                case 'alphaTab.updateSettings':
                    this.updateSettings(data.settings);
                    break;
            }
        };
        AlphaTabWebWorker.prototype.updateFontSizes = function (fontSizes) {
            if (fontSizes) {
                if (!FontSizes.FontSizeLookupTables) {
                    FontSizes.FontSizeLookupTables = new Map();
                }
                for (var font in fontSizes) {
                    FontSizes.FontSizeLookupTables.set(font, fontSizes[font]);
                }
            }
        };
        AlphaTabWebWorker.prototype.updateSettings = function (json) {
            this._renderer.settings.fillFromJson(json);
        };
        AlphaTabWebWorker.prototype.renderMultiple = function (score, trackIndexes) {
            try {
                this._renderer.renderScore(score, trackIndexes);
            }
            catch (e) {
                this.error(e);
            }
        };
        AlphaTabWebWorker.prototype.error = function (error) {
            Logger.error('Worker', 'An unexpected error occurred in worker', error);
            this._main.postMessage({
                cmd: 'alphaTab.error',
                error: error
            });
        };
        return AlphaTabWebWorker;
    }());

    /**
     * A canvas implementation for HTML5 canvas
     * @target web
     */
    var Html5Canvas = /** @class */ (function () {
        function Html5Canvas() {
            this._canvas = null;
            this._color = new Color(0, 0, 0, 0xff);
            this._font = new Font('Arial', 10, FontStyle.Plain);
            this._lineWidth = 0;
            var fontElement = document.createElement('span');
            fontElement.classList.add('at');
            document.body.appendChild(fontElement);
            var style = window.getComputedStyle(fontElement);
            var family = style.fontFamily;
            if (family.startsWith('"') || family.startsWith("'")) {
                family = family.substr(1, family.length - 2);
            }
            this._musicFont = new Font(family, parseFloat(style.fontSize), FontStyle.Plain);
            this._measureCanvas = document.createElement('canvas');
            this._measureCanvas.width = 10;
            this._measureCanvas.height = 10;
            this._measureCanvas.style.width = '10px';
            this._measureCanvas.style.height = '10px';
            this._measureContext = this._measureCanvas.getContext('2d');
            this._measureContext.textBaseline = 'hanging';
        }
        Html5Canvas.prototype.onRenderFinished = function () {
            return null;
        };
        Html5Canvas.prototype.beginRender = function (width, height) {
            this._canvas = document.createElement('canvas');
            this._canvas.width = width | 0;
            this._canvas.height = height | 0;
            this._canvas.style.width = width + 'px';
            this._canvas.style.height = height + 'px';
            this._context = this._canvas.getContext('2d');
            this._context.textBaseline = 'hanging';
            this._context.lineWidth = this._lineWidth;
        };
        Html5Canvas.prototype.endRender = function () {
            var result = this._canvas;
            this._canvas = null;
            return result;
        };
        Object.defineProperty(Html5Canvas.prototype, "color", {
            get: function () {
                return this._color;
            },
            set: function (value) {
                if (this._color.rgba === value.rgba) {
                    return;
                }
                this._color = value;
                this._context.strokeStyle = value.rgba;
                this._context.fillStyle = value.rgba;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Html5Canvas.prototype, "lineWidth", {
            get: function () {
                return this._lineWidth;
            },
            set: function (value) {
                this._lineWidth = value;
                if (this._context) {
                    this._context.lineWidth = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Html5Canvas.prototype.fillRect = function (x, y, w, h) {
            if (w > 0) {
                this._context.fillRect((x | 0), (y | 0), w, h);
            }
        };
        Html5Canvas.prototype.strokeRect = function (x, y, w, h) {
            this._context.strokeRect((x | 0), (y | 0), w, h);
        };
        Html5Canvas.prototype.beginPath = function () {
            this._context.beginPath();
        };
        Html5Canvas.prototype.closePath = function () {
            this._context.closePath();
        };
        Html5Canvas.prototype.moveTo = function (x, y) {
            this._context.moveTo(x, y);
        };
        Html5Canvas.prototype.lineTo = function (x, y) {
            this._context.lineTo(x, y);
        };
        Html5Canvas.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            this._context.quadraticCurveTo(cpx, cpy, x, y);
        };
        Html5Canvas.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        };
        Html5Canvas.prototype.fillCircle = function (x, y, radius) {
            this._context.beginPath();
            this._context.arc(x, y, radius, 0, Math.PI * 2, true);
            this.fill();
        };
        Html5Canvas.prototype.strokeCircle = function (x, y, radius) {
            this._context.beginPath();
            this._context.arc(x, y, radius, 0, Math.PI * 2, true);
            this.stroke();
        };
        Html5Canvas.prototype.fill = function () {
            this._context.fill();
        };
        Html5Canvas.prototype.stroke = function () {
            this._context.stroke();
        };
        Object.defineProperty(Html5Canvas.prototype, "font", {
            get: function () {
                return this._font;
            },
            set: function (value) {
                this._font = value;
                if (this._context) {
                    this._context.font = value.toCssString(this.settings.display.scale);
                }
                this._measureContext.font = value.toCssString(this.settings.display.scale);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Html5Canvas.prototype, "textAlign", {
            get: function () {
                switch (this._context.textAlign) {
                    case 'left':
                        return TextAlign.Left;
                    case 'center':
                        return TextAlign.Center;
                    case 'right':
                        return TextAlign.Right;
                    default:
                        return TextAlign.Left;
                }
            },
            set: function (value) {
                switch (value) {
                    case TextAlign.Left:
                        this._context.textAlign = 'left';
                        break;
                    case TextAlign.Center:
                        this._context.textAlign = 'center';
                        break;
                    case TextAlign.Right:
                        this._context.textAlign = 'right';
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Html5Canvas.prototype, "textBaseline", {
            get: function () {
                switch (this._context.textBaseline) {
                    case 'hanging':
                        return TextBaseline.Top;
                    case 'middle':
                        return TextBaseline.Middle;
                    case 'bottom':
                        return TextBaseline.Bottom;
                    default:
                        return TextBaseline.Top;
                }
            },
            set: function (value) {
                switch (value) {
                    case TextBaseline.Top:
                        this._context.textBaseline = 'hanging';
                        break;
                    case TextBaseline.Middle:
                        this._context.textBaseline = 'middle';
                        break;
                    case TextBaseline.Bottom:
                        this._context.textBaseline = 'bottom';
                        break;
                }
            },
            enumerable: false,
            configurable: true
        });
        Html5Canvas.prototype.beginGroup = function (_) {
            // not supported
        };
        Html5Canvas.prototype.endGroup = function () {
            // not supported
        };
        Html5Canvas.prototype.fillText = function (text, x, y) {
            this._context.fillText(text, x, y);
        };
        Html5Canvas.prototype.measureText = function (text) {
            return this._measureContext.measureText(text).width;
        };
        Html5Canvas.prototype.fillMusicFontSymbol = function (x, y, scale, symbol, centerAtPosition) {
            if (centerAtPosition === void 0) { centerAtPosition = false; }
            if (symbol === MusicFontSymbol.None) {
                return;
            }
            this.fillMusicFontSymbolText(x, y, scale, String.fromCharCode(symbol), centerAtPosition);
        };
        Html5Canvas.prototype.fillMusicFontSymbols = function (x, y, scale, symbols, centerAtPosition) {
            if (centerAtPosition === void 0) { centerAtPosition = false; }
            var s = '';
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                if (symbol !== MusicFontSymbol.None) {
                    s += String.fromCharCode(symbol);
                }
            }
            this.fillMusicFontSymbolText(x, y, scale, s, centerAtPosition);
        };
        Html5Canvas.prototype.fillMusicFontSymbolText = function (x, y, scale, symbols, centerAtPosition) {
            if (centerAtPosition === void 0) { centerAtPosition = false; }
            var textAlign = this._context.textAlign;
            var baseLine = this._context.textBaseline;
            var font = this._context.font;
            this._context.font = this._musicFont.toCssString(scale);
            this._context.textBaseline = 'middle';
            if (centerAtPosition) {
                this._context.textAlign = 'center';
            }
            this._context.fillText(symbols, x, y);
            this._context.textBaseline = baseLine;
            this._context.font = font;
            this._context.textAlign = textAlign;
        };
        Html5Canvas.prototype.beginRotate = function (centerX, centerY, angle) {
            this._context.save();
            this._context.translate(centerX, centerY);
            this._context.rotate((angle * Math.PI) / 180.0);
        };
        Html5Canvas.prototype.endRotate = function () {
            this._context.restore();
        };
        return Html5Canvas;
    }());

    /**
     * This implementation of the {@link IMidiFileHandler}
     * generates a {@link MidiFile} object which can be used in AlphaSynth for playback.
     */
    var AlphaSynthMidiFileHandler = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link AlphaSynthMidiFileHandler} class.
         * @param midiFile The midi file.
         */
        function AlphaSynthMidiFileHandler(midiFile) {
            this._midiFile = midiFile;
        }
        AlphaSynthMidiFileHandler.prototype.addTimeSignature = function (tick, timeSignatureNumerator, timeSignatureDenominator) {
            var denominatorIndex = 0;
            // tslint:disable-next-line: no-conditional-assignment
            while ((timeSignatureDenominator = timeSignatureDenominator >> 1) > 0) {
                denominatorIndex++;
            }
            var message = new MetaDataEvent(tick, 0xff, MetaEventType.TimeSignature, new Uint8Array([timeSignatureNumerator & 0xff, denominatorIndex & 0xff, 48, 8]));
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.addRest = function (track, tick, channel) {
            var message = new SystemExclusiveEvent(tick, SystemCommonType.SystemExclusive, 0, new Uint8Array([0xff]));
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.addNote = function (track, start, length, key, dynamicValue, channel) {
            var velocity = MidiUtils.dynamicToVelocity(dynamicValue);
            var noteOn = new MidiEvent(start, this.makeCommand(MidiEventType.NoteOn, channel), AlphaSynthMidiFileHandler.fixValue(key), AlphaSynthMidiFileHandler.fixValue(velocity));
            this._midiFile.addEvent(noteOn);
            var noteOff = new MidiEvent(start + length, this.makeCommand(MidiEventType.NoteOff, channel), AlphaSynthMidiFileHandler.fixValue(key), AlphaSynthMidiFileHandler.fixValue(velocity));
            this._midiFile.addEvent(noteOff);
        };
        AlphaSynthMidiFileHandler.prototype.makeCommand = function (command, channel) {
            return (command & 0xf0) | (channel & 0x0f);
        };
        AlphaSynthMidiFileHandler.fixValue = function (value) {
            if (value > 127) {
                return 127;
            }
            if (value < 0) {
                return 0;
            }
            return value;
        };
        AlphaSynthMidiFileHandler.prototype.addControlChange = function (track, tick, channel, controller, value) {
            var message = new MidiEvent(tick, this.makeCommand(MidiEventType.Controller, channel), AlphaSynthMidiFileHandler.fixValue(controller), AlphaSynthMidiFileHandler.fixValue(value));
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.addProgramChange = function (track, tick, channel, program) {
            var message = new MidiEvent(tick, this.makeCommand(MidiEventType.ProgramChange, channel), AlphaSynthMidiFileHandler.fixValue(program), 0);
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.addTempo = function (tick, tempo) {
            // bpm -> microsecond per quarter note
            var tempoInUsq = (60000000 / tempo) | 0;
            var message = new MetaNumberEvent(tick, 0xff, MetaEventType.Tempo, tempoInUsq);
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.addBend = function (track, tick, channel, value) {
            if (value >= SynthConstants.MaxPitchWheel) {
                value = SynthConstants.MaxPitchWheel;
            }
            else {
                value = Math.floor(value);
            }
            var message = new MidiEvent(tick, this.makeCommand(MidiEventType.PitchBend, channel), value & 0x7F, (value >> 7) & 0x7F);
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.addNoteBend = function (track, tick, channel, key, value) {
            if (value >= SynthConstants.MaxPitchWheel) {
                value = SynthConstants.MaxPitchWheel;
            }
            else {
                value = Math.floor(value);
            }
            // map midi 1.0 range of 0-16384     (0x4000)
            // to midi 2.0 range of 0-4294967296 (0x100000000)
            value = value * SynthConstants.MaxPitchWheel20 / SynthConstants.MaxPitchWheel;
            var message = new Midi20PerNotePitchBendEvent(tick, this.makeCommand(MidiEventType.PerNotePitchBend, channel), key, value);
            this._midiFile.addEvent(message);
        };
        AlphaSynthMidiFileHandler.prototype.finishTrack = function (track, tick) {
            var message = new MetaDataEvent(tick, 0xff, MetaEventType.EndOfTrack, new Uint8Array(0));
            this._midiFile.addEvent(message);
        };
        return AlphaSynthMidiFileHandler;
    }());

    /**
     * Represents the time period, for which a {@link Beat} is played.
     */
    var BeatTickLookup = /** @class */ (function () {
        function BeatTickLookup() {
            this._highlightedBeats = new Map();
            /**
             * Gets or sets the start time in midi ticks at which the given beat is played.
             */
            this.start = 0;
            /**
             * Gets or sets the end time in midi ticks at which the given beat is played.
             */
            this.end = 0;
            /**
             * Gets or sets whether the beat is the placeholder beat for an empty bar.
             */
            this.isEmptyBar = false;
            /**
             * Gets or sets a list of all beats that should be highlighted when
             * the beat of this lookup starts playing.
             */
            this.beatsToHighlight = [];
        }
        BeatTickLookup.prototype.highlightBeat = function (beat) {
            if (!this._highlightedBeats.has(beat.id)) {
                this._highlightedBeats.set(beat.id, true);
                this.beatsToHighlight.push(beat);
            }
        };
        return BeatTickLookup;
    }());

    /**
     * Lists all midi controllers.
     */
    var ControllerType;
    (function (ControllerType) {
        /**
         * Bank Select. MSB
         */
        ControllerType[ControllerType["BankSelectCoarse"] = 0] = "BankSelectCoarse";
        /**
         * Modulation wheel or lever MSB
         */
        ControllerType[ControllerType["ModulationCoarse"] = 1] = "ModulationCoarse";
        //BreathControllerCoarse = 0x02,
        //FootControllerCoarse = 0x04,
        //PortamentoTimeCoarse = 0x05,
        /**
         * Data entry MSB
         */
        ControllerType[ControllerType["DataEntryCoarse"] = 6] = "DataEntryCoarse";
        /**
         * Channel Volume MSB
         */
        ControllerType[ControllerType["VolumeCoarse"] = 7] = "VolumeCoarse";
        //BalanceCoarse = 0x08,
        /**
         * Pan MSB
         */
        ControllerType[ControllerType["PanCoarse"] = 10] = "PanCoarse";
        /**
         * Expression Controller MSB
         */
        ControllerType[ControllerType["ExpressionControllerCoarse"] = 11] = "ExpressionControllerCoarse";
        //EffectControl1Coarse = 0x0C,
        //EffectControl2Coarse = 0x0D,
        //GeneralPurposeSlider1 = 0x10,
        //GeneralPurposeSlider2 = 0x11,
        //GeneralPurposeSlider3 = 0x12,
        //GeneralPurposeSlider4 = 0x13,
        //BankSelectFine = 0x20,
        /**
         * Modulation wheel or level LSB
         */
        ControllerType[ControllerType["ModulationFine"] = 33] = "ModulationFine";
        //BreathControllerFine = 0x22,
        //FootControllerFine = 0x24,
        //PortamentoTimeFine = 0x25,
        /**
         * Data Entry LSB
         */
        ControllerType[ControllerType["DataEntryFine"] = 38] = "DataEntryFine";
        /**
         * Channel Volume LSB
         */
        ControllerType[ControllerType["VolumeFine"] = 39] = "VolumeFine";
        //BalanceFine = 0x28,
        /**
         * Pan LSB
         */
        ControllerType[ControllerType["PanFine"] = 42] = "PanFine";
        /**
         * Expression controller LSB
         */
        ControllerType[ControllerType["ExpressionControllerFine"] = 43] = "ExpressionControllerFine";
        //EffectControl1Fine = 0x2C,
        //EffectControl2Fine = 0x2D,
        /**
         * Damper pedal (sustain)
         */
        ControllerType[ControllerType["HoldPedal"] = 64] = "HoldPedal";
        //Portamento = 0x41,
        //SostenutoPedal = 0x42,
        //SoftPedal = 0x43,
        /**
         * Legato Footswitch
         */
        ControllerType[ControllerType["LegatoPedal"] = 68] = "LegatoPedal";
        //Hold2Pedal = 0x45,
        //SoundVariation = 0x46,
        //SoundTimbre = 0x47,
        //SoundReleaseTime = 0x48,
        //SoundAttackTime = 0x49,
        //SoundBrightness = 0x4A,
        //SoundControl6 = 0x4B,
        //SoundControl7 = 0x4C,
        //SoundControl8 = 0x4D,
        //SoundControl9 = 0x4E,
        //SoundControl10 = 0x4F,
        //GeneralPurposeButton1 = 0x50,
        //GeneralPurposeButton2 = 0x51,
        //GeneralPurposeButton3 = 0x52,
        //GeneralPurposeButton4 = 0x53,
        //EffectsLevel = 0x5B,
        //TremuloLevel = 0x5C,
        //ChorusLevel = 0x5D,
        //CelesteLevel = 0x5E,
        //PhaseLevel = 0x5F,
        //DataButtonIncrement = 0x60,
        //DataButtonDecrement = 0x61,
        /**
         * Non-Registered Parameter Number LSB
         */
        ControllerType[ControllerType["NonRegisteredParameterFine"] = 98] = "NonRegisteredParameterFine";
        /**
         * Non-Registered Parameter Number MSB
         */
        ControllerType[ControllerType["NonRegisteredParameterCourse"] = 99] = "NonRegisteredParameterCourse";
        /**
         * Registered Parameter Number LSB
         */
        ControllerType[ControllerType["RegisteredParameterFine"] = 100] = "RegisteredParameterFine";
        /**
         * Registered Parameter Number MSB
         */
        ControllerType[ControllerType["RegisteredParameterCourse"] = 101] = "RegisteredParameterCourse";
        //AllSoundOff = 0x78,
        /**
         * Reset all controllers
         */
        ControllerType[ControllerType["ResetControllers"] = 121] = "ResetControllers";
        //LocalKeyboard = 0x7A,
        /**
         * All notes of.
         */
        ControllerType[ControllerType["AllNotesOff"] = 123] = "AllNotesOff";
        //OmniModeOff = 0x7C,
        //OmniModeOn = 0x7D,
        //MonoMode = 0x7E,
        //PolyMode = 0x7F
    })(ControllerType || (ControllerType = {}));

    var MidiPlaybackController = /** @class */ (function () {
        function MidiPlaybackController(score) {
            this._repeatStartIndex = 0;
            this._repeatNumber = 0;
            this._repeatOpen = false;
            this.shouldPlay = true;
            this.index = 0;
            this.currentTick = 0;
            this._score = score;
        }
        Object.defineProperty(MidiPlaybackController.prototype, "finished", {
            get: function () {
                return this.index >= this._score.masterBars.length;
            },
            enumerable: false,
            configurable: true
        });
        MidiPlaybackController.prototype.processCurrent = function () {
            var masterBar = this._score.masterBars[this.index];
            var masterBarAlternateEndings = masterBar.alternateEndings;
            // if the repeat group wasn't closed we reset the repeating
            // on the last group opening
            if (!masterBar.repeatGroup.isClosed &&
                masterBar.repeatGroup.openings[masterBar.repeatGroup.openings.length - 1] === masterBar) {
                this._repeatNumber = 0;
                this._repeatOpen = false;
            }
            if ((masterBar.isRepeatStart || masterBar.index === 0) && this._repeatNumber === 0) {
                this._repeatStartIndex = this.index;
                this._repeatOpen = true;
            }
            else if (masterBar.isRepeatStart) {
                this.shouldPlay = true;
            }
            // if we encounter an alternate ending
            if (this._repeatOpen && masterBarAlternateEndings > 0) {
                // do we need to skip this section?
                if ((masterBarAlternateEndings & (1 << this._repeatNumber)) === 0) {
                    this.shouldPlay = false;
                }
                else {
                    this.shouldPlay = true;
                }
            }
            if (this.shouldPlay) {
                this.currentTick += masterBar.calculateDuration();
            }
        };
        MidiPlaybackController.prototype.moveNext = function () {
            var masterBar = this._score.masterBars[this.index];
            var masterBarRepeatCount = masterBar.repeatCount - 1;
            // if we encounter a repeat end
            if (this._repeatOpen && masterBarRepeatCount > 0) {
                // more repeats required?
                if (this._repeatNumber < masterBarRepeatCount) {
                    // jump to start
                    this.index = this._repeatStartIndex;
                    this._repeatNumber++;
                }
                else {
                    // no repeats anymore, jump after repeat end
                    this._repeatNumber = 0;
                    this._repeatOpen = false;
                    this.shouldPlay = true;
                    this.index++;
                }
            }
            else {
                this.index++;
            }
        };
        return MidiPlaybackController;
    }());

    /**
     * Represents the time period, for which all bars of a {@link MasterBar} are played.
     */
    var MasterBarTickLookup = /** @class */ (function () {
        function MasterBarTickLookup() {
            /**
             * Gets or sets the start time in midi ticks at which the MasterBar is played.
             */
            this.start = 0;
            /**
             * Gets or sets the end time in midi ticks at which the MasterBar is played.
             */
            this.end = 0;
            /**
             * Gets or sets the current tempo when the MasterBar is played.
             */
            this.tempo = 0;
            /**
             * Gets or sets the list of {@link BeatTickLookup} object which define the durations
             * for all {@link Beats} played within the period of this MasterBar.
             */
            this.beats = [];
            /**
             * Gets or sets the {@link MasterBarTickLookup} of the next masterbar in the {@link Score}
             */
            this.nextMasterBar = null;
        }
        /**
         * Performs the neccessary finalization steps after all information was written.
         */
        MasterBarTickLookup.prototype.finish = function () {
            this.beats.sort(function (a, b) {
                return a.start - b.start;
            });
        };
        /**
         * Adds a new {@link BeatTickLookup} to the list of played beats during this MasterBar period.
         * @param beat
         */
        MasterBarTickLookup.prototype.addBeat = function (beat) {
            this.beats.push(beat);
        };
        return MasterBarTickLookup;
    }());

    /**
     * Represents the results of searching the currently played beat.
     * @see MidiTickLookup.FindBeat
     */
    var MidiTickLookupFindBeatResult = /** @class */ (function () {
        function MidiTickLookupFindBeatResult() {
            /**
             * Gets or sets the beat that will be played next.
             */
            this.nextBeat = null;
            /**
             * Gets or sets the duration in milliseconds how long this beat is playing.
             */
            this.duration = 0;
        }
        return MidiTickLookupFindBeatResult;
    }());
    /**
     * This class holds all information about when {@link MasterBar}s and {@link Beat}s are played.
     */
    var MidiTickLookup = /** @class */ (function () {
        function MidiTickLookup() {
            this._currentMasterBar = null;
            /**
             * Gets a dictionary of all master bars played. The index is the index equals to {@link MasterBar.index}.
             * This lookup only contains the first time a MasterBar is played. For a whole sequence of the song refer to {@link MasterBars}.
             */
            this.masterBarLookup = new Map();
            /**
             * Gets a list of all {@link MasterBarTickLookup} sorted by time.
             */
            this.masterBars = [];
        }
        /**
         * Performs the neccessary finalization steps after all information was written.
         */
        MidiTickLookup.prototype.finish = function () {
            var previous = null;
            var activeBeats = [];
            for (var _i = 0, _a = this.masterBars; _i < _a.length; _i++) {
                var bar = _a[_i];
                bar.finish();
                if (previous) {
                    previous.nextMasterBar = bar;
                }
                for (var _b = 0, _c = bar.beats; _b < _c.length; _b++) {
                    var beat = _c[_b];
                    // 1. calculate newly which beats are still active
                    var newActiveBeats = [];
                    // TODO: only create new list if current position changed
                    for (var _d = 0, activeBeats_1 = activeBeats; _d < activeBeats_1.length; _d++) {
                        var activeBeat = activeBeats_1[_d];
                        if (activeBeat.end > beat.start) {
                            newActiveBeats.push(activeBeat);
                            // 2. remember for current beat which active beats to highlight
                            beat.highlightBeat(activeBeat.beat);
                            // 3. ensure that active beat highlights current beat if they match the range
                            if (beat.start <= activeBeat.start) {
                                activeBeat.highlightBeat(beat.beat);
                            }
                        }
                    }
                    newActiveBeats.push(beat);
                    activeBeats = newActiveBeats;
                }
                previous = bar;
            }
        };
        /**
         * Finds the currently played beat given a list of tracks and the current time.
         * @param tracks The tracks in which to search the played beat for.
         * @param tick The current time in midi ticks.
         * @returns The information about the current beat or null if no beat could be found.
         */
        MidiTickLookup.prototype.findBeat = function (tracks, tick) {
            // get all beats within the masterbar
            var masterBar = this.findMasterBar(tick);
            if (!masterBar) {
                return null;
            }
            var trackLookup = new Map();
            for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                var track = tracks_1[_i];
                trackLookup.set(track.index, true);
            }
            var beat = null;
            var index = 0;
            var beats = masterBar.beats;
            for (var b = 0; b < beats.length; b++) {
                // is the current beat played on the given tick?
                var currentBeat = beats[b];
                // skip non relevant beats
                if (!trackLookup.has(currentBeat.beat.voice.bar.staff.track.index)) {
                    continue;
                }
                if (currentBeat.start <= tick && tick < currentBeat.end) {
                    // take the latest played beat we can find. (most right)
                    if (!beat || beat.start < currentBeat.start) {
                        beat = beats[b];
                        index = b;
                    }
                }
                else if (currentBeat.end > tick) {
                    break;
                }
            }
            if (!beat) {
                return null;
            }
            // search for next relevant beat in masterbar
            var nextBeat = null;
            for (var b = index + 1; b < beats.length; b++) {
                var currentBeat = beats[b];
                if (currentBeat.start > beat.start &&
                    trackLookup.has(currentBeat.beat.voice.bar.staff.track.index)) {
                    nextBeat = currentBeat;
                    break;
                }
            }
            // first relevant beat in next bar
            if (!nextBeat && masterBar.nextMasterBar) {
                beats = masterBar.nextMasterBar.beats;
                for (var b = 0; b < beats.length; b++) {
                    var currentBeat = beats[b];
                    if (trackLookup.has(currentBeat.beat.voice.bar.staff.track.index)) {
                        nextBeat = currentBeat;
                        break;
                    }
                }
            }
            var result = new MidiTickLookupFindBeatResult();
            result.currentBeat = beat.beat;
            result.nextBeat = !nextBeat ? null : nextBeat.beat;
            result.duration = !nextBeat
                ? MidiUtils.ticksToMillis(beat.end - beat.start, masterBar.tempo)
                : MidiUtils.ticksToMillis(nextBeat.start - beat.start, masterBar.tempo);
            result.beatsToHighlight = beat.beatsToHighlight;
            return result;
        };
        MidiTickLookup.prototype.findMasterBar = function (tick) {
            var bars = this.masterBars;
            var bottom = 0;
            var top = bars.length - 1;
            while (bottom <= top) {
                var middle = ((top + bottom) / 2) | 0;
                var bar = bars[middle];
                // found?
                if (tick >= bar.start && tick < bar.end) {
                    return bar;
                }
                // search in lower half
                if (tick < bar.start) {
                    top = middle - 1;
                }
                else {
                    bottom = middle + 1;
                }
            }
            return null;
        };
        /**
         * Gets the {@link MasterBarTickLookup} for a given masterbar at which the masterbar is played the first time.
         * @param bar The masterbar to find the time period for.
         * @returns A {@link MasterBarTickLookup} containing the details about the first time the {@link MasterBar} is played.
         */
        MidiTickLookup.prototype.getMasterBar = function (bar) {
            if (!this.masterBarLookup.has(bar.index)) {
                var fallback = new MasterBarTickLookup();
                fallback.masterBar = bar;
                return fallback;
            }
            return this.masterBarLookup.get(bar.index);
        };
        /**
         * Gets the start time in midi ticks for a given masterbar at which the masterbar is played the first time.
         * @param bar The masterbar to find the time period for.
         * @returns The time in midi ticks at which the masterbar is played the first time or 0 if the masterbar is not contained
         */
        MidiTickLookup.prototype.getMasterBarStart = function (bar) {
            if (!this.masterBarLookup.has(bar.index)) {
                return 0;
            }
            return this.masterBarLookup.get(bar.index).start;
        };
        /**
         * Adds a new {@link MasterBarTickLookup} to the lookup table.
         * @param masterBar The item to add.
         */
        MidiTickLookup.prototype.addMasterBar = function (masterBar) {
            this.masterBars.push(masterBar);
            this._currentMasterBar = masterBar;
            if (!this.masterBarLookup.has(masterBar.masterBar.index)) {
                this.masterBarLookup.set(masterBar.masterBar.index, masterBar);
            }
        };
        /**
         * Adds the given {@link BeatTickLookup} to the current {@link MidiTickLookup}.
         * @param beat The lookup to add.
         */
        MidiTickLookup.prototype.addBeat = function (beat) {
            var _a;
            (_a = this._currentMasterBar) === null || _a === void 0 ? void 0 : _a.addBeat(beat);
        };
        return MidiTickLookup;
    }());

    var MidiNoteDuration = /** @class */ (function () {
        function MidiNoteDuration() {
            this.noteOnly = 0;
            this.untilTieOrSlideEnd = 0;
            this.letRingEnd = 0;
        }
        return MidiNoteDuration;
    }());
    var TripletFeelDurations = /** @class */ (function () {
        function TripletFeelDurations() {
            this.firstBeatDuration = 0;
            this.secondBeatStartOffset = 0;
            this.secondBeatDuration = 0;
        }
        return TripletFeelDurations;
    }());
    /**
     * This generator creates a midi file using a score.
     */
    var MidiFileGenerator = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link MidiFileGenerator} class.
         * @param score The score for which the midi file should be generated.
         * @param settings The settings ot use for generation.
         * @param handler The handler that should be used for generating midi events.
         */
        function MidiFileGenerator(score, settings, handler) {
            this._currentTempo = 0;
            this._currentBarRepeatLookup = null;
            /**
             * Gets a lookup object which can be used to quickly find beats and bars
             * at a given midi tick position.
             */
            this.tickLookup = new MidiTickLookup();
            this._currentTripletFeel = null;
            this._score = score;
            this._settings = !settings ? new Settings() : settings;
            this._currentTempo = this._score.tempo;
            this._handler = handler;
        }
        /**
         * Starts the generation of the midi file.
         */
        MidiFileGenerator.prototype.generate = function () {
            // initialize tracks
            for (var _i = 0, _a = this._score.tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                this.generateTrack(track);
            }
            Logger.debug('Midi', 'Begin midi generation');
            var controller = new MidiPlaybackController(this._score);
            var previousMasterBar = null;
            // store the previous played bar for repeats
            while (!controller.finished) {
                var index = controller.index;
                var bar = this._score.masterBars[index];
                var currentTick = controller.currentTick;
                controller.processCurrent();
                if (controller.shouldPlay) {
                    this.generateMasterBar(bar, previousMasterBar, currentTick);
                    for (var _b = 0, _c = this._score.tracks; _b < _c.length; _b++) {
                        var track = _c[_b];
                        for (var _d = 0, _e = track.staves; _d < _e.length; _d++) {
                            var staff = _e[_d];
                            if (index < staff.bars.length) {
                                this.generateBar(staff.bars[index], currentTick);
                            }
                        }
                    }
                }
                controller.moveNext();
                previousMasterBar = bar;
            }
            for (var _f = 0, _g = this._score.tracks; _f < _g.length; _f++) {
                var track = _g[_f];
                this._handler.finishTrack(track.index, controller.currentTick);
            }
            this.tickLookup.finish();
            Logger.debug('Midi', 'Midi generation done');
        };
        MidiFileGenerator.prototype.generateTrack = function (track) {
            // channel
            this.generateChannel(track, track.playbackInfo.primaryChannel, track.playbackInfo);
            if (track.playbackInfo.primaryChannel !== track.playbackInfo.secondaryChannel) {
                this.generateChannel(track, track.playbackInfo.secondaryChannel, track.playbackInfo);
            }
        };
        MidiFileGenerator.prototype.generateChannel = function (track, channel, playbackInfo) {
            var volume = MidiFileGenerator.toChannelShort(playbackInfo.volume);
            var balance = MidiFileGenerator.toChannelShort(playbackInfo.balance);
            this._handler.addControlChange(track.index, 0, channel, ControllerType.VolumeCoarse, volume);
            this._handler.addControlChange(track.index, 0, channel, ControllerType.PanCoarse, balance);
            this._handler.addControlChange(track.index, 0, channel, ControllerType.ExpressionControllerCoarse, 127);
            // set parameter that is being updated (0) -> PitchBendRangeCoarse
            this._handler.addControlChange(track.index, 0, channel, ControllerType.RegisteredParameterFine, 0);
            this._handler.addControlChange(track.index, 0, channel, ControllerType.RegisteredParameterCourse, 0);
            // Set PitchBendRangeCoarse to 12
            this._handler.addControlChange(track.index, 0, channel, ControllerType.DataEntryFine, 0);
            this._handler.addControlChange(track.index, 0, channel, ControllerType.DataEntryCoarse, MidiFileGenerator.PitchBendRangeInSemitones);
            this._handler.addProgramChange(track.index, 0, channel, playbackInfo.program);
        };
        MidiFileGenerator.toChannelShort = function (data) {
            var value = Math.max(-32768, Math.min(32767, data * 8 - 1));
            return Math.max(value, -1) + 1;
        };
        MidiFileGenerator.prototype.generateMasterBar = function (masterBar, previousMasterBar, currentTick) {
            // time signature
            if (!previousMasterBar ||
                previousMasterBar.timeSignatureDenominator !== masterBar.timeSignatureDenominator ||
                previousMasterBar.timeSignatureNumerator !== masterBar.timeSignatureNumerator) {
                this._handler.addTimeSignature(currentTick, masterBar.timeSignatureNumerator, masterBar.timeSignatureDenominator);
            }
            // tempo
            if (!previousMasterBar) {
                this._handler.addTempo(currentTick, masterBar.score.tempo);
                this._currentTempo = masterBar.score.tempo;
            }
            else if (masterBar.tempoAutomation) {
                this._handler.addTempo(currentTick, masterBar.tempoAutomation.value);
                this._currentTempo = masterBar.tempoAutomation.value;
            }
            var masterBarLookup = new MasterBarTickLookup();
            masterBarLookup.masterBar = masterBar;
            masterBarLookup.start = currentTick;
            masterBarLookup.tempo = this._currentTempo;
            masterBarLookup.end = masterBarLookup.start + masterBar.calculateDuration();
            this.tickLookup.addMasterBar(masterBarLookup);
        };
        MidiFileGenerator.prototype.generateBar = function (bar, barStartTick) {
            var playbackBar = this.getPlaybackBar(bar);
            this._currentBarRepeatLookup = null;
            for (var _i = 0, _a = playbackBar.voices; _i < _a.length; _i++) {
                var v = _a[_i];
                this.generateVoice(v, barStartTick, bar);
            }
        };
        MidiFileGenerator.prototype.getPlaybackBar = function (bar) {
            switch (bar.simileMark) {
                case SimileMark.Simple:
                    if (bar.previousBar) {
                        bar = this.getPlaybackBar(bar.previousBar);
                    }
                    break;
                case SimileMark.FirstOfDouble:
                    if (bar.previousBar && bar.previousBar.previousBar) {
                        bar = this.getPlaybackBar(bar.previousBar.previousBar);
                    }
                    break;
                case SimileMark.SecondOfDouble:
                    if (bar.previousBar && bar.previousBar.previousBar) {
                        bar = this.getPlaybackBar(bar.previousBar.previousBar);
                    }
                    break;
            }
            return bar;
        };
        MidiFileGenerator.prototype.generateVoice = function (voice, barStartTick, realBar) {
            if (voice.isEmpty && (!voice.bar.isEmpty || voice.index !== 0)) {
                return;
            }
            for (var _i = 0, _a = voice.beats; _i < _a.length; _i++) {
                var b = _a[_i];
                this.generateBeat(b, barStartTick, realBar);
            }
        };
        MidiFileGenerator.prototype.generateBeat = function (beat, barStartTick, realBar) {
            var _this = this;
            var beatStart = beat.playbackStart;
            var audioDuration = beat.playbackDuration;
            if (beat.voice.bar.isEmpty) {
                audioDuration = beat.voice.bar.masterBar.calculateDuration();
            }
            else if (beat.voice.bar.masterBar.tripletFeel !== TripletFeel.NoTripletFeel &&
                this._settings.player.playTripletFeel) {
                if (this._currentTripletFeel) {
                    beatStart -= this._currentTripletFeel.secondBeatStartOffset;
                    audioDuration = this._currentTripletFeel.secondBeatDuration;
                    this._currentTripletFeel = null;
                }
                else {
                    this._currentTripletFeel = MidiFileGenerator.calculateTripletFeelInfo(beatStart, audioDuration, beat);
                    if (this._currentTripletFeel) {
                        audioDuration = this._currentTripletFeel.firstBeatDuration;
                    }
                }
            }
            var beatLookup = new BeatTickLookup();
            beatLookup.start = barStartTick + beatStart;
            var realTickOffset = !beat.nextBeat
                ? audioDuration
                : beat.nextBeat.absolutePlaybackStart - beat.absolutePlaybackStart;
            beatLookup.end = barStartTick + beatStart;
            beatLookup.highlightBeat(beat);
            beatLookup.end += realTickOffset > audioDuration ? realTickOffset : audioDuration;
            // in case of normal playback register playback
            if (realBar === beat.voice.bar) {
                beatLookup.beat = beat;
                this.tickLookup.addBeat(beatLookup);
            }
            else {
                beatLookup.isEmptyBar = true;
                beatLookup.beat = realBar.voices[0].beats[0];
                if (!this._currentBarRepeatLookup) {
                    this._currentBarRepeatLookup = beatLookup;
                    this.tickLookup.addBeat(this._currentBarRepeatLookup);
                }
                else {
                    this._currentBarRepeatLookup.end = beatLookup.end;
                }
            }
            var track = beat.voice.bar.staff.track;
            for (var _i = 0, _a = beat.automations; _i < _a.length; _i++) {
                var automation = _a[_i];
                this.generateAutomation(beat, automation, barStartTick);
            }
            if (beat.isRest) {
                this._handler.addRest(track.index, barStartTick + beatStart, track.playbackInfo.primaryChannel);
            }
            else {
                var brushInfo = this.getBrushInfo(beat);
                for (var _b = 0, _c = beat.notes; _b < _c.length; _b++) {
                    var n = _c[_b];
                    this.generateNote(n, barStartTick + beatStart, audioDuration, brushInfo);
                }
            }
            if (beat.vibrato !== VibratoType.None) {
                var phaseLength = 240;
                var bendAmplitude = 3;
                switch (beat.vibrato) {
                    case VibratoType.Slight:
                        phaseLength = this._settings.player.vibrato.beatSlightLength;
                        bendAmplitude = this._settings.player.vibrato.beatSlightAmplitude;
                        break;
                    case VibratoType.Wide:
                        phaseLength = this._settings.player.vibrato.beatWideLength;
                        bendAmplitude = this._settings.player.vibrato.beatWideAmplitude;
                        break;
                }
                this.generateVibratorWithParams(barStartTick + beatStart, beat.playbackDuration, phaseLength, bendAmplitude, function (tick, value) {
                    _this._handler.addBend(beat.voice.bar.staff.track.index, tick, track.playbackInfo.secondaryChannel, value);
                });
            }
        };
        MidiFileGenerator.calculateTripletFeelInfo = function (beatStart, audioDuration, beat) {
            var initialDuration;
            switch (beat.voice.bar.masterBar.tripletFeel) {
                case TripletFeel.Triplet8th:
                case TripletFeel.Dotted8th:
                case TripletFeel.Scottish8th:
                    initialDuration = Duration.Eighth;
                    break;
                case TripletFeel.Triplet16th:
                case TripletFeel.Dotted16th:
                case TripletFeel.Scottish16th:
                    initialDuration = Duration.Sixteenth;
                    break;
                default:
                    // not possible
                    return null;
            }
            var interval = MidiUtils.toTicks(initialDuration);
            // it must be a plain note with the expected duration
            // without dots, triplets, grace notes etc.
            if (audioDuration !== interval) {
                return null;
            }
            // check if the beat is aligned in respect to the duration
            // e.g. the eighth notes on a 4/4 time signature must start exactly on the following
            // times to get a triplet feel applied
            // 0 480 960 1440 1920 2400 2880 3360
            if (beatStart % interval !== 0) {
                return null;
            }
            // ensure next beat matches spec
            if (!beat.nextBeat || beat.nextBeat.voice !== beat.voice || beat.playbackDuration !== interval) {
                return null;
            }
            // looks like we have a triplet feel combination start here!
            var durations = new TripletFeelDurations();
            switch (beat.voice.bar.masterBar.tripletFeel) {
                case TripletFeel.Triplet8th:
                    durations.firstBeatDuration = MidiUtils.applyTuplet(MidiUtils.toTicks(Duration.Quarter), 3, 2);
                    durations.secondBeatDuration = MidiUtils.applyTuplet(MidiUtils.toTicks(Duration.Eighth), 3, 2);
                    break;
                case TripletFeel.Dotted8th:
                    durations.firstBeatDuration = MidiUtils.applyDot(MidiUtils.toTicks(Duration.Eighth), false);
                    durations.secondBeatDuration = MidiUtils.toTicks(Duration.Sixteenth);
                    break;
                case TripletFeel.Scottish8th:
                    durations.firstBeatDuration = MidiUtils.toTicks(Duration.Sixteenth);
                    durations.secondBeatDuration = MidiUtils.applyDot(MidiUtils.toTicks(Duration.Eighth), false);
                    break;
                case TripletFeel.Triplet16th:
                    durations.firstBeatDuration = MidiUtils.applyTuplet(MidiUtils.toTicks(Duration.Eighth), 3, 2);
                    durations.secondBeatDuration = MidiUtils.applyTuplet(MidiUtils.toTicks(Duration.Sixteenth), 3, 2);
                    break;
                case TripletFeel.Dotted16th:
                    durations.firstBeatDuration = MidiUtils.applyDot(MidiUtils.toTicks(Duration.Sixteenth), false);
                    durations.secondBeatDuration = MidiUtils.toTicks(Duration.ThirtySecond);
                    break;
                case TripletFeel.Scottish16th:
                    durations.firstBeatDuration = MidiUtils.toTicks(Duration.ThirtySecond);
                    durations.secondBeatDuration = MidiUtils.applyDot(MidiUtils.toTicks(Duration.Sixteenth), false);
                    break;
            }
            // calculate the number of ticks the second beat can start earlier
            durations.secondBeatStartOffset = audioDuration - durations.firstBeatDuration;
            return durations;
        };
        MidiFileGenerator.prototype.generateNote = function (note, beatStart, beatDuration, brushInfo) {
            var track = note.beat.voice.bar.staff.track;
            var staff = note.beat.voice.bar.staff;
            var noteKey = note.realValue;
            if (note.isPercussion) {
                var articulation = PercussionMapper.getArticulation(note);
                if (articulation) {
                    noteKey = articulation.outputMidiNumber;
                }
            }
            var brushOffset = note.isStringed && note.string <= brushInfo.length ? brushInfo[note.string - 1] : 0;
            var noteStart = beatStart + brushOffset;
            var noteDuration = this.getNoteDuration(note, beatDuration);
            noteDuration.untilTieOrSlideEnd -= brushOffset;
            noteDuration.noteOnly -= brushOffset;
            noteDuration.letRingEnd -= brushOffset;
            var dynamicValue = MidiFileGenerator.getDynamicValue(note);
            var channel = note.hasBend || note.beat.hasWhammyBar || note.beat.vibrato !== VibratoType.None
                ? track.playbackInfo.secondaryChannel
                : track.playbackInfo.primaryChannel;
            var initialBend = 0;
            if (note.hasBend) {
                initialBend = MidiFileGenerator.getPitchWheel(note.bendPoints[0].value);
            }
            else if (note.beat.hasWhammyBar) {
                initialBend = MidiFileGenerator.getPitchWheel(note.beat.whammyBarPoints[0].value);
            }
            else if (note.isTieDestination ||
                (note.slideOrigin && note.slideOrigin.slideOutType === SlideOutType.Legato)) {
                initialBend = -1;
            }
            else {
                initialBend = MidiFileGenerator.getPitchWheel(0);
            }
            if (initialBend >= 0) {
                this._handler.addBend(track.index, noteStart, channel, initialBend);
            }
            //
            // Fade in
            if (note.beat.fadeIn) {
                this.generateFadeIn(note, noteStart, noteDuration);
            }
            //
            // Trill
            if (note.isTrill && !staff.isPercussion) {
                this.generateTrill(note, noteStart, noteDuration, noteKey, dynamicValue, channel);
                // no further generation needed
                return;
            }
            //
            // Tremolo Picking
            if (note.beat.isTremolo) {
                this.generateTremoloPicking(note, noteStart, noteDuration, noteKey, dynamicValue, channel);
                // no further generation needed
                return;
            }
            //
            // All String Bending/Variation effects
            if (note.hasBend) {
                this.generateBend(note, noteStart, noteDuration, noteKey, channel);
            }
            else if (note.beat.hasWhammyBar && note.index === 0) {
                this.generateWhammy(note.beat, noteStart, noteDuration, channel);
            }
            else if (note.slideInType !== SlideInType.None || note.slideOutType !== SlideOutType.None) {
                this.generateSlide(note, noteStart, noteDuration, noteKey, dynamicValue, channel);
            }
            else if (note.vibrato !== VibratoType.None) {
                this.generateVibrato(note, noteStart, noteDuration, noteKey, channel);
            }
            // for tied notes, and target notes of legato slides we do not pick the note
            // the previous one is extended
            if (!note.isTieDestination && (!note.slideOrigin || note.slideOrigin.slideOutType !== SlideOutType.Legato)) {
                var noteSoundDuration = Math.max(noteDuration.untilTieOrSlideEnd, noteDuration.letRingEnd);
                this._handler.addNote(track.index, noteStart, noteSoundDuration, noteKey, dynamicValue, channel);
            }
        };
        MidiFileGenerator.prototype.getNoteDuration = function (note, duration) {
            var durationWithEffects = new MidiNoteDuration();
            durationWithEffects.noteOnly = duration;
            durationWithEffects.untilTieOrSlideEnd = duration;
            durationWithEffects.letRingEnd = duration;
            if (note.isDead) {
                durationWithEffects.noteOnly = this.applyStaticDuration(MidiFileGenerator.DefaultDurationDead, duration);
                durationWithEffects.untilTieOrSlideEnd = durationWithEffects.noteOnly;
                durationWithEffects.letRingEnd = durationWithEffects.noteOnly;
                return durationWithEffects;
            }
            if (note.isPalmMute) {
                durationWithEffects.noteOnly = this.applyStaticDuration(MidiFileGenerator.DefaultDurationPalmMute, duration);
                durationWithEffects.untilTieOrSlideEnd = durationWithEffects.noteOnly;
                durationWithEffects.letRingEnd = durationWithEffects.noteOnly;
                return durationWithEffects;
            }
            if (note.isStaccato) {
                durationWithEffects.noteOnly = (duration / 2) | 0;
                durationWithEffects.untilTieOrSlideEnd = durationWithEffects.noteOnly;
                durationWithEffects.letRingEnd = durationWithEffects.noteOnly;
                return durationWithEffects;
            }
            if (note.isTieOrigin) {
                var endNote = note.tieDestination;
                // for the initial start of the tie calculate absolute duration from start to end note
                if (endNote) {
                    if (!note.isTieDestination) {
                        var startTick = note.beat.absolutePlaybackStart;
                        var tieDestinationDuration = this.getNoteDuration(endNote, endNote.beat.playbackDuration);
                        var endTick = endNote.beat.absolutePlaybackStart + tieDestinationDuration.untilTieOrSlideEnd;
                        durationWithEffects.untilTieOrSlideEnd = endTick - startTick;
                    }
                    else {
                        // for continuing ties, take the current duration + the one from the destination
                        // this branch will be entered as part of the recusion of the if branch
                        var tieDestinationDuration = this.getNoteDuration(endNote, endNote.beat.playbackDuration);
                        durationWithEffects.untilTieOrSlideEnd = duration + tieDestinationDuration.untilTieOrSlideEnd;
                    }
                }
            }
            else if (note.slideOutType === SlideOutType.Legato) {
                var endNote = note.slideTarget;
                if (endNote) {
                    var startTick = note.beat.absolutePlaybackStart;
                    var slideTargetDuration = this.getNoteDuration(endNote, endNote.beat.playbackDuration);
                    var endTick = endNote.beat.absolutePlaybackStart + slideTargetDuration.untilTieOrSlideEnd;
                    durationWithEffects.untilTieOrSlideEnd = endTick - startTick;
                }
            }
            if (note.isLetRing && this._settings.notation.notationMode === exports.NotationMode.GuitarPro) {
                // LetRing ends when:
                // - rest
                var lastLetRingBeat = note.beat;
                var letRingEnd = 0;
                var maxDuration = note.beat.voice.bar.masterBar.calculateDuration();
                while (lastLetRingBeat.nextBeat) {
                    var next = lastLetRingBeat.nextBeat;
                    if (next.isRest) {
                        break;
                    }
                    // note on the same string
                    if (note.isStringed && next.hasNoteOnString(note.string)) {
                        break;
                    }
                    lastLetRingBeat = lastLetRingBeat.nextBeat;
                    letRingEnd =
                        lastLetRingBeat.absolutePlaybackStart -
                            note.beat.absolutePlaybackStart +
                            lastLetRingBeat.playbackDuration;
                    if (letRingEnd > maxDuration) {
                        letRingEnd = maxDuration;
                        break;
                    }
                }
                if (lastLetRingBeat === note.beat) {
                    durationWithEffects.letRingEnd = duration;
                }
                else {
                    durationWithEffects.letRingEnd = letRingEnd;
                }
            }
            else {
                durationWithEffects.letRingEnd = durationWithEffects.untilTieOrSlideEnd;
            }
            return durationWithEffects;
        };
        MidiFileGenerator.prototype.applyStaticDuration = function (duration, maximum) {
            var value = ((this._currentTempo * duration) / BendPoint.MaxPosition) | 0;
            return Math.min(value, maximum);
        };
        MidiFileGenerator.getDynamicValue = function (note) {
            var dynamicValue = note.dynamics;
            // more silent on hammer destination
            if (!note.beat.voice.bar.staff.isPercussion && note.hammerPullOrigin) {
                dynamicValue--;
            }
            // more silent on ghost notes
            if (note.isGhost) {
                dynamicValue--;
            }
            // louder on accent
            switch (note.accentuated) {
                case AccentuationType.Normal:
                    dynamicValue++;
                    break;
                case AccentuationType.Heavy:
                    dynamicValue += 2;
                    break;
            }
            return dynamicValue;
        };
        MidiFileGenerator.prototype.generateFadeIn = function (note, noteStart, noteDuration) {
            var track = note.beat.voice.bar.staff.track;
            var endVolume = MidiFileGenerator.toChannelShort(track.playbackInfo.volume);
            var volumeFactor = endVolume / noteDuration.noteOnly;
            var tickStep = 120;
            var steps = (noteDuration.noteOnly / tickStep) | 0;
            var endTick = noteStart + noteDuration.noteOnly;
            for (var i = steps - 1; i >= 0; i--) {
                var tick = endTick - i * tickStep;
                var volume = (tick - noteStart) * volumeFactor;
                if (i === steps - 1) {
                    this._handler.addControlChange(track.index, noteStart, track.playbackInfo.primaryChannel, ControllerType.VolumeCoarse, volume);
                    this._handler.addControlChange(track.index, noteStart, track.playbackInfo.secondaryChannel, ControllerType.VolumeCoarse, volume);
                }
                this._handler.addControlChange(track.index, tick, track.playbackInfo.primaryChannel, ControllerType.VolumeCoarse, volume);
                this._handler.addControlChange(track.index, tick, track.playbackInfo.secondaryChannel, ControllerType.VolumeCoarse, volume);
            }
        };
        MidiFileGenerator.prototype.generateVibrato = function (note, noteStart, noteDuration, noteKey, channel) {
            var _this = this;
            var phaseLength = 0;
            var bendAmplitude = 0;
            switch (note.vibrato) {
                case VibratoType.Slight:
                    phaseLength = this._settings.player.vibrato.noteSlightLength;
                    bendAmplitude = this._settings.player.vibrato.noteSlightAmplitude;
                    break;
                case VibratoType.Wide:
                    phaseLength = this._settings.player.vibrato.noteWideLength;
                    bendAmplitude = this._settings.player.vibrato.noteWideAmplitude;
                    break;
                default:
                    return;
            }
            var track = note.beat.voice.bar.staff.track;
            this.generateVibratorWithParams(noteStart, noteDuration.noteOnly, phaseLength, bendAmplitude, function (tick, value) {
                _this._handler.addNoteBend(track.index, tick, channel, noteKey, value);
            });
        };
        MidiFileGenerator.prototype.generateVibratorWithParams = function (noteStart, noteDuration, phaseLength, bendAmplitude, addBend) {
            var resolution = 16;
            var phaseHalf = (phaseLength / 2) | 0;
            // 1st Phase stays at bend 0,
            // then we have a sine wave with the given amplitude and phase length
            noteStart += phaseLength;
            var noteEnd = noteStart + noteDuration;
            while (noteStart < noteEnd) {
                var phase = 0;
                var phaseDuration = noteStart + phaseLength < noteEnd ? phaseLength : noteEnd - noteStart;
                while (phase < phaseDuration) {
                    var bend = bendAmplitude * Math.sin((phase * Math.PI) / phaseHalf);
                    addBend((noteStart + phase) | 0, MidiFileGenerator.getPitchWheel(bend));
                    phase += resolution;
                }
                noteStart += phaseLength;
            }
        };
        /**
         * Calculates the midi pitch wheel value for the give bend value.
         */
        MidiFileGenerator.getPitchWheel = function (bendValue) {
            // bend values are 1/4 notes therefore we only take half a semitone value per bend value
            return SynthConstants.DefaultPitchWheel + (bendValue / 2) * MidiFileGenerator.PitchValuePerSemitone;
        };
        MidiFileGenerator.prototype.generateSlide = function (note, noteStart, noteDuration, noteKey, dynamicValue, channel) {
            var _this = this;
            var duration = note.slideOutType === SlideOutType.Legato ? noteDuration.noteOnly : noteDuration.untilTieOrSlideEnd;
            var playedBendPoints = [];
            var track = note.beat.voice.bar.staff.track;
            var simpleSlidePitchOffset = this._settings.player.slide.simpleSlidePitchOffset;
            var simpleSlideDurationOffset = Math.floor(BendPoint.MaxPosition * this._settings.player.slide.simpleSlideDurationRatio);
            var shiftSlideDurationOffset = Math.floor(BendPoint.MaxPosition * this._settings.player.slide.shiftSlideDurationRatio);
            // Shift Slide: Play note, move up to target note, play end note
            // Legato Slide: Play note, move up to target note, no pick on end note, just keep it ringing
            // 2 bend points: one on 0/0, dy/MaxPos.
            // Slide into from above/below: Play note on lower pitch, slide into it quickly at start
            // Slide out above/blow: Play note on normal pitch, slide out quickly at end
            switch (note.slideInType) {
                case SlideInType.IntoFromAbove:
                    playedBendPoints.push(new BendPoint(0, simpleSlidePitchOffset));
                    playedBendPoints.push(new BendPoint(simpleSlideDurationOffset, 0));
                    break;
                case SlideInType.IntoFromBelow:
                    playedBendPoints.push(new BendPoint(0, -simpleSlidePitchOffset));
                    playedBendPoints.push(new BendPoint(simpleSlideDurationOffset, 0));
                    break;
            }
            switch (note.slideOutType) {
                case SlideOutType.Legato:
                case SlideOutType.Shift:
                    playedBendPoints.push(new BendPoint(shiftSlideDurationOffset, 0));
                    // normal note values are in 1/2 tones, bends are in 1/4 tones
                    var dy = (note.slideTarget.realValue - note.realValue) * 2;
                    playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, dy));
                    break;
                case SlideOutType.OutDown:
                    playedBendPoints.push(new BendPoint(BendPoint.MaxPosition - simpleSlideDurationOffset, 0));
                    playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, -simpleSlidePitchOffset));
                    break;
                case SlideOutType.OutUp:
                    playedBendPoints.push(new BendPoint(BendPoint.MaxPosition - simpleSlideDurationOffset, 0));
                    playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, simpleSlidePitchOffset));
                    break;
            }
            this.generateWhammyOrBend(noteStart, duration, playedBendPoints, function (tick, value) {
                _this._handler.addNoteBend(track.index, tick, channel, noteKey, value);
            });
        };
        MidiFileGenerator.prototype.generateBend = function (note, noteStart, noteDuration, noteKey, channel) {
            var _this = this;
            var bendPoints = note.bendPoints;
            var track = note.beat.voice.bar.staff.track;
            var addBend = function (tick, value) {
                _this._handler.addNoteBend(track.index, tick, channel, noteKey, value);
            };
            // if bend is extended on next tied note, we directly bend to the final bend value
            var finalBendValue = null;
            // Bends are spread across all tied notes unless they have a bend on their own.
            var duration;
            if (note.isTieOrigin && this._settings.notation.extendBendArrowsOnTiedNotes) {
                var endNote = note;
                while (endNote.isTieOrigin && !endNote.tieDestination.hasBend) {
                    endNote = endNote.tieDestination;
                }
                duration =
                    endNote.beat.absolutePlaybackStart -
                        note.beat.absolutePlaybackStart +
                        this.getNoteDuration(endNote, endNote.beat.playbackDuration).noteOnly;
            }
            else if (note.isTieOrigin && note.beat.graceType !== GraceType.None) {
                switch (note.tieDestination.bendType) {
                    case BendType.Bend:
                    case BendType.BendRelease:
                    case BendType.PrebendBend:
                        finalBendValue = note.tieDestination.bendPoints[1].value;
                        break;
                    case BendType.Prebend:
                    case BendType.PrebendRelease:
                        finalBendValue = note.tieDestination.bendPoints[0].value;
                        break;
                }
                duration = Math.max(noteDuration.noteOnly, MidiUtils.millisToTicks(this._settings.player.songBookBendDuration, this._currentTempo));
            }
            else {
                duration = noteDuration.noteOnly;
            }
            // ensure prebends are slightly before the actual note.
            if (bendPoints[0].value > 0 && !note.isContinuedBend) {
                noteStart--;
            }
            var bendDuration = Math.min(duration, MidiUtils.millisToTicks(this._settings.player.songBookBendDuration, this._currentTempo));
            var playedBendPoints = [];
            switch (note.bendType) {
                case BendType.Custom:
                    playedBendPoints = bendPoints;
                    break;
                case BendType.Bend:
                case BendType.Release:
                    switch (note.bendStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, note.bendPoints[0].value));
                            if (!finalBendValue || finalBendValue < note.bendPoints[1].value) {
                                finalBendValue = note.bendPoints[1].value;
                            }
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, finalBendValue));
                            break;
                        case BendStyle.Fast:
                            if (!finalBendValue || finalBendValue < note.bendPoints[1].value) {
                                finalBendValue = note.bendPoints[1].value;
                            }
                            if (note.beat.graceType === GraceType.BendGrace) {
                                this.generateSongBookWhammyOrBend(noteStart, duration, true, [note.bendPoints[0].value, finalBendValue], bendDuration, addBend);
                            }
                            else {
                                this.generateSongBookWhammyOrBend(noteStart, duration, false, [note.bendPoints[0].value, finalBendValue], bendDuration, addBend);
                            }
                            return;
                    }
                    break;
                case BendType.BendRelease:
                    switch (note.bendStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, note.bendPoints[0].value));
                            playedBendPoints.push(new BendPoint((BendPoint.MaxPosition / 2) | 0, note.bendPoints[1].value));
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, note.bendPoints[2].value));
                            break;
                        case BendStyle.Fast:
                            this.generateSongBookWhammyOrBend(noteStart, duration, false, [note.bendPoints[0].value, note.bendPoints[1].value, note.bendPoints[2].value], bendDuration, addBend);
                            return;
                    }
                    break;
                case BendType.Hold:
                    playedBendPoints = bendPoints;
                    break;
                case BendType.Prebend:
                    playedBendPoints = bendPoints;
                    break;
                case BendType.PrebendBend:
                    switch (note.bendStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, note.bendPoints[0].value));
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, note.bendPoints[1].value));
                            break;
                        case BendStyle.Fast:
                            var preBendValue = MidiFileGenerator.getPitchWheel(note.bendPoints[0].value);
                            this._handler.addBend(track.index, noteStart, channel, preBendValue | 0);
                            if (!finalBendValue || finalBendValue < note.bendPoints[1].value) {
                                finalBendValue = note.bendPoints[1].value;
                            }
                            this.generateSongBookWhammyOrBend(noteStart, duration, false, [note.bendPoints[0].value, finalBendValue], bendDuration, addBend);
                            return;
                    }
                    break;
                case BendType.PrebendRelease:
                    switch (note.bendStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, note.bendPoints[0].value));
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, note.bendPoints[1].value));
                            break;
                        case BendStyle.Fast:
                            var preBendValue = MidiFileGenerator.getPitchWheel(note.bendPoints[0].value);
                            this._handler.addBend(track.index, noteStart, channel, preBendValue | 0);
                            this.generateSongBookWhammyOrBend(noteStart, duration, false, [note.bendPoints[0].value, note.bendPoints[1].value], bendDuration, addBend);
                            return;
                    }
                    break;
            }
            this.generateWhammyOrBend(noteStart, duration, playedBendPoints, addBend);
        };
        MidiFileGenerator.prototype.generateSongBookWhammyOrBend = function (noteStart, duration, bendAtBeginning, bendValues, bendDuration, addBend) {
            var startTick = bendAtBeginning ? noteStart : noteStart + duration - bendDuration;
            var ticksBetweenPoints = bendDuration / (bendValues.length - 1);
            for (var i = 0; i < bendValues.length - 1; i++) {
                var currentBendValue = MidiFileGenerator.getPitchWheel(bendValues[i]);
                var nextBendValue = MidiFileGenerator.getPitchWheel(bendValues[i + 1]);
                var tick = startTick + ticksBetweenPoints * i;
                this.generateBendValues(tick, ticksBetweenPoints, currentBendValue, nextBendValue, addBend);
            }
        };
        MidiFileGenerator.prototype.generateWhammy = function (beat, noteStart, noteDuration, channel) {
            var _this = this;
            var bendPoints = beat.whammyBarPoints;
            var track = beat.voice.bar.staff.track;
            var duration = noteDuration.noteOnly;
            // ensure prebends are slightly before the actual note.
            if (bendPoints[0].value > 0 && !beat.isContinuedWhammy) {
                noteStart--;
            }
            var addBend = function (tick, value) {
                _this._handler.addBend(track.index, tick, channel, value);
            };
            var playedBendPoints = [];
            switch (beat.whammyBarType) {
                case WhammyType.Custom:
                    playedBendPoints = bendPoints;
                    break;
                case WhammyType.Dive:
                    switch (beat.whammyStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, bendPoints[0].value));
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, bendPoints[1].value));
                            break;
                        case BendStyle.Fast:
                            var whammyDuration = Math.min(duration, MidiUtils.millisToTicks(this._settings.player.songBookBendDuration, this._currentTempo));
                            this.generateSongBookWhammyOrBend(noteStart, duration, false, [bendPoints[0].value, bendPoints[1].value], whammyDuration, addBend);
                            return;
                    }
                    break;
                case WhammyType.Dip:
                    switch (beat.whammyStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, bendPoints[0].value));
                            playedBendPoints.push(new BendPoint((BendPoint.MaxPosition / 2) | 0, bendPoints[1].value));
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, bendPoints[2].value));
                            break;
                        case BendStyle.Fast:
                            var whammyDuration = Math.min(duration, MidiUtils.millisToTicks(this._settings.player.songBookDipDuration, this._currentTempo));
                            this.generateSongBookWhammyOrBend(noteStart, duration, true, [bendPoints[0].value, bendPoints[1].value, bendPoints[2].value], whammyDuration, addBend);
                            return;
                    }
                    break;
                case WhammyType.Hold:
                    playedBendPoints = bendPoints;
                    break;
                case WhammyType.Predive:
                    playedBendPoints = bendPoints;
                    break;
                case WhammyType.PrediveDive:
                    switch (beat.whammyStyle) {
                        case BendStyle.Default:
                            playedBendPoints = bendPoints;
                            break;
                        case BendStyle.Gradual:
                            playedBendPoints.push(new BendPoint(0, bendPoints[0].value));
                            playedBendPoints.push(new BendPoint((BendPoint.MaxPosition / 2) | 0, bendPoints[0].value));
                            playedBendPoints.push(new BendPoint(BendPoint.MaxPosition, bendPoints[1].value));
                            break;
                        case BendStyle.Fast:
                            var preDiveValue = MidiFileGenerator.getPitchWheel(bendPoints[0].value);
                            this._handler.addBend(track.index, noteStart, channel, preDiveValue | 0);
                            var whammyDuration = Math.min(duration, MidiUtils.millisToTicks(this._settings.player.songBookBendDuration, this._currentTempo));
                            this.generateSongBookWhammyOrBend(noteStart, duration, false, [bendPoints[0].value, bendPoints[1].value], whammyDuration, addBend);
                            return;
                    }
                    break;
            }
            this.generateWhammyOrBend(noteStart, duration, playedBendPoints, addBend);
        };
        MidiFileGenerator.prototype.generateWhammyOrBend = function (noteStart, duration, playedBendPoints, addBend) {
            var ticksPerPosition = duration / BendPoint.MaxPosition;
            for (var i = 0; i < playedBendPoints.length - 1; i++) {
                var currentPoint = playedBendPoints[i];
                var nextPoint = playedBendPoints[i + 1];
                // calculate the midi pitchbend values start and end values
                var currentBendValue = MidiFileGenerator.getPitchWheel(currentPoint.value);
                var nextBendValue = MidiFileGenerator.getPitchWheel(nextPoint.value);
                // how many midi ticks do we have to spend between this point and the next one?
                var ticksBetweenPoints = ticksPerPosition * (nextPoint.offset - currentPoint.offset);
                // we will generate one pitchbend message for each value
                // for this we need to calculate how many ticks to offset per value
                var tick = noteStart + ticksPerPosition * currentPoint.offset;
                this.generateBendValues(tick, ticksBetweenPoints, currentBendValue, nextBendValue, addBend);
            }
        };
        MidiFileGenerator.prototype.generateBendValues = function (currentTick, ticksBetweenPoints, currentBendValue, nextBendValue, addBend) {
            var millisBetweenPoints = MidiUtils.ticksToMillis(ticksBetweenPoints, this._currentTempo);
            var numberOfSemitones = Math.abs(nextBendValue - currentBendValue) / MidiFileGenerator.PitchValuePerSemitone;
            var numberOfSteps = Math.max(MidiFileGenerator.MinBreakpointsPerSemitone * numberOfSemitones, millisBetweenPoints / MidiFileGenerator.MillisecondsPerBreakpoint);
            var ticksPerBreakpoint = ticksBetweenPoints / numberOfSteps;
            var pitchPerBreakpoint = (nextBendValue - currentBendValue) / numberOfSteps;
            for (var i = 0; i < numberOfSteps; i++) {
                addBend(currentTick | 0, Math.round(currentBendValue));
                currentBendValue += pitchPerBreakpoint;
                currentTick += ticksPerBreakpoint;
            }
            // final bend value if needed
            if (currentBendValue < nextBendValue) {
                addBend(currentTick | 0, nextBendValue);
            }
        };
        MidiFileGenerator.prototype.generateTrill = function (note, noteStart, noteDuration, noteKey, dynamicValue, channel) {
            var track = note.beat.voice.bar.staff.track;
            var trillKey = note.stringTuning + note.trillFret;
            var trillLength = MidiUtils.toTicks(note.trillSpeed);
            var realKey = true;
            var tick = noteStart;
            var end = noteStart + noteDuration.untilTieOrSlideEnd;
            while (tick + 10 < end) {
                // only the rest on last trill play
                if (tick + trillLength >= end) {
                    trillLength = end - tick;
                }
                this._handler.addNote(track.index, tick, trillLength, realKey ? trillKey : noteKey, dynamicValue, channel);
                realKey = !realKey;
                tick += trillLength;
            }
        };
        MidiFileGenerator.prototype.generateTremoloPicking = function (note, noteStart, noteDuration, noteKey, dynamicValue, channel) {
            var track = note.beat.voice.bar.staff.track;
            var tpLength = MidiUtils.toTicks(note.beat.tremoloSpeed);
            var tick = noteStart;
            var end = noteStart + noteDuration.untilTieOrSlideEnd;
            while (tick + 10 < end) {
                // only the rest on last trill play
                if (tick + tpLength >= end) {
                    tpLength = end - tick;
                }
                this._handler.addNote(track.index, tick, tpLength, noteKey, dynamicValue, channel);
                tick += tpLength;
            }
        };
        MidiFileGenerator.prototype.getBrushInfo = function (beat) {
            var brushInfo = new Int32Array(beat.voice.bar.staff.tuning.length);
            if (beat.brushType !== BrushType.None) {
                //
                // calculate the number of
                // a mask where the single bits indicate the strings used
                var stringUsed = 0;
                var stringCount = 0;
                for (var _i = 0, _a = beat.notes; _i < _a.length; _i++) {
                    var n = _a[_i];
                    if (n.isTieDestination) {
                        continue;
                    }
                    stringUsed |= 0x01 << (n.string - 1);
                    stringCount++;
                }
                //
                // calculate time offset for all strings
                if (beat.notes.length > 0) {
                    var brushMove = 0;
                    var brushIncrement = (beat.brushDuration / (stringCount - 1)) | 0;
                    for (var i = 0; i < beat.voice.bar.staff.tuning.length; i++) {
                        var index = beat.brushType === BrushType.ArpeggioDown || beat.brushType === BrushType.BrushDown
                            ? i
                            : brushInfo.length - 1 - i;
                        if ((stringUsed & (0x01 << index)) !== 0) {
                            brushInfo[index] = brushMove;
                            brushMove += brushIncrement;
                        }
                    }
                }
            }
            return brushInfo;
        };
        MidiFileGenerator.prototype.generateAutomation = function (beat, automation, startMove) {
            switch (automation.type) {
                case AutomationType.Instrument:
                    this._handler.addProgramChange(beat.voice.bar.staff.track.index, beat.playbackStart + startMove, beat.voice.bar.staff.track.playbackInfo.primaryChannel, (automation.value | 0) & 0xff);
                    this._handler.addProgramChange(beat.voice.bar.staff.track.index, beat.playbackStart + startMove, beat.voice.bar.staff.track.playbackInfo.secondaryChannel, (automation.value | 0) & 0xff);
                    break;
                case AutomationType.Balance:
                    var balance = MidiFileGenerator.toChannelShort(automation.value);
                    this._handler.addControlChange(beat.voice.bar.staff.track.index, beat.playbackStart + startMove, beat.voice.bar.staff.track.playbackInfo.primaryChannel, ControllerType.PanCoarse, balance);
                    this._handler.addControlChange(beat.voice.bar.staff.track.index, beat.playbackStart + startMove, beat.voice.bar.staff.track.playbackInfo.secondaryChannel, ControllerType.PanCoarse, balance);
                    break;
                case AutomationType.Volume:
                    var volume = MidiFileGenerator.toChannelShort(automation.value);
                    this._handler.addControlChange(beat.voice.bar.staff.track.index, beat.playbackStart + startMove, beat.voice.bar.staff.track.playbackInfo.primaryChannel, ControllerType.VolumeCoarse, volume);
                    this._handler.addControlChange(beat.voice.bar.staff.track.index, beat.playbackStart + startMove, beat.voice.bar.staff.track.playbackInfo.secondaryChannel, ControllerType.VolumeCoarse, volume);
                    break;
            }
        };
        MidiFileGenerator.prototype.prepareSingleBeat = function (beat) {
            // collect tempo and program at given beat
            var tempo = -1;
            var program = -1;
            // traverse to previous beats until we maybe hit the automations needed
            var currentBeat = beat;
            while (currentBeat && (tempo === -1 || program === -1)) {
                for (var _i = 0, _a = beat.automations; _i < _a.length; _i++) {
                    var automation = _a[_i];
                    switch (automation.type) {
                        case AutomationType.Instrument:
                            program = automation.value;
                            break;
                        case AutomationType.Tempo:
                            tempo = automation.value;
                            break;
                    }
                }
                currentBeat = currentBeat.previousBeat;
            }
            var track = beat.voice.bar.staff.track;
            var masterBar = beat.voice.bar.masterBar;
            if (tempo === -1) {
                tempo = masterBar.score.tempo;
            }
            if (program === -1) {
                program = track.playbackInfo.program;
            }
            var volume = track.playbackInfo.volume;
            // setup channel
            this.generateTrack(track);
            this._handler.addTimeSignature(0, masterBar.timeSignatureNumerator, masterBar.timeSignatureDenominator);
            this._handler.addTempo(0, tempo);
            var volumeCoarse = MidiFileGenerator.toChannelShort(volume);
            this._handler.addControlChange(0, 0, track.playbackInfo.primaryChannel, ControllerType.VolumeCoarse, volumeCoarse);
            this._handler.addControlChange(0, 0, track.playbackInfo.secondaryChannel, ControllerType.VolumeCoarse, volumeCoarse);
        };
        MidiFileGenerator.prototype.generateSingleBeat = function (beat) {
            this.prepareSingleBeat(beat);
            this.generateBeat(beat, -beat.playbackStart /* to bring it to 0*/, beat.voice.bar);
        };
        MidiFileGenerator.prototype.generateSingleNote = function (note) {
            this.prepareSingleBeat(note.beat);
            this.generateNote(note, -note.beat.playbackStart, note.beat.playbackDuration, new Int32Array(note.beat.voice.bar.staff.tuning.length));
        };
        MidiFileGenerator.DefaultDurationDead = 30;
        MidiFileGenerator.DefaultDurationPalmMute = 80;
        /**
         * Maximum semitones that are supported in bends in one direction (up or down)
         * GP has 8 full tones on whammys.
         */
        MidiFileGenerator.PitchBendRangeInSemitones = 8 * 2;
        /**
         * The value on how many pitch-values are used for one semitone
         */
        MidiFileGenerator.PitchValuePerSemitone = SynthConstants.DefaultPitchWheel / MidiFileGenerator.PitchBendRangeInSemitones;
        /**
         * The minimum number of breakpoints generated per semitone bend.
         */
        MidiFileGenerator.MinBreakpointsPerSemitone = 6;
        /**
         * How long until a new breakpoint is generated for a bend.
         */
        MidiFileGenerator.MillisecondsPerBreakpoint = 150;
        return MidiFileGenerator;
    }());

    /**
     * Represents a range of the song that should be played.
     */
    var PlaybackRange = /** @class */ (function () {
        function PlaybackRange() {
            /**
             * The position in midi ticks from where the song should start.
             */
            this.startTick = 0;
            /**
             * The position in midi ticks to where the song should be played.
             */
            this.endTick = 0;
        }
        return PlaybackRange;
    }());

    /**
     * A glyph is a single symbol which can be added to a GlyphBarRenderer for automated
     * layouting and drawing of stacked symbols.
     */
    var Glyph = /** @class */ (function () {
        function Glyph(x, y) {
            this.width = 0;
            this.x = x;
            this.y = y;
        }
        Object.defineProperty(Glyph.prototype, "scale", {
            get: function () {
                return this.renderer.scale;
            },
            enumerable: false,
            configurable: true
        });
        Glyph.prototype.doLayout = function () {
            // to be implemented in subclass
        };
        Glyph.prototype.paint = function (cx, cy, canvas) {
            // to be implemented in subclass
        };
        return Glyph;
    }());

    var __extends$i = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * Effect-Glyphs implementing this public interface get notified
     * as they are expanded over multiple beats.
     */
    var EffectGlyph = /** @class */ (function (_super) {
        __extends$i(EffectGlyph, _super);
        function EffectGlyph(x, y) {
            if (x === void 0) { x = 0; }
            if (y === void 0) { y = 0; }
            var _this = _super.call(this, x, y) || this;
            /**
             * Gets or sets the next glyph of the same type in case
             * the effect glyph is expanded when using {@link EffectBarGlyphSizing.groupedOnBeat}.
             */
            _this.nextGlyph = null;
            /**
             * Gets or sets the previous glyph of the same type in case
             * the effect glyph is expanded when using {@link EffectBarGlyphSizing.groupedOnBeat}.
             */
            _this.previousGlyph = null;
            _this.height = 0;
            return _this;
        }
        return EffectGlyph;
    }(Glyph));

    var __extends$j = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MusicFontGlyph = /** @class */ (function (_super) {
        __extends$j(MusicFontGlyph, _super);
        function MusicFontGlyph(x, y, glyphScale, symbol) {
            var _this = _super.call(this, x, y) || this;
            _this.glyphScale = 0;
            _this.glyphScale = glyphScale;
            _this.symbol = symbol;
            return _this;
        }
        MusicFontGlyph.prototype.paint = function (cx, cy, canvas) {
            canvas.fillMusicFontSymbol(cx + this.x, cy + this.y, this.glyphScale * this.scale, this.symbol, false);
        };
        return MusicFontGlyph;
    }(EffectGlyph));

    var __extends$k = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var NoteHeadGlyph = /** @class */ (function (_super) {
        __extends$k(NoteHeadGlyph, _super);
        function NoteHeadGlyph(x, y, duration, isGrace) {
            var _this = _super.call(this, x, y, isGrace ? NoteHeadGlyph.GraceScale : 1, NoteHeadGlyph.getSymbol(duration)) || this;
            _this._isGrace = isGrace;
            _this._duration = duration;
            return _this;
        }
        NoteHeadGlyph.prototype.paint = function (cx, cy, canvas) {
            var offset = this._isGrace ? this.scale : 0;
            canvas.fillMusicFontSymbol(cx + this.x, cy + this.y + offset, this.glyphScale * this.scale, this.symbol, false);
        };
        NoteHeadGlyph.prototype.doLayout = function () {
            var scale = (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
            switch (this._duration) {
                case Duration.QuadrupleWhole:
                    this.width = 14 * scale;
                    break;
                case Duration.DoubleWhole:
                    this.width = 14 * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
                    break;
                case Duration.Whole:
                    this.width = 14 * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
                    break;
                default:
                    this.width = NoteHeadGlyph.QuarterNoteHeadWidth * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
                    break;
            }
            this.height = NoteHeadGlyph.NoteHeadHeight * scale;
        };
        NoteHeadGlyph.getSymbol = function (duration) {
            switch (duration) {
                case Duration.QuadrupleWhole:
                    return MusicFontSymbol.NoteheadDoubleWholeSquare;
                case Duration.DoubleWhole:
                    return MusicFontSymbol.NoteheadDoubleWhole;
                case Duration.Whole:
                    return MusicFontSymbol.NoteheadWhole;
                case Duration.Half:
                    return MusicFontSymbol.NoteheadHalf;
                default:
                    return MusicFontSymbol.NoteheadBlack;
            }
        };
        NoteHeadGlyph.GraceScale = 0.75;
        NoteHeadGlyph.NoteHeadHeight = 8;
        NoteHeadGlyph.QuarterNoteHeadWidth = 9;
        return NoteHeadGlyph;
    }(MusicFontGlyph));

    var __extends$l = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FlagGlyph = /** @class */ (function (_super) {
        __extends$l(FlagGlyph, _super);
        function FlagGlyph(x, y, duration, direction, isGrace) {
            return _super.call(this, x, y, isGrace ? NoteHeadGlyph.GraceScale : 1, FlagGlyph.getSymbol(duration, direction, isGrace)) || this;
        }
        FlagGlyph.prototype.doLayout = function () {
            this.width = 0;
        };
        FlagGlyph.getSymbol = function (duration, direction, isGrace) {
            if (isGrace) {
                duration = Duration.Eighth;
            }
            if (direction === BeamDirection.Up) {
                switch (duration) {
                    case Duration.Eighth:
                        return MusicFontSymbol.FlagEighthUp;
                    case Duration.Sixteenth:
                        return MusicFontSymbol.FlagSixteenthUp;
                    case Duration.ThirtySecond:
                        return MusicFontSymbol.FlagThirtySecondUp;
                    case Duration.SixtyFourth:
                        return MusicFontSymbol.FlagSixtyFourthUp;
                    case Duration.OneHundredTwentyEighth:
                        return MusicFontSymbol.FlagOneHundredTwentyEighthUp;
                    case Duration.TwoHundredFiftySixth:
                        return MusicFontSymbol.FlagTwoHundredFiftySixthUp;
                    default:
                        return MusicFontSymbol.FlagEighthUp;
                }
            }
            switch (duration) {
                case Duration.Eighth:
                    return MusicFontSymbol.FlagEighthDown;
                case Duration.Sixteenth:
                    return MusicFontSymbol.FlagSixteenthDown;
                case Duration.ThirtySecond:
                    return MusicFontSymbol.FlagThirtySecondDown;
                case Duration.SixtyFourth:
                    return MusicFontSymbol.FlagSixtyFourthDown;
                case Duration.OneHundredTwentyEighth:
                    return MusicFontSymbol.FlagOneHundredTwentyEighthDown;
                case Duration.TwoHundredFiftySixth:
                    return MusicFontSymbol.FlagOneHundredTwentyEighthDown;
                default:
                    return MusicFontSymbol.FlagEighthDown;
            }
        };
        FlagGlyph.FlagWidth = 11;
        return FlagGlyph;
    }(MusicFontGlyph));

    var __extends$m = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BeatContainerGlyph = /** @class */ (function (_super) {
        __extends$m(BeatContainerGlyph, _super);
        function BeatContainerGlyph(beat, voiceContainer) {
            var _this = _super.call(this, 0, 0) || this;
            _this.ties = [];
            _this.minWidth = 0;
            _this.beat = beat;
            _this.ties = [];
            _this.voiceContainer = voiceContainer;
            return _this;
        }
        Object.defineProperty(BeatContainerGlyph.prototype, "onTimeX", {
            get: function () {
                return this.onNotes.x + this.onNotes.centerX;
            },
            enumerable: false,
            configurable: true
        });
        BeatContainerGlyph.prototype.registerLayoutingInfo = function (layoutings) {
            var preBeatStretch = this.onTimeX;
            var postBeatStretch = this.onNotes.width - this.onNotes.centerX;
            // make space for flag
            var helper = this.renderer.helpers.getBeamingHelperForBeat(this.beat);
            if (helper && helper.hasFlag) {
                postBeatStretch += FlagGlyph.FlagWidth * this.scale;
            }
            for (var _i = 0, _a = this.ties; _i < _a.length; _i++) {
                var tie = _a[_i];
                postBeatStretch += tie.width;
            }
            layoutings.addBeatSpring(this.beat, preBeatStretch, postBeatStretch);
            // store sizes for special renderers like the EffectBarRenderer
            layoutings.setPreBeatSize(this.beat, this.preNotes.width);
            layoutings.setOnBeatSize(this.beat, this.onNotes.width);
            layoutings.setBeatCenterX(this.beat, this.onNotes.centerX);
        };
        BeatContainerGlyph.prototype.applyLayoutingInfo = function (info) {
            var offset = info.getBeatCenterX(this.beat) - this.onNotes.centerX;
            this.preNotes.x = offset;
            this.preNotes.width = info.getPreBeatSize(this.beat);
            this.onNotes.width = info.getOnBeatSize(this.beat);
            this.onNotes.x = this.preNotes.x + this.preNotes.width;
            this.onNotes.updateBeamingHelper();
        };
        BeatContainerGlyph.prototype.doLayout = function () {
            this.preNotes.x = 0;
            this.preNotes.renderer = this.renderer;
            this.preNotes.container = this;
            this.preNotes.doLayout();
            this.onNotes.x = this.preNotes.x + this.preNotes.width;
            this.onNotes.renderer = this.renderer;
            this.onNotes.container = this;
            this.onNotes.doLayout();
            var i = this.beat.notes.length - 1;
            while (i >= 0) {
                this.createTies(this.beat.notes[i--]);
            }
            this.updateWidth();
        };
        BeatContainerGlyph.prototype.updateWidth = function () {
            this.minWidth = this.preNotes.width + this.onNotes.width;
            if (!this.beat.isRest) {
                if (this.onNotes.beamingHelper.beats.length === 1) {
                    // make space for footer
                    if (this.beat.duration >= Duration.Eighth) {
                        this.minWidth += 20 * this.scale;
                    }
                }
                else {
                    // ensure some space for small notes
                    switch (this.beat.duration) {
                        case Duration.OneHundredTwentyEighth:
                        case Duration.TwoHundredFiftySixth:
                            this.minWidth += 10 * this.scale;
                            break;
                    }
                }
            }
            var tieWidth = 0;
            for (var _i = 0, _a = this.ties; _i < _a.length; _i++) {
                var tie = _a[_i];
                if (tie.width > tieWidth) {
                    tieWidth = tie.width;
                }
            }
            this.minWidth += tieWidth;
            this.width = this.minWidth;
        };
        BeatContainerGlyph.prototype.scaleToWidth = function (beatWidth) {
            for (var _i = 0, _a = this.ties; _i < _a.length; _i++) {
                var tie = _a[_i];
                tie.doLayout();
            }
            this.onNotes.updateBeamingHelper();
            this.width = beatWidth;
        };
        BeatContainerGlyph.prototype.createTies = function (n) {
            // no default ties
        };
        BeatContainerGlyph.getGroupId = function (beat) {
            return 'b' + beat.id;
        };
        BeatContainerGlyph.prototype.paint = function (cx, cy, canvas) {
            if (this.beat.voice.isEmpty) {
                return;
            }
            var isEmptyGlyph = this.preNotes.isEmpty && this.onNotes.isEmpty && this.ties.length === 0;
            if (isEmptyGlyph) {
                return;
            }
            canvas.beginGroup(BeatContainerGlyph.getGroupId(this.beat));
            // var c = canvas.color;
            // var ta = canvas.textAlign;
            // canvas.color = new Color(255, 0, 0);
            // canvas.textAlign = TextAlign.Left;
            // canvas.fillText(this.beat.displayStart.toString(), cx + this.x, cy + this.y - 10);
            // canvas.color = c;
            // canvas.textAlign = ta;
            // canvas.color = Color.random();
            // canvas.fillRect(cx + this.x, cy + this.y, this.width, this.renderer.height);
            // var oldColor = canvas.color;
            // canvas.color = Color.random(100);
            // canvas.fillRect(cx + this.x, cy + this.y, this.width, this.renderer.height);
            // canvas.color = oldColor;
            // canvas.color = new Color(200, 0, 0, 100);
            // canvas.strokeRect(cx + this.x, cy + this.y + 15 * this.beat.voice.index, this.width, 10);
            // canvas.font = new Font("Arial", 10);
            // canvas.color = new Color(0, 0, 0);
            // canvas.fillText(this.beat.voice.index + ":" + this.beat.index, cx + this.x, cy + this.y + 15 * this.beat.voice.index);
            // if (this.beat.voice.index === 0) {
            //     canvas.color = new Color(200, 0, 0, 100);
            //     canvas.strokeRect(cx + this.x, cy + this.y + this.preNotes.y + 30, this.width, 10);
            // }
            this.preNotes.paint(cx + this.x, cy + this.y, canvas);
            // if (this.beat.voice.index === 0) {
            //     canvas.color = new Color(200, 0, 0, 100);
            //     canvas.strokeRect(cx + this.x + this.preNotes.x, cy + this.y + this.preNotes.y, this.preNotes.width, 10);
            // }
            this.onNotes.paint(cx + this.x, cy + this.y, canvas);
            // if (this.beat.voice.index === 0) {
            //     canvas.color = new Color(0, 200, 0, 100);
            //     canvas.strokeRect(cx + this.x + this.onNotes.x, cy + this.y + this.onNotes.y - 10, this.onNotes.width, 10);
            // }
            // paint the ties relative to the whole staff,
            // reason: we have possibly multiple staves involved and need to calculate the correct positions.
            var staffX = cx - this.voiceContainer.x - this.renderer.x;
            var staffY = cy - this.voiceContainer.y - this.renderer.y;
            for (var i = 0, j = this.ties.length; i < j; i++) {
                var t = this.ties[i];
                t.renderer = this.renderer;
                t.paint(staffX, staffY, canvas);
            }
            canvas.endGroup();
        };
        BeatContainerGlyph.prototype.buildBoundingsLookup = function (barBounds, cx, cy, isEmptyBar) {
            var beatBoundings = new BeatBounds();
            beatBoundings.beat = this.beat;
            beatBoundings.visualBounds = new Bounds();
            beatBoundings.visualBounds.x = cx + this.x + this.onNotes.x;
            beatBoundings.visualBounds.y = barBounds.visualBounds.y;
            beatBoundings.visualBounds.w = this.onNotes.width;
            beatBoundings.visualBounds.h = barBounds.visualBounds.h;
            beatBoundings.realBounds = new Bounds();
            beatBoundings.realBounds.x = cx + this.x;
            beatBoundings.realBounds.y = barBounds.realBounds.y;
            beatBoundings.realBounds.w = this.width;
            beatBoundings.realBounds.h = barBounds.realBounds.h;
            if (isEmptyBar) {
                beatBoundings.visualBounds.x = cx + this.x;
                beatBoundings.realBounds.x = beatBoundings.visualBounds.x;
            }
            barBounds.addBeat(beatBoundings);
            if (this.renderer.settings.core.includeNoteBounds) {
                this.onNotes.buildBoundingsLookup(beatBoundings, cx + this.x, cy + this.y);
            }
        };
        return BeatContainerGlyph;
    }(Glyph));

    /**
     * Represents the information related to a resize event.
     */
    var ResizeEventArgs = /** @class */ (function () {
        function ResizeEventArgs() {
            /**
             * Gets the size before the resizing happened.
             */
            this.oldWidth = 0;
            /**
             * Gets the size after the resize was complete.
             */
            this.newWidth = 0;
            /**
             * Gets the settings currently used for rendering.
             */
            this.settings = null;
        }
        ResizeEventArgs.prototype.core = function () {
            if (this.settings && this.causeIssue()) {
                return this.settings.core;
            }
            return new CoreSettings();
        };
        ResizeEventArgs.prototype.causeIssue = function () {
            this.settings = null;
            return true;
        };
        return ResizeEventArgs;
    }());

    var SelectionInfo = /** @class */ (function () {
        function SelectionInfo(beat) {
            this.bounds = null;
            this.beat = beat;
        }
        return SelectionInfo;
    }());
    /**
     * This class represents the public API of alphaTab and provides all logic to display
     * a music sheet in any UI using the given {@link IUiFacade}
     * @param <TSettings> The UI object holding the settings.
     * @csharp_public
     */
    var AlphaTabApiBase = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link AlphaTabApiBase} class.
         * @param uiFacade The UI facade to use for interacting with the user interface.
         * @param settings The UI settings object to use for loading the settings.
         */
        function AlphaTabApiBase(uiFacade, settings) {
            var _this = this;
            this._startTime = 0;
            this._trackIndexes = null;
            /**
             * Gets the score holding all information about the song being rendered.
             */
            this.score = null;
            /**
             * Gets a list of the tracks that are currently rendered;
             */
            this.tracks = [];
            this._tickCache = null;
            /**
             * Gets the alphaSynth player used for playback. This is the low-level API to the Midi synthesizer used for playback.
             */
            this.player = null;
            this._cursorWrapper = null;
            this._barCursor = null;
            this._beatCursor = null;
            this._selectionWrapper = null;
            this._previousTick = 0;
            this._playerState = PlayerState.Paused;
            this._currentBeat = null;
            this._previousStateForCursor = PlayerState.Paused;
            this._previousCursorCache = null;
            this._lastScroll = 0;
            this.playedBeatChanged = new EventEmitterOfT();
            this._beatMouseDown = false;
            this._selectionStart = null;
            this._selectionEnd = null;
            this.beatMouseDown = new EventEmitterOfT();
            this.beatMouseMove = new EventEmitterOfT();
            this.beatMouseUp = new EventEmitterOfT();
            this.scoreLoaded = new EventEmitterOfT();
            this.resize = new EventEmitterOfT();
            this.renderStarted = new EventEmitterOfT();
            this.renderFinished = new EventEmitterOfT();
            this.postRenderFinished = new EventEmitter();
            this.error = new EventEmitterOfT();
            this.playerReady = new EventEmitter();
            this.playerFinished = new EventEmitter();
            this.soundFontLoaded = new EventEmitter();
            this.midiLoaded = new EventEmitter();
            this.playerStateChanged = new EventEmitterOfT();
            this.playerPositionChanged = new EventEmitterOfT();
            this.uiFacade = uiFacade;
            this.container = uiFacade.rootContainer;
            uiFacade.initialize(this, settings);
            Logger.logLevel = this.settings.core.logLevel;
            this.canvasElement = uiFacade.createCanvasElement();
            this.container.appendChild(this.canvasElement);
            this.container.resize.on(Environment.throttle(function () {
                if (_this.container.width !== _this.renderer.width) {
                    _this.triggerResize();
                }
            }, uiFacade.resizeThrottle));
            if (this.settings.core.useWorkers &&
                this.uiFacade.areWorkersSupported &&
                Environment.getRenderEngineFactory(this.settings).supportsWorkers) {
                this.renderer = this.uiFacade.createWorkerRenderer();
            }
            else {
                this.renderer = new ScoreRenderer(this.settings);
            }
            var initialResizeEventInfo = new ResizeEventArgs();
            initialResizeEventInfo.oldWidth = this.renderer.width;
            initialResizeEventInfo.newWidth = this.container.width | 0;
            initialResizeEventInfo.settings = this.settings;
            this.onResize(initialResizeEventInfo);
            this.renderer.preRender.on(this.onRenderStarted.bind(this));
            this.renderer.renderFinished.on(function (renderingResult) {
                _this.onRenderFinished(renderingResult);
            });
            this.renderer.postRenderFinished.on(function () {
                var duration = Date.now() - _this._startTime;
                Logger.debug('rendering', 'Rendering completed in ' + duration + 'ms');
                _this.onPostRenderFinished();
            });
            this.renderer.preRender.on(function (_) {
                _this._startTime = Date.now();
            });
            this.renderer.partialRenderFinished.on(this.appendRenderResult.bind(this));
            this.renderer.renderFinished.on(function (r) {
                _this.appendRenderResult(r);
                _this.appendRenderResult(null); // marks last element
            });
            this.renderer.error.on(this.onError.bind(this));
            if (this.settings.player.enablePlayer) {
                this.setupPlayer();
            }
            this.setupClickHandling();
            // delay rendering to allow ui to hook up with events first.
            this.uiFacade.beginInvoke(function () {
                _this.uiFacade.initialRender();
            });
        }
        /**
         * Destroys the alphaTab control and restores the initial state of the UI.
         */
        AlphaTabApiBase.prototype.destroy = function () {
            if (this.player) {
                this.player.destroy();
            }
            this.uiFacade.destroy();
            this.renderer.destroy();
        };
        /**
         * Applies any changes that were done to the settings object and informs the {@link renderer} about any new values to consider.
         */
        AlphaTabApiBase.prototype.updateSettings = function () {
            this.renderer.updateSettings(this.settings);
            // enable/disable player if needed
            if (this.settings.player.enablePlayer) {
                this.setupPlayer();
            }
            else {
                this.destroyPlayer();
            }
        };
        /**
         * Attempts a load of the score represented by the given data object.
         * @param scoreData The data container supported by {@link IUiFacade}
         * @param trackIndexes The indexes of the tracks from the song that should be rendered. If not provided, the first track of the
         * song will be shown.
         * @returns true if the data object is supported and a load was initiated, otherwise false
         */
        AlphaTabApiBase.prototype.load = function (scoreData, trackIndexes) {
            var _this = this;
            try {
                return this.uiFacade.load(scoreData, function (score) {
                    _this.renderScore(score, trackIndexes);
                }, function (error) {
                    _this.onError(error);
                });
            }
            catch (e) {
                this.onError(e);
                return false;
            }
        };
        /**
         * Initiates a rendering of the given score.
         * @param score The score containing the tracks to be rendered.
         * @param trackIndexes The indexes of the tracks from the song that should be rendered. If not provided, the first track of the
         * song will be shown.
         */
        AlphaTabApiBase.prototype.renderScore = function (score, trackIndexes) {
            var tracks = [];
            if (!trackIndexes) {
                if (score.tracks.length > 0) {
                    tracks.push(score.tracks[0]);
                }
            }
            else {
                if (trackIndexes.length === 0) {
                    if (score.tracks.length > 0) {
                        tracks.push(score.tracks[0]);
                    }
                }
                else if (trackIndexes.length === 1 && trackIndexes[0] === -1) {
                    for (var _i = 0, _a = score.tracks; _i < _a.length; _i++) {
                        var track = _a[_i];
                        tracks.push(track);
                    }
                }
                else {
                    for (var _b = 0, trackIndexes_1 = trackIndexes; _b < trackIndexes_1.length; _b++) {
                        var index = trackIndexes_1[_b];
                        if (index >= 0 && index <= score.tracks.length) {
                            tracks.push(score.tracks[index]);
                        }
                    }
                }
            }
            this.internalRenderTracks(score, tracks);
        };
        /**
         * Renders the given list of tracks.
         * @param tracks The tracks to render. They must all belong to the same score.
         */
        AlphaTabApiBase.prototype.renderTracks = function (tracks) {
            if (tracks.length > 0) {
                var score = tracks[0].score;
                for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                    var track = tracks_1[_i];
                    if (track.score !== score) {
                        this.onError(new AlphaTabError(exports.AlphaTabErrorType.General, 'All rendered tracks must belong to the same score.'));
                        return;
                    }
                }
                this.internalRenderTracks(score, tracks);
            }
        };
        AlphaTabApiBase.prototype.internalRenderTracks = function (score, tracks) {
            if (score !== this.score) {
                ModelUtils.applyPitchOffsets(this.settings, score);
                this.score = score;
                this.tracks = tracks;
                this._trackIndexes = [];
                for (var _i = 0, tracks_2 = tracks; _i < tracks_2.length; _i++) {
                    var track = tracks_2[_i];
                    this._trackIndexes.push(track.index);
                }
                this.onScoreLoaded(score);
                this.loadMidiForScore();
                this.render();
            }
            else {
                this.tracks = tracks;
                this._trackIndexes = [];
                for (var _a = 0, tracks_3 = tracks; _a < tracks_3.length; _a++) {
                    var track = tracks_3[_a];
                    this._trackIndexes.push(track.index);
                }
                this.render();
            }
        };
        AlphaTabApiBase.prototype.triggerResize = function () {
            var _this = this;
            if (!this.container.isVisible) {
                Logger.warning('Rendering', 'AlphaTab container was invisible while autosizing, waiting for element to become visible', null);
                this.uiFacade.rootContainerBecameVisible.on(function () {
                    Logger.debug('Rendering', 'AlphaTab container became visible, doing autosizing', null);
                    _this.triggerResize();
                });
            }
            else {
                var resizeEventInfo = new ResizeEventArgs();
                resizeEventInfo.oldWidth = this.renderer.width;
                resizeEventInfo.newWidth = this.container.width;
                resizeEventInfo.settings = this.settings;
                this.onResize(resizeEventInfo);
                this.renderer.updateSettings(this.settings);
                this.renderer.width = this.container.width;
                this.renderer.resizeRender();
            }
        };
        AlphaTabApiBase.prototype.appendRenderResult = function (result) {
            if (result) {
                this.canvasElement.width = result.totalWidth;
                this.canvasElement.height = result.totalHeight;
                if (this._cursorWrapper) {
                    this._cursorWrapper.width = result.totalWidth;
                    this._cursorWrapper.height = result.totalHeight;
                }
            }
            if (!result || result.renderResult) {
                this.uiFacade.beginAppendRenderResults(result);
            }
        };
        /**
         * Tells alphaTab to render the given alphaTex.
         * @param tex The alphaTex code to render.
         * @param tracks If set, the given tracks will be rendered, otherwise the first track only will be rendered.
         */
        AlphaTabApiBase.prototype.tex = function (tex, tracks) {
            try {
                var parser = new AlphaTexImporter();
                var data = ByteBuffer.fromString(tex);
                parser.init(data, this.settings);
                var score = parser.readScore();
                this.renderScore(score, tracks);
            }
            catch (e) {
                this.onError(e);
            }
        };
        /**
         * Attempts a load of the score represented by the given data object.
         * @param data The data object to decode
         * @param append Whether to fully replace or append the data from the given soundfont.
         * @returns true if the data object is supported and a load was initiated, otherwise false
         */
        AlphaTabApiBase.prototype.loadSoundFont = function (data, append) {
            if (append === void 0) { append = false; }
            if (!this.player) {
                return false;
            }
            return this.uiFacade.loadSoundFont(data, append);
        };
        /**
         * Resets all loaded soundfonts as if they were not loaded.
         */
        AlphaTabApiBase.prototype.resetSoundFonts = function () {
            if (!this.player) {
                return;
            }
            this.player.resetSoundFonts();
        };
        /**
         * Initiates a re-rendering of the current setup. If rendering is not yet possible, it will be deferred until the UI changes to be ready for rendering.
         */
        AlphaTabApiBase.prototype.render = function () {
            var _this = this;
            if (!this.renderer) {
                return;
            }
            if (this.uiFacade.canRender) {
                // when font is finally loaded, start rendering
                this.renderer.width = this.container.width;
                this.renderer.renderScore(this.score, this._trackIndexes);
            }
            else {
                this.uiFacade.canRenderChanged.on(function () { return _this.render(); });
            }
        };
        Object.defineProperty(AlphaTabApiBase.prototype, "isReadyForPlayback", {
            get: function () {
                if (!this.player) {
                    return false;
                }
                return this.player.isReadyForPlayback;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "playerState", {
            get: function () {
                if (!this.player) {
                    return PlayerState.Paused;
                }
                return this.player.state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "masterVolume", {
            get: function () {
                if (!this.player) {
                    return 0;
                }
                return this.player.masterVolume;
            },
            set: function (value) {
                if (this.player) {
                    this.player.masterVolume = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "metronomeVolume", {
            get: function () {
                if (!this.player) {
                    return 0;
                }
                return this.player.metronomeVolume;
            },
            set: function (value) {
                if (this.player) {
                    this.player.metronomeVolume = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "countInVolume", {
            get: function () {
                if (!this.player) {
                    return 0;
                }
                return this.player.countInVolume;
            },
            set: function (value) {
                if (this.player) {
                    this.player.countInVolume = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "tickPosition", {
            get: function () {
                if (!this.player) {
                    return 0;
                }
                return this.player.tickPosition;
            },
            set: function (value) {
                if (this.player) {
                    this.player.tickPosition = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "timePosition", {
            get: function () {
                if (!this.player) {
                    return 0;
                }
                return this.player.timePosition;
            },
            set: function (value) {
                if (this.player) {
                    this.player.timePosition = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "playbackRange", {
            get: function () {
                if (!this.player) {
                    return null;
                }
                return this.player.playbackRange;
            },
            set: function (value) {
                if (this.player) {
                    this.player.playbackRange = value;
                    if (this.settings.player.enableCursor) {
                        this.updateSelectionCursor(value);
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "playbackSpeed", {
            get: function () {
                if (!this.player) {
                    return 0;
                }
                return this.player.playbackSpeed;
            },
            set: function (value) {
                if (this.player) {
                    this.player.playbackSpeed = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaTabApiBase.prototype, "isLooping", {
            get: function () {
                if (!this.player) {
                    return false;
                }
                return this.player.isLooping;
            },
            set: function (value) {
                if (this.player) {
                    this.player.isLooping = value;
                }
            },
            enumerable: false,
            configurable: true
        });
        AlphaTabApiBase.prototype.destroyPlayer = function () {
            if (!this.player) {
                return;
            }
            this.player.destroy();
            this.player = null;
            this.destroyCursors();
        };
        AlphaTabApiBase.prototype.setupPlayer = function () {
            var _this = this;
            if (this.player) {
                return;
            }
            this.player = this.uiFacade.createWorkerPlayer();
            if (!this.player) {
                return;
            }
            this.player.ready.on(function () {
                _this.loadMidiForScore();
            });
            this.player.readyForPlayback.on(function () {
                _this.onPlayerReady();
                if (_this.tracks) {
                    for (var _i = 0, _a = _this.tracks; _i < _a.length; _i++) {
                        var track = _a[_i];
                        var volume = track.playbackInfo.volume / 16;
                        _this.player.setChannelVolume(track.playbackInfo.primaryChannel, volume);
                        _this.player.setChannelVolume(track.playbackInfo.secondaryChannel, volume);
                    }
                }
            });
            this.player.soundFontLoaded.on(this.onSoundFontLoaded.bind(this));
            this.player.soundFontLoadFailed.on(function (e) {
                _this.onError(e);
            });
            this.player.midiLoaded.on(this.onMidiLoaded.bind(this));
            this.player.midiLoadFailed.on(function (e) {
                _this.onError(e);
            });
            this.player.stateChanged.on(this.onPlayerStateChanged.bind(this));
            this.player.positionChanged.on(this.onPlayerPositionChanged.bind(this));
            this.player.finished.on(this.onPlayerFinished.bind(this));
            if (this.settings.player.enableCursor) {
                this.setupCursors();
            }
            else {
                this.destroyCursors();
            }
        };
        AlphaTabApiBase.prototype.loadMidiForScore = function () {
            if (!this.player || !this.score || !this.player.isReady) {
                return;
            }
            Logger.debug('AlphaTab', 'Generating Midi');
            var midiFile = new MidiFile();
            var handler = new AlphaSynthMidiFileHandler(midiFile);
            var generator = new MidiFileGenerator(this.score, this.settings, handler);
            generator.generate();
            this._tickCache = generator.tickLookup;
            this.player.loadMidiFile(midiFile);
        };
        /**
         * Changes the volume of the given tracks.
         * @param tracks The tracks for which the volume should be changed.
         * @param volume The volume to set for all tracks in percent (0-1)
         */
        AlphaTabApiBase.prototype.changeTrackVolume = function (tracks, volume) {
            if (!this.player) {
                return;
            }
            for (var _i = 0, tracks_4 = tracks; _i < tracks_4.length; _i++) {
                var track = tracks_4[_i];
                this.player.setChannelVolume(track.playbackInfo.primaryChannel, volume);
                this.player.setChannelVolume(track.playbackInfo.secondaryChannel, volume);
            }
        };
        /**
         * Changes the given tracks to be played solo or not.
         * If one or more tracks are set to solo, only those tracks are hearable.
         * @param tracks The list of tracks to play solo or not.
         * @param solo If set to true, the tracks will be added to the solo list. If false, they are removed.
         */
        AlphaTabApiBase.prototype.changeTrackSolo = function (tracks, solo) {
            if (!this.player) {
                return;
            }
            for (var _i = 0, tracks_5 = tracks; _i < tracks_5.length; _i++) {
                var track = tracks_5[_i];
                this.player.setChannelSolo(track.playbackInfo.primaryChannel, solo);
                this.player.setChannelSolo(track.playbackInfo.secondaryChannel, solo);
            }
        };
        /**
         * Changes the given tracks to be muted or not.
         * @param tracks The list of track to mute or unmute.
         * @param mute If set to true, the tracks will be muted. If false they are unmuted.
         */
        AlphaTabApiBase.prototype.changeTrackMute = function (tracks, mute) {
            if (!this.player) {
                return;
            }
            for (var _i = 0, tracks_6 = tracks; _i < tracks_6.length; _i++) {
                var track = tracks_6[_i];
                this.player.setChannelMute(track.playbackInfo.primaryChannel, mute);
                this.player.setChannelMute(track.playbackInfo.secondaryChannel, mute);
            }
        };
        /**
         * Starts the playback of the current song.
         * @returns true if the playback was started, otherwise false. Reasons for not starting can be that the player is not ready or already playing.
         */
        AlphaTabApiBase.prototype.play = function () {
            if (!this.player) {
                return false;
            }
            return this.player.play();
        };
        /**
         * Pauses the playback of the current song.
         */
        AlphaTabApiBase.prototype.pause = function () {
            if (!this.player) {
                return;
            }
            this.player.pause();
        };
        /**
         * Toggles between play/pause depending on the current player state.
         */
        AlphaTabApiBase.prototype.playPause = function () {
            if (!this.player) {
                return;
            }
            this.player.playPause();
        };
        /**
         * Stops the playback of the current song, and moves the playback position back to the start.
         */
        AlphaTabApiBase.prototype.stop = function () {
            if (!this.player) {
                return;
            }
            this.player.stop();
        };
        /**
         * Triggers the play of the given beat. This will stop the any other current ongoing playback.
         * @param beat the single beat to play
         */
        AlphaTabApiBase.prototype.playBeat = function (beat) {
            if (!this.player) {
                return;
            }
            // we generate a new midi file containing only the beat
            var midiFile = new MidiFile();
            var handler = new AlphaSynthMidiFileHandler(midiFile);
            var generator = new MidiFileGenerator(beat.voice.bar.staff.track.score, this.settings, handler);
            generator.generateSingleBeat(beat);
            this.player.playOneTimeMidiFile(midiFile);
        };
        /**
         * Triggers the play of the given note. This will stop the any other current ongoing playback.
         * @param beat the single note to play
         */
        AlphaTabApiBase.prototype.playNote = function (note) {
            if (!this.player) {
                return;
            }
            // we generate a new midi file containing only the beat
            var midiFile = new MidiFile();
            var handler = new AlphaSynthMidiFileHandler(midiFile);
            var generator = new MidiFileGenerator(note.beat.voice.bar.staff.track.score, this.settings, handler);
            generator.generateSingleNote(note);
            this.player.playOneTimeMidiFile(midiFile);
        };
        AlphaTabApiBase.prototype.destroyCursors = function () {
            if (!this._cursorWrapper) {
                return;
            }
            this.uiFacade.destroyCursors();
            this._cursorWrapper = null;
            this._barCursor = null;
            this._beatCursor = null;
            this._selectionWrapper = null;
            this._previousTick = 0;
            this._playerState = PlayerState.Paused;
        };
        AlphaTabApiBase.prototype.setupCursors = function () {
            var _this = this;
            //
            // Create cursors
            var cursors = this.uiFacade.createCursors();
            if (!cursors) {
                return;
            }
            // store options and created elements for fast access
            this._cursorWrapper = cursors.cursorWrapper;
            this._barCursor = cursors.barCursor;
            this._beatCursor = cursors.beatCursor;
            this._selectionWrapper = cursors.selectionWrapper;
            //
            // Hook into events
            this._previousTick = 0;
            this._playerState = PlayerState.Paused;
            // we need to update our position caches if we render a tablature
            this.renderer.postRenderFinished.on(function () {
                _this.cursorUpdateTick(_this._previousTick, false);
            });
            if (this.player) {
                this.player.positionChanged.on(function (e) {
                    _this._previousTick = e.currentTick;
                    _this.uiFacade.beginInvoke(function () {
                        _this.cursorUpdateTick(e.currentTick, false);
                    });
                });
                this.player.stateChanged.on(function (e) {
                    _this._playerState = e.state;
                    if (!e.stopped && e.state === PlayerState.Paused) {
                        var currentBeat = _this._currentBeat;
                        var tickCache = _this._tickCache;
                        if (currentBeat && tickCache) {
                            _this.player.tickPosition =
                                tickCache.getMasterBarStart(currentBeat.voice.bar.masterBar) + currentBeat.playbackStart;
                        }
                    }
                });
            }
        };
        /**
         * updates the cursors to highlight the beat at the specified tick position
         * @param tick
         * @param stop
         */
        AlphaTabApiBase.prototype.cursorUpdateTick = function (tick, stop) {
            var _this = this;
            if (stop === void 0) { stop = false; }
            this.uiFacade.beginInvoke(function () {
                var cache = _this._tickCache;
                if (cache) {
                    var tracks = _this.tracks;
                    if (tracks.length > 0) {
                        var beat = cache.findBeat(tracks, tick);
                        if (beat) {
                            _this.cursorUpdateBeat(beat.currentBeat, beat.nextBeat, beat.duration, stop, beat.beatsToHighlight);
                        }
                    }
                }
            });
        };
        /**
         * updates the cursors to highlight the specified beat
         */
        AlphaTabApiBase.prototype.cursorUpdateBeat = function (beat, nextBeat, duration, stop, beatsToHighlight) {
            if (beatsToHighlight === void 0) { beatsToHighlight = null; }
            if (!beat) {
                return;
            }
            var cache = this.renderer.boundsLookup;
            if (!cache) {
                return;
            }
            var previousBeat = this._currentBeat;
            var previousCache = this._previousCursorCache;
            var previousState = this._previousStateForCursor;
            this._currentBeat = beat;
            this._previousCursorCache = cache;
            this._previousStateForCursor = this._playerState;
            if (beat === previousBeat && cache === previousCache && previousState === this._playerState) {
                return;
            }
            var barCursor = this._barCursor;
            var beatCursor = this._beatCursor;
            var beatBoundings = cache.findBeat(beat);
            if (!beatBoundings) {
                return;
            }
            var barBoundings = beatBoundings.barBounds.masterBarBounds;
            var barBounds = barBoundings.visualBounds;
            if (barCursor) {
                barCursor.top = barBounds.y;
                barCursor.left = barBounds.x;
                barCursor.width = barBounds.w;
                barCursor.height = barBounds.h;
            }
            if (beatCursor) {
                // move beat to start position immediately
                beatCursor.stopAnimation();
                beatCursor.top = barBounds.y;
                beatCursor.left = beatBoundings.visualBounds.x;
                beatCursor.height = barBounds.h;
            }
            // if playing, animate the cursor to the next beat
            this.uiFacade.removeHighlights();
            if (this._playerState === PlayerState.Playing || stop) {
                duration /= this.playbackSpeed;
                if (!stop) {
                    if (beatsToHighlight) {
                        for (var _i = 0, beatsToHighlight_1 = beatsToHighlight; _i < beatsToHighlight_1.length; _i++) {
                            var highlight = beatsToHighlight_1[_i];
                            var className = BeatContainerGlyph.getGroupId(highlight);
                            this.uiFacade.highlightElements(className);
                        }
                    }
                    var nextBeatX_1 = barBoundings.visualBounds.x + barBoundings.visualBounds.w;
                    // get position of next beat on same stavegroup
                    if (nextBeat) {
                        // if we are moving within the same bar or to the next bar
                        // transition to the next beat, otherwise transition to the end of the bar.
                        if (nextBeat.voice.bar.index === beat.voice.bar.index ||
                            nextBeat.voice.bar.index === beat.voice.bar.index + 1) {
                            var nextBeatBoundings = cache.findBeat(nextBeat);
                            if (nextBeatBoundings &&
                                nextBeatBoundings.barBounds.masterBarBounds.staveGroupBounds ===
                                    barBoundings.staveGroupBounds) {
                                nextBeatX_1 = nextBeatBoundings.visualBounds.x;
                            }
                        }
                    }
                    if (beatCursor) {
                        this.uiFacade.beginInvoke(function () {
                            // Logger.Info("Player",
                            //    "Transition from " + beatBoundings.VisualBounds.X + " to " + nextBeatX + " in " + duration +
                            //    "(" + Player.PlaybackRange + ")");
                            beatCursor.transitionToX(duration, nextBeatX_1);
                        });
                    }
                }
                if (!this._beatMouseDown && this.settings.player.scrollMode !== exports.ScrollMode.Off) {
                    var scrollElement = this.uiFacade.getScrollContainer();
                    var isVertical = Environment.getLayoutEngineFactory(this.settings).vertical;
                    var mode = this.settings.player.scrollMode;
                    var elementOffset = this.uiFacade.getOffset(scrollElement, this.container);
                    if (isVertical) {
                        switch (mode) {
                            case exports.ScrollMode.Continuous:
                                var y = elementOffset.y + barBoundings.realBounds.y + this.settings.player.scrollOffsetY;
                                if (y !== this._lastScroll) {
                                    this._lastScroll = y;
                                    this.uiFacade.scrollToY(scrollElement, y, this.settings.player.scrollSpeed);
                                }
                                break;
                            case exports.ScrollMode.OffScreen:
                                var elementBottom = scrollElement.scrollTop + this.uiFacade.getOffset(null, scrollElement).h;
                                if (barBoundings.visualBounds.y + barBoundings.visualBounds.h >= elementBottom ||
                                    barBoundings.visualBounds.y < scrollElement.scrollTop) {
                                    var scrollTop = barBoundings.realBounds.y + this.settings.player.scrollOffsetY;
                                    this._lastScroll = barBoundings.visualBounds.x;
                                    this.uiFacade.scrollToY(scrollElement, scrollTop, this.settings.player.scrollSpeed);
                                }
                                break;
                        }
                    }
                    else {
                        switch (mode) {
                            case exports.ScrollMode.Continuous:
                                var x = barBoundings.visualBounds.x;
                                if (x !== this._lastScroll) {
                                    var scrollLeft = barBoundings.realBounds.x + this.settings.player.scrollOffsetX;
                                    this._lastScroll = barBoundings.visualBounds.x;
                                    this.uiFacade.scrollToX(scrollElement, scrollLeft, this.settings.player.scrollSpeed);
                                }
                                break;
                            case exports.ScrollMode.OffScreen:
                                var elementRight = scrollElement.scrollLeft + this.uiFacade.getOffset(null, scrollElement).w;
                                if (barBoundings.visualBounds.x + barBoundings.visualBounds.w >= elementRight ||
                                    barBoundings.visualBounds.x < scrollElement.scrollLeft) {
                                    var scrollLeft = barBoundings.realBounds.x + this.settings.player.scrollOffsetX;
                                    this._lastScroll = barBoundings.visualBounds.x;
                                    this.uiFacade.scrollToX(scrollElement, scrollLeft, this.settings.player.scrollSpeed);
                                }
                                break;
                        }
                    }
                }
                // trigger an event for others to indicate which beat/bar is played
                this.onPlayedBeatChanged(beat);
            }
        };
        AlphaTabApiBase.prototype.onPlayedBeatChanged = function (beat) {
            this.playedBeatChanged.trigger(beat);
            this.uiFacade.triggerEvent(this.container, 'playedBeatChanged', beat);
        };
        AlphaTabApiBase.prototype.onBeatMouseDown = function (originalEvent, beat) {
            if (this.settings.player.enablePlayer &&
                this.settings.player.enableCursor &&
                this.settings.player.enableUserInteraction) {
                this._selectionStart = new SelectionInfo(beat);
                this._selectionEnd = null;
            }
            this._beatMouseDown = true;
            this.beatMouseDown.trigger(beat);
            this.uiFacade.triggerEvent(this.container, 'beatMouseDown', beat, originalEvent);
        };
        AlphaTabApiBase.prototype.onBeatMouseMove = function (originalEvent, beat) {
            if (this.settings.player.enableUserInteraction) {
                if (!this._selectionEnd || this._selectionEnd.beat !== beat) {
                    this._selectionEnd = new SelectionInfo(beat);
                    this.cursorSelectRange(this._selectionStart, this._selectionEnd);
                }
            }
            this.beatMouseMove.trigger(beat);
            this.uiFacade.triggerEvent(this.container, 'beatMouseMove', beat, originalEvent);
        };
        AlphaTabApiBase.prototype.onBeatMouseUp = function (originalEvent, beat) {
            if (this.settings.player.enableUserInteraction) {
                // for the selection ensure start < end
                if (this._selectionEnd) {
                    var startTick = this._selectionStart.beat.absoluteDisplayStart;
                    var endTick = this._selectionStart.beat.absoluteDisplayStart;
                    if (endTick < startTick) {
                        var t = this._selectionStart;
                        this._selectionStart = this._selectionEnd;
                        this._selectionEnd = t;
                    }
                }
                if (this._selectionStart && this._tickCache) {
                    // get the start and stop ticks (which consider properly repeats)
                    var tickCache = this._tickCache;
                    var realMasterBarStart = tickCache.getMasterBarStart(this._selectionStart.beat.voice.bar.masterBar);
                    // move to selection start
                    this._currentBeat = null; // reset current beat so it is updating the cursor
                    if (this._playerState === PlayerState.Paused) {
                        this.cursorUpdateBeat(this._selectionStart.beat, null, 0, false, [this._selectionStart.beat]);
                    }
                    this.tickPosition = realMasterBarStart + this._selectionStart.beat.playbackStart;
                    // set playback range
                    if (this._selectionEnd && this._selectionStart.beat !== this._selectionEnd.beat) {
                        var realMasterBarEnd = tickCache.getMasterBarStart(this._selectionEnd.beat.voice.bar.masterBar);
                        var range = new PlaybackRange();
                        range.startTick = realMasterBarStart + this._selectionStart.beat.playbackStart;
                        range.endTick =
                            realMasterBarEnd +
                                this._selectionEnd.beat.playbackStart +
                                this._selectionEnd.beat.playbackDuration -
                                50;
                        this.playbackRange = range;
                    }
                    else {
                        this._selectionStart = null;
                        this.playbackRange = null;
                        this.cursorSelectRange(this._selectionStart, this._selectionEnd);
                    }
                }
            }
            this.beatMouseUp.trigger(beat);
            this.uiFacade.triggerEvent(this.container, 'beatMouseUp', beat, originalEvent);
            this._beatMouseDown = false;
        };
        AlphaTabApiBase.prototype.updateSelectionCursor = function (range) {
            if (!this._tickCache) {
                return;
            }
            if (range) {
                var startBeat = this._tickCache.findBeat(this.tracks, range.startTick);
                var endBeat = this._tickCache.findBeat(this.tracks, range.endTick);
                if (startBeat && endBeat) {
                    var selectionStart = new SelectionInfo(startBeat.currentBeat);
                    var selectionEnd = new SelectionInfo(endBeat.currentBeat);
                    this.cursorSelectRange(selectionStart, selectionEnd);
                }
            }
            else {
                this.cursorSelectRange(null, null);
            }
        };
        AlphaTabApiBase.prototype.setupClickHandling = function () {
            var _this = this;
            this.canvasElement.mouseDown.on(function (e) {
                var _a, _b;
                if (!e.isLeftMouseButton) {
                    return;
                }
                if (_this.settings.player.enableUserInteraction) {
                    e.preventDefault();
                }
                var relX = e.getX(_this.canvasElement);
                var relY = e.getY(_this.canvasElement);
                var beat = (_b = (_a = _this.renderer.boundsLookup) === null || _a === void 0 ? void 0 : _a.getBeatAtPos(relX, relY)) !== null && _b !== void 0 ? _b : null;
                if (beat) {
                    _this.onBeatMouseDown(e, beat);
                }
            });
            this.canvasElement.mouseMove.on(function (e) {
                var _a, _b;
                if (!_this._beatMouseDown) {
                    return;
                }
                var relX = e.getX(_this.canvasElement);
                var relY = e.getY(_this.canvasElement);
                var beat = (_b = (_a = _this.renderer.boundsLookup) === null || _a === void 0 ? void 0 : _a.getBeatAtPos(relX, relY)) !== null && _b !== void 0 ? _b : null;
                if (beat) {
                    _this.onBeatMouseMove(e, beat);
                }
            });
            this.canvasElement.mouseUp.on(function (e) {
                var _a, _b;
                if (!_this._beatMouseDown) {
                    return;
                }
                if (_this.settings.player.enableUserInteraction) {
                    e.preventDefault();
                }
                var relX = e.getX(_this.canvasElement);
                var relY = e.getY(_this.canvasElement);
                var beat = (_b = (_a = _this.renderer.boundsLookup) === null || _a === void 0 ? void 0 : _a.getBeatAtPos(relX, relY)) !== null && _b !== void 0 ? _b : null;
                _this.onBeatMouseUp(e, beat);
            });
            this.renderer.postRenderFinished.on(function () {
                if (!_this._selectionStart ||
                    !_this.settings.player.enablePlayer ||
                    !_this.settings.player.enableCursor ||
                    !_this.settings.player.enableUserInteraction) {
                    return;
                }
                _this.cursorSelectRange(_this._selectionStart, _this._selectionEnd);
            });
        };
        AlphaTabApiBase.prototype.cursorSelectRange = function (startBeat, endBeat) {
            var cache = this.renderer.boundsLookup;
            if (!cache) {
                return;
            }
            var selectionWrapper = this._selectionWrapper;
            if (!selectionWrapper) {
                return;
            }
            selectionWrapper.clear();
            if (!startBeat || !endBeat || startBeat.beat === endBeat.beat) {
                return;
            }
            if (!startBeat.bounds) {
                startBeat.bounds = cache.findBeat(startBeat.beat);
            }
            if (!endBeat.bounds) {
                endBeat.bounds = cache.findBeat(endBeat.beat);
            }
            var startTick = startBeat.beat.absolutePlaybackStart;
            var endTick = endBeat.beat.absolutePlaybackStart;
            if (endTick < startTick) {
                var t = startBeat;
                startBeat = endBeat;
                endBeat = t;
            }
            var startX = startBeat.bounds.realBounds.x;
            var endX = endBeat.bounds.realBounds.x + endBeat.bounds.realBounds.w;
            if (endBeat.beat.index === endBeat.beat.voice.beats.length - 1) {
                endX =
                    endBeat.bounds.barBounds.masterBarBounds.realBounds.x +
                        endBeat.bounds.barBounds.masterBarBounds.realBounds.w;
            }
            // if the selection goes across multiple staves, we need a special selection highlighting
            if (startBeat.bounds.barBounds.masterBarBounds.staveGroupBounds !==
                endBeat.bounds.barBounds.masterBarBounds.staveGroupBounds) {
                // from the startbeat to the end of the staff,
                // then fill all staffs until the end-beat staff
                // then from staff-start to the end beat (or to end of bar if it's the last beat)
                var staffStartX = startBeat.bounds.barBounds.masterBarBounds.staveGroupBounds.visualBounds.x;
                var staffEndX = startBeat.bounds.barBounds.masterBarBounds.staveGroupBounds.visualBounds.x +
                    startBeat.bounds.barBounds.masterBarBounds.staveGroupBounds.visualBounds.w;
                var startSelection = this.uiFacade.createSelectionElement();
                startSelection.top = startBeat.bounds.barBounds.masterBarBounds.visualBounds.y;
                startSelection.left = startX;
                startSelection.width = staffEndX - startX;
                startSelection.height = startBeat.bounds.barBounds.masterBarBounds.visualBounds.h;
                selectionWrapper.appendChild(startSelection);
                var staffStartIndex = startBeat.bounds.barBounds.masterBarBounds.staveGroupBounds.index + 1;
                var staffEndIndex = endBeat.bounds.barBounds.masterBarBounds.staveGroupBounds.index;
                for (var staffIndex = staffStartIndex; staffIndex < staffEndIndex; staffIndex++) {
                    var staffBounds = cache.staveGroups[staffIndex];
                    var middleSelection = this.uiFacade.createSelectionElement();
                    middleSelection.top = staffBounds.visualBounds.y;
                    middleSelection.left = staffStartX;
                    middleSelection.width = staffEndX - staffStartX;
                    middleSelection.height = staffBounds.visualBounds.h;
                    selectionWrapper.appendChild(middleSelection);
                }
                var endSelection = this.uiFacade.createSelectionElement();
                endSelection.top = endBeat.bounds.barBounds.masterBarBounds.visualBounds.y;
                endSelection.left = staffStartX;
                endSelection.width = endX - staffStartX;
                endSelection.height = endBeat.bounds.barBounds.masterBarBounds.visualBounds.h;
                selectionWrapper.appendChild(endSelection);
            }
            else {
                // if the beats are on the same staff, we simply highlight from the startbeat to endbeat
                var selection = this.uiFacade.createSelectionElement();
                selection.top = startBeat.bounds.barBounds.masterBarBounds.visualBounds.y;
                selection.left = startX;
                selection.width = endX - startX;
                selection.height = startBeat.bounds.barBounds.masterBarBounds.visualBounds.h;
                selectionWrapper.appendChild(selection);
            }
        };
        AlphaTabApiBase.prototype.onScoreLoaded = function (score) {
            this.scoreLoaded.trigger(score);
            this.uiFacade.triggerEvent(this.container, 'scoreLoaded', score);
        };
        AlphaTabApiBase.prototype.onResize = function (e) {
            this.resize.trigger(e);
            this.uiFacade.triggerEvent(this.container, 'resize', e);
        };
        AlphaTabApiBase.prototype.onRenderStarted = function (resize) {
            this.renderStarted.trigger(resize);
            this.uiFacade.triggerEvent(this.container, 'renderStarted', resize);
        };
        AlphaTabApiBase.prototype.onRenderFinished = function (renderingResult) {
            this.renderFinished.trigger(renderingResult);
            this.uiFacade.triggerEvent(this.container, 'renderFinished', renderingResult);
        };
        AlphaTabApiBase.prototype.onPostRenderFinished = function () {
            this.postRenderFinished.trigger();
            this.uiFacade.triggerEvent(this.container, 'postRenderFinished', null);
        };
        AlphaTabApiBase.prototype.onError = function (error) {
            Logger.error('API', 'An unexpected error occurred', error);
            this.error.trigger(error);
            this.uiFacade.triggerEvent(this.container, 'error', error);
        };
        AlphaTabApiBase.prototype.onPlayerReady = function () {
            this.playerReady.trigger();
            this.uiFacade.triggerEvent(this.container, 'playerReady', null);
        };
        AlphaTabApiBase.prototype.onPlayerFinished = function () {
            this.playerFinished.trigger();
            this.uiFacade.triggerEvent(this.container, 'playerFinished', null);
        };
        AlphaTabApiBase.prototype.onSoundFontLoaded = function () {
            this.soundFontLoaded.trigger();
            this.uiFacade.triggerEvent(this.container, 'soundFontLoaded', null);
        };
        AlphaTabApiBase.prototype.onMidiLoaded = function () {
            this.midiLoaded.trigger();
            this.uiFacade.triggerEvent(this.container, 'midiFileLoaded', null);
        };
        AlphaTabApiBase.prototype.onPlayerStateChanged = function (e) {
            this.playerStateChanged.trigger(e);
            this.uiFacade.triggerEvent(this.container, 'playerStateChanged', e);
        };
        AlphaTabApiBase.prototype.onPlayerPositionChanged = function (e) {
            this.playerPositionChanged.trigger(e);
            this.uiFacade.triggerEvent(this.container, 'playerPositionChanged', e);
        };
        return AlphaTabApiBase;
    }());

    var __extends$n = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @target web
     */
    var FileLoadError = /** @class */ (function (_super) {
        __extends$n(FileLoadError, _super);
        function FileLoadError(message, xhr) {
            var _this = _super.call(this, exports.AlphaTabErrorType.General, message) || this;
            _this.xhr = xhr;
            Object.setPrototypeOf(_this, FileLoadError.prototype);
            return _this;
        }
        return FileLoadError;
    }(AlphaTabError));

    /**
     * The ScoreLoader enables you easy loading of Scores using all
     * available importers
     */
    var ScoreLoader = /** @class */ (function () {
        function ScoreLoader() {
        }
        /**
         * Loads a score asynchronously from the given datasource
         * @param path the source path to load the binary file from
         * @param success this function is called if the Score was successfully loaded from the datasource
         * @param error this function is called if any error during the loading occured.
         * @param settings settings for the score import
         * @target web
         */
        // TODO: use promises
        ScoreLoader.loadScoreAsync = function (path, success, error, settings) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', path, true, null, null);
            xhr.responseType = 'arraybuffer';
            xhr.onreadystatechange = function () {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    var response = xhr.response;
                    if (xhr.status === 200 || (xhr.status === 0 && response)) {
                        try {
                            var buffer = xhr.response;
                            var reader = new Uint8Array(buffer);
                            var score = ScoreLoader.loadScoreFromBytes(reader, settings);
                            success(score);
                        }
                        catch (e) {
                            error(e);
                        }
                    }
                    else if (xhr.status === 0) {
                        error(new FileLoadError('You are offline!!\n Please Check Your Network.', xhr));
                    }
                    else if (xhr.status === 404) {
                        error(new FileLoadError('Requested URL not found.', xhr));
                    }
                    else if (xhr.status === 500) {
                        error(new FileLoadError('Internel Server Error.', xhr));
                    }
                    else if (xhr.statusText === 'parsererror') {
                        error(new FileLoadError('Error.\nParsing JSON Request failed.', xhr));
                    }
                    else if (xhr.statusText === 'timeout') {
                        error(new FileLoadError('Request Time out.', xhr));
                    }
                    else {
                        error(new FileLoadError('Unknow Error: ' + xhr.responseText, xhr));
                    }
                }
            };
            // IE fallback
            if (xhr.responseType !== 'arraybuffer') {
                // use VB Loader to load binary array
                var vbArr = VbAjaxLoader('GET', path);
                var fileContents = vbArr.toArray();
                // decode byte array to string
                var data = '';
                var i = 0;
                while (i < fileContents.length - 1) {
                    data += fileContents[i].toString();
                    i++;
                }
                var reader = ScoreLoader.getBytesFromString(data);
                var score = ScoreLoader.loadScoreFromBytes(reader, settings);
                success(score);
            }
            xhr.send();
        };
        ScoreLoader.getBytesFromString = function (s) {
            var b = new Uint8Array(s.length);
            for (var i = 0; i < s.length; i++) {
                b[i] = s.charCodeAt(i);
            }
            return b;
        };
        /**
         * Loads the score from the given binary data.
         * @param data The binary data containing a score in any known file format.
         * @param settings The settings to use during importing.
         * @returns The loaded score.
         */
        ScoreLoader.loadScoreFromBytes = function (data, settings) {
            if (!settings) {
                settings = new Settings();
            }
            var importers = Environment.buildImporters();
            Logger.debug('ScoreLoader', 'Loading score from ' + data.length + ' bytes using ' + importers.length + ' importers', null);
            var score = null;
            var bb = ByteBuffer.fromBuffer(data);
            for (var _i = 0, importers_1 = importers; _i < importers_1.length; _i++) {
                var importer = importers_1[_i];
                bb.reset();
                try {
                    Logger.debug('ScoreLoader', 'Importing using importer ' + importer.name);
                    importer.init(bb, settings);
                    score = importer.readScore();
                    Logger.debug('ScoreLoader', 'Score imported using ' + importer.name);
                    break;
                }
                catch (e) {
                    if (e instanceof UnsupportedFormatError) {
                        Logger.debug('ScoreLoader', importer.name + ' does not support the file');
                    }
                    else {
                        Logger.error('ScoreLoader', 'Score import failed due to unexpected error: ', e);
                        throw e;
                    }
                }
            }
            if (score) {
                return score;
            }
            Logger.error('ScoreLoader', 'No compatible importer found for file');
            throw new UnsupportedFormatError('No compatible importer found for file');
        };
        return ScoreLoader;
    }());

    /**
     * @target web
     */
    var BrowserMouseEventArgs = /** @class */ (function () {
        function BrowserMouseEventArgs(e) {
            this.mouseEvent = e;
        }
        Object.defineProperty(BrowserMouseEventArgs.prototype, "isLeftMouseButton", {
            get: function () {
                return this.mouseEvent.button === 0;
            },
            enumerable: false,
            configurable: true
        });
        BrowserMouseEventArgs.prototype.getX = function (relativeTo) {
            var relativeToElement = relativeTo.element;
            var bounds = relativeToElement.getBoundingClientRect();
            var left = bounds.left + relativeToElement.ownerDocument.defaultView.pageXOffset;
            return this.mouseEvent.pageX - left;
        };
        BrowserMouseEventArgs.prototype.getY = function (relativeTo) {
            var relativeToElement = relativeTo.element;
            var bounds = relativeToElement.getBoundingClientRect();
            var top = bounds.top + relativeToElement.ownerDocument.defaultView.pageYOffset;
            return this.mouseEvent.pageY - top;
        };
        BrowserMouseEventArgs.prototype.preventDefault = function () {
            this.mouseEvent.preventDefault();
        };
        return BrowserMouseEventArgs;
    }());

    /**
     * @target web
     */
    var HtmlElementContainer = /** @class */ (function () {
        function HtmlElementContainer(element) {
            var _this = this;
            this.element = element;
            this.mouseDown = {
                on: function (value) {
                    _this.element.addEventListener('mousedown', function (e) {
                        value(new BrowserMouseEventArgs(e));
                    }, true);
                },
                off: function (value) {
                    // not supported due to wrapping
                }
            };
            this.mouseUp = {
                on: function (value) {
                    _this.element.addEventListener('mouseup', function (e) {
                        value(new BrowserMouseEventArgs(e));
                    }, true);
                },
                off: function (value) {
                    // not supported due to wrapping
                }
            };
            this.mouseMove = {
                on: function (value) {
                    _this.element.addEventListener('mousemove', function (e) {
                        value(new BrowserMouseEventArgs(e));
                    }, true);
                },
                off: function (_) {
                    // not supported due to wrapping
                }
            };
            this.scroll = {
                on: function (value) {
                    window.addEventListener('scroll', value, true);
                },
                off: function (value) {
                    window.removeEventListener('scroll', value, true);
                }
            };
            this.resize = {
                on: function (value) {
                    window.addEventListener('resize', value, true);
                },
                off: function (value) {
                    window.removeEventListener('resize', value, true);
                }
            };
        }
        Object.defineProperty(HtmlElementContainer.prototype, "top", {
            get: function () {
                return parseFloat(this.element.style.top);
            },
            set: function (value) {
                this.element.style.top = value + 'px';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HtmlElementContainer.prototype, "left", {
            get: function () {
                return parseFloat(this.element.style.top);
            },
            set: function (value) {
                this.element.style.left = value + 'px';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HtmlElementContainer.prototype, "width", {
            get: function () {
                return this.element.offsetWidth;
            },
            set: function (value) {
                this.element.style.width = value + 'px';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HtmlElementContainer.prototype, "scrollLeft", {
            get: function () {
                return this.element.scrollLeft;
            },
            set: function (value) {
                this.element.scrollTop = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HtmlElementContainer.prototype, "scrollTop", {
            get: function () {
                return this.element.scrollLeft;
            },
            set: function (value) {
                this.element.scrollTop = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HtmlElementContainer.prototype, "height", {
            get: function () {
                return this.element.offsetHeight;
            },
            set: function (value) {
                if (value >= 0) {
                    this.element.style.height = value + 'px';
                }
                else {
                    this.element.style.height = '100%';
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HtmlElementContainer.prototype, "isVisible", {
            get: function () {
                return !!this.element.offsetWidth || !!this.element.offsetHeight || !!this.element.getClientRects().length;
            },
            enumerable: false,
            configurable: true
        });
        HtmlElementContainer.prototype.stopAnimation = function () {
            this.element.style.transition = 'none';
        };
        HtmlElementContainer.prototype.transitionToX = function (duration, x) {
            this.element.style.transition = 'all 0s linear';
            this.element.style.transitionDuration = duration + 'ms';
            this.element.style.left = x + 'px';
        };
        HtmlElementContainer.prototype.appendChild = function (child) {
            this.element.appendChild(child.element);
        };
        HtmlElementContainer.prototype.clear = function () {
            this.element.innerHTML = '';
        };
        return HtmlElementContainer;
    }());

    /**
     * This small utility helps to detect whether a particular font is already loaded.
     * @target web
     */
    var FontLoadingChecker = /** @class */ (function () {
        function FontLoadingChecker(family, fallbackText) {
            if (fallbackText === void 0) { fallbackText = 'BESbwy'; }
            this._isStarted = false;
            this.isFontLoaded = false;
            this.fontLoaded = new EventEmitterOfT();
            this._family = family;
            this._fallbackText = fallbackText;
        }
        FontLoadingChecker.prototype.checkForFontAvailability = function () {
            var _this = this;
            if (Environment.isRunningInWorker) {
                // no web fonts in web worker
                this.isFontLoaded = false;
                return;
            }
            if (this._isStarted) {
                return;
            }
            this._isStarted = true;
            var failCounter = 0;
            var failCounterId = window.setInterval(function () {
                failCounter++;
                Logger.warning('Rendering', "Could not load font '" + _this._family + "' within " + failCounter * 5 + " seconds", null);
            }, 5000);
            Logger.debug('Font', "Start checking for font availablility: " + this._family);
            if (Environment.supportsFontsApi) {
                Logger.debug('Font', "[" + this._family + "] Font API available");
                var checkFont_1 = function () {
                    document.fonts.load("1em " + _this._family).then(function () {
                        Logger.debug('Font', "[" + _this._family + "] Font API signaled loaded");
                        if (document.fonts.check('1em ' + _this._family)) {
                            Logger.debug('Rendering', "[" + _this._family + "] Font API signaled available");
                            _this.isFontLoaded = true;
                            window.clearInterval(failCounterId);
                            _this.fontLoaded.trigger(_this._family);
                        }
                        else {
                            Logger.debug('Font', "[" + _this._family + "] Font API loaded reported, but font not available, checking later again", null);
                            window.setTimeout(function () {
                                checkFont_1();
                            }, 250);
                        }
                        return true;
                    });
                };
                checkFont_1();
            }
            else {
                Logger.debug('Font', "[" + this._family + "] Font API not available, using resize trick", null);
                // based on the idea of https://www.bramstein.com/writing/detecting-system-fonts-without-flash.html
                // simply create 3 elements with the 3 default font families and measure them
                // then change to the desired font and expect a change on the width
                var sans_1;
                var serif_1;
                var monospace_1;
                var initialSansWidth_1 = -1;
                var initialSerifWidth_1 = -1;
                var initialMonospaceWidth_1 = -1;
                var checkFont_2 = function () {
                    if (!sans_1) {
                        sans_1 = _this.createCheckerElement('sans-serif');
                        serif_1 = _this.createCheckerElement('serif');
                        monospace_1 = _this.createCheckerElement('monospace');
                        document.body.appendChild(sans_1);
                        document.body.appendChild(serif_1);
                        document.body.appendChild(monospace_1);
                        initialSansWidth_1 = sans_1.offsetWidth;
                        initialSerifWidth_1 = serif_1.offsetWidth;
                        initialMonospaceWidth_1 = monospace_1.offsetWidth;
                        sans_1.style.fontFamily = "'" + _this._family + "',sans-serif";
                        serif_1.style.fontFamily = "'" + _this._family + "',serif";
                        monospace_1.style.fontFamily = "'" + _this._family + "',monospace";
                    }
                    var sansWidth = sans_1.offsetWidth;
                    var serifWidth = serif_1.offsetWidth;
                    var monospaceWidth = monospace_1.offsetWidth;
                    if ((sansWidth !== initialSansWidth_1 && serifWidth !== initialSerifWidth_1) ||
                        (sansWidth !== initialSansWidth_1 && monospaceWidth !== initialMonospaceWidth_1) ||
                        (serifWidth !== initialSerifWidth_1 && monospaceWidth !== initialMonospaceWidth_1)) {
                        if (sansWidth === serifWidth || sansWidth === monospaceWidth || serifWidth === monospaceWidth) {
                            document.body.removeChild(sans_1);
                            document.body.removeChild(serif_1);
                            document.body.removeChild(monospace_1);
                            _this.isFontLoaded = true;
                            window.clearInterval(failCounterId);
                            _this.fontLoaded.trigger(_this._family);
                        }
                        else {
                            window.setTimeout(checkFont_2, 250);
                        }
                    }
                    else {
                        window.setTimeout(checkFont_2, 250);
                    }
                };
                var readyState = document.readyState;
                if (readyState === "complete"
                    || readyState === "loaded"
                    || readyState === "interactive") {
                    checkFont_2();
                }
                else {
                    document.addEventListener('DOMContentLoaded', function () {
                        checkFont_2();
                    });
                }
            }
        };
        FontLoadingChecker.prototype.createCheckerElement = function (family) {
            var checkerElement = document.createElement('span');
            checkerElement.style.display = 'inline-block';
            checkerElement.style.position = 'absolute';
            checkerElement.style.overflow = 'hidden';
            checkerElement.style.top = '-1000px';
            checkerElement.style.fontSize = '100px';
            checkerElement.style.fontFamily = family;
            checkerElement.innerHTML = this._fallbackText;
            document.body.appendChild(checkerElement);
            return checkerElement;
        };
        return FontLoadingChecker;
    }());

    /**
     * Represents a fixed size circular sample buffer that can be written to and read from.
     * @csharp_public
     */
    var CircularSampleBuffer = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link CircularSampleBuffer} class.
         * @param size The size.
         */
        function CircularSampleBuffer(size) {
            this._writePosition = 0;
            this._readPosition = 0;
            /**
             * Gets the number of samples written to the buffer.
             */
            this.count = 0;
            this._buffer = new Float32Array(size);
        }
        /**
         * Clears all samples written to this buffer.
         */
        CircularSampleBuffer.prototype.clear = function () {
            this._readPosition = 0;
            this._writePosition = 0;
            this.count = 0;
            this._buffer = new Float32Array(this._buffer.length);
        };
        /**
         * Writes the given samples to this buffer.
         * @param data The sample array to read from.
         * @param offset
         * @param count
         * @returns
         */
        CircularSampleBuffer.prototype.write = function (data, offset, count) {
            var samplesWritten = 0;
            if (count > this._buffer.length - this.count) {
                count = this._buffer.length - this.count;
            }
            var writeToEnd = Math.min(this._buffer.length - this._writePosition, count);
            this._buffer.set(data.subarray(offset, offset + writeToEnd), this._writePosition);
            this._writePosition += writeToEnd;
            this._writePosition %= this._buffer.length;
            samplesWritten += writeToEnd;
            if (samplesWritten < count) {
                this._buffer.set(data.subarray(offset + samplesWritten, offset + samplesWritten + count - samplesWritten), this._writePosition);
                this._writePosition += count - samplesWritten;
                samplesWritten = count;
            }
            this.count += samplesWritten;
            return samplesWritten;
        };
        /**
         * Reads the requested amount of samples from the buffer.
         * @param data The sample array to store the read elements.
         * @param offset The offset within the destination buffer to put the items at.
         * @param count The number of items to read from this buffer.
         * @returns The number of items actually read from the buffer.
         */
        CircularSampleBuffer.prototype.read = function (data, offset, count) {
            if (count > this.count) {
                count = this.count;
            }
            var samplesRead = 0;
            var readToEnd = Math.min(this._buffer.length - this._readPosition, count);
            data.set(this._buffer.subarray(this._readPosition, this._readPosition + readToEnd), offset);
            samplesRead += readToEnd;
            this._readPosition += readToEnd;
            this._readPosition %= this._buffer.length;
            if (samplesRead < count) {
                data.set(this._buffer.subarray(this._readPosition, this._readPosition + count - samplesRead), offset + samplesRead);
                this._readPosition += count - samplesRead;
                samplesRead = count;
            }
            this.count -= samplesRead;
            return samplesRead;
        };
        return CircularSampleBuffer;
    }());

    /**
     * This class implements a HTML5 Web Audio API based audio output device
     * for alphaSynth. It can be controlled via a JS API.
     * @target web
     */
    var AlphaSynthWebAudioOutput = /** @class */ (function () {
        function AlphaSynthWebAudioOutput() {
            this._context = null;
            this._buffer = null;
            this._source = null;
            this._audioNode = null;
            this._outputBuffer = new Float32Array(0);
            this.ready = new EventEmitter();
            this.samplesPlayed = new EventEmitterOfT();
            this.sampleRequest = new EventEmitter();
        }
        Object.defineProperty(AlphaSynthWebAudioOutput.prototype, "sampleRate", {
            get: function () {
                return this._context ? this._context.sampleRate : AlphaSynthWebAudioOutput.PreferredSampleRate;
            },
            enumerable: false,
            configurable: true
        });
        AlphaSynthWebAudioOutput.prototype.open = function () {
            this.patchIosSampleRate();
            this._circularBuffer = new CircularSampleBuffer(AlphaSynthWebAudioOutput.BufferSize * AlphaSynthWebAudioOutput.BufferCount);
            this._context = this.createAudioContext();
            // possible fix for Web Audio in iOS 9 (issue #4)
            var ctx = this._context;
            if (ctx.state === 'suspended') {
                var resume_1 = function () {
                    ctx.resume();
                    window.setTimeout(function () {
                        if (ctx.state === 'running') {
                            document.body.removeEventListener('touchend', resume_1, false);
                            document.body.removeEventListener('click', resume_1, false);
                        }
                    }, 0);
                };
                document.body.addEventListener('touchend', resume_1, false);
                document.body.addEventListener('click', resume_1, false);
            }
            this.ready.trigger();
        };
        AlphaSynthWebAudioOutput.prototype.activate = function () {
            if (!this._context) {
                this._context = this.createAudioContext();
            }
            // tslint:disable-next-line: no-floating-promises
            this._context.resume();
        };
        AlphaSynthWebAudioOutput.prototype.patchIosSampleRate = function () {
            var ua = navigator.userAgent;
            if (ua.indexOf('iPhone') !== -1 || ua.indexOf('iPad') !== 0) {
                var context = this.createAudioContext();
                var buffer = context.createBuffer(1, 1, AlphaSynthWebAudioOutput.PreferredSampleRate);
                var dummy = context.createBufferSource();
                dummy.buffer = buffer;
                dummy.connect(context.destination);
                dummy.start(0);
                dummy.disconnect(0);
                // tslint:disable-next-line: no-floating-promises
                context.close();
            }
        };
        AlphaSynthWebAudioOutput.prototype.createAudioContext = function () {
            if ('AudioContext' in Environment.globalThis) {
                return new AudioContext();
            }
            else if ('webkitAudioContext' in Environment.globalThis) {
                return new webkitAudioContext();
            }
            throw new AlphaTabError(exports.AlphaTabErrorType.General, "AudioContext not found");
        };
        AlphaSynthWebAudioOutput.prototype.play = function () {
            var ctx = this._context;
            if (!ctx) {
                return;
            }
            if (ctx.state === 'suspended' || ctx.state === 'interrupted') {
                // tslint:disable-next-line: no-floating-promises
                ctx.resume();
            }
            // create an empty buffer source (silence)
            this._buffer = ctx.createBuffer(2, 4096, ctx.sampleRate);
            // create a script processor node which will replace the silence with the generated audio
            this._audioNode = ctx.createScriptProcessor(4096, 0, 2);
            this._audioNode.onaudioprocess = this.generateSound.bind(this);
            this._circularBuffer.clear();
            this.requestBuffers();
            this._source = ctx.createBufferSource();
            this._source.buffer = this._buffer;
            this._source.loop = true;
            this._source.connect(this._audioNode, 0, 0);
            this._source.start(0);
            this._audioNode.connect(ctx.destination, 0, 0);
        };
        AlphaSynthWebAudioOutput.prototype.pause = function () {
            if (this._source) {
                this._source.stop(0);
                this._source.disconnect(0);
            }
            this._source = null;
            if (this._audioNode) {
                this._audioNode.disconnect(0);
            }
            this._audioNode = null;
        };
        AlphaSynthWebAudioOutput.prototype.addSamples = function (f) {
            this._circularBuffer.write(f, 0, f.length);
        };
        AlphaSynthWebAudioOutput.prototype.resetSamples = function () {
            this._circularBuffer.clear();
        };
        AlphaSynthWebAudioOutput.prototype.requestBuffers = function () {
            // if we fall under the half of buffers
            // we request one half
            var count = ((10 / 2) | 0) * 4096;
            if (this._circularBuffer.count < count && this.sampleRequest) {
                for (var i = 0; i < ((10 / 2) | 0); i++) {
                    this.sampleRequest.trigger();
                }
            }
        };
        AlphaSynthWebAudioOutput.prototype.generateSound = function (e) {
            var left = e.outputBuffer.getChannelData(0);
            var right = e.outputBuffer.getChannelData(1);
            var samples = left.length + right.length;
            var buffer = this._outputBuffer;
            if (buffer.length != samples) {
                buffer = new Float32Array(samples);
                this._outputBuffer = buffer;
            }
            this._circularBuffer.read(buffer, 0, Math.min(buffer.length, this._circularBuffer.count));
            var s = 0;
            for (var i = 0; i < left.length; i++) {
                left[i] = buffer[s++];
                right[i] = buffer[s++];
            }
            this.samplesPlayed.trigger(left.length);
            this.requestBuffers();
        };
        AlphaSynthWebAudioOutput.BufferSize = 4096;
        AlphaSynthWebAudioOutput.BufferCount = 10;
        AlphaSynthWebAudioOutput.PreferredSampleRate = 44100;
        return AlphaSynthWebAudioOutput;
    }());

    /**
     * a WebWorker based alphaSynth which uses the given player as output.
     * @target web
     */
    var AlphaSynthWebWorkerApi = /** @class */ (function () {
        function AlphaSynthWebWorkerApi(player, alphaSynthScriptFile, logLevel) {
            this._workerIsReadyForPlayback = false;
            this._workerIsReady = false;
            this._outputIsReady = false;
            this._state = PlayerState.Paused;
            this._masterVolume = 0;
            this._metronomeVolume = 0;
            this._countInVolume = 0;
            this._playbackSpeed = 0;
            this._tickPosition = 0;
            this._timePosition = 0;
            this._isLooping = false;
            this._playbackRange = null;
            this.ready = new EventEmitter();
            this.readyForPlayback = new EventEmitter();
            this.finished = new EventEmitter();
            this.soundFontLoaded = new EventEmitter();
            this.soundFontLoadFailed = new EventEmitterOfT();
            this.midiLoaded = new EventEmitter();
            this.midiLoadFailed = new EventEmitterOfT();
            this.stateChanged = new EventEmitterOfT();
            this.positionChanged = new EventEmitterOfT();
            this._workerIsReadyForPlayback = false;
            this._workerIsReady = false;
            this._outputIsReady = false;
            this._state = PlayerState.Paused;
            this._masterVolume = 0.0;
            this._metronomeVolume = 0.0;
            this._playbackSpeed = 0.0;
            this._tickPosition = 0;
            this._timePosition = 0.0;
            this._isLooping = false;
            this._playbackRange = null;
            this._output = player;
            this._output.ready.on(this.onOutputReady.bind(this));
            this._output.samplesPlayed.on(this.onOutputSamplesPlayed.bind(this));
            this._output.sampleRequest.on(this.onOutputSampleRequest.bind(this));
            this._output.open();
            try {
                var script = "importScripts('" + alphaSynthScriptFile + "')";
                var blob = new Blob([script]);
                this._synth = new Worker(URL.createObjectURL(blob));
            }
            catch (e) {
                // fallback to direct worker
                try {
                    this._synth = new Worker(alphaSynthScriptFile);
                }
                catch (e2) {
                    Logger.error('AlphaSynth', 'Failed to create WebWorker: ' + e2);
                    return;
                }
            }
            this._synth.addEventListener('message', this.handleWorkerMessage.bind(this), false);
            this._synth.postMessage({
                cmd: 'alphaSynth.initialize',
                sampleRate: this._output.sampleRate,
                logLevel: logLevel
            });
            this.masterVolume = 1;
            this.playbackSpeed = 1;
            this.metronomeVolume = 0;
        }
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "isReady", {
            get: function () {
                return this._workerIsReady && this._outputIsReady;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "isReadyForPlayback", {
            get: function () {
                return this._workerIsReadyForPlayback;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "state", {
            get: function () {
                return this._state;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "logLevel", {
            get: function () {
                return Logger.logLevel;
            },
            set: function (value) {
                Logger.logLevel = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setLogLevel',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "masterVolume", {
            get: function () {
                return this._masterVolume;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinVolume, SynthConstants.MaxVolume);
                this._masterVolume = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setMasterVolume',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "metronomeVolume", {
            get: function () {
                return this._metronomeVolume;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinVolume, SynthConstants.MaxVolume);
                this._metronomeVolume = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setMetronomeVolume',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "countInVolume", {
            get: function () {
                return this._countInVolume;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinVolume, SynthConstants.MaxVolume);
                this._countInVolume = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setCountInVolume',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "playbackSpeed", {
            get: function () {
                return this._playbackSpeed;
            },
            set: function (value) {
                value = SynthHelper.clamp(value, SynthConstants.MinPlaybackSpeed, SynthConstants.MaxPlaybackSpeed);
                this._playbackSpeed = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setPlaybackSpeed',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "tickPosition", {
            get: function () {
                return this._tickPosition;
            },
            set: function (value) {
                if (value < 0) {
                    value = 0;
                }
                this._tickPosition = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setTickPosition',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "timePosition", {
            get: function () {
                return this._timePosition;
            },
            set: function (value) {
                if (value < 0) {
                    value = 0;
                }
                this._timePosition = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setTimePosition',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "isLooping", {
            get: function () {
                return this._isLooping;
            },
            set: function (value) {
                this._isLooping = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setIsLooping',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlphaSynthWebWorkerApi.prototype, "playbackRange", {
            get: function () {
                return this._playbackRange;
            },
            set: function (value) {
                if (value) {
                    if (value.startTick < 0) {
                        value.startTick = 0;
                    }
                    if (value.endTick < 0) {
                        value.endTick = 0;
                    }
                }
                this._playbackRange = value;
                this._synth.postMessage({
                    cmd: 'alphaSynth.setPlaybackRange',
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        AlphaSynthWebWorkerApi.prototype.destroy = function () {
            this._synth.terminate();
        };
        //
        // API communicating with the web worker
        AlphaSynthWebWorkerApi.prototype.play = function () {
            this._output.activate();
            this._synth.postMessage({
                cmd: 'alphaSynth.play'
            });
            return true;
        };
        AlphaSynthWebWorkerApi.prototype.pause = function () {
            this._synth.postMessage({
                cmd: 'alphaSynth.pause'
            });
        };
        AlphaSynthWebWorkerApi.prototype.playPause = function () {
            this._output.activate();
            this._synth.postMessage({
                cmd: 'alphaSynth.playPause'
            });
        };
        AlphaSynthWebWorkerApi.prototype.stop = function () {
            this._synth.postMessage({
                cmd: 'alphaSynth.stop'
            });
        };
        AlphaSynthWebWorkerApi.prototype.playOneTimeMidiFile = function (midi) {
            this._synth.postMessage({
                cmd: 'alphaSynth.playOneTimeMidiFile',
                midi: JsonConverter.midiFileToJsObject(midi)
            });
        };
        AlphaSynthWebWorkerApi.prototype.loadSoundFont = function (data, append) {
            this._synth.postMessage({
                cmd: 'alphaSynth.loadSoundFontBytes',
                data: data,
                append: append
            });
        };
        AlphaSynthWebWorkerApi.prototype.loadSoundFontFromUrl = function (url, append, progress) {
            var _this = this;
            Logger.debug('AlphaSynth', "Start loading Soundfont from url " + url);
            var request = new XMLHttpRequest();
            request.open('GET', url, true, null, null);
            request.responseType = 'arraybuffer';
            request.onload = function (_) {
                var buffer = new Uint8Array(request.response);
                _this.loadSoundFont(buffer, append);
            };
            request.onerror = function (e) {
                Logger.error('AlphaSynth', 'Loading failed: ' + e.message);
                _this.soundFontLoadFailed.trigger(new FileLoadError(e.message, request));
            };
            request.onprogress = function (e) {
                Logger.debug('AlphaSynth', "Soundfont downloading: " + e.loaded + "/" + e.total + " bytes");
                progress(new ProgressEventArgs(e.loaded, e.total));
            };
            request.send();
        };
        AlphaSynthWebWorkerApi.prototype.resetSoundFonts = function () {
            this._synth.postMessage({
                cmd: 'alphaSynth.resetSoundFonts'
            });
        };
        AlphaSynthWebWorkerApi.prototype.loadMidiFile = function (midi) {
            this._synth.postMessage({
                cmd: 'alphaSynth.loadMidi',
                midi: JsonConverter.midiFileToJsObject(midi)
            });
        };
        AlphaSynthWebWorkerApi.prototype.setChannelMute = function (channel, mute) {
            this._synth.postMessage({
                cmd: 'alphaSynth.setChannelMute',
                channel: channel,
                mute: mute
            });
        };
        AlphaSynthWebWorkerApi.prototype.resetChannelStates = function () {
            this._synth.postMessage({
                cmd: 'alphaSynth.resetChannelStates'
            });
        };
        AlphaSynthWebWorkerApi.prototype.setChannelSolo = function (channel, solo) {
            this._synth.postMessage({
                cmd: 'alphaSynth.setChannelSolo',
                channel: channel,
                solo: solo
            });
        };
        AlphaSynthWebWorkerApi.prototype.setChannelVolume = function (channel, volume) {
            volume = SynthHelper.clamp(volume, SynthConstants.MinVolume, SynthConstants.MaxVolume);
            this._synth.postMessage({
                cmd: 'alphaSynth.setChannelVolume',
                channel: channel,
                volume: volume
            });
        };
        AlphaSynthWebWorkerApi.prototype.handleWorkerMessage = function (e) {
            var data = e.data;
            var cmd = data.cmd;
            switch (cmd) {
                case 'alphaSynth.ready':
                    this._workerIsReady = true;
                    this.checkReady();
                    break;
                case 'alphaSynth.readyForPlayback':
                    this._workerIsReadyForPlayback = true;
                    this.checkReadyForPlayback();
                    break;
                case 'alphaSynth.positionChanged':
                    this._timePosition = data.currentTime;
                    this._tickPosition = data.currentTick;
                    this.positionChanged.trigger(new PositionChangedEventArgs(data.currentTime, data.endTime, data.currentTick, data.endTick));
                    break;
                case 'alphaSynth.playerStateChanged':
                    this._state = data.state;
                    this.stateChanged.trigger(new PlayerStateChangedEventArgs(data.state, data.stopped));
                    break;
                case 'alphaSynth.finished':
                    this.finished.trigger();
                    break;
                case 'alphaSynth.soundFontLoaded':
                    this.soundFontLoaded.trigger();
                    break;
                case 'alphaSynth.soundFontLoadFailed':
                    this.soundFontLoadFailed.trigger(data.error);
                    break;
                case 'alphaSynth.midiLoaded':
                    this.checkReadyForPlayback();
                    this.midiLoaded.trigger();
                    break;
                case 'alphaSynth.midiLoadFailed':
                    this.checkReadyForPlayback();
                    this.midiLoadFailed.trigger(data.error);
                    break;
                case 'alphaSynth.output.addSamples':
                    this._output.addSamples(data.samples);
                    break;
                case 'alphaSynth.output.play':
                    this._output.play();
                    break;
                case 'alphaSynth.output.pause':
                    this._output.pause();
                    break;
                case 'alphaSynth.output.resetSamples':
                    this._output.resetSamples();
                    break;
            }
        };
        AlphaSynthWebWorkerApi.prototype.checkReady = function () {
            if (this.isReady) {
                this.ready.trigger();
            }
        };
        AlphaSynthWebWorkerApi.prototype.checkReadyForPlayback = function () {
            if (this.isReadyForPlayback) {
                this.readyForPlayback.trigger();
            }
        };
        //
        // output communication ( output -> worker )
        AlphaSynthWebWorkerApi.prototype.onOutputSampleRequest = function () {
            this._synth.postMessage({
                cmd: 'alphaSynth.output.sampleRequest'
            });
        };
        AlphaSynthWebWorkerApi.prototype.onOutputSamplesPlayed = function (samples) {
            this._synth.postMessage({
                cmd: 'alphaSynth.output.samplesPlayed',
                samples: samples
            });
        };
        AlphaSynthWebWorkerApi.prototype.onOutputReady = function () {
            this._outputIsReady = true;
            this.checkReady();
        };
        return AlphaSynthWebWorkerApi;
    }());

    /**
     * @target web
     */
    var AlphaTabWorkerScoreRenderer = /** @class */ (function () {
        function AlphaTabWorkerScoreRenderer(api, settings) {
            this._width = 0;
            this.boundsLookup = null;
            this.preRender = new EventEmitterOfT();
            this.partialRenderFinished = new EventEmitterOfT();
            this.renderFinished = new EventEmitterOfT();
            this.postRenderFinished = new EventEmitter();
            this.error = new EventEmitterOfT();
            this._api = api;
            if (!settings.core.scriptFile) {
                Logger.error('Rendering', "Could not detect alphaTab script file, cannot initialize renderer");
                return;
            }
            // first try blob worker
            try {
                var script = "importScripts('" + settings.core.scriptFile + "')";
                var blob = new Blob([script]);
                this._worker = new Worker(URL.createObjectURL(blob));
            }
            catch (e) {
                try {
                    this._worker = new Worker(settings.core.scriptFile);
                }
                catch (e2) {
                    Logger.error('Rendering', "Failed to create WebWorker: " + e);
                    return;
                }
            }
            this._worker.postMessage({
                cmd: 'alphaTab.initialize',
                settings: this.serializeSettingsForWorker(settings)
            });
            this._worker.addEventListener('message', this.handleWorkerMessage.bind(this));
        }
        AlphaTabWorkerScoreRenderer.prototype.destroy = function () {
            this._worker.terminate();
        };
        AlphaTabWorkerScoreRenderer.prototype.updateSettings = function (settings) {
            this._worker.postMessage({
                cmd: 'alphaTab.updateSettings',
                settings: this.serializeSettingsForWorker(settings)
            });
        };
        AlphaTabWorkerScoreRenderer.prototype.serializeSettingsForWorker = function (settings) {
            var json = Settings.toJson(settings);
            // cut out player settings, they are only needed on UI thread side
            json.player = null;
            return json;
        };
        AlphaTabWorkerScoreRenderer.prototype.render = function () {
            this._worker.postMessage({
                cmd: 'alphaTab.render'
            });
        };
        AlphaTabWorkerScoreRenderer.prototype.resizeRender = function () {
            this._worker.postMessage({
                cmd: 'alphaTab.resizeRender'
            });
        };
        Object.defineProperty(AlphaTabWorkerScoreRenderer.prototype, "width", {
            get: function () {
                return this._width;
            },
            set: function (value) {
                this._width = value;
                this._worker.postMessage({
                    cmd: 'alphaTab.setWidth',
                    width: value
                });
            },
            enumerable: false,
            configurable: true
        });
        AlphaTabWorkerScoreRenderer.prototype.handleWorkerMessage = function (e) {
            var data = e.data;
            var cmd = data.cmd;
            switch (cmd) {
                case 'alphaTab.preRender':
                    this.preRender.trigger(data.resize);
                    break;
                case 'alphaTab.partialRenderFinished':
                    this.partialRenderFinished.trigger(data.result);
                    break;
                case 'alphaTab.renderFinished':
                    this.renderFinished.trigger(data.result);
                    break;
                case 'alphaTab.postRenderFinished':
                    this.boundsLookup = BoundsLookup.fromJson(data.boundsLookup, this._api.score);
                    this.postRenderFinished.trigger();
                    break;
                case 'alphaTab.error':
                    this.error.trigger(data.error);
                    break;
            }
        };
        AlphaTabWorkerScoreRenderer.prototype.renderScore = function (score, trackIndexes) {
            var jsObject = JsonConverter.scoreToJsObject(score);
            this._worker.postMessage({
                cmd: 'alphaTab.renderScore',
                score: jsObject,
                trackIndexes: trackIndexes,
                fontSizes: FontSizes.FontSizeLookupTables
            });
        };
        return AlphaTabWorkerScoreRenderer;
    }());

    /**
     * This wrapper holds all cursor related elements.
     */
    var Cursors = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link Cursors} class.
         * @param cursorWrapper
         * @param barCursor
         * @param beatCursor
         * @param selectionWrapper
         */
        function Cursors(cursorWrapper, barCursor, beatCursor, selectionWrapper) {
            this.cursorWrapper = cursorWrapper;
            this.barCursor = barCursor;
            this.beatCursor = beatCursor;
            this.selectionWrapper = selectionWrapper;
        }
        return Cursors;
    }());

    /**
     * @target web
     */
    var BrowserUiFacade = /** @class */ (function () {
        function BrowserUiFacade(rootElement) {
            var _this = this;
            this._fontCheckers = new Map();
            this._contents = null;
            this._file = null;
            this._visibilityCheckIntervalId = 0;
            this._visibilityCheckInterval = 0;
            this._totalResultCount = 0;
            this._initialTrackIndexes = null;
            this._rootContainerBecameVisible = new EventEmitter();
            this.canRenderChanged = new EventEmitter();
            rootElement.classList.add('alphaTab');
            this.rootContainer = new HtmlElementContainer(rootElement);
            this.areWorkersSupported = 'Worker' in window;
            Environment.bravuraFontChecker.fontLoaded.on(this.onFontLoaded.bind(this));
            this.rootContainerBecameVisible = {
                on: function (value) {
                    if (_this.rootContainer.isVisible) {
                        value();
                    }
                    else {
                        _this._rootContainerBecameVisible.on(value);
                        if (_this._visibilityCheckIntervalId === 0) {
                            _this._visibilityCheckIntervalId = window.setInterval(function () {
                                if (_this._api.container.isVisible) {
                                    window.clearInterval(_this._visibilityCheckIntervalId);
                                    _this._visibilityCheckIntervalId = 0;
                                    _this._rootContainerBecameVisible.trigger();
                                }
                            }, _this._visibilityCheckInterval);
                        }
                    }
                },
                off: function (value) {
                    _this._rootContainerBecameVisible.off(value);
                }
            };
        }
        Object.defineProperty(BrowserUiFacade.prototype, "resizeThrottle", {
            get: function () {
                return 10;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BrowserUiFacade.prototype, "canRender", {
            get: function () {
                return this.areAllFontsLoaded();
            },
            enumerable: false,
            configurable: true
        });
        BrowserUiFacade.prototype.areAllFontsLoaded = function () {
            Environment.bravuraFontChecker.checkForFontAvailability();
            if (!Environment.bravuraFontChecker.isFontLoaded) {
                return false;
            }
            var isAnyNotLoaded = false;
            this._fontCheckers.forEach(function (checker) {
                if (!checker.isFontLoaded) {
                    isAnyNotLoaded = true;
                }
            });
            if (isAnyNotLoaded) {
                return false;
            }
            Logger.debug('Font', 'All fonts loaded: ' + this._fontCheckers.size);
            return true;
        };
        BrowserUiFacade.prototype.onFontLoaded = function (family) {
            FontSizes.generateFontLookup(family);
            if (this.areAllFontsLoaded()) {
                this.canRenderChanged.trigger();
            }
        };
        BrowserUiFacade.prototype.createWorkerRenderer = function () {
            return new AlphaTabWorkerScoreRenderer(this._api, this._api.settings);
        };
        BrowserUiFacade.prototype.initialize = function (api, raw) {
            this._api = api;
            var settings;
            if (raw instanceof Settings) {
                settings = raw;
            }
            else {
                settings = new Settings();
                settings.fillFromJson(raw);
            }
            var dataAttributes = this.getDataAttributes();
            settings.fillFromDataAttributes(dataAttributes);
            if (settings.notation.notationMode === exports.NotationMode.SongBook) {
                settings.setSongBookModeSettings();
            }
            api.settings = settings;
            if (settings.core.engine === 'default' || settings.core.engine === 'svg') {
                api.container.scroll.on(this.showSvgsInViewPort.bind(this));
                api.container.resize.on(this.showSvgsInViewPort.bind(this));
            }
            this.setupFontCheckers(settings);
            this._initialTrackIndexes = this.parseTracks(settings.core.tracks);
            this._contents = '';
            var element = api.container;
            if (settings.core.tex) {
                this._contents = element.element.innerHTML;
                element.element.innerHTML = '';
            }
            this.createStyleElement(settings);
            this._file = settings.core.file;
            this._visibilityCheckInterval = settings.core.visibilityCheckInterval;
        };
        BrowserUiFacade.prototype.setupFontCheckers = function (settings) {
            this.registerFontChecker(settings.display.resources.copyrightFont);
            this.registerFontChecker(settings.display.resources.effectFont);
            this.registerFontChecker(settings.display.resources.fingeringFont);
            this.registerFontChecker(settings.display.resources.graceFont);
            this.registerFontChecker(settings.display.resources.markerFont);
            this.registerFontChecker(settings.display.resources.tablatureFont);
            this.registerFontChecker(settings.display.resources.titleFont);
            this.registerFontChecker(settings.display.resources.wordsFont);
            this.registerFontChecker(settings.display.resources.barNumberFont);
            this.registerFontChecker(settings.display.resources.fretboardNumberFont);
            this.registerFontChecker(settings.display.resources.subTitleFont);
        };
        BrowserUiFacade.prototype.registerFontChecker = function (font) {
            if (!this._fontCheckers.has(font.family)) {
                var checker = new FontLoadingChecker(font.family);
                this._fontCheckers.set(font.family, checker);
                checker.fontLoaded.on(this.onFontLoaded.bind(this));
                checker.checkForFontAvailability();
            }
        };
        BrowserUiFacade.prototype.destroy = function () {
            this.rootContainer.element.innerHTML = '';
        };
        BrowserUiFacade.prototype.createCanvasElement = function () {
            var canvasElement = document.createElement('div');
            canvasElement.className = 'at-surface';
            canvasElement.style.fontSize = '0';
            canvasElement.style.overflow = 'hidden';
            canvasElement.style.lineHeight = '0';
            return new HtmlElementContainer(canvasElement);
        };
        BrowserUiFacade.prototype.triggerEvent = function (container, name, details, originalEvent) {
            if (details === void 0) { details = null; }
            var element = container.element;
            name = 'alphaTab.' + name;
            var e = document.createEvent('CustomEvent');
            var originalMouseEvent = originalEvent
                ? originalEvent.mouseEvent
                : null;
            e.initCustomEvent(name, false, false, details);
            if (originalMouseEvent) {
                e.originalEvent = originalMouseEvent;
            }
            element.dispatchEvent(e);
            if (window && 'jQuery' in window) {
                var jquery = window['jQuery'];
                var args = [];
                args.push(details);
                if (originalMouseEvent) {
                    args.push(originalMouseEvent);
                }
                jquery(element).trigger(name, args);
            }
        };
        BrowserUiFacade.prototype.load = function (data, success, error) {
            if (data instanceof Score) {
                success(data);
                return true;
            }
            if (data instanceof ArrayBuffer) {
                var byteArray = new Uint8Array(data);
                success(ScoreLoader.loadScoreFromBytes(byteArray, this._api.settings));
                return true;
            }
            if (data instanceof Uint8Array) {
                success(ScoreLoader.loadScoreFromBytes(data, this._api.settings));
                return true;
            }
            if (typeof data === 'string') {
                ScoreLoader.loadScoreAsync(data, success, error, this._api.settings);
                return true;
            }
            return false;
        };
        BrowserUiFacade.prototype.loadSoundFont = function (data, append) {
            if (!this._api.player) {
                return false;
            }
            if (data instanceof ArrayBuffer) {
                this._api.player.loadSoundFont(new Uint8Array(data), append);
                return true;
            }
            if (data instanceof Uint8Array) {
                this._api.player.loadSoundFont(data, append);
                return true;
            }
            if (typeof data === 'string') {
                this._api.loadSoundFontFromUrl(data, append);
                return true;
            }
            return false;
        };
        BrowserUiFacade.prototype.initialRender = function () {
            var _this = this;
            this._api.renderer.preRender.on(function (_) {
                _this._totalResultCount = 0;
            });
            this.rootContainerBecameVisible.on(function () {
                var _a;
                // rendering was possibly delayed due to invisible element
                // in this case we need the correct width for autosize
                _this._api.renderer.width = _this.rootContainer.width | 0;
                _this._api.renderer.updateSettings(_this._api.settings);
                if (_this._contents) {
                    _this._api.tex(_this._contents, (_a = _this._initialTrackIndexes) !== null && _a !== void 0 ? _a : undefined);
                    _this._initialTrackIndexes = null;
                }
                else if (_this._file) {
                    ScoreLoader.loadScoreAsync(_this._file, function (s) {
                        var _a;
                        _this._api.renderScore(s, (_a = _this._initialTrackIndexes) !== null && _a !== void 0 ? _a : undefined);
                        _this._initialTrackIndexes = null;
                    }, function (e) {
                        _this._api.onError(e);
                    }, _this._api.settings);
                }
            });
        };
        BrowserUiFacade.prototype.showSvgsInViewPort = function () {
            var placeholders = this._api.canvasElement.element.querySelectorAll('[data-lazy=true]');
            for (var i = 0; i < placeholders.length; i++) {
                var placeholder = placeholders.item(i);
                if (this.isElementInViewPort(placeholder)) {
                    this.replacePlaceholder(placeholder, placeholder['svg']);
                }
            }
        };
        BrowserUiFacade.prototype.isElementInViewPort = function (element) {
            var rect = element.getBoundingClientRect();
            return (rect.top + rect.height >= 0 &&
                rect.top <= window.innerHeight &&
                rect.left + rect.width >= 0 &&
                rect.left <= window.innerWidth);
        };
        BrowserUiFacade.prototype.createStyleElement = function (settings) {
            var elementDocument = this._api.container.element.ownerDocument;
            Environment.createStyleElement(elementDocument, settings.core.fontDirectory);
        };
        BrowserUiFacade.prototype.parseTracks = function (tracksData) {
            if (!tracksData) {
                return [];
            }
            var tracks = [];
            // decode string
            if (typeof tracksData === 'string') {
                try {
                    if (tracksData === 'all') {
                        return [-1];
                    }
                    tracksData = JSON.parse(tracksData);
                }
                catch (e) {
                    tracksData = [0];
                }
            }
            // decode array
            if (typeof tracksData === 'number') {
                tracks.push(tracksData);
            }
            else if ('length' in tracksData) {
                var length_1 = tracksData.length;
                var array = tracksData;
                for (var i = 0; i < length_1; i++) {
                    var item = array[i];
                    var value = 0;
                    if (typeof item === 'number') {
                        value = item;
                    }
                    else if ('index' in item) {
                        value = item.index;
                    }
                    else {
                        value = parseInt(item.toString());
                    }
                    if (value >= 0 || value === -1) {
                        tracks.push(value);
                    }
                }
            }
            else if ('index' in tracksData) {
                tracks.push(tracksData.index);
            }
            return tracks;
        };
        BrowserUiFacade.prototype.getDataAttributes = function () {
            var dataAttributes = new Map();
            var element = this._api.container.element;
            if (element.dataset) {
                for (var _i = 0, _a = Object.keys(element.dataset); _i < _a.length; _i++) {
                    var key = _a[_i];
                    var value = element.dataset[key];
                    try {
                        var stringValue = value;
                        value = JSON.parse(stringValue);
                    }
                    catch (e) {
                        if (value === '') {
                            value = null;
                        }
                    }
                    dataAttributes.set(key, value);
                }
            }
            else {
                for (var i = 0; i < element.attributes.length; i++) {
                    var attr = element.attributes.item(i);
                    var nodeName = attr.nodeName;
                    if (nodeName.startsWith('data-')) {
                        var keyParts = nodeName.substr(5).split('-');
                        var key = keyParts[0];
                        for (var j = 1; j < keyParts.length; j++) {
                            key += keyParts[j].substr(0, 1).toUpperCase() + keyParts[j].substr(1);
                        }
                        var value = attr.nodeValue;
                        try {
                            value = JSON.parse(value);
                        }
                        catch (e) {
                            if (value === '') {
                                value = null;
                            }
                        }
                        dataAttributes.set(key, value);
                    }
                }
            }
            return dataAttributes;
        };
        BrowserUiFacade.prototype.beginAppendRenderResults = function (renderResult) {
            var canvasElement = this._api.canvasElement.element;
            // null result indicates that the rendering finished
            if (!renderResult) {
                // so we remove elements that might be from a previous render session
                while (canvasElement.childElementCount > this._totalResultCount) {
                    canvasElement.removeChild(canvasElement.lastChild);
                }
                // directly show the elements in the viewport once we're done.
                if (this._api.settings.core.enableLazyLoading) {
                    this.showSvgsInViewPort();
                }
            }
            else {
                var body = renderResult.renderResult;
                if (typeof body === 'string') {
                    var placeholder = void 0;
                    if (this._totalResultCount < canvasElement.childElementCount) {
                        placeholder = canvasElement.childNodes.item(this._totalResultCount);
                    }
                    else {
                        placeholder = document.createElement('div');
                        canvasElement.appendChild(placeholder);
                    }
                    placeholder.style.width = renderResult.width + 'px';
                    placeholder.style.height = renderResult.height + 'px';
                    placeholder.style.display = 'inline-block';
                    if (!this._api.settings.core.enableLazyLoading || this.isElementInViewPort(placeholder)) {
                        this.replacePlaceholder(placeholder, body);
                    }
                    else {
                        placeholder['svg'] = body;
                        placeholder.setAttribute('data-lazy', 'true');
                    }
                }
                else {
                    if (this._totalResultCount < canvasElement.childElementCount) {
                        canvasElement.replaceChild(renderResult.renderResult, canvasElement.childNodes.item(this._totalResultCount));
                    }
                    else {
                        canvasElement.appendChild(renderResult.renderResult);
                    }
                }
                this._totalResultCount++;
            }
        };
        BrowserUiFacade.prototype.replacePlaceholder = function (placeholder, body) {
            var _a;
            if (typeof placeholder.outerHTML === 'string') {
                placeholder.outerHTML = body;
            }
            else {
                var display = document.createElement('div');
                display.innerHTML = body;
                (_a = placeholder.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(display.firstChild, placeholder);
            }
        };
        /**
         * This method creates the player. It detects browser compatibility and
         * initializes a alphaSynth version for the client.
         */
        BrowserUiFacade.prototype.createWorkerPlayer = function () {
            var _this = this;
            var supportsWebAudio = 'ScriptProcessorNode' in window;
            var alphaSynthScriptFile = Environment.scriptFile;
            if (!alphaSynthScriptFile) {
                Logger.error('Player', 'alphaTab script file could not be detected, player cannot initialize');
                return null;
            }
            var player = null;
            if (supportsWebAudio) {
                Logger.debug('Player', 'Will use webworkers for synthesizing and web audio api for playback');
                player = new AlphaSynthWebWorkerApi(new AlphaSynthWebAudioOutput(), alphaSynthScriptFile, this._api.settings.core.logLevel);
            }
            if (!player) {
                Logger.error('Player', 'Player requires webworkers and web audio api, browser unsupported', null);
            }
            else {
                player.ready.on(function () {
                    if (_this._api.settings.player.soundFont) {
                        _this._api.loadSoundFontFromUrl(_this._api.settings.player.soundFont, false);
                    }
                });
            }
            return player;
        };
        BrowserUiFacade.prototype.beginInvoke = function (action) {
            window.requestAnimationFrame(function () {
                action();
            });
        };
        BrowserUiFacade.prototype.highlightElements = function (groupId) {
            var element = this._api.container.element;
            var elementsToHighlight = element.getElementsByClassName(groupId);
            for (var i = 0; i < elementsToHighlight.length; i++) {
                elementsToHighlight.item(i).classList.add('at-highlight');
            }
        };
        BrowserUiFacade.prototype.removeHighlights = function () {
            var element = this._api.container.element;
            var elements = element.getElementsByClassName('at-highlight');
            while (elements.length > 0) {
                elements.item(0).classList.remove('at-highlight');
            }
        };
        BrowserUiFacade.prototype.destroyCursors = function () {
            var element = this._api.container.element;
            var cursorWrapper = element.querySelector('.at-cursors');
            element.removeChild(cursorWrapper);
        };
        BrowserUiFacade.prototype.createCursors = function () {
            var element = this._api.container.element;
            var cursorWrapper = document.createElement('div');
            cursorWrapper.classList.add('at-cursors');
            var selectionWrapper = document.createElement('div');
            selectionWrapper.classList.add('at-selection');
            var barCursor = document.createElement('div');
            barCursor.classList.add('at-cursor-bar');
            var beatCursor = document.createElement('div');
            beatCursor.classList.add('at-cursor-beat');
            // required css styles
            element.style.position = 'relative';
            element.style.textAlign = 'left';
            cursorWrapper.style.position = 'absolute';
            cursorWrapper.style.zIndex = '1000';
            cursorWrapper.style.display = 'inline';
            cursorWrapper.style.pointerEvents = 'none';
            selectionWrapper.style.position = 'absolute';
            barCursor.style.position = 'absolute';
            beatCursor.style.position = 'absolute';
            beatCursor.style.transition = 'all 0s linear';
            // add cursors to UI
            element.insertBefore(cursorWrapper, element.firstChild);
            cursorWrapper.appendChild(selectionWrapper);
            cursorWrapper.appendChild(barCursor);
            cursorWrapper.appendChild(beatCursor);
            return new Cursors(new HtmlElementContainer(cursorWrapper), new HtmlElementContainer(barCursor), new HtmlElementContainer(beatCursor), new HtmlElementContainer(selectionWrapper));
        };
        BrowserUiFacade.prototype.getOffset = function (scrollContainer, container) {
            var element = container.element;
            var bounds = element.getBoundingClientRect();
            var top = bounds.top + element.ownerDocument.defaultView.pageYOffset;
            var left = bounds.left + element.ownerDocument.defaultView.pageXOffset;
            if (scrollContainer) {
                var scrollElement = scrollContainer.element;
                var nodeName = scrollElement.nodeName.toLowerCase();
                if (nodeName !== 'html' && nodeName !== 'body') {
                    var scrollElementOffset = this.getOffset(null, scrollContainer);
                    top = top + scrollElement.scrollTop - scrollElementOffset.y;
                    left = left + scrollElement.scrollLeft - scrollElementOffset.x;
                }
            }
            var b = new Bounds();
            b.x = left;
            b.y = top;
            b.w = bounds.width;
            b.h = bounds.height;
            return b;
        };
        BrowserUiFacade.prototype.getScrollContainer = function () {
            var scrollElement = 
            // tslint:disable-next-line: strict-type-predicates
            typeof this._api.settings.player.scrollElement === 'string'
                ? document.querySelector(this._api.settings.player.scrollElement)
                : this._api.settings.player.scrollElement;
            var nodeName = scrollElement.nodeName.toLowerCase();
            if (nodeName === 'html' || nodeName === 'body') {
                // https://github.com/CoderLine/alphaTab/issues/205
                // https://github.com/CoderLine/alphaTab/issues/354
                // https://dev.opera.com/articles/fixing-the-scrolltop-bug/
                if ('scrollingElement' in document) {
                    scrollElement = document.scrollingElement;
                }
                else {
                    var userAgent = navigator.userAgent;
                    if (userAgent.indexOf('WebKit') !== -1) {
                        scrollElement = document.body;
                    }
                    else {
                        scrollElement = document.documentElement;
                    }
                }
            }
            return new HtmlElementContainer(scrollElement);
        };
        BrowserUiFacade.prototype.createSelectionElement = function () {
            var element = document.createElement('div');
            element.style.position = 'absolute';
            return new HtmlElementContainer(element);
        };
        BrowserUiFacade.prototype.scrollToY = function (element, scrollTargetY, speed) {
            this.internalScrollToY(element.element, scrollTargetY, speed);
        };
        BrowserUiFacade.prototype.scrollToX = function (element, scrollTargetY, speed) {
            this.internalScrollToX(element.element, scrollTargetY, speed);
        };
        BrowserUiFacade.prototype.internalScrollToY = function (element, scrollTargetY, speed) {
            var startY = element.scrollTop;
            var diff = scrollTargetY - startY;
            var start = 0;
            var step = function (x) {
                if (start === 0) {
                    start = x;
                }
                var time = x - start;
                var percent = Math.min(time / speed, 1);
                element.scrollTop = (startY + diff * percent) | 0;
                if (time < speed) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        };
        BrowserUiFacade.prototype.internalScrollToX = function (element, scrollTargetX, speed) {
            var startX = element.scrollLeft;
            var diff = scrollTargetX - startX;
            var start = 0;
            var step = function (t) {
                if (start === 0) {
                    start = t;
                }
                var time = t - start;
                var percent = Math.min(time / speed, 1);
                element.scrollLeft = (startX + diff * percent) | 0;
                if (time < speed) {
                    window.requestAnimationFrame(step);
                }
            };
            window.requestAnimationFrame(step);
        };
        return BrowserUiFacade;
    }());

    var __extends$o = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * @target web
     */
    var AlphaTabApi = /** @class */ (function (_super) {
        __extends$o(AlphaTabApi, _super);
        function AlphaTabApi(element, options) {
            var _this = _super.call(this, new BrowserUiFacade(element), options) || this;
            _this.soundFontLoad = new EventEmitterOfT();
            return _this;
        }
        AlphaTabApi.prototype.tex = function (tex, tracks) {
            var browser = this.uiFacade;
            _super.prototype.tex.call(this, tex, browser.parseTracks(tracks));
        };
        AlphaTabApi.prototype.print = function (width) {
            // prepare a popup window for printing (a4 width, window height, centered)
            var preview = window.open('', '', 'width=0,height=0');
            var a4 = preview.document.createElement('div');
            if (width) {
                a4.style.width = width;
            }
            else {
                if (this.settings.display.layoutMode === exports.LayoutMode.Horizontal) {
                    a4.style.width = '297mm';
                }
                else {
                    a4.style.width = '210mm';
                }
            }
            preview.document.write('<!DOCTYPE html><html></head><body></body></html>');
            preview.document.body.appendChild(a4);
            var dualScreenLeft = typeof window['screenLeft'] !== 'undefined'
                ? window['screenLeft']
                : window['left'];
            var dualScreenTop = typeof window['screenTop'] !== 'undefined' ? window['screenTop'] : window['top'];
            var screenWidth = "innerWidth" in window
                ? window.innerWidth
                : "clientWidth" in document.documentElement
                    ? document.documentElement.clientWidth
                    : window.screen.width;
            var screenHeight = "innerHeight" in window
                ? window.innerHeight
                : "clientHeight" in document.documentElement
                    ? document.documentElement.clientHeight
                    : window.screen.height;
            var w = a4.offsetWidth + 50;
            var h = window.innerHeight;
            var left = ((screenWidth / 2) | 0) - ((w / 2) | 0) + dualScreenLeft;
            var top = ((screenHeight / 2) | 0) - ((h / 2) | 0) + dualScreenTop;
            preview.resizeTo(w, h);
            preview.moveTo(left, top);
            preview.focus();
            // render alphaTab
            var settings = new Settings();
            settings.core.scriptFile = this.settings.core.scriptFile;
            settings.core.fontDirectory = this.settings.core.fontDirectory;
            settings.core.enableLazyLoading = false;
            settings.core.useWorkers = false;
            settings.display.scale = 0.8;
            settings.display.stretchForce = 0.8;
            settings.display.resources = this.settings.display.resources;
            var alphaTab = new AlphaTabApi(a4, settings);
            alphaTab.renderer.postRenderFinished.on(function () {
                alphaTab.canvasElement.height = -1;
                preview.print();
            });
            alphaTab.renderTracks(this.tracks);
        };
        AlphaTabApi.prototype.downloadMidi = function () {
            if (!this.score) {
                return;
            }
            var midiFile = new MidiFile();
            var handler = new AlphaSynthMidiFileHandler(midiFile);
            var generator = new MidiFileGenerator(this.score, this.settings, handler);
            generator.generate();
            var binary = midiFile.toBinary();
            var fileName = !this.score.title ? 'File.mid' : this.score.title + ".mid";
            var dlLink = document.createElement('a');
            dlLink.download = fileName;
            var blob = new Blob([binary], {
                type: 'audio/midi'
            });
            var url = URL.createObjectURL(blob);
            dlLink.href = url;
            dlLink.style.display = 'none';
            document.body.appendChild(dlLink);
            dlLink.click();
            document.body.removeChild(dlLink);
        };
        AlphaTabApi.prototype.changeTrackMute = function (tracks, mute) {
            var trackList = this.trackIndexesToTracks(this.uiFacade.parseTracks(tracks));
            _super.prototype.changeTrackMute.call(this, trackList, mute);
        };
        AlphaTabApi.prototype.changeTrackSolo = function (tracks, solo) {
            var trackList = this.trackIndexesToTracks(this.uiFacade.parseTracks(tracks));
            _super.prototype.changeTrackSolo.call(this, trackList, solo);
        };
        AlphaTabApi.prototype.changeTrackVolume = function (tracks, volume) {
            var trackList = this.trackIndexesToTracks(this.uiFacade.parseTracks(tracks));
            _super.prototype.changeTrackVolume.call(this, trackList, volume);
        };
        AlphaTabApi.prototype.trackIndexesToTracks = function (trackIndexes) {
            if (!this.score) {
                return [];
            }
            var tracks = [];
            if (trackIndexes.length === 1 && trackIndexes[0] === -1) {
                for (var _i = 0, _a = this.score.tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    tracks.push(track);
                }
            }
            else {
                for (var _b = 0, trackIndexes_1 = trackIndexes; _b < trackIndexes_1.length; _b++) {
                    var index = trackIndexes_1[_b];
                    if (index >= 0 && index < this.score.tracks.length) {
                        tracks.push(this.score.tracks[index]);
                    }
                }
            }
            return tracks;
        };
        AlphaTabApi.prototype.loadSoundFontFromUrl = function (url, append) {
            var _this = this;
            if (!this.player) {
                return;
            }
            this.player.loadSoundFontFromUrl(url, append, function (e) {
                _this.soundFontLoad.trigger(e);
                _this.uiFacade.triggerEvent(_this.container, 'soundFontLoad', e);
            });
        };
        return AlphaTabApi;
    }(AlphaTabApiBase));

    /**
     * @target web
     */
    var JQueryAlphaTab = /** @class */ (function () {
        function JQueryAlphaTab() {
            this._initListeners = [];
        }
        JQueryAlphaTab.prototype.exec = function (element, method, args) {
            if (typeof method !== 'string') {
                args = [method];
                method = 'init';
            }
            if (method.charCodeAt(0) === 95 || method === 'exec') {
                return null;
            }
            var jElement = new jQuery(element);
            var context = jElement.data('alphaTab');
            if (method === 'destroy' && !context) {
                return null;
            }
            if (method !== 'init' && !context) {
                throw new Error('alphaTab not initialized');
            }
            var apiMethod = this[method];
            if (apiMethod) {
                var realArgs = [jElement, context].concat(args);
                return apiMethod.apply(this, realArgs);
            }
            else {
                Logger.error('Api', "Method '" + method + "' does not exist on jQuery.alphaTab");
                return null;
            }
        };
        JQueryAlphaTab.prototype.init = function (element, context, options) {
            if (!context) {
                context = new AlphaTabApi(element[0], options);
                element.data('alphaTab', context);
                for (var _i = 0, _a = this._initListeners; _i < _a.length; _i++) {
                    var listener = _a[_i];
                    listener(element, context, options);
                }
            }
        };
        JQueryAlphaTab.prototype.destroy = function (element, context) {
            element.removeData('alphaTab');
            context.destroy();
        };
        JQueryAlphaTab.prototype.print = function (element, context, width) {
            context.print(width);
        };
        JQueryAlphaTab.prototype.load = function (element, context, data, tracks) {
            return context.load(data, tracks);
        };
        JQueryAlphaTab.prototype.render = function (element, context) {
            context.render();
        };
        JQueryAlphaTab.prototype.renderScore = function (element, context, score, tracks) {
            context.renderScore(score, tracks);
        };
        JQueryAlphaTab.prototype.renderTracks = function (element, context, tracks) {
            context.renderTracks(tracks);
        };
        JQueryAlphaTab.prototype.invalidate = function (element, context) {
            context.render();
        };
        JQueryAlphaTab.prototype.tex = function (element, context, tex, tracks) {
            context.tex(tex, tracks);
        };
        JQueryAlphaTab.prototype.muteTrack = function (element, context, tracks, mute) {
            context.changeTrackMute(tracks, mute);
        };
        JQueryAlphaTab.prototype.soloTrack = function (element, context, tracks, solo) {
            context.changeTrackSolo(tracks, solo);
        };
        JQueryAlphaTab.prototype.trackVolume = function (element, context, tracks, volume) {
            context.changeTrackVolume(tracks, volume);
        };
        JQueryAlphaTab.prototype.loadSoundFont = function (element, context, value, append) {
            context.loadSoundFont(value, append);
        };
        JQueryAlphaTab.prototype.resetSoundFonts = function (element, context) {
            context.resetSoundFonts();
        };
        JQueryAlphaTab.prototype.pause = function (element, context) {
            context.pause();
        };
        JQueryAlphaTab.prototype.play = function (element, context) {
            return context.play();
        };
        JQueryAlphaTab.prototype.playPause = function (element, context) {
            context.playPause();
        };
        JQueryAlphaTab.prototype.stop = function (element, context) {
            context.stop();
        };
        JQueryAlphaTab.prototype.api = function (element, context) {
            return context;
        };
        JQueryAlphaTab.prototype.player = function (element, context) {
            return context.player;
        };
        JQueryAlphaTab.prototype.isReadyForPlayback = function (element, context) {
            return context.isReadyForPlayback;
        };
        JQueryAlphaTab.prototype.playerState = function (element, context) {
            return context.playerState;
        };
        JQueryAlphaTab.prototype.masterVolume = function (element, context, masterVolume) {
            if (typeof masterVolume === 'number') {
                context.masterVolume = masterVolume;
            }
            return context.masterVolume;
        };
        JQueryAlphaTab.prototype.metronomeVolume = function (element, context, metronomeVolume) {
            if (typeof metronomeVolume === 'number') {
                context.metronomeVolume = metronomeVolume;
            }
            return context.metronomeVolume;
        };
        JQueryAlphaTab.prototype.countInVolume = function (element, context, countInVolume) {
            if (typeof countInVolume === 'number') {
                context.countInVolume = countInVolume;
            }
            return context.countInVolume;
        };
        JQueryAlphaTab.prototype.playbackSpeed = function (element, context, playbackSpeed) {
            if (typeof playbackSpeed === 'number') {
                context.playbackSpeed = playbackSpeed;
            }
            return context.playbackSpeed;
        };
        JQueryAlphaTab.prototype.tickPosition = function (element, context, tickPosition) {
            if (typeof tickPosition === 'number') {
                context.tickPosition = tickPosition;
            }
            return context.tickPosition;
        };
        JQueryAlphaTab.prototype.timePosition = function (element, context, timePosition) {
            if (typeof timePosition === 'number') {
                context.timePosition = timePosition;
            }
            return context.timePosition;
        };
        JQueryAlphaTab.prototype.loop = function (element, context, loop) {
            if (typeof loop === 'boolean') {
                context.isLooping = loop;
            }
            return context.isLooping;
        };
        JQueryAlphaTab.prototype.renderer = function (element, context) {
            return context.renderer;
        };
        JQueryAlphaTab.prototype.score = function (element, context) {
            return context.score;
        };
        JQueryAlphaTab.prototype.settings = function (element, context) {
            return context.settings;
        };
        JQueryAlphaTab.prototype.tracks = function (element, context) {
            return context.tracks;
        };
        JQueryAlphaTab.prototype._oninit = function (listener) {
            this._initListeners.push(listener);
        };
        JQueryAlphaTab.restore = function (selector) {
            new jQuery(selector).empty().removeData('alphaTab');
        };
        return JQueryAlphaTab;
    }());

    /**
     * A canvas implementation storing SVG data
     */
    var SvgCanvas = /** @class */ (function () {
        function SvgCanvas() {
            this.buffer = '';
            this._currentPath = '';
            this._currentPathIsEmpty = true;
            this.color = new Color(255, 255, 255, 0xff);
            this.lineWidth = 1;
            this.font = new Font('Arial', 10, FontStyle.Plain);
            this.textAlign = TextAlign.Left;
            this.textBaseline = TextBaseline.Top;
        }
        SvgCanvas.prototype.beginRender = function (width, height) {
            this.buffer = "<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"" + (width | 0) + "px\" height=\"" + (height | 0) + "px\" class=\"at-surface-svg\">\n";
            this._currentPath = '';
            this._currentPathIsEmpty = true;
        };
        SvgCanvas.prototype.beginGroup = function (identifier) {
            this.buffer += "<g class=\"" + identifier + "\">";
        };
        SvgCanvas.prototype.endGroup = function () {
            this.buffer += '</g>';
        };
        SvgCanvas.prototype.endRender = function () {
            this.buffer += '</svg>';
            return this.buffer;
        };
        SvgCanvas.prototype.fillRect = function (x, y, w, h) {
            if (w > 0) {
                this.buffer += "<rect x=\"" + (x | 0) + "\" y=\"" + (y | 0) + "\" width=\"" + w + "\" height=\"" + h + "\" fill=\"" + this.color.rgba + "\" />\n";
            }
        };
        SvgCanvas.prototype.strokeRect = function (x, y, w, h) {
            this.buffer += "<rect x=\"" + (x | 0) + "\" y=\"" + (y | 0) + "\" width=\"" + w + "\" height=\"" + h + "\" stroke=\"" + this.color.rgba + "\"";
            if (this.lineWidth !== 1) {
                this.buffer += " stroke-width=\"" + this.lineWidth + "\"";
            }
            this.buffer += ' fill="transparent" />\n';
        };
        SvgCanvas.prototype.beginPath = function () {
            // nothing to do
        };
        SvgCanvas.prototype.closePath = function () {
            this._currentPath += ' z';
        };
        SvgCanvas.prototype.moveTo = function (x, y) {
            this._currentPath += " M" + x + "," + y;
        };
        SvgCanvas.prototype.lineTo = function (x, y) {
            this._currentPathIsEmpty = false;
            this._currentPath += " L" + x + "," + y;
        };
        SvgCanvas.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
            this._currentPathIsEmpty = false;
            this._currentPath += " Q" + cpx + "," + cpy + "," + x + "," + y;
        };
        SvgCanvas.prototype.bezierCurveTo = function (cp1X, cp1Y, cp2X, cp2Y, x, y) {
            this._currentPathIsEmpty = false;
            this._currentPath += " C" + cp1X + "," + cp1Y + "," + cp2X + "," + cp2Y + "," + x + "," + y;
        };
        SvgCanvas.prototype.fillCircle = function (x, y, radius) {
            this._currentPathIsEmpty = false;
            //
            // M0,250 A1,1 0 0,0 500,250 A1,1 0 0,0 0,250 z
            this._currentPath += " M" + (x - radius) + "," + y + " A1,1 0 0,0 " + (x + radius) + "," + y + " A1,1 0 0,0 " + (x - radius) + "," + y + " z";
            this.fill();
        };
        SvgCanvas.prototype.strokeCircle = function (x, y, radius) {
            this._currentPathIsEmpty = false;
            //
            // M0,250 A1,1 0 0,0 500,250 A1,1 0 0,0 0,250 z
            this._currentPath += " M" + (x - radius) + "," + y + " A1,1 0 0,0 " + (x + radius) + "," + y + " A1,1 0 0,0 " + (x - radius) + "," + y + " z";
            this.stroke();
        };
        SvgCanvas.prototype.fill = function () {
            if (!this._currentPathIsEmpty) {
                this.buffer += "<path d=\"" + this._currentPath + "\"";
                if (this.color.rgba !== '#000000') {
                    this.buffer += " fill=\"" + this.color.rgba + "\"";
                }
                this.buffer += ' style="stroke: none"/>';
            }
            this._currentPath = '';
            this._currentPathIsEmpty = true;
        };
        SvgCanvas.prototype.stroke = function () {
            if (!this._currentPathIsEmpty) {
                var s = "<path d=\"" + this._currentPath + "\" stroke=\"" + this.color.rgba + "\"";
                if (this.lineWidth !== 1) {
                    s += " stroke-width=\"" + this.lineWidth + "\"";
                }
                s += ' style="fill: none" />';
                this.buffer += s;
            }
            this._currentPath = '';
            this._currentPathIsEmpty = true;
        };
        SvgCanvas.prototype.fillText = function (text, x, y) {
            if (text === '') {
                return;
            }
            var s = "<text x=\"" + (x | 0) + "\" y=\"" + (y | 0) + "\" style=\"stroke: none; font:" + this.font.toCssString(this.settings.display.scale) + "\" " + this.getSvgBaseLine();
            if (this.color.rgba !== '#000000') {
                s += " fill=\"" + this.color.rgba + "\"";
            }
            if (this.textAlign !== TextAlign.Left) {
                s += " text-anchor=\"" + this.getSvgTextAlignment(this.textAlign) + "\"";
            }
            s += ">" + text + "</text>";
            this.buffer += s;
        };
        SvgCanvas.prototype.getSvgTextAlignment = function (textAlign) {
            switch (textAlign) {
                case TextAlign.Left:
                    return 'start';
                case TextAlign.Center:
                    return 'middle';
                case TextAlign.Right:
                    return 'end';
            }
            return '';
        };
        SvgCanvas.prototype.getSvgBaseLine = function () {
            switch (this.textBaseline) {
                case TextBaseline.Top:
                    return "dy=\"1.25ex\"";
                case TextBaseline.Middle:
                    return "dy=\"0.5ex\"";
                case TextBaseline.Bottom:
                default:
                    return '';
            }
        };
        SvgCanvas.prototype.measureText = function (text) {
            if (!text) {
                return 0;
            }
            return FontSizes.measureString(text, this.font.family, this.font.size, this.font.style);
        };
        SvgCanvas.prototype.onRenderFinished = function () {
            // nothing to do
            return null;
        };
        SvgCanvas.prototype.beginRotate = function (centerX, centerY, angle) {
            this.buffer += '<g transform="translate(' + centerX + ' ,' + centerY + ') rotate( ' + angle + ')">';
        };
        SvgCanvas.prototype.endRotate = function () {
            this.buffer += '</g>';
        };
        return SvgCanvas;
    }());

    var __extends$p = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This SVG canvas renders the music symbols by adding a CSS class 'at' to all elements.
     */
    var CssFontSvgCanvas = /** @class */ (function (_super) {
        __extends$p(CssFontSvgCanvas, _super);
        function CssFontSvgCanvas() {
            return _super.call(this) || this;
        }
        CssFontSvgCanvas.prototype.fillMusicFontSymbol = function (x, y, scale, symbol, centerAtPosition) {
            if (centerAtPosition === void 0) { centerAtPosition = false; }
            if (symbol === MusicFontSymbol.None) {
                return;
            }
            this.fillMusicFontSymbolText(x, y, scale, "&#" + symbol + ";", centerAtPosition);
        };
        CssFontSvgCanvas.prototype.fillMusicFontSymbols = function (x, y, scale, symbols, centerAtPosition) {
            if (centerAtPosition === void 0) { centerAtPosition = false; }
            var s = '';
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                if (symbol !== MusicFontSymbol.None) {
                    s += "&#" + symbol + ";";
                }
            }
            this.fillMusicFontSymbolText(x, y, scale, s, centerAtPosition);
        };
        CssFontSvgCanvas.prototype.fillMusicFontSymbolText = function (x, y, scale, symbols, centerAtPosition) {
            if (centerAtPosition === void 0) { centerAtPosition = false; }
            this.buffer += "<g transform=\"translate(" + x + " " + y + ")\" class=\"at\" ><text";
            if (scale !== 1) {
                this.buffer += " style=\"font-size: " + scale * 100 + "%; stroke:none\"";
            }
            else {
                this.buffer += ' style="stroke:none"';
            }
            if (this.color.rgba !== '#000000') {
                this.buffer += " fill=\"" + this.color.rgba + "\"";
            }
            if (centerAtPosition) {
                this.buffer += ' text-anchor="' + this.getSvgTextAlignment(TextAlign.Center) + '"';
            }
            this.buffer += ">" + symbols + "</text></g>";
        };
        return CssFontSvgCanvas;
    }(SvgCanvas));

    /**
     * This is the base public class for creating factories providing BarRenderers
     */
    var BarRendererFactory = /** @class */ (function () {
        function BarRendererFactory() {
            this.isInAccolade = true;
            this.isRelevantForBoundsLookup = true;
            this.hideOnMultiTrack = false;
            this.hideOnPercussionTrack = false;
        }
        BarRendererFactory.prototype.canCreate = function (track, staff) {
            return !this.hideOnPercussionTrack || !staff.isPercussion;
        };
        return BarRendererFactory;
    }());

    /**
     * Lists the different position modes for {@link BarRendererBase.getBeatX}
     */
    var BeatXPosition;
    (function (BeatXPosition) {
        /**
         * Gets the pre-notes position which is located before the accidentals
         */
        BeatXPosition[BeatXPosition["PreNotes"] = 0] = "PreNotes";
        /**
         * Gets the on-notes position which is located after the accidentals but before the note heads.
         */
        BeatXPosition[BeatXPosition["OnNotes"] = 1] = "OnNotes";
        /**
         * Gets the middle-notes position which is located after in the middle the note heads.
         */
        BeatXPosition[BeatXPosition["MiddleNotes"] = 2] = "MiddleNotes";
        /**
         * Gets position of the stem for this beat
         */
        BeatXPosition[BeatXPosition["Stem"] = 3] = "Stem";
        /**
         * Get the post-notes position which is located at after the note heads.
         */
        BeatXPosition[BeatXPosition["PostNotes"] = 4] = "PostNotes";
        /**
         * Get the end-beat position which is located at the end of the beat. This position is almost
         * equal to the pre-notes position of the next beat.
         */
        BeatXPosition[BeatXPosition["EndBeat"] = 5] = "EndBeat";
    })(BeatXPosition || (BeatXPosition = {}));

    var __extends$q = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This glyph allows to group several other glyphs to be
     * drawn at the same x position
     */
    var GlyphGroup = /** @class */ (function (_super) {
        __extends$q(GlyphGroup, _super);
        function GlyphGroup(x, y) {
            var _this = _super.call(this, x, y) || this;
            _this.glyphs = null;
            return _this;
        }
        Object.defineProperty(GlyphGroup.prototype, "isEmpty", {
            get: function () {
                return !this.glyphs || this.glyphs.length === 0;
            },
            enumerable: false,
            configurable: true
        });
        GlyphGroup.prototype.doLayout = function () {
            if (!this.glyphs || this.glyphs.length === 0) {
                this.width = 0;
                return;
            }
            var w = 0;
            for (var i = 0, j = this.glyphs.length; i < j; i++) {
                var g = this.glyphs[i];
                g.renderer = this.renderer;
                g.doLayout();
                w = Math.max(w, g.width);
            }
            this.width = w;
        };
        GlyphGroup.prototype.addGlyph = function (g) {
            if (!this.glyphs) {
                this.glyphs = [];
            }
            this.glyphs.push(g);
        };
        GlyphGroup.prototype.paint = function (cx, cy, canvas) {
            var glyphs = this.glyphs;
            if (!glyphs || glyphs.length === 0) {
                return;
            }
            for (var _i = 0, glyphs_1 = glyphs; _i < glyphs_1.length; _i++) {
                var g = glyphs_1[_i];
                g.paint(cx + this.x, cy + this.y, canvas);
            }
        };
        return GlyphGroup;
    }(Glyph));

    var __extends$r = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LeftToRightLayoutingGlyphGroup = /** @class */ (function (_super) {
        __extends$r(LeftToRightLayoutingGlyphGroup, _super);
        function LeftToRightLayoutingGlyphGroup() {
            var _this = _super.call(this, 0, 0) || this;
            _this.glyphs = [];
            return _this;
        }
        LeftToRightLayoutingGlyphGroup.prototype.addGlyph = function (g) {
            g.x =
                this.glyphs.length === 0
                    ? 0
                    : this.glyphs[this.glyphs.length - 1].x + this.glyphs[this.glyphs.length - 1].width;
            g.renderer = this.renderer;
            g.doLayout();
            this.width = g.x + g.width;
            _super.prototype.addGlyph.call(this, g);
        };
        return LeftToRightLayoutingGlyphGroup;
    }(GlyphGroup));

    var __extends$s = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This glyph acts as container for handling
     * multiple voice rendering
     */
    var VoiceContainerGlyph = /** @class */ (function (_super) {
        __extends$s(VoiceContainerGlyph, _super);
        function VoiceContainerGlyph(x, y, voice) {
            var _this = _super.call(this, x, y) || this;
            _this.voice = voice;
            _this.beatGlyphs = [];
            _this.tupletGroups = [];
            return _this;
        }
        VoiceContainerGlyph.prototype.scaleToWidth = function (width) {
            var force = this.renderer.layoutingInfo.spaceToForce(width);
            this.scaleToForce(force);
        };
        VoiceContainerGlyph.prototype.scaleToForce = function (force) {
            this.width = this.renderer.layoutingInfo.calculateVoiceWidth(force);
            var positions = this.renderer.layoutingInfo.buildOnTimePositions(force);
            var beatGlyphs = this.beatGlyphs;
            for (var i = 0, j = beatGlyphs.length; i < j; i++) {
                var currentBeatGlyph = beatGlyphs[i];
                var time = currentBeatGlyph.beat.absoluteDisplayStart;
                currentBeatGlyph.x = positions.get(time) - currentBeatGlyph.onTimeX;
                // size always previousl glyph after we know the position
                // of the next glyph
                if (i > 0) {
                    var beatWidth = currentBeatGlyph.x - beatGlyphs[i - 1].x;
                    beatGlyphs[i - 1].scaleToWidth(beatWidth);
                }
                // for the last glyph size based on the full width
                if (i === j - 1) {
                    var beatWidth = this.width - beatGlyphs[beatGlyphs.length - 1].x;
                    currentBeatGlyph.scaleToWidth(beatWidth);
                }
            }
        };
        VoiceContainerGlyph.prototype.registerLayoutingInfo = function (info) {
            info.updateVoiceSize(this.width);
            var beatGlyphs = this.beatGlyphs;
            for (var _i = 0, beatGlyphs_1 = beatGlyphs; _i < beatGlyphs_1.length; _i++) {
                var b = beatGlyphs_1[_i];
                b.registerLayoutingInfo(info);
            }
        };
        VoiceContainerGlyph.prototype.applyLayoutingInfo = function (info) {
            var beatGlyphs = this.beatGlyphs;
            for (var _i = 0, beatGlyphs_2 = beatGlyphs; _i < beatGlyphs_2.length; _i++) {
                var b = beatGlyphs_2[_i];
                b.applyLayoutingInfo(info);
            }
            this.scaleToForce(Math.max(this.renderer.settings.display.stretchForce, info.minStretchForce));
        };
        VoiceContainerGlyph.prototype.addGlyph = function (g) {
            var bg = g;
            g.x =
                this.beatGlyphs.length === 0
                    ? 0
                    : this.beatGlyphs[this.beatGlyphs.length - 1].x + this.beatGlyphs[this.beatGlyphs.length - 1].width;
            g.renderer = this.renderer;
            g.doLayout();
            this.beatGlyphs.push(bg);
            this.width = g.x + g.width;
            if (bg.beat.hasTuplet && bg.beat.tupletGroup.beats[0].id === bg.beat.id) {
                this.tupletGroups.push(bg.beat.tupletGroup);
            }
        };
        VoiceContainerGlyph.prototype.doLayout = function () {
        };
        VoiceContainerGlyph.prototype.paint = function (cx, cy, canvas) {
            // canvas.color = Color.random();
            // canvas.strokeRect(cx + this.x, cy + this.y, this.width, this.renderer.height);
            canvas.color =
                this.voice.index === 0
                    ? this.renderer.resources.mainGlyphColor
                    : this.renderer.resources.secondaryGlyphColor;
            for (var i = 0, j = this.beatGlyphs.length; i < j; i++) {
                this.beatGlyphs[i].paint(cx + this.x, cy + this.y, canvas);
            }
        };
        VoiceContainerGlyph.KeySizeBeat = 'Beat';
        return VoiceContainerGlyph;
    }(GlyphGroup));

    /**
     * Defines all possible accidentals for notes.
     */
    var AccidentalType;
    (function (AccidentalType) {
        /**
         * No accidental
         */
        AccidentalType[AccidentalType["None"] = 0] = "None";
        /**
         * Naturalize
         */
        AccidentalType[AccidentalType["Natural"] = 1] = "Natural";
        /**
         * Sharp
         */
        AccidentalType[AccidentalType["Sharp"] = 2] = "Sharp";
        /**
         * Flat
         */
        AccidentalType[AccidentalType["Flat"] = 3] = "Flat";
        /**
         * Natural for smear bends
         */
        AccidentalType[AccidentalType["NaturalQuarterNoteUp"] = 4] = "NaturalQuarterNoteUp";
        /**
         * Sharp for smear bends
         */
        AccidentalType[AccidentalType["SharpQuarterNoteUp"] = 5] = "SharpQuarterNoteUp";
        /**
         * Flat for smear bends
         */
        AccidentalType[AccidentalType["FlatQuarterNoteUp"] = 6] = "FlatQuarterNoteUp";
        /**
         * Double Sharp, indicated by an 'x'
         */
        AccidentalType[AccidentalType["DoubleSharp"] = 7] = "DoubleSharp";
        /**
         * Double Flat, indicated by 'bb'
         */
        AccidentalType[AccidentalType["DoubleFlat"] = 8] = "DoubleFlat";
    })(AccidentalType || (AccidentalType = {}));

    var BeatLines = /** @class */ (function () {
        function BeatLines() {
            this.maxLine = -1000;
            this.minLine = -1000;
        }
        return BeatLines;
    }());
    /**
     * This small utilty public class allows the assignment of accidentals within a
     * desired scope.
     */
    var AccidentalHelper = /** @class */ (function () {
        function AccidentalHelper(bar) {
            this._registeredAccidentals = new Map();
            this._appliedScoreLines = new Map();
            this._appliedScoreLinesByValue = new Map();
            this._notesByValue = new Map();
            this._beatLines = new Map();
            /**
             * The beat on which the highest note of this helper was added.
             * Used together with beaming helper to calculate overflow.
             */
            this.maxLineBeat = null;
            /**
             * The beat on which the lowest note of this helper was added.
             * Used together with beaming helper to calculate overflow.
             */
            this.minLineBeat = null;
            /**
             * The line of the highest note added to this helper.
             */
            this.maxLine = -1000;
            /**
             * The line of the lowest note added to this helper.
             */
            this.minLine = -1000;
            this._bar = bar;
        }
        AccidentalHelper.getPercussionLine = function (bar, noteValue) {
            var _a, _b;
            if (noteValue < bar.staff.track.percussionArticulations.length) {
                return bar.staff.track.percussionArticulations[noteValue].staffLine;
            }
            else {
                return (_b = (_a = PercussionMapper.getArticulationByValue(noteValue)) === null || _a === void 0 ? void 0 : _a.staffLine) !== null && _b !== void 0 ? _b : 0;
            }
        };
        AccidentalHelper.getNoteValue = function (note) {
            if (note.isPercussion) {
                return note.percussionArticulation;
            }
            var noteValue = note.displayValue;
            // adjust note height according to accidentals enforced
            switch (note.accidentalMode) {
                case NoteAccidentalMode.ForceDoubleFlat:
                    noteValue += 2;
                    break;
                case NoteAccidentalMode.ForceDoubleSharp:
                    noteValue -= 2;
                    break;
                case NoteAccidentalMode.ForceFlat:
                    noteValue += 1;
                    break;
                case NoteAccidentalMode.ForceSharp:
                    noteValue -= 1;
                    break;
            }
            return noteValue;
        };
        /**
         * Calculates the accidental for the given note and assignes the value to it.
         * The new accidental type is also registered within the current scope
         * @param note
         * @returns
         */
        AccidentalHelper.prototype.applyAccidental = function (note) {
            var noteValue = AccidentalHelper.getNoteValue(note);
            var quarterBend = note.hasQuarterToneOffset;
            return this.getAccidental(noteValue, quarterBend, note.beat, false, note);
        };
        /**
         * Calculates the accidental for the given note value and assignes the value to it.
         * The new accidental type is also registered within the current scope
         * @param relatedBeat
         * @param noteValue
         * @param quarterBend
         * @param isHelperNote true if the note registered via this call, is a small helper note (e.g. for bends) or false if it is a main note head (e.g. for harmonics)
         * @returns
         */
        AccidentalHelper.prototype.applyAccidentalForValue = function (relatedBeat, noteValue, quarterBend, isHelperNote) {
            return this.getAccidental(noteValue, quarterBend, relatedBeat, isHelperNote, null);
        };
        AccidentalHelper.computeLineWithoutAccidentals = function (bar, note) {
            var line = 0;
            var noteValue = AccidentalHelper.getNoteValue(note);
            if (bar.staff.isPercussion) {
                line = AccidentalHelper.getPercussionLine(bar, noteValue);
            }
            else {
                var accidentalMode = note ? note.accidentalMode : NoteAccidentalMode.Default;
                line = AccidentalHelper.calculateNoteLine(bar, noteValue, accidentalMode);
            }
            return line;
        };
        AccidentalHelper.prototype.getAccidental = function (noteValue, quarterBend, relatedBeat, isHelperNote, note) {
            if (note === void 0) { note = null; }
            var accidentalToSet = AccidentalType.None;
            var line = 0;
            if (this._bar.staff.isPercussion) {
                line = AccidentalHelper.getPercussionLine(this._bar, noteValue);
            }
            else {
                var accidentalMode = note ? note.accidentalMode : NoteAccidentalMode.Default;
                line = AccidentalHelper.calculateNoteLine(this._bar, noteValue, accidentalMode);
                var ks = this._bar.masterBar.keySignature;
                var ksi = ks + 7;
                var index = noteValue % 12;
                var accidentalForKeySignature = ksi < 7 ? AccidentalType.Flat : AccidentalType.Sharp;
                var hasKeySignatureAccidentalSetForNote = AccidentalHelper.KeySignatureLookup[ksi][index];
                var hasNoteAccidentalWithinOctave = AccidentalHelper.AccidentalNotes[index];
                // the general logic is like this:
                // - we check if the key signature has an accidental defined
                // - we calculate which accidental a note needs according to its index in the octave
                // - if the accidental is already placed at this line, nothing needs to be done, otherwise we place it
                // - if there should not be an accidental, but there is one in the key signature, we clear it.
                // the exceptions are:
                // - for quarter bends we just place the corresponding accidental
                // - the accidental mode can enforce the accidentals for the note
                if (quarterBend) {
                    accidentalToSet = hasNoteAccidentalWithinOctave ? accidentalForKeySignature : AccidentalType.Natural;
                    switch (accidentalToSet) {
                        case AccidentalType.Natural:
                            accidentalToSet = AccidentalType.NaturalQuarterNoteUp;
                            break;
                        case AccidentalType.Sharp:
                            accidentalToSet = AccidentalType.SharpQuarterNoteUp;
                            break;
                        case AccidentalType.Flat:
                            accidentalToSet = AccidentalType.FlatQuarterNoteUp;
                            break;
                    }
                }
                else {
                    // define which accidental should be shown ignoring what might be set on the KS already
                    switch (accidentalMode) {
                        case NoteAccidentalMode.ForceSharp:
                            accidentalToSet = AccidentalType.Sharp;
                            hasNoteAccidentalWithinOctave = true;
                            break;
                        case NoteAccidentalMode.ForceDoubleSharp:
                            accidentalToSet = AccidentalType.DoubleSharp;
                            hasNoteAccidentalWithinOctave = true;
                            break;
                        case NoteAccidentalMode.ForceFlat:
                            accidentalToSet = AccidentalType.Flat;
                            hasNoteAccidentalWithinOctave = true;
                            break;
                        case NoteAccidentalMode.ForceDoubleFlat:
                            accidentalToSet = AccidentalType.DoubleFlat;
                            hasNoteAccidentalWithinOctave = true;
                            break;
                        default:
                            // if note has an accidental in the octave, we place a symbol
                            // according to the Key Signature
                            if (hasNoteAccidentalWithinOctave) {
                                accidentalToSet = accidentalForKeySignature;
                            }
                            else if (hasKeySignatureAccidentalSetForNote) {
                                // note does not get an accidental, but KS defines one -> Naturalize
                                accidentalToSet = AccidentalType.Natural;
                            }
                            break;
                    }
                    // do we need an accidental on the note?
                    if (accidentalToSet !== AccidentalType.None) {
                        // if we already have an accidental on this line we will reset it if it's the same
                        if (this._registeredAccidentals.has(line)) {
                            if (this._registeredAccidentals.get(line) === accidentalToSet) {
                                accidentalToSet = AccidentalType.None;
                            }
                        }
                        // if there is no accidental on the line, and the key signature has it set already, we clear it on the note
                        else if (hasKeySignatureAccidentalSetForNote && accidentalToSet === accidentalForKeySignature) {
                            accidentalToSet = AccidentalType.None;
                        }
                        // register the new accidental on the line if any.
                        if (accidentalToSet != AccidentalType.None) {
                            this._registeredAccidentals.set(line, accidentalToSet);
                        }
                    }
                    else {
                        // if we don't want an accidental, but there is already one applied, we place a naturalize accidental
                        // and clear the registration
                        if (this._registeredAccidentals.has(line)) {
                            // if there is already a naturalize symbol on the line, we don't care.
                            if (this._registeredAccidentals.get(line) === AccidentalType.Natural) {
                                accidentalToSet = AccidentalType.None;
                            }
                            else {
                                accidentalToSet = AccidentalType.Natural;
                                this._registeredAccidentals.set(line, accidentalToSet);
                            }
                        }
                        else {
                            this._registeredAccidentals.delete(line);
                        }
                    }
                }
            }
            if (note) {
                this._appliedScoreLines.set(note.id, line);
                this._notesByValue.set(noteValue, note);
            }
            else {
                this._appliedScoreLinesByValue.set(noteValue, line);
            }
            if (this.minLine === -1000 || this.minLine < line) {
                this.minLine = line;
                this.minLineBeat = relatedBeat;
            }
            if (this.maxLine === -1000 || this.maxLine > line) {
                this.maxLine = line;
                this.maxLineBeat = relatedBeat;
            }
            if (!isHelperNote) {
                var lines = void 0;
                if (this._beatLines.has(relatedBeat.id)) {
                    lines = this._beatLines.get(relatedBeat.id);
                }
                else {
                    lines = new BeatLines();
                    this._beatLines.set(relatedBeat.id, lines);
                }
                if (lines.minLine === -1000 || line < lines.minLine) {
                    lines.minLine = line;
                }
                if (lines.minLine === -1000 || line > lines.maxLine) {
                    lines.maxLine = line;
                }
            }
            return accidentalToSet;
        };
        AccidentalHelper.prototype.getMaxLine = function (b) {
            return this._beatLines.has(b.id)
                ? this._beatLines.get(b.id).maxLine
                : 0;
        };
        AccidentalHelper.prototype.getMinLine = function (b) {
            return this._beatLines.has(b.id)
                ? this._beatLines.get(b.id).minLine
                : 0;
        };
        AccidentalHelper.calculateNoteLine = function (bar, noteValue, mode) {
            var value = noteValue;
            var ks = bar.masterBar.keySignature;
            var clef = bar.clef;
            var index = value % 12;
            var octave = ((value / 12) | 0) - 1;
            // Initial Position
            var steps = AccidentalHelper.OctaveSteps[clef];
            // Move to Octave
            steps -= octave * AccidentalHelper.StepsPerOctave;
            // get the step list for the current keySignature
            var stepList = ModelUtils.keySignatureIsSharp(ks) || ModelUtils.keySignatureIsNatural(ks)
                ? AccidentalHelper.SharpNoteSteps
                : AccidentalHelper.FlatNoteSteps;
            steps -= stepList[index];
            return steps;
        };
        AccidentalHelper.prototype.getNoteLine = function (n) {
            return this._appliedScoreLines.get(n.id);
        };
        AccidentalHelper.prototype.getNoteLineForValue = function (rawValue, searchForNote) {
            if (searchForNote === void 0) { searchForNote = false; }
            if (this._appliedScoreLinesByValue.has(rawValue)) {
                return this._appliedScoreLinesByValue.get(rawValue);
            }
            if (searchForNote && this._notesByValue.has(rawValue)) {
                return this.getNoteLine(this._notesByValue.get(rawValue));
            }
            return 0;
        };
        /**
         * a lookup list containing an info whether the notes within an octave
         * need an accidental rendered. the accidental symbol is determined based on the type of key signature.
         */
        AccidentalHelper.KeySignatureLookup = [
            // Flats (where the value is true, a flat accidental is required for the notes)
            [true, true, true, true, true, true, true, true, true, true, true, true],
            [true, true, true, true, true, false, true, true, true, true, true, true],
            [false, true, true, true, true, false, true, true, true, true, true, true],
            [false, true, true, true, true, false, false, false, true, true, true, true],
            [false, false, false, true, true, false, false, false, true, true, true, true],
            [false, false, false, true, true, false, false, false, false, false, true, true],
            [false, false, false, false, false, false, false, false, false, false, true, true],
            // natural
            [false, false, false, false, false, false, false, false, false, false, false, false],
            // sharps  (where the value is true, a flat accidental is required for the notes)
            [false, false, false, false, false, true, true, false, false, false, false, false],
            [true, true, false, false, false, true, true, false, false, false, false, false],
            [true, true, false, false, false, true, true, true, true, false, false, false],
            [true, true, true, true, false, true, true, true, true, false, false, false],
            [true, true, true, true, false, true, true, true, true, true, true, false],
            [true, true, true, true, true, true, true, true, true, true, true, false],
            [true, true, true, true, true, true, true, true, true, true, true, true]
        ];
        /**
         * Contains the list of notes within an octave have accidentals set.
         */
        // prettier-ignore
        AccidentalHelper.AccidentalNotes = [
            false, true, false, true, false, false, true, false, true, false, true, false
        ];
        /**
         * We always have 7 steps per octave.
         * (by a step the offsets inbetween score lines is meant,
         *      0 steps is on the first line (counting from top)
         *      1 steps is on the space inbetween the first and the second line
         */
        AccidentalHelper.StepsPerOctave = 7;
        /**
         * Those are the amount of steps for the different clefs in case of a note value 0
         * [Neutral, C3, C4, F4, G2]
         */
        AccidentalHelper.OctaveSteps = [38, 32, 30, 26, 38];
        /**
         * The step offsets of the notes within an octave in case of for sharp keysignatures
         */
        AccidentalHelper.SharpNoteSteps = [0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6];
        /**
         * The step offsets of the notes within an octave in case of for flat keysignatures
         */
        AccidentalHelper.FlatNoteSteps = [0, 1, 1, 2, 2, 3, 4, 4, 5, 5, 6, 6];
        return AccidentalHelper;
    }());

    var BeatLinePositions = /** @class */ (function () {
        function BeatLinePositions() {
            this.staffId = '';
            this.up = 0;
            this.down = 0;
        }
        return BeatLinePositions;
    }());
    /**
     * This public class helps drawing beams and bars for notes.
     */
    var BeamingHelper = /** @class */ (function () {
        function BeamingHelper(staff, renderer) {
            this._beatLineXPositions = new Map();
            this.voice = null;
            this.beats = [];
            this.shortestDuration = Duration.QuadrupleWhole;
            /**
             * the number of fingering indicators that will be drawn
             */
            this.fingeringCount = 0;
            /**
             * an indicator whether any beat has a tuplet on it.
             */
            this.hasTuplet = false;
            this._firstBeatLowestNote = null;
            this._firstBeatLowestNoteCompareValue = -1;
            this._firstBeatHighestNote = null;
            this._firstBeatHighestNoteCompareValue = -1;
            this._lastBeatLowestNote = null;
            this._lastBeatLowestNoteCompareValue = -1;
            this._lastBeatHighestNote = null;
            this._lastBeatHighestNoteCompareValue = -1;
            this._lowestNoteInHelper = null;
            this._lowestNoteCompareValueInHelper = -1;
            this._highestNoteInHelper = null;
            this._highestNoteCompareValueInHelper = -1;
            this.invertBeamDirection = false;
            this.preferredBeamDirection = null;
            this.isGrace = false;
            this.direction = BeamDirection.Up;
            this._staff = staff;
            this._renderer = renderer;
            this.beats = [];
        }
        Object.defineProperty(BeamingHelper.prototype, "hasLine", {
            get: function () {
                return this.beats.length === 1 && this.beats[0].duration > Duration.Whole;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BeamingHelper.prototype, "hasFlag", {
            get: function () {
                return (this.beats.length === 1 &&
                    (this.beats[0].duration > Duration.Quarter || this.beats[0].graceType !== GraceType.None));
            },
            enumerable: false,
            configurable: true
        });
        BeamingHelper.prototype.getBeatLineX = function (beat) {
            if (this.hasBeatLineX(beat)) {
                if (this.direction === BeamDirection.Up) {
                    return this._beatLineXPositions.get(beat.index).up;
                }
                return this._beatLineXPositions.get(beat.index).down;
            }
            return 0;
        };
        BeamingHelper.prototype.hasBeatLineX = function (beat) {
            return this._beatLineXPositions.has(beat.index);
        };
        BeamingHelper.prototype.registerBeatLineX = function (staffId, beat, up, down) {
            var positions = this.getOrCreateBeatPositions(beat);
            positions.staffId = staffId;
            positions.up = up;
            positions.down = down;
        };
        BeamingHelper.prototype.getOrCreateBeatPositions = function (beat) {
            if (!this._beatLineXPositions.has(beat.index)) {
                this._beatLineXPositions.set(beat.index, new BeatLinePositions());
            }
            return this._beatLineXPositions.get(beat.index);
        };
        BeamingHelper.prototype.finish = function () {
            this.direction = this.calculateDirection();
        };
        BeamingHelper.prototype.calculateDirection = function () {
            var preferredBeamDirection = this.preferredBeamDirection;
            if (preferredBeamDirection !== null) {
                return preferredBeamDirection;
            }
            if (!this.voice) {
                return BeamDirection.Up;
            }
            // multivoice handling
            if (this.voice.index > 0) {
                return this.invert(BeamDirection.Down);
            }
            if (this.voice.bar.voices.length > 1) {
                for (var v = 1; v < this.voice.bar.voices.length; v++) {
                    if (!this.voice.bar.voices[v].isEmpty) {
                        return this.invert(BeamDirection.Up);
                    }
                }
            }
            if (this.beats[0].graceType !== GraceType.None) {
                return this.invert(BeamDirection.Up);
            }
            // the average line is used for determination
            //      key lowerequal than middle line -> up
            //      key higher than middle line -> down
            var highestNotePosition = this._renderer.getNoteY(this._highestNoteInHelper, NoteYPosition.Center);
            var lowestNotePosition = this._renderer.getNoteY(this._lowestNoteInHelper, NoteYPosition.Center);
            var avg = (highestNotePosition + lowestNotePosition) / 2;
            return this.invert(this._renderer.middleYPosition < avg ? BeamDirection.Up : BeamDirection.Down);
        };
        BeamingHelper.prototype.invert = function (direction) {
            if (!this.invertBeamDirection) {
                return direction;
            }
            switch (direction) {
                case BeamDirection.Down:
                    return BeamDirection.Up;
                case BeamDirection.Up:
                default:
                    return BeamDirection.Down;
            }
        };
        BeamingHelper.prototype.checkBeat = function (beat) {
            if (beat.invertBeamDirection) {
                this.invertBeamDirection = true;
            }
            if (!this.voice) {
                this.voice = beat.voice;
            }
            // allow adding if there are no beats yet
            var add = false;
            if (this.beats.length === 0) {
                add = true;
            }
            else {
                switch (this.beats[this.beats.length - 1].beamingMode) {
                    case BeatBeamingMode.Auto:
                        add = BeamingHelper.canJoin(this.beats[this.beats.length - 1], beat);
                        break;
                    case BeatBeamingMode.ForceSplitToNext:
                        add = false;
                        break;
                    case BeatBeamingMode.ForceMergeWithNext:
                        add = true;
                        break;
                }
            }
            if (add) {
                if (beat.preferredBeamDirection !== null) {
                    this.preferredBeamDirection = beat.preferredBeamDirection;
                }
                this.beats.push(beat);
                if (beat.graceType !== GraceType.None) {
                    this.isGrace = true;
                }
                if (beat.hasTuplet) {
                    this.hasTuplet = true;
                }
                var fingeringCount = 0;
                for (var n = 0; n < beat.notes.length; n++) {
                    var note = beat.notes[n];
                    if (note.leftHandFinger !== Fingers.Unknown || note.rightHandFinger !== Fingers.Unknown) {
                        fingeringCount++;
                    }
                }
                if (fingeringCount > this.fingeringCount) {
                    this.fingeringCount = fingeringCount;
                }
                this._lastBeatLowestNote = null;
                this._lastBeatHighestNote = null;
                this.checkNote(beat.minNote);
                this.checkNote(beat.maxNote);
                if (this.shortestDuration < beat.duration) {
                    this.shortestDuration = beat.duration;
                }
                if (beat.hasTuplet) {
                    this.hasTuplet = true;
                }
            }
            return add;
        };
        BeamingHelper.prototype.checkNote = function (note) {
            if (!note) {
                return;
            }
            // a note can expand to 2 note heads if it has a harmonic
            var lowestValueForNote;
            var highestValueForNote;
            // For percussion we use the line as value to compare whether it is
            // higher or lower.
            if (this.voice && note.isPercussion) {
                lowestValueForNote = -AccidentalHelper.getPercussionLine(this.voice.bar, AccidentalHelper.getNoteValue(note));
                highestValueForNote = lowestValueForNote;
            }
            else {
                lowestValueForNote = AccidentalHelper.getNoteValue(note);
                highestValueForNote = lowestValueForNote;
                if (note.harmonicType !== HarmonicType.None && note.harmonicType !== HarmonicType.Natural) {
                    highestValueForNote = note.realValue - this._staff.displayTranspositionPitch;
                }
            }
            if (this.beats.length === 1 && this.beats[0] === note.beat) {
                if (!this._firstBeatLowestNote || lowestValueForNote < this._firstBeatLowestNoteCompareValue) {
                    this._firstBeatLowestNote = note;
                    this._firstBeatLowestNoteCompareValue = lowestValueForNote;
                }
                if (!this._firstBeatHighestNote || highestValueForNote > this._firstBeatHighestNoteCompareValue) {
                    this._firstBeatHighestNote = note;
                    this._firstBeatHighestNoteCompareValue = highestValueForNote;
                }
            }
            if (!this._lastBeatLowestNote || lowestValueForNote < this._lastBeatLowestNoteCompareValue) {
                this._lastBeatLowestNote = note;
                this._lastBeatLowestNoteCompareValue = lowestValueForNote;
            }
            if (!this._lastBeatHighestNote || highestValueForNote > this._lastBeatHighestNoteCompareValue) {
                this._lastBeatHighestNote = note;
                this._lastBeatHighestNoteCompareValue = highestValueForNote;
            }
            if (!this._lowestNoteInHelper || lowestValueForNote < this._lowestNoteCompareValueInHelper) {
                this._lowestNoteInHelper = note;
                this._lowestNoteCompareValueInHelper = lowestValueForNote;
            }
            if (!this._highestNoteInHelper || highestValueForNote > this._highestNoteCompareValueInHelper) {
                this._highestNoteInHelper = note;
                this._highestNoteCompareValueInHelper = highestValueForNote;
            }
        };
        // TODO: Check if this beaming is really correct, I'm not sure if we are connecting beats correctly
        BeamingHelper.canJoin = function (b1, b2) {
            // is this a voice we can join with?
            if (!b1 ||
                !b2 ||
                b1.isRest ||
                b2.isRest ||
                b1.graceType !== b2.graceType ||
                b1.graceType === GraceType.BendGrace ||
                b2.graceType === GraceType.BendGrace) {
                return false;
            }
            if (b1.graceType !== GraceType.None && b2.graceType !== GraceType.None) {
                return true;
            }
            var m1 = b1.voice.bar;
            var m2 = b2.voice.bar;
            // only join on same measure
            if (m1 !== m2) {
                return false;
            }
            // get times of those voices and check if the times
            // are in the same division
            var start1 = b1.playbackStart;
            var start2 = b2.playbackStart;
            // we can only join 8th, 16th, 32th and 64th voices
            if (!BeamingHelper.canJoinDuration(b1.duration) || !BeamingHelper.canJoinDuration(b2.duration)) {
                return start1 === start2;
            }
            // break between different tuplet groups
            if (b1.tupletGroup !== b2.tupletGroup) {
                return false;
            }
            if (b1.hasTuplet && b2.hasTuplet) {
                // force joining for full tuplet groups
                if (b1.tupletGroup === b2.tupletGroup && b1.tupletGroup.isFull) {
                    return true;
                }
            }
            // TODO: create more rules for automatic beaming
            var divisionLength = MidiUtils.QuarterTime;
            switch (m1.masterBar.timeSignatureDenominator) {
                case 8:
                    if (m1.masterBar.timeSignatureNumerator % 3 === 0) {
                        divisionLength += (MidiUtils.QuarterTime / 2) | 0;
                    }
                    break;
            }
            // check if they are on the same division
            var division1 = ((divisionLength + start1) / divisionLength) | 0 | 0;
            var division2 = ((divisionLength + start2) / divisionLength) | 0 | 0;
            return division1 === division2;
        };
        BeamingHelper.canJoinDuration = function (d) {
            switch (d) {
                case Duration.Whole:
                case Duration.Half:
                case Duration.Quarter:
                    return false;
                default:
                    return true;
            }
        };
        BeamingHelper.isFullBarJoin = function (a, b, barIndex) {
            // TODO: this getindex call seems expensive since we call this method very often.
            return ModelUtils.getIndex(a.duration) - 2 - barIndex > 0 && ModelUtils.getIndex(b.duration) - 2 - barIndex > 0;
        };
        Object.defineProperty(BeamingHelper.prototype, "beatOfLowestNote", {
            get: function () {
                return this._lowestNoteInHelper.beat;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BeamingHelper.prototype, "beatOfHighestNote", {
            get: function () {
                return this._highestNoteInHelper.beat;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Returns whether the the position of the given beat, was registered by the staff of the given ID
         * @param staffId
         * @param beat
         * @returns
         */
        BeamingHelper.prototype.isPositionFrom = function (staffId, beat) {
            if (!this._beatLineXPositions.has(beat.index)) {
                return true;
            }
            return (this._beatLineXPositions.get(beat.index).staffId === staffId ||
                !this._beatLineXPositions.get(beat.index).staffId);
        };
        return BeamingHelper;
    }());

    var BarHelpers = /** @class */ (function () {
        function BarHelpers(renderer) {
            this.beamHelpers = [];
            this.beamHelperLookup = [];
            this._renderer = renderer;
        }
        BarHelpers.prototype.initialize = function () {
            var barRenderer = this._renderer;
            var bar = this._renderer.bar;
            var currentBeamHelper = null;
            var currentGraceBeamHelper = null;
            for (var i = 0, j = bar.voices.length; i < j; i++) {
                var v = bar.voices[i];
                this.beamHelpers.push([]);
                this.beamHelperLookup.push(new Map());
                for (var k = 0, l = v.beats.length; k < l; k++) {
                    var b = v.beats[k];
                    var helperForBeat = void 0;
                    if (b.graceType !== GraceType.None) {
                        helperForBeat = currentGraceBeamHelper;
                    }
                    else {
                        helperForBeat = currentBeamHelper;
                        currentGraceBeamHelper = null;
                    }
                    // if a new beaming helper was started, we close our tuplet grouping as well
                    if (!b.isRest) {
                        // try to fit beam to current beamhelper
                        if (!helperForBeat || !helperForBeat.checkBeat(b)) {
                            if (helperForBeat) {
                                helperForBeat.finish();
                            }
                            // if not possible, create the next beaming helper
                            helperForBeat = new BeamingHelper(bar.staff, barRenderer);
                            helperForBeat.checkBeat(b);
                            if (b.graceType !== GraceType.None) {
                                currentGraceBeamHelper = helperForBeat;
                            }
                            else {
                                currentBeamHelper = helperForBeat;
                            }
                            this.beamHelpers[v.index].push(helperForBeat);
                        }
                    }
                    this.beamHelperLookup[v.index].set(b.index, helperForBeat);
                }
                if (currentBeamHelper) {
                    currentBeamHelper.finish();
                }
                if (currentGraceBeamHelper) {
                    currentGraceBeamHelper.finish();
                }
                currentBeamHelper = null;
                currentGraceBeamHelper = null;
            }
        };
        BarHelpers.prototype.getBeamingHelperForBeat = function (beat) {
            return this.beamHelperLookup[beat.voice.index].get(beat.index);
        };
        return BarHelpers;
    }());

    /**
     * Lists the different position modes for {@link BarRendererBase.getNoteY}
     */
    var NoteYPosition;
    (function (NoteYPosition) {
        /**
         * Gets the note y-position on top of the note stem or tab number.
         */
        NoteYPosition[NoteYPosition["TopWithStem"] = 0] = "TopWithStem";
        /**
         * Gets the note y-position on top of the note head or tab number.
         */
        NoteYPosition[NoteYPosition["Top"] = 1] = "Top";
        /**
         * Gets the note y-position on the center of the note head or tab number.
         */
        NoteYPosition[NoteYPosition["Center"] = 2] = "Center";
        /**
         * Gets the note y-position on the bottom of the note head or tab number.
         */
        NoteYPosition[NoteYPosition["Bottom"] = 3] = "Bottom";
        /**
         * Gets the note y-position on the bottom of the note stem or tab number.
         */
        NoteYPosition[NoteYPosition["BottomWithStem"] = 4] = "BottomWithStem";
    })(NoteYPosition || (NoteYPosition = {}));
    /**
     * Lists the different position modes for {@link BarRendererBase.getNoteX}
     */
    var NoteXPosition;
    (function (NoteXPosition) {
        /**
         * Gets the note x-position on left of the note head or tab number.
         */
        NoteXPosition[NoteXPosition["Left"] = 0] = "Left";
        /**
         * Gets the note x-position on the center of the note head or tab number.
         */
        NoteXPosition[NoteXPosition["Center"] = 1] = "Center";
        /**
         * Gets the note x-position on the right of the note head or tab number.
         */
        NoteXPosition[NoteXPosition["Right"] = 2] = "Right";
    })(NoteXPosition || (NoteXPosition = {}));
    /**
     * This is the base public class for creating blocks which can render bars.
     */
    var BarRendererBase = /** @class */ (function () {
        function BarRendererBase(renderer, bar) {
            this._preBeatGlyphs = new LeftToRightLayoutingGlyphGroup();
            this._voiceContainers = new Map();
            this._postBeatGlyphs = new LeftToRightLayoutingGlyphGroup();
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.index = 0;
            this.topOverflow = 0;
            this.bottomOverflow = 0;
            /**
             * Gets or sets whether this renderer is linked to the next one
             * by some glyphs like a vibrato effect
             */
            this.isLinkedToPrevious = false;
            /**
             * Gets or sets whether this renderer can wrap to the next line
             * or it needs to stay connected to the previous one.
             * (e.g. when having double bar repeats we must not separate the 2 bars)
             */
            this.canWrap = true;
            this._wasFirstOfLine = false;
            this._appliedLayoutingInfo = 0;
            this.isFinalized = false;
            /**
             * Gets the top padding for the main content of the renderer.
             * Can be used to specify where i.E. the score lines of the notation start.
             * @returns
             */
            this.topPadding = 0;
            /**
             * Gets the bottom padding for the main content of the renderer.
             * Can be used to specify where i.E. the score lines of the notation end.
             */
            this.bottomPadding = 0;
            this.scoreRenderer = renderer;
            this.bar = bar;
            if (bar) {
                this.helpers = new BarHelpers(this);
            }
        }
        Object.defineProperty(BarRendererBase.prototype, "nextRenderer", {
            get: function () {
                if (!this.bar || !this.bar.nextBar) {
                    return null;
                }
                return this.scoreRenderer.layout.getRendererForBar(this.staff.staveId, this.bar.nextBar);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "previousRenderer", {
            get: function () {
                if (!this.bar || !this.bar.previousBar) {
                    return null;
                }
                return this.scoreRenderer.layout.getRendererForBar(this.staff.staveId, this.bar.previousBar);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "middleYPosition", {
            get: function () {
                return 0;
            },
            enumerable: false,
            configurable: true
        });
        BarRendererBase.prototype.registerOverflowTop = function (topOverflow) {
            if (topOverflow > this.topOverflow) {
                this.topOverflow = topOverflow;
            }
        };
        BarRendererBase.prototype.registerOverflowBottom = function (bottomOverflow) {
            if (bottomOverflow > this.bottomOverflow) {
                this.bottomOverflow = bottomOverflow;
            }
        };
        BarRendererBase.prototype.scaleToWidth = function (width) {
            // preBeat and postBeat glyphs do not get resized
            var containerWidth = width - this._preBeatGlyphs.width - this._postBeatGlyphs.width;
            this._voiceContainers.forEach(function (container) {
                container.scaleToWidth(containerWidth);
            });
            this._postBeatGlyphs.x = this._preBeatGlyphs.x + this._preBeatGlyphs.width + containerWidth;
            this.width = width;
        };
        Object.defineProperty(BarRendererBase.prototype, "resources", {
            get: function () {
                return this.settings.display.resources;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "settings", {
            get: function () {
                return this.scoreRenderer.settings;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "scale", {
            get: function () {
                return this.settings.display.scale;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "isFirstOfLine", {
            get: function () {
                return this.index === 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "isLast", {
            get: function () {
                return !this.bar || this.bar.index === this.scoreRenderer.layout.lastBarIndex;
            },
            enumerable: false,
            configurable: true
        });
        BarRendererBase.prototype.registerLayoutingInfo = function () {
            var info = this.layoutingInfo;
            var preSize = this._preBeatGlyphs.width;
            if (info.preBeatSize < preSize) {
                info.preBeatSize = preSize;
            }
            this._voiceContainers.forEach(function (container) {
                container.registerLayoutingInfo(info);
            });
            var postSize = this._postBeatGlyphs.width;
            if (info.postBeatSize < postSize) {
                info.postBeatSize = postSize;
            }
        };
        BarRendererBase.prototype.applyLayoutingInfo = function () {
            var _this = this;
            if (this._appliedLayoutingInfo >= this.layoutingInfo.version) {
                return false;
            }
            this._appliedLayoutingInfo = this.layoutingInfo.version;
            // if we need additional space in the preBeat group we simply
            // add a new spacer
            this._preBeatGlyphs.width = this.layoutingInfo.preBeatSize;
            // on beat glyphs we apply the glyph spacing
            var voiceEnd = this._preBeatGlyphs.x + this._preBeatGlyphs.width;
            this._voiceContainers.forEach(function (c) {
                c.x = _this._preBeatGlyphs.x + _this._preBeatGlyphs.width;
                c.applyLayoutingInfo(_this.layoutingInfo);
                var newEnd = c.x + c.width;
                if (voiceEnd < newEnd) {
                    voiceEnd = newEnd;
                }
            });
            // on the post glyphs we add the spacing before all other glyphs
            this._postBeatGlyphs.x = Math.floor(voiceEnd);
            this._postBeatGlyphs.width = this.layoutingInfo.postBeatSize;
            this.width = Math.ceil(this._postBeatGlyphs.x + this._postBeatGlyphs.width);
            return true;
        };
        BarRendererBase.prototype.finalizeRenderer = function () {
            this.isFinalized = true;
        };
        BarRendererBase.prototype.doLayout = function () {
            if (!this.bar) {
                return;
            }
            this.helpers.initialize();
            this._preBeatGlyphs = new LeftToRightLayoutingGlyphGroup();
            this._preBeatGlyphs.renderer = this;
            this._voiceContainers.clear();
            this._postBeatGlyphs = new LeftToRightLayoutingGlyphGroup();
            this._postBeatGlyphs.renderer = this;
            for (var i = 0; i < this.bar.voices.length; i++) {
                var voice = this.bar.voices[i];
                if (this.hasVoiceContainer(voice)) {
                    var c = new VoiceContainerGlyph(0, 0, voice);
                    c.renderer = this;
                    this._voiceContainers.set(this.bar.voices[i].index, c);
                }
            }
            if (this.bar.simileMark === SimileMark.SecondOfDouble) {
                this.canWrap = false;
            }
            this.createPreBeatGlyphs();
            this.createBeatGlyphs();
            this.createPostBeatGlyphs();
            this.updateSizes();
            // finish up all helpers
            for (var _i = 0, _a = this.helpers.beamHelpers; _i < _a.length; _i++) {
                var v = _a[_i];
                for (var _b = 0, v_1 = v; _b < v_1.length; _b++) {
                    var h = v_1[_b];
                    h.finish();
                }
            }
        };
        BarRendererBase.prototype.hasVoiceContainer = function (voice) {
            return !voice.isEmpty || voice.index === 0;
        };
        BarRendererBase.prototype.updateSizes = function () {
            this.staff.registerStaffTop(this.topPadding);
            this.staff.registerStaffBottom(this.height - this.bottomPadding);
            var voiceContainers = this._voiceContainers;
            var beatGlyphsStart = this.beatGlyphsStart;
            var postBeatStart = beatGlyphsStart;
            voiceContainers.forEach(function (c) {
                c.x = beatGlyphsStart;
                c.doLayout();
                var x = c.x + c.width;
                if (postBeatStart < x) {
                    postBeatStart = x;
                }
            });
            this._postBeatGlyphs.x = Math.floor(postBeatStart);
            this.width = Math.ceil(this._postBeatGlyphs.x + this._postBeatGlyphs.width);
            this.height += this.layoutingInfo.height * this.scale;
        };
        BarRendererBase.prototype.addPreBeatGlyph = function (g) {
            g.renderer = this;
            this._preBeatGlyphs.addGlyph(g);
        };
        BarRendererBase.prototype.addBeatGlyph = function (g) {
            g.renderer = this;
            g.preNotes.renderer = this;
            g.onNotes.renderer = this;
            g.onNotes.beamingHelper = this.helpers.beamHelperLookup[g.beat.voice.index].get(g.beat.index);
            this.getVoiceContainer(g.beat.voice).addGlyph(g);
        };
        BarRendererBase.prototype.getVoiceContainer = function (voice) {
            return this._voiceContainers.get(voice.index);
        };
        BarRendererBase.prototype.getBeatContainer = function (beat) {
            var _a;
            return (_a = this.getVoiceContainer(beat.voice)) === null || _a === void 0 ? void 0 : _a.beatGlyphs[beat.index];
        };
        BarRendererBase.prototype.getPreNotesGlyphForBeat = function (beat) {
            var _a;
            return (_a = this.getBeatContainer(beat)) === null || _a === void 0 ? void 0 : _a.preNotes;
        };
        BarRendererBase.prototype.getOnNotesGlyphForBeat = function (beat) {
            var _a;
            return (_a = this.getBeatContainer(beat)) === null || _a === void 0 ? void 0 : _a.onNotes;
        };
        BarRendererBase.prototype.paint = function (cx, cy, canvas) {
            var _this = this;
            this.paintBackground(cx, cy, canvas);
            canvas.color = this.resources.mainGlyphColor;
            this._preBeatGlyphs.paint(cx + this.x, cy + this.y, canvas);
            this._voiceContainers.forEach(function (c) {
                canvas.color = c.voice.index === 0 ? _this.resources.mainGlyphColor : _this.resources.secondaryGlyphColor;
                c.paint(cx + _this.x, cy + _this.y, canvas);
            });
            canvas.color = this.resources.mainGlyphColor;
            this._postBeatGlyphs.paint(cx + this.x, cy + this.y, canvas);
        };
        BarRendererBase.prototype.paintBackground = function (cx, cy, canvas) {
            this.layoutingInfo.paint(cx + this.x + this._preBeatGlyphs.x + this._preBeatGlyphs.width, cy + this.y + this.height, canvas);
            // canvas.color = Color.random();
            // canvas.fillRect(cx + this.x + this._preBeatGlyphs.x, cy + this.y, this._preBeatGlyphs.width, this.height);
        };
        BarRendererBase.prototype.buildBoundingsLookup = function (masterBarBounds, cx, cy) {
            var _this = this;
            var barBounds = new BarBounds();
            barBounds.bar = this.bar;
            barBounds.visualBounds = new Bounds();
            barBounds.visualBounds.x = cx + this.x;
            barBounds.visualBounds.y = cy + this.y + this.topPadding;
            barBounds.visualBounds.w = this.width;
            barBounds.visualBounds.h = this.height - this.topPadding - this.bottomPadding;
            barBounds.realBounds = new Bounds();
            barBounds.realBounds.x = cx + this.x;
            barBounds.realBounds.y = cy + this.y;
            barBounds.realBounds.w = this.width;
            barBounds.realBounds.h = this.height;
            masterBarBounds.addBar(barBounds);
            this._voiceContainers.forEach(function (c, index) {
                var isEmptyBar = _this.bar.isEmpty && index === 0;
                if (!c.voice.isEmpty || isEmptyBar) {
                    for (var i = 0, j = c.beatGlyphs.length; i < j; i++) {
                        var bc = c.beatGlyphs[i];
                        bc.buildBoundingsLookup(barBounds, cx + _this.x + c.x, cy + _this.y + c.y, isEmptyBar);
                    }
                }
            });
        };
        BarRendererBase.prototype.addPostBeatGlyph = function (g) {
            this._postBeatGlyphs.addGlyph(g);
        };
        BarRendererBase.prototype.createPreBeatGlyphs = function () {
            this._wasFirstOfLine = this.isFirstOfLine;
        };
        BarRendererBase.prototype.createBeatGlyphs = function () {
            for (var v = 0; v < this.bar.voices.length; v++) {
                var voice = this.bar.voices[v];
                if (this.hasVoiceContainer(voice)) {
                    this.createVoiceGlyphs(this.bar.voices[v]);
                }
            }
        };
        BarRendererBase.prototype.createVoiceGlyphs = function (v) {
            // filled in subclasses
        };
        BarRendererBase.prototype.createPostBeatGlyphs = function () {
            // filled in subclasses
        };
        Object.defineProperty(BarRendererBase.prototype, "beatGlyphsStart", {
            get: function () {
                return this._preBeatGlyphs.x + this._preBeatGlyphs.width;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BarRendererBase.prototype, "postBeatGlyphsStart", {
            get: function () {
                return this._postBeatGlyphs.x;
            },
            enumerable: false,
            configurable: true
        });
        BarRendererBase.prototype.getBeatX = function (beat, requestedPosition) {
            if (requestedPosition === void 0) { requestedPosition = BeatXPosition.PreNotes; }
            var container = this.getBeatContainer(beat);
            if (container) {
                switch (requestedPosition) {
                    case BeatXPosition.PreNotes:
                        return container.voiceContainer.x + container.x;
                    case BeatXPosition.OnNotes:
                        return container.voiceContainer.x + container.x + container.onNotes.x;
                    case BeatXPosition.MiddleNotes:
                        return container.voiceContainer.x + container.x + container.onTimeX;
                    case BeatXPosition.Stem:
                        var offset = container.onNotes.beamingHelper
                            ? container.onNotes.beamingHelper.getBeatLineX(beat)
                            : container.onNotes.x + container.onNotes.width / 2;
                        return container.voiceContainer.x + offset;
                    case BeatXPosition.PostNotes:
                        return container.voiceContainer.x + container.x + container.onNotes.x + container.onNotes.width;
                    case BeatXPosition.EndBeat:
                        return container.voiceContainer.x + container.x + container.width;
                }
            }
            return 0;
        };
        BarRendererBase.prototype.getNoteX = function (note, requestedPosition) {
            var container = this.getBeatContainer(note.beat);
            if (container) {
                return (container.voiceContainer.x +
                    container.x +
                    container.onNotes.x +
                    container.onNotes.getNoteX(note, requestedPosition));
            }
            return 0;
        };
        BarRendererBase.prototype.getNoteY = function (note, requestedPosition) {
            var beat = this.getOnNotesGlyphForBeat(note.beat);
            if (beat) {
                return beat.getNoteY(note, requestedPosition);
            }
            return NaN;
        };
        BarRendererBase.prototype.reLayout = function () {
            // there are some glyphs which are shown only for renderers at the line start, so we simply recreate them
            // but we only need to recreate them for the renderers that were the first of the line or are now the first of the line
            if ((this._wasFirstOfLine && !this.isFirstOfLine) || (!this._wasFirstOfLine && this.isFirstOfLine)) {
                this._preBeatGlyphs = new LeftToRightLayoutingGlyphGroup();
                this._preBeatGlyphs.renderer = this;
                this.createPreBeatGlyphs();
            }
            this.updateSizes();
            this.registerLayoutingInfo();
        };
        BarRendererBase.prototype.paintSimileMark = function (cx, cy, canvas) {
            switch (this.bar.simileMark) {
                case SimileMark.Simple:
                    canvas.fillMusicFontSymbol(cx + this.x + (this.width - 20 * this.scale) / 2, cy + this.y + this.height / 2, 1, MusicFontSymbol.Repeat1Bar, false);
                    break;
                case SimileMark.SecondOfDouble:
                    canvas.fillMusicFontSymbol(cx + this.x - (28 * this.scale) / 2, cy + this.y + this.height / 2, 1, MusicFontSymbol.Repeat2Bars, false);
                    break;
            }
        };
        BarRendererBase.LineSpacing = 8;
        BarRendererBase.StemWidth = 0.12 /*bravura stemThickness */ * BarRendererBase.LineSpacing;
        BarRendererBase.StaffLineThickness = 0.13 /*bravura staffLineThickness */ * BarRendererBase.LineSpacing;
        BarRendererBase.BeamThickness = 0.5 /*bravura beamThickness */ * BarRendererBase.LineSpacing;
        BarRendererBase.BeamSpacing = 0.25 /*bravura beamSpacing */ * BarRendererBase.LineSpacing;
        return BarRendererBase;
    }());

    /**
     * Lists all sizing types of the effect bar glyphs
     */
    var EffectBarGlyphSizing;
    (function (EffectBarGlyphSizing) {
        /**
         * The effect glyph is placed above the pre-beat glyph which is before
         * the actual note in the area where also accidentals are renderered.
         */
        EffectBarGlyphSizing[EffectBarGlyphSizing["SinglePreBeat"] = 0] = "SinglePreBeat";
        /**
         * The effect glyph is placed above the on-beat glyph which is where
         * the actual note head glyphs are placed.
         */
        EffectBarGlyphSizing[EffectBarGlyphSizing["SingleOnBeat"] = 1] = "SingleOnBeat";
        /**
         * The effect glyph is placed above the on-beat glyph which is where
         * the actual note head glyphs are placed. The glyph will size to the end of
         * the applied beat.
         */
        EffectBarGlyphSizing[EffectBarGlyphSizing["SingleOnBeatToEnd"] = 2] = "SingleOnBeatToEnd";
        /**
         * The effect glyph is placed above the on-beat glyph and expaded to the
         * on-beat position of the next beat.
         */
        EffectBarGlyphSizing[EffectBarGlyphSizing["GroupedOnBeat"] = 3] = "GroupedOnBeat";
        /**
         * The effect glyph is placed above the on-beat glyph and expaded to the
         * on-beat position of the next beat. The glyph will size to the end of
         * the applied beat.
         */
        EffectBarGlyphSizing[EffectBarGlyphSizing["GroupedOnBeatToEnd"] = 4] = "GroupedOnBeatToEnd";
        /**
         * The effect glyph is placed on the whole bar covering the whole width
         */
        EffectBarGlyphSizing[EffectBarGlyphSizing["FullBar"] = 5] = "FullBar";
    })(EffectBarGlyphSizing || (EffectBarGlyphSizing = {}));

    var __extends$t = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var EffectBand = /** @class */ (function (_super) {
        __extends$t(EffectBand, _super);
        function EffectBand(voice, info) {
            var _this = _super.call(this, 0, 0) || this;
            _this._uniqueEffectGlyphs = [];
            _this._effectGlyphs = [];
            _this.isEmpty = true;
            _this.previousBand = null;
            _this.isLinkedToPrevious = false;
            _this.firstBeat = null;
            _this.lastBeat = null;
            _this.height = 0;
            _this.slot = null;
            _this.voice = voice;
            _this.info = info;
            return _this;
        }
        EffectBand.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            for (var i = 0; i < this.renderer.bar.voices.length; i++) {
                this._effectGlyphs.push(new Map());
                this._uniqueEffectGlyphs.push([]);
            }
        };
        EffectBand.prototype.createGlyph = function (beat) {
            if (beat.voice !== this.voice) {
                return;
            }
            // NOTE: the track order will never change. even if the staff behind the renderer changes, the trackIndex will not.
            // so it's okay to access the staff here while creating the glyphs.
            if (this.info.shouldCreateGlyph(this.renderer.settings, beat) &&
                (!this.info.hideOnMultiTrack || this.renderer.staff.trackIndex === 0)) {
                this.isEmpty = false;
                if (!this.firstBeat || beat.isBefore(this.firstBeat)) {
                    this.firstBeat = beat;
                }
                if (!this.lastBeat || beat.isAfter(this.lastBeat)) {
                    this.lastBeat = beat;
                    // for "toEnd" sizing occupy until next follow-up-beat
                    switch (this.info.sizingMode) {
                        case EffectBarGlyphSizing.SingleOnBeatToEnd:
                        case EffectBarGlyphSizing.GroupedOnBeatToEnd:
                            if (this.lastBeat.nextBeat) {
                                this.lastBeat = this.lastBeat.nextBeat;
                            }
                            break;
                    }
                }
                var glyph = this.createOrResizeGlyph(this.info.sizingMode, beat);
                if (glyph.height > this.height) {
                    this.height = glyph.height;
                }
            }
        };
        EffectBand.prototype.createOrResizeGlyph = function (sizing, b) {
            var g;
            switch (sizing) {
                case EffectBarGlyphSizing.FullBar:
                    g = this.info.createNewGlyph(this.renderer, b);
                    g.renderer = this.renderer;
                    g.beat = b;
                    g.doLayout();
                    this._effectGlyphs[b.voice.index].set(b.index, g);
                    this._uniqueEffectGlyphs[b.voice.index].push(g);
                    return g;
                case EffectBarGlyphSizing.SinglePreBeat:
                case EffectBarGlyphSizing.SingleOnBeat:
                case EffectBarGlyphSizing.SingleOnBeatToEnd:
                    g = this.info.createNewGlyph(this.renderer, b);
                    g.renderer = this.renderer;
                    g.beat = b;
                    g.doLayout();
                    this._effectGlyphs[b.voice.index].set(b.index, g);
                    this._uniqueEffectGlyphs[b.voice.index].push(g);
                    return g;
                case EffectBarGlyphSizing.GroupedOnBeat:
                case EffectBarGlyphSizing.GroupedOnBeatToEnd:
                    var singleSizing = sizing === EffectBarGlyphSizing.GroupedOnBeat
                        ? EffectBarGlyphSizing.SingleOnBeat
                        : EffectBarGlyphSizing.SingleOnBeatToEnd;
                    if (b.index > 0 || this.renderer.index > 0) {
                        // check if the previous beat also had this effect
                        var prevBeat = b.previousBeat;
                        if (this.info.shouldCreateGlyph(this.renderer.settings, prevBeat)) {
                            // first load the effect bar renderer and glyph
                            var prevEffect = null;
                            if (b.index > 0 && this._effectGlyphs[b.voice.index].has(prevBeat.index)) {
                                // load effect from previous beat in the same renderer
                                prevEffect = this._effectGlyphs[b.voice.index].get(prevBeat.index);
                            }
                            else if (this.renderer.index > 0) {
                                // load the effect from the previous renderer if possible.
                                var previousRenderer = this.renderer
                                    .previousRenderer;
                                var previousBand = previousRenderer.getBand(this.voice, this.info.effectId);
                                var voiceGlyphs = previousBand._effectGlyphs[b.voice.index];
                                if (voiceGlyphs.has(prevBeat.index)) {
                                    prevEffect = voiceGlyphs.get(prevBeat.index);
                                }
                            }
                            // if the effect cannot be expanded, create a new glyph
                            // in case of expansion also create a new glyph, but also link the glyphs together
                            // so for rendering it might be expanded.
                            var newGlyph = this.createOrResizeGlyph(singleSizing, b);
                            if (prevEffect && this.info.canExpand(prevBeat, b)) {
                                // link glyphs
                                prevEffect.nextGlyph = newGlyph;
                                newGlyph.previousGlyph = prevEffect;
                                // mark renderers as linked for consideration when layouting the renderers (line breaking, partial breaking)
                                this.isLinkedToPrevious = true;
                            }
                            return newGlyph;
                        }
                        // in case the previous beat did not have the same effect, we simply create a new glyph
                        return this.createOrResizeGlyph(singleSizing, b);
                    }
                    // in case of the very first beat, we simply create the glyph.
                    return this.createOrResizeGlyph(singleSizing, b);
                default:
                    return this.createOrResizeGlyph(EffectBarGlyphSizing.SingleOnBeat, b);
            }
        };
        EffectBand.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy, canvas);
            // canvas.LineWidth = 1;
            // canvas.StrokeRect(cx + X, cy + Y, Renderer.Width, Slot.Shared.Height);
            // canvas.LineWidth = 1.5f;
            for (var i = 0, j = this._uniqueEffectGlyphs.length; i < j; i++) {
                var v = this._uniqueEffectGlyphs[i];
                for (var k = 0, l = v.length; k < l; k++) {
                    var g = v[k];
                    g.paint(cx + this.x, cy + this.y, canvas);
                }
            }
        };
        EffectBand.prototype.alignGlyphs = function () {
            var _this = this;
            var _loop_1 = function (v) {
                this_1._effectGlyphs[v].forEach(function (g, beatIndex) {
                    _this.alignGlyph(_this.info.sizingMode, _this.renderer.bar.voices[v].beats[beatIndex]);
                });
            };
            var this_1 = this;
            for (var v = 0; v < this._effectGlyphs.length; v++) {
                _loop_1(v);
            }
        };
        EffectBand.prototype.alignGlyph = function (sizing, beat) {
            var g = this._effectGlyphs[beat.voice.index].get(beat.index);
            var pos;
            var container = this.renderer.getBeatContainer(beat);
            switch (sizing) {
                case EffectBarGlyphSizing.SinglePreBeat:
                    pos = container.preNotes;
                    g.x = this.renderer.beatGlyphsStart + pos.x + container.x;
                    g.width = pos.width;
                    break;
                case EffectBarGlyphSizing.SingleOnBeat:
                case EffectBarGlyphSizing.GroupedOnBeat:
                    pos = container.onNotes;
                    g.x = this.renderer.beatGlyphsStart + pos.x + container.x;
                    g.width = pos.width;
                    break;
                case EffectBarGlyphSizing.SingleOnBeatToEnd:
                case EffectBarGlyphSizing.GroupedOnBeatToEnd:
                    pos = container.onNotes;
                    g.x = this.renderer.beatGlyphsStart + pos.x + container.x;
                    if (container.beat.isLastOfVoice) {
                        g.width = this.renderer.width - g.x;
                    }
                    else {
                        g.width = container.width - container.preNotes.width - container.preNotes.x;
                    }
                    break;
                case EffectBarGlyphSizing.FullBar:
                    g.width = this.renderer.width;
                    break;
            }
        };
        return EffectBand;
    }(Glyph));

    var EffectBandSlotShared = /** @class */ (function () {
        function EffectBandSlotShared() {
            this.uniqueEffectId = null;
            this.y = 0;
            this.height = 0;
            this.firstBeat = null;
            this.lastBeat = null;
        }
        return EffectBandSlotShared;
    }());
    var EffectBandSlot = /** @class */ (function () {
        function EffectBandSlot() {
            this.bands = [];
            this.shared = new EffectBandSlotShared();
        }
        EffectBandSlot.prototype.update = function (effectBand) {
            // lock band to particular effect if needed
            if (!effectBand.info.canShareBand) {
                this.shared.uniqueEffectId = effectBand.info.effectId;
            }
            effectBand.slot = this;
            this.bands.push(effectBand);
            if (effectBand.height > this.shared.height) {
                this.shared.height = effectBand.height;
            }
            if (!this.shared.firstBeat || effectBand.firstBeat.isBefore(this.shared.firstBeat)) {
                this.shared.firstBeat = effectBand.firstBeat;
            }
            if (!this.shared.lastBeat || effectBand.lastBeat.isAfter(this.shared.lastBeat)) {
                this.shared.lastBeat = effectBand.lastBeat;
            }
        };
        EffectBandSlot.prototype.canBeUsed = function (band) {
            return (((!this.shared.uniqueEffectId && band.info.canShareBand) ||
                band.info.effectId === this.shared.uniqueEffectId) &&
                (!this.shared.firstBeat ||
                    this.shared.lastBeat.isBefore(band.firstBeat) ||
                    this.shared.lastBeat.isBefore(this.shared.firstBeat)));
        };
        return EffectBandSlot;
    }());

    var EffectBandSizingInfo = /** @class */ (function () {
        function EffectBandSizingInfo() {
            this.slots = [];
            this._effectSlot = new Map();
        }
        EffectBandSizingInfo.prototype.getOrCreateSlot = function (band) {
            // first check preferrable slot depending on type
            if (this._effectSlot.has(band.info.effectId)) {
                var slot = this._effectSlot.get(band.info.effectId);
                if (slot.canBeUsed(band)) {
                    return slot;
                }
            }
            // find any slot that can be used
            for (var _i = 0, _a = this.slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                if (slot.canBeUsed(band)) {
                    return slot;
                }
            }
            // create a new slot if required
            var newSlot = new EffectBandSlot();
            this.slots.push(newSlot);
            return newSlot;
        };
        EffectBandSizingInfo.prototype.register = function (effectBand) {
            var freeSlot = this.getOrCreateSlot(effectBand);
            freeSlot.update(effectBand);
            this._effectSlot.set(effectBand.info.effectId, freeSlot);
        };
        return EffectBandSizingInfo;
    }());

    var __extends$u = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BeatGlyphBase = /** @class */ (function (_super) {
        __extends$u(BeatGlyphBase, _super);
        function BeatGlyphBase() {
            return _super.call(this, 0, 0) || this;
        }
        BeatGlyphBase.prototype.doLayout = function () {
            // left to right layout
            var w = 0;
            if (this.glyphs) {
                for (var i = 0, j = this.glyphs.length; i < j; i++) {
                    var g = this.glyphs[i];
                    g.x = w;
                    g.renderer = this.renderer;
                    g.doLayout();
                    w += g.width;
                }
            }
            this.width = w;
        };
        BeatGlyphBase.prototype.noteLoop = function (action) {
            for (var i = this.container.beat.notes.length - 1; i >= 0; i--) {
                action(this.container.beat.notes[i]);
            }
        };
        return BeatGlyphBase;
    }(GlyphGroup));

    var __extends$v = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BeatOnNoteGlyphBase = /** @class */ (function (_super) {
        __extends$v(BeatOnNoteGlyphBase, _super);
        function BeatOnNoteGlyphBase() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.centerX = 0;
            return _this;
        }
        BeatOnNoteGlyphBase.prototype.updateBeamingHelper = function () {
            //
        };
        BeatOnNoteGlyphBase.prototype.buildBoundingsLookup = function (beatBounds, cx, cy) {
            // implemented in subclasses
        };
        BeatOnNoteGlyphBase.prototype.getNoteX = function (note, requestedPosition) {
            return 0;
        };
        BeatOnNoteGlyphBase.prototype.getNoteY = function (note, requestedPosition) {
            return 0;
        };
        return BeatOnNoteGlyphBase;
    }(BeatGlyphBase));

    var __extends$w = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This renderer is responsible for displaying effects above or below the other staves
     * like the vibrato.
     */
    var EffectBarRenderer = /** @class */ (function (_super) {
        __extends$w(EffectBarRenderer, _super);
        function EffectBarRenderer(renderer, bar, infos) {
            var _this = _super.call(this, renderer, bar) || this;
            _this._bands = [];
            _this._bandLookup = new Map();
            _this.sizingInfo = null;
            _this._infos = infos;
            return _this;
        }
        EffectBarRenderer.prototype.updateSizes = function () {
            this.topOverflow = 0;
            this.bottomOverflow = 0;
            this.topPadding = 0;
            this.bottomPadding = 0;
            this.updateHeight();
            _super.prototype.updateSizes.call(this);
        };
        EffectBarRenderer.prototype.finalizeRenderer = function () {
            _super.prototype.finalizeRenderer.call(this);
            this.updateHeight();
        };
        EffectBarRenderer.prototype.updateHeight = function () {
            if (!this.sizingInfo) {
                return;
            }
            var y = 0;
            for (var _i = 0, _a = this.sizingInfo.slots; _i < _a.length; _i++) {
                var slot = _a[_i];
                slot.shared.y = y;
                for (var _b = 0, _c = slot.bands; _b < _c.length; _b++) {
                    var band = _c[_b];
                    band.y = y;
                    band.height = slot.shared.height;
                }
                y += slot.shared.height;
            }
            this.height = y;
        };
        EffectBarRenderer.prototype.applyLayoutingInfo = function () {
            if (!_super.prototype.applyLayoutingInfo.call(this)) {
                return false;
            }
            // we create empty slots for the same group
            if (this.index > 0) {
                var previousRenderer = this.previousRenderer;
                this.sizingInfo = previousRenderer.sizingInfo;
            }
            else {
                this.sizingInfo = new EffectBandSizingInfo();
            }
            for (var _i = 0, _a = this._bands; _i < _a.length; _i++) {
                var effectBand = _a[_i];
                effectBand.alignGlyphs();
                if (!effectBand.isEmpty) {
                    // find a slot that ended before the start of the band
                    this.sizingInfo.register(effectBand);
                }
            }
            this.updateHeight();
            return true;
        };
        EffectBarRenderer.prototype.scaleToWidth = function (width) {
            _super.prototype.scaleToWidth.call(this, width);
            for (var _i = 0, _a = this._bands; _i < _a.length; _i++) {
                var effectBand = _a[_i];
                effectBand.alignGlyphs();
            }
        };
        EffectBarRenderer.prototype.createBeatGlyphs = function () {
            this._bands = [];
            this._bandLookup = new Map();
            for (var _i = 0, _a = this.bar.voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                if (this.hasVoiceContainer(voice)) {
                    for (var _b = 0, _c = this._infos; _b < _c.length; _b++) {
                        var info = _c[_b];
                        var band = new EffectBand(voice, info);
                        band.renderer = this;
                        band.doLayout();
                        this._bands.push(band);
                        this._bandLookup.set(voice.index + '.' + info.effectId, band);
                    }
                }
            }
            for (var _d = 0, _e = this.bar.voices; _d < _e.length; _d++) {
                var voice = _e[_d];
                if (this.hasVoiceContainer(voice)) {
                    this.createVoiceGlyphs(voice);
                }
            }
            for (var _f = 0, _g = this._bands; _f < _g.length; _f++) {
                var effectBand = _g[_f];
                if (effectBand.isLinkedToPrevious) {
                    this.isLinkedToPrevious = true;
                }
            }
        };
        EffectBarRenderer.prototype.createVoiceGlyphs = function (v) {
            for (var _i = 0, _a = v.beats; _i < _a.length; _i++) {
                var b = _a[_i];
                // we create empty glyphs as alignment references and to get the
                // effect bar sized
                var container = new BeatContainerGlyph(b, this.getVoiceContainer(v));
                container.preNotes = new BeatGlyphBase();
                container.onNotes = new BeatOnNoteGlyphBase();
                this.addBeatGlyph(container);
                for (var _b = 0, _c = this._bands; _b < _c.length; _b++) {
                    var effectBand = _c[_b];
                    effectBand.createGlyph(b);
                }
            }
        };
        EffectBarRenderer.prototype.paint = function (cx, cy, canvas) {
            this.paintBackground(cx, cy, canvas);
            // canvas.color = new Color(255, 0, 0, 100);
            // canvas.fillRect(cx + this.x, cy + this.y, this.width, this.height);
            for (var _i = 0, _a = this._bands; _i < _a.length; _i++) {
                var effectBand = _a[_i];
                canvas.color =
                    effectBand.voice.index === 0 ? this.resources.mainGlyphColor : this.resources.secondaryGlyphColor;
                if (!effectBand.isEmpty) {
                    effectBand.paint(cx + this.x, cy + this.y, canvas);
                }
            }
        };
        EffectBarRenderer.prototype.getBand = function (voice, effectId) {
            var id = voice.index + '.' + effectId;
            if (this._bandLookup.has(id)) {
                return this._bandLookup.get(id);
            }
            return null;
        };
        return EffectBarRenderer;
    }(BarRendererBase));

    var __extends$x = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var EffectBarRendererFactory = /** @class */ (function (_super) {
        __extends$x(EffectBarRendererFactory, _super);
        function EffectBarRendererFactory(staffId, infos) {
            var _this = _super.call(this) || this;
            _this._infos = infos;
            _this._staffId = staffId;
            _this.isInAccolade = false;
            _this.isRelevantForBoundsLookup = false;
            return _this;
        }
        Object.defineProperty(EffectBarRendererFactory.prototype, "staffId", {
            get: function () {
                return this._staffId;
            },
            enumerable: false,
            configurable: true
        });
        EffectBarRendererFactory.prototype.create = function (renderer, bar) {
            return new EffectBarRenderer(renderer, bar, this._infos.filter(function (i) { return renderer.settings.notation.isNotationElementVisible(i.notationElement); }));
        };
        return EffectBarRendererFactory;
    }(BarRendererFactory));

    var __extends$y = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var AlternateEndingsGlyph = /** @class */ (function (_super) {
        __extends$y(AlternateEndingsGlyph, _super);
        function AlternateEndingsGlyph(x, y, alternateEndings) {
            var _this = _super.call(this, x, y) || this;
            _this._endingsString = "";
            _this._endings = [];
            for (var i = 0; i < MasterBar.MaxAlternateEndings; i++) {
                if ((alternateEndings & (0x01 << i)) !== 0) {
                    _this._endings.push(i);
                }
            }
            return _this;
        }
        AlternateEndingsGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = this.renderer.resources.wordsFont.size + (AlternateEndingsGlyph.Padding * this.scale + 2);
            var endingsStrings = '';
            for (var i = 0, j = this._endings.length; i < j; i++) {
                endingsStrings += this._endings[i] + 1;
                endingsStrings += '. ';
            }
            this._endingsString = endingsStrings;
        };
        AlternateEndingsGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy, canvas);
            var baseline = canvas.textBaseline;
            canvas.textBaseline = TextBaseline.Top;
            if (this._endings.length > 0) {
                var res = this.renderer.resources;
                canvas.font = res.wordsFont;
                canvas.moveTo(cx + this.x, cy + this.y + this.height);
                canvas.lineTo(cx + this.x, cy + this.y);
                canvas.lineTo(cx + this.x + this.width, cy + this.y);
                canvas.stroke();
                canvas.fillText(this._endingsString, cx + this.x + AlternateEndingsGlyph.Padding * this.scale, cy + this.y * this.scale);
            }
            canvas.textBaseline = baseline;
        };
        AlternateEndingsGlyph.Padding = 3;
        return AlternateEndingsGlyph;
    }(EffectGlyph));

    /**
     * A classes inheriting from this base can provide the
     * data needed by a EffectBarRenderer to create effect glyphs dynamically.
     */
    var EffectBarRendererInfo = /** @class */ (function () {
        function EffectBarRendererInfo() {
        }
        Object.defineProperty(EffectBarRendererInfo.prototype, "effectId", {
            /**
             * Gets the unique effect name for this effect. (Used for grouping)
             */
            get: function () {
                return this.notationElement.toString();
            },
            enumerable: false,
            configurable: true
        });
        return EffectBarRendererInfo;
    }());

    var __extends$z = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var AlternateEndingsEffectInfo = /** @class */ (function (_super) {
        __extends$z(AlternateEndingsEffectInfo, _super);
        function AlternateEndingsEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(AlternateEndingsEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectAlternateEndings;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlternateEndingsEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlternateEndingsEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(AlternateEndingsEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.FullBar;
            },
            enumerable: false,
            configurable: true
        });
        AlternateEndingsEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.voice.index === 0 && beat.index === 0 && beat.voice.bar.masterBar.alternateEndings !== 0;
        };
        AlternateEndingsEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new AlternateEndingsGlyph(0, 0, beat.voice.bar.masterBar.alternateEndings);
        };
        AlternateEndingsEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return AlternateEndingsEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$A = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TextGlyph = /** @class */ (function (_super) {
        __extends$A(TextGlyph, _super);
        function TextGlyph(x, y, text, font, textAlign) {
            if (textAlign === void 0) { textAlign = TextAlign.Left; }
            var _this = _super.call(this, x, y) || this;
            _this._lines = text.split('\n');
            _this.font = font;
            _this.textAlign = textAlign;
            return _this;
        }
        TextGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = this.font.size * this._lines.length;
        };
        TextGlyph.prototype.paint = function (cx, cy, canvas) {
            var color = canvas.color;
            canvas.color = color;
            canvas.font = this.font;
            var old = canvas.textAlign;
            canvas.textAlign = this.textAlign;
            var y = cy + this.y;
            for (var _i = 0, _a = this._lines; _i < _a.length; _i++) {
                var line = _a[_i];
                canvas.fillText(line, cx + this.x, y);
                y += this.font.size;
            }
            canvas.textAlign = old;
        };
        return TextGlyph;
    }(EffectGlyph));

    var __extends$B = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CapoEffectInfo = /** @class */ (function (_super) {
        __extends$B(CapoEffectInfo, _super);
        function CapoEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(CapoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectCapo;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CapoEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CapoEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CapoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        CapoEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.index === 0 && beat.voice.bar.index === 0 && beat.voice.bar.staff.capo !== 0;
        };
        CapoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new TextGlyph(0, 0, 'Capo. fret ' + beat.voice.bar.staff.capo, renderer.resources.effectFont, TextAlign.Left);
        };
        CapoEffectInfo.prototype.canExpand = function (from, to) {
            return false;
        };
        return CapoEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$C = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ChordsEffectInfo = /** @class */ (function (_super) {
        __extends$C(ChordsEffectInfo, _super);
        function ChordsEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ChordsEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectChordNames;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChordsEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChordsEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ChordsEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        ChordsEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.hasChord;
        };
        ChordsEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new TextGlyph(0, 0, beat.chord.name, renderer.resources.effectFont, TextAlign.Center);
        };
        ChordsEffectInfo.prototype.canExpand = function (from, to) {
            return false;
        };
        return ChordsEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$D = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GroupedEffectGlyph = /** @class */ (function (_super) {
        __extends$D(GroupedEffectGlyph, _super);
        function GroupedEffectGlyph(endPosition) {
            var _this = _super.call(this) || this;
            _this.forceGroupedRendering = false;
            _this.endOnBarLine = false;
            _this.endPosition = endPosition;
            return _this;
        }
        Object.defineProperty(GroupedEffectGlyph.prototype, "isLinkedWithPrevious", {
            get: function () {
                return !!this.previousGlyph && this.previousGlyph.renderer.staff.staveGroup === this.renderer.staff.staveGroup;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(GroupedEffectGlyph.prototype, "isLinkedWithNext", {
            get: function () {
                return (!!this.nextGlyph &&
                    this.nextGlyph.renderer.isFinalized &&
                    this.nextGlyph.renderer.staff.staveGroup === this.renderer.staff.staveGroup);
            },
            enumerable: false,
            configurable: true
        });
        GroupedEffectGlyph.prototype.paint = function (cx, cy, canvas) {
            // if we are linked with the previous, the first glyph of the group will also render this one.
            if (this.isLinkedWithPrevious) {
                return;
            }
            // we are not linked with any glyph therefore no expansion is required, we render a simple glyph.
            if (!this.isLinkedWithNext && !this.forceGroupedRendering) {
                this.paintNonGrouped(cx, cy, canvas);
                return;
            }
            // find last linked glyph that can be
            var lastLinkedGlyph;
            if (!this.isLinkedWithNext && this.forceGroupedRendering) {
                lastLinkedGlyph = this;
            }
            else {
                lastLinkedGlyph = this.nextGlyph;
                while (lastLinkedGlyph.isLinkedWithNext) {
                    lastLinkedGlyph = lastLinkedGlyph.nextGlyph;
                }
            }
            // use start position of next beat when possible
            var endBeatRenderer = lastLinkedGlyph.renderer;
            var endBeat = lastLinkedGlyph.beat;
            var position = this.endPosition;
            // calculate end X-position
            var cxRenderer = cx - this.renderer.x;
            var endX = this.calculateEndX(endBeatRenderer, endBeat, cxRenderer, position);
            this.paintGrouped(cx, cy, endX, canvas);
        };
        GroupedEffectGlyph.prototype.calculateEndX = function (endBeatRenderer, endBeat, cx, endPosition) {
            if (!endBeat) {
                return cx + endBeatRenderer.x + this.x + this.width;
            }
            return cx + endBeatRenderer.x + endBeatRenderer.getBeatX(endBeat, endPosition);
        };
        GroupedEffectGlyph.prototype.paintNonGrouped = function (cx, cy, canvas) {
            var cxRenderer = cx - this.renderer.x;
            var endX = this.calculateEndX(this.renderer, this.beat, cxRenderer, this.endPosition);
            this.paintGrouped(cx, cy, endX, canvas);
        };
        return GroupedEffectGlyph;
    }(EffectGlyph));

    var __extends$E = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CrescendoGlyph = /** @class */ (function (_super) {
        __extends$E(CrescendoGlyph, _super);
        function CrescendoGlyph(x, y, crescendo) {
            var _this = _super.call(this, BeatXPosition.EndBeat) || this;
            _this._crescendo = CrescendoType.None;
            _this._crescendo = crescendo;
            _this.x = x;
            _this.y = y;
            return _this;
        }
        CrescendoGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 17 * this.scale;
        };
        CrescendoGlyph.prototype.paintGrouped = function (cx, cy, endX, canvas) {
            var startX = cx + this.x;
            var height = this.height * this.scale;
            canvas.beginPath();
            if (this._crescendo === CrescendoType.Crescendo) {
                endX -= CrescendoGlyph.Padding * this.scale;
                canvas.moveTo(endX, cy + this.y);
                canvas.lineTo(startX, cy + this.y + height / 2);
                canvas.lineTo(endX, cy + this.y + height);
            }
            else {
                endX -= CrescendoGlyph.Padding * this.scale;
                canvas.moveTo(startX, cy + this.y);
                canvas.lineTo(endX, cy + this.y + height / 2);
                canvas.lineTo(startX, cy + this.y + height);
            }
            canvas.stroke();
        };
        CrescendoGlyph.Padding = (NoteHeadGlyph.QuarterNoteHeadWidth / 2) | 0;
        return CrescendoGlyph;
    }(GroupedEffectGlyph));

    var __extends$F = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CrescendoEffectInfo = /** @class */ (function (_super) {
        __extends$F(CrescendoEffectInfo, _super);
        function CrescendoEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(CrescendoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectCrescendo;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CrescendoEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CrescendoEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(CrescendoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeatToEnd;
            },
            enumerable: false,
            configurable: true
        });
        CrescendoEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.crescendo !== CrescendoType.None;
        };
        CrescendoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new CrescendoGlyph(0, 0, beat.crescendo);
        };
        CrescendoEffectInfo.prototype.canExpand = function (from, to) {
            return from.crescendo === to.crescendo;
        };
        return CrescendoEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$G = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DynamicsGlyph = /** @class */ (function (_super) {
        __extends$G(DynamicsGlyph, _super);
        function DynamicsGlyph(x, y, dynamics) {
            return _super.call(this, x, y, 0.6, DynamicsGlyph.getSymbol(dynamics)) || this;
        }
        DynamicsGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 17 * this.scale;
            this.y += this.height / 2;
        };
        DynamicsGlyph.getSymbol = function (dynamics) {
            switch (dynamics) {
                case DynamicValue.PPP:
                    return MusicFontSymbol.DynamicPPP;
                case DynamicValue.PP:
                    return MusicFontSymbol.DynamicPP;
                case DynamicValue.P:
                    return MusicFontSymbol.DynamicPiano;
                case DynamicValue.MP:
                    return MusicFontSymbol.DynamicMP;
                case DynamicValue.MF:
                    return MusicFontSymbol.DynamicMF;
                case DynamicValue.F:
                    return MusicFontSymbol.DynamicForte;
                case DynamicValue.FF:
                    return MusicFontSymbol.DynamicFF;
                case DynamicValue.FFF:
                    return MusicFontSymbol.DynamicFFF;
                default:
                    return MusicFontSymbol.None;
            }
        };
        return DynamicsGlyph;
    }(MusicFontGlyph));

    var __extends$H = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DynamicsEffectInfo = /** @class */ (function (_super) {
        __extends$H(DynamicsEffectInfo, _super);
        function DynamicsEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(DynamicsEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectDynamics;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicsEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicsEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DynamicsEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        DynamicsEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return this.internalShouldCreateGlyph(beat);
        };
        DynamicsEffectInfo.prototype.internalShouldCreateGlyph = function (beat) {
            if (beat.voice.bar.staff.track.score.stylesheet.hideDynamics || beat.isEmpty || beat.voice.isEmpty) {
                return false;
            }
            var show = (beat.voice.index === 0 && beat.index === 0 && beat.voice.bar.index === 0) ||
                (!!beat.previousBeat && beat.dynamics !== beat.previousBeat.dynamics);
            // ensure we do not show duplicate dynamics
            if (show && beat.voice.index > 0) {
                for (var _i = 0, _a = beat.voice.bar.voices; _i < _a.length; _i++) {
                    var voice = _a[_i];
                    if (voice.index < beat.voice.index) {
                        var beatAtSamePos = voice.getBeatAtDisplayStart(beat.displayStart);
                        if (beatAtSamePos &&
                            beat.dynamics === beatAtSamePos.dynamics &&
                            this.internalShouldCreateGlyph(beatAtSamePos)) {
                            show = false;
                        }
                    }
                }
            }
            return show;
        };
        DynamicsEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new DynamicsGlyph(0, 0, beat.dynamics);
        };
        DynamicsEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return DynamicsEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$I = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FadeInGlyph = /** @class */ (function (_super) {
        __extends$I(FadeInGlyph, _super);
        function FadeInGlyph() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FadeInGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 17 * this.scale;
        };
        FadeInGlyph.prototype.paint = function (cx, cy, canvas) {
            var size = 6 * this.scale;
            var width = Math.max(this.width, 14 * this.scale);
            var offset = this.height / 2;
            canvas.beginPath();
            canvas.moveTo(cx + this.x, cy + this.y + offset);
            canvas.quadraticCurveTo(cx + this.x + width / 2, cy + this.y + offset, cx + this.x + width, cy + this.y + offset - size);
            canvas.moveTo(cx + this.x, cy + this.y + offset);
            canvas.quadraticCurveTo(cx + this.x + width / 2, cy + this.y + offset, cx + this.x + width, cy + this.y + offset + size);
            canvas.stroke();
        };
        return FadeInGlyph;
    }(EffectGlyph));

    var __extends$J = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FadeInEffectInfo = /** @class */ (function (_super) {
        __extends$J(FadeInEffectInfo, _super);
        function FadeInEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(FadeInEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectFadeIn;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FadeInEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FadeInEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FadeInEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        FadeInEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.fadeIn;
        };
        FadeInEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new FadeInGlyph();
        };
        FadeInEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return FadeInEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$K = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FermataGlyph = /** @class */ (function (_super) {
        __extends$K(FermataGlyph, _super);
        function FermataGlyph(x, y, fermata) {
            return _super.call(this, x, y, 1, FermataGlyph.getSymbol(fermata)) || this;
        }
        FermataGlyph.getSymbol = function (accentuation) {
            switch (accentuation) {
                case FermataType.Short:
                    return MusicFontSymbol.FermataShortAbove;
                case FermataType.Medium:
                    return MusicFontSymbol.FermataAbove;
                case FermataType.Long:
                    return MusicFontSymbol.FermataLongAbove;
                default:
                    return MusicFontSymbol.None;
            }
        };
        FermataGlyph.prototype.doLayout = function () {
            this.width = 23 * this.scale;
            this.height = 12 * this.scale;
        };
        FermataGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx - this.width / 2, cy + this.height, canvas);
        };
        return FermataGlyph;
    }(MusicFontGlyph));

    var __extends$L = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FermataEffectInfo = /** @class */ (function (_super) {
        __extends$L(FermataEffectInfo, _super);
        function FermataEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(FermataEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectFermata;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FermataEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FermataEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FermataEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        FermataEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.voice.index === 0 && !!beat.fermata;
        };
        FermataEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new FermataGlyph(0, 0, beat.fermata.type);
        };
        FermataEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return FermataEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$M = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var FingeringEffectInfo = /** @class */ (function (_super) {
        __extends$M(FingeringEffectInfo, _super);
        function FingeringEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(FingeringEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectFingering;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FingeringEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FingeringEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FingeringEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        FingeringEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            if (beat.voice.index !== 0 ||
                beat.isRest ||
                (settings.notation.fingeringMode !== exports.FingeringMode.SingleNoteEffectBand &&
                    settings.notation.fingeringMode !== exports.FingeringMode.SingleNoteEffectBandForcePiano)) {
                return false;
            }
            if (beat.notes.length !== 1) {
                return false;
            }
            return beat.notes[0].isFingering;
        };
        FingeringEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            var _a;
            var finger = Fingers.Unknown;
            var isLeft = false;
            var note = beat.notes[0];
            if (note.leftHandFinger !== Fingers.Unknown) {
                finger = note.leftHandFinger;
                isLeft = true;
            }
            else if (note.rightHandFinger !== Fingers.Unknown) {
                finger = note.rightHandFinger;
            }
            var s = (_a = ModelUtils.fingerToString(renderer.settings, beat, finger, isLeft)) !== null && _a !== void 0 ? _a : "";
            return new TextGlyph(0, 0, s, renderer.resources.fingeringFont, TextAlign.Left);
        };
        FingeringEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return FingeringEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$N = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var NoteEffectInfoBase = /** @class */ (function (_super) {
        __extends$N(NoteEffectInfoBase, _super);
        function NoteEffectInfoBase() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.lastCreateInfo = null;
            return _this;
        }
        NoteEffectInfoBase.prototype.shouldCreateGlyph = function (settings, beat) {
            this.lastCreateInfo = [];
            for (var i = 0, j = beat.notes.length; i < j; i++) {
                var n = beat.notes[i];
                if (this.shouldCreateGlyphForNote(n)) {
                    this.lastCreateInfo.push(n);
                }
            }
            return this.lastCreateInfo.length > 0;
        };
        Object.defineProperty(NoteEffectInfoBase.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NoteEffectInfoBase.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        NoteEffectInfoBase.prototype.canExpand = function (from, to) {
            return true;
        };
        return NoteEffectInfoBase;
    }(EffectBarRendererInfo));

    var __extends$O = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LineRangedGlyph = /** @class */ (function (_super) {
        __extends$O(LineRangedGlyph, _super);
        function LineRangedGlyph(label) {
            var _this = _super.call(this, BeatXPosition.OnNotes) || this;
            _this._label = label;
            return _this;
        }
        LineRangedGlyph.prototype.doLayout = function () {
            if (this.renderer.settings.notation.extendLineEffectsToBeatEnd) {
                this.endPosition = BeatXPosition.EndBeat;
                this.forceGroupedRendering = true;
            }
            _super.prototype.doLayout.call(this);
            this.height = this.renderer.resources.effectFont.size;
        };
        LineRangedGlyph.prototype.paintNonGrouped = function (cx, cy, canvas) {
            var res = this.renderer.resources;
            canvas.font = res.effectFont;
            var x = canvas.textAlign;
            canvas.textAlign = TextAlign.Center;
            canvas.fillText(this._label, cx + this.x, cy + this.y);
            canvas.textAlign = x;
        };
        LineRangedGlyph.prototype.paintGrouped = function (cx, cy, endX, canvas) {
            this.paintNonGrouped(cx, cy, canvas);
            var lineSpacing = 3 * this.scale;
            var textWidth = canvas.measureText(this._label);
            var startX = cx + this.x + textWidth / 2 + lineSpacing;
            var lineY = cy + this.y + 4 * this.scale;
            var lineSize = 8 * this.scale;
            if (endX > startX) {
                var lineX = startX;
                while (lineX < endX) {
                    canvas.beginPath();
                    canvas.moveTo(lineX, lineY | 0);
                    canvas.lineTo(Math.min(lineX + lineSize, endX), lineY | 0);
                    lineX += lineSize + lineSpacing;
                    canvas.stroke();
                }
                canvas.beginPath();
                canvas.moveTo(endX, (lineY - 5 * this.scale) | 0);
                canvas.lineTo(endX, (lineY + 5 * this.scale) | 0);
                canvas.stroke();
            }
        };
        LineRangedGlyph.LineSpacing = 3;
        LineRangedGlyph.LineTopPadding = 4;
        LineRangedGlyph.LineTopOffset = 5;
        LineRangedGlyph.LineSize = 8;
        return LineRangedGlyph;
    }(GroupedEffectGlyph));

    var __extends$P = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var HarmonicsEffectInfo = /** @class */ (function (_super) {
        __extends$P(HarmonicsEffectInfo, _super);
        function HarmonicsEffectInfo(harmonicType) {
            var _this = _super.call(this) || this;
            _this._beat = null;
            _this._harmonicType = HarmonicType.None;
            _this._harmonicType = harmonicType;
            switch (harmonicType) {
                case HarmonicType.None:
                    _this._effectId = 'harmonics-none';
                    break;
                case HarmonicType.Natural:
                    _this._effectId = 'harmonics-natural';
                    break;
                case HarmonicType.Artificial:
                    _this._effectId = 'harmonics-artificial';
                    break;
                case HarmonicType.Pinch:
                    _this._effectId = 'harmonics-pinch';
                    break;
                case HarmonicType.Tap:
                    _this._effectId = 'harmonics-tap';
                    break;
                case HarmonicType.Semi:
                    _this._effectId = 'harmonics-semi';
                    break;
                case HarmonicType.Feedback:
                    _this._effectId = 'harmonics-feedback';
                    break;
            }
            return _this;
        }
        Object.defineProperty(HarmonicsEffectInfo.prototype, "effectId", {
            get: function () {
                return this._effectId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HarmonicsEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectHarmonics;
            },
            enumerable: false,
            configurable: true
        });
        HarmonicsEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            if (!note.isHarmonic || note.harmonicType !== this._harmonicType) {
                return false;
            }
            if (note.beat !== this._beat) {
                this._beat = note.beat;
            }
            return true;
        };
        Object.defineProperty(HarmonicsEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        HarmonicsEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LineRangedGlyph(HarmonicsEffectInfo.harmonicToString(this._harmonicType));
        };
        HarmonicsEffectInfo.harmonicToString = function (type) {
            switch (type) {
                case HarmonicType.Natural:
                    return 'N.H.';
                case HarmonicType.Artificial:
                    return 'A.H.';
                case HarmonicType.Pinch:
                    return 'P.H.';
                case HarmonicType.Tap:
                    return 'T.H.';
                case HarmonicType.Semi:
                    return 'S.H.';
                case HarmonicType.Feedback:
                    return 'Fdbk.';
            }
            return '';
        };
        return HarmonicsEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$Q = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LetRingEffectInfo = /** @class */ (function (_super) {
        __extends$Q(LetRingEffectInfo, _super);
        function LetRingEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(LetRingEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectLetRing;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LetRingEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LetRingEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        LetRingEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.isLetRing;
        };
        Object.defineProperty(LetRingEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        LetRingEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LineRangedGlyph('LetRing');
        };
        LetRingEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return LetRingEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$R = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LyricsGlyph = /** @class */ (function (_super) {
        __extends$R(LyricsGlyph, _super);
        function LyricsGlyph(x, y, lines, font, textAlign) {
            if (textAlign === void 0) { textAlign = TextAlign.Center; }
            var _this = _super.call(this, x, y) || this;
            _this._lines = lines;
            _this.font = font;
            _this.textAlign = textAlign;
            return _this;
        }
        LyricsGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = this.font.size * this._lines.length;
        };
        LyricsGlyph.prototype.paint = function (cx, cy, canvas) {
            canvas.font = this.font;
            var old = canvas.textAlign;
            canvas.textAlign = this.textAlign;
            for (var i = 0; i < this._lines.length; i++) {
                if (this._lines[i]) {
                    canvas.fillText(this._lines[i], cx + this.x, cy + this.y + i * this.font.size);
                }
            }
            canvas.textAlign = old;
        };
        return LyricsGlyph;
    }(EffectGlyph));

    var __extends$S = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LyricsEffectInfo = /** @class */ (function (_super) {
        __extends$S(LyricsEffectInfo, _super);
        function LyricsEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(LyricsEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectLyrics;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyricsEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyricsEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LyricsEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        LyricsEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return !!beat.lyrics;
        };
        LyricsEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LyricsGlyph(0, 0, beat.lyrics, renderer.resources.effectFont, TextAlign.Center);
        };
        LyricsEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return LyricsEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$T = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var MarkerEffectInfo = /** @class */ (function (_super) {
        __extends$T(MarkerEffectInfo, _super);
        function MarkerEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MarkerEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectMarker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MarkerEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MarkerEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MarkerEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SinglePreBeat;
            },
            enumerable: false,
            configurable: true
        });
        MarkerEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return (beat.voice.bar.staff.index === 0 &&
                beat.voice.index === 0 &&
                beat.index === 0 &&
                beat.voice.bar.masterBar.isSectionStart);
        };
        MarkerEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new TextGlyph(0, 0, !beat.voice.bar.masterBar.section.marker
                ? beat.voice.bar.masterBar.section.text
                : '[' + beat.voice.bar.masterBar.section.marker + '] ' + beat.voice.bar.masterBar.section.text, renderer.resources.markerFont, TextAlign.Left);
        };
        MarkerEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return MarkerEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$U = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var OttavaGlyph = /** @class */ (function (_super) {
        __extends$U(OttavaGlyph, _super);
        function OttavaGlyph(ottava, aboveStaff) {
            var _this = _super.call(this, BeatXPosition.PostNotes) || this;
            _this._ottava = ottava;
            _this._aboveStaff = aboveStaff;
            return _this;
        }
        OttavaGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 13 * this.scale;
        };
        OttavaGlyph.prototype.paintNonGrouped = function (cx, cy, canvas) {
            this.paintOttava(cx, cy, canvas);
        };
        OttavaGlyph.prototype.paintOttava = function (cx, cy, canvas) {
            var size = 0;
            switch (this._ottava) {
                case Ottavia._15ma:
                    size = 37 * this.scale;
                    canvas.fillMusicFontSymbol(cx + this.x - size / 2, cy + this.y + this.height, 0.8, MusicFontSymbol.QuindicesimaAlta, false);
                    break;
                case Ottavia._8va:
                    size = 26 * this.scale;
                    canvas.fillMusicFontSymbol(cx + this.x - size / 2, cy + this.y + this.height, 0.8, MusicFontSymbol.OttavaAlta, false);
                    break;
                case Ottavia._8vb:
                    size = 23 * this.scale;
                    canvas.fillMusicFontSymbol(cx + this.x - size / 2, cy + this.y + this.height, 0.8, MusicFontSymbol.OttavaBassaVb, false);
                    break;
                case Ottavia._15mb:
                    size = 36 * this.scale;
                    // NOTE: SMUFL does not have a glyph for 15mb so we build it
                    canvas.fillMusicFontSymbols(cx + this.x - size / 2, cy + this.y + this.height, 0.8, [MusicFontSymbol.Quindicesima, MusicFontSymbol.OctaveBaselineM, MusicFontSymbol.OctaveBaselineB], false);
                    break;
            }
            return size / 2;
        };
        OttavaGlyph.prototype.paintGrouped = function (cx, cy, endX, canvas) {
            var size = this.paintOttava(cx, cy, canvas);
            var lineSpacing = 3 * this.scale;
            var startX = cx + this.x + size + lineSpacing;
            var lineY = cy + this.y;
            lineY += this._aboveStaff ? 2 * this.scale : this.height - 2 * this.scale;
            var lineSize = 8 * this.scale;
            if (endX > startX) {
                var lineX = startX;
                while (lineX < endX) {
                    canvas.beginPath();
                    canvas.moveTo(lineX, lineY | 0);
                    canvas.lineTo(Math.min(lineX + lineSize, endX), lineY | 0);
                    lineX += lineSize + lineSpacing;
                    canvas.stroke();
                }
                canvas.beginPath();
                if (this._aboveStaff) {
                    canvas.moveTo(endX, lineY);
                    canvas.lineTo(endX, cy + this.y + this.height);
                }
                else {
                    canvas.moveTo(endX, lineY);
                    canvas.lineTo(endX, cy + this.y);
                }
                canvas.stroke();
            }
        };
        return OttavaGlyph;
    }(GroupedEffectGlyph));

    var __extends$V = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var OttaviaEffectInfo = /** @class */ (function (_super) {
        __extends$V(OttaviaEffectInfo, _super);
        function OttaviaEffectInfo(aboveStaff) {
            var _this = _super.call(this) || this;
            _this._aboveStaff = aboveStaff;
            return _this;
        }
        Object.defineProperty(OttaviaEffectInfo.prototype, "effectId", {
            get: function () {
                return 'ottavia-' + (this._aboveStaff ? 'above' : 'below');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OttaviaEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectOttavia;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OttaviaEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OttaviaEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(OttaviaEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        OttaviaEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            switch (beat.ottava) {
                case Ottavia._15ma:
                    return this._aboveStaff;
                case Ottavia._8va:
                    return this._aboveStaff;
                case Ottavia._8vb:
                    return !this._aboveStaff;
                case Ottavia._15mb:
                    return !this._aboveStaff;
            }
            return false;
        };
        OttaviaEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new OttavaGlyph(beat.ottava, this._aboveStaff);
        };
        OttaviaEffectInfo.prototype.canExpand = function (from, to) {
            return from.ottava === to.ottava;
        };
        return OttaviaEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$W = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PalmMuteEffectInfo = /** @class */ (function (_super) {
        __extends$W(PalmMuteEffectInfo, _super);
        function PalmMuteEffectInfo() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PalmMuteEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectPalmMute;
            },
            enumerable: false,
            configurable: true
        });
        PalmMuteEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            return note.isPalmMute;
        };
        Object.defineProperty(PalmMuteEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        PalmMuteEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LineRangedGlyph('P.M.');
        };
        return PalmMuteEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$X = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PickSlideEffectInfo = /** @class */ (function (_super) {
        __extends$X(PickSlideEffectInfo, _super);
        function PickSlideEffectInfo() {
            return _super.call(this) || this;
        }
        Object.defineProperty(PickSlideEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectPickSlide;
            },
            enumerable: false,
            configurable: true
        });
        PickSlideEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            return note.slideOutType === SlideOutType.PickSlideDown || note.slideOutType === SlideOutType.PickSlideUp;
        };
        Object.defineProperty(PickSlideEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        PickSlideEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LineRangedGlyph('P.S.');
        };
        return PickSlideEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$Y = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PickStrokeGlyph = /** @class */ (function (_super) {
        __extends$Y(PickStrokeGlyph, _super);
        function PickStrokeGlyph(x, y, pickStroke) {
            return _super.call(this, x, y, NoteHeadGlyph.GraceScale, PickStrokeGlyph.getSymbol(pickStroke)) || this;
        }
        PickStrokeGlyph.prototype.doLayout = function () {
            this.width = 9 * this.scale;
            this.height = 13 * this.scale;
        };
        PickStrokeGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy + this.height, canvas);
        };
        PickStrokeGlyph.getSymbol = function (pickStroke) {
            switch (pickStroke) {
                case PickStroke.Up:
                    return MusicFontSymbol.StringsUpBow;
                case PickStroke.Down:
                    return MusicFontSymbol.StringsDownBow;
                default:
                    return MusicFontSymbol.None;
            }
        };
        return PickStrokeGlyph;
    }(MusicFontGlyph));

    var __extends$Z = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PickStrokeEffectInfo = /** @class */ (function (_super) {
        __extends$Z(PickStrokeEffectInfo, _super);
        function PickStrokeEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(PickStrokeEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectPickStroke;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PickStrokeEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PickStrokeEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PickStrokeEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        PickStrokeEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.pickStroke !== PickStroke.None;
        };
        PickStrokeEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new PickStrokeGlyph(0, 0, beat.pickStroke);
        };
        PickStrokeEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return PickStrokeEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$_ = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BeatVibratoGlyph = /** @class */ (function (_super) {
        __extends$_(BeatVibratoGlyph, _super);
        function BeatVibratoGlyph(type) {
            var _this = _super.call(this, BeatXPosition.EndBeat) || this;
            _this._stepSize = 0;
            _this._type = type;
            return _this;
        }
        BeatVibratoGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            switch (this._type) {
                case VibratoType.Slight:
                    this._stepSize = 12 * this.scale;
                    break;
                case VibratoType.Wide:
                    this._stepSize = 23 * this.scale;
                    break;
            }
            this.height = 18 * this.scale;
        };
        BeatVibratoGlyph.prototype.paintGrouped = function (cx, cy, endX, canvas) {
            var startX = cx + this.x;
            var width = endX - startX;
            var loops = Math.max(1, width / this._stepSize);
            canvas.beginPath();
            canvas.moveTo(startX, cy + this.y);
            for (var i = 0; i < loops; i++) {
                canvas.lineTo(startX + this._stepSize / 2, cy + this.y + this.height);
                canvas.lineTo(startX + this._stepSize, cy + this.y);
                startX += this._stepSize;
            }
            canvas.stroke();
        };
        return BeatVibratoGlyph;
    }(GroupedEffectGlyph));

    var __extends$$ = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var SlightBeatVibratoEffectInfo = /** @class */ (function (_super) {
        __extends$$(SlightBeatVibratoEffectInfo, _super);
        function SlightBeatVibratoEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(SlightBeatVibratoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectSlightBeatVibrato;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SlightBeatVibratoEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SlightBeatVibratoEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(SlightBeatVibratoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeatToEnd;
            },
            enumerable: false,
            configurable: true
        });
        SlightBeatVibratoEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.vibrato === VibratoType.Slight;
        };
        SlightBeatVibratoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new BeatVibratoGlyph(VibratoType.Slight);
        };
        SlightBeatVibratoEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return SlightBeatVibratoEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$10 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var NoteVibratoGlyph = /** @class */ (function (_super) {
        __extends$10(NoteVibratoGlyph, _super);
        function NoteVibratoGlyph(x, y, type, scale, partialWaves) {
            if (scale === void 0) { scale = 1.2; }
            if (partialWaves === void 0) { partialWaves = false; }
            var _this = _super.call(this, BeatXPosition.EndBeat) || this;
            _this._scale = 0;
            _this._symbol = MusicFontSymbol.None;
            _this._symbolSize = 0;
            _this._type = type;
            _this._scale = scale;
            _this.x = x;
            _this.y = y;
            _this._partialWaves = partialWaves;
            return _this;
        }
        NoteVibratoGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            var symbolHeight = 0;
            switch (this._type) {
                case VibratoType.Slight:
                    this._symbol = MusicFontSymbol.WiggleTrill;
                    this._symbolSize = 9 * this._scale;
                    symbolHeight = 6 * this._scale;
                    break;
                case VibratoType.Wide:
                    this._symbol = MusicFontSymbol.WiggleVibratoMediumFast;
                    this._symbolSize = 10 * this._scale;
                    symbolHeight = 10 * this._scale;
                    break;
            }
            this.height = symbolHeight * this.scale;
        };
        NoteVibratoGlyph.prototype.paintGrouped = function (cx, cy, endX, canvas) {
            var startX = cx + this.x;
            var width = endX - startX;
            var step = this._symbolSize * this.scale;
            var loops = width / step;
            if (!this._partialWaves) {
                loops = Math.floor(loops);
            }
            if (loops < 1) {
                loops = 1;
            }
            var loopX = 0;
            for (var i = 0; i < loops; i++) {
                canvas.fillMusicFontSymbol(cx + this.x + loopX, cy + this.y + this.height * 2, this._scale * this.scale, this._symbol, false);
                loopX += step;
            }
        };
        return NoteVibratoGlyph;
    }(GroupedEffectGlyph));

    var __extends$11 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var SlightNoteVibratoEffectInfo = /** @class */ (function (_super) {
        __extends$11(SlightNoteVibratoEffectInfo, _super);
        function SlightNoteVibratoEffectInfo() {
            return _super.call(this) || this;
        }
        Object.defineProperty(SlightNoteVibratoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectSlightNoteVibrato;
            },
            enumerable: false,
            configurable: true
        });
        SlightNoteVibratoEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            return (note.vibrato === VibratoType.Slight ||
                (note.isTieDestination && note.tieOrigin.vibrato === VibratoType.Slight));
        };
        Object.defineProperty(SlightNoteVibratoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeatToEnd;
            },
            enumerable: false,
            configurable: true
        });
        SlightNoteVibratoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new NoteVibratoGlyph(0, 0, VibratoType.Slight, 1.2);
        };
        return SlightNoteVibratoEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$12 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TapEffectInfo = /** @class */ (function (_super) {
        __extends$12(TapEffectInfo, _super);
        function TapEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TapEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectTap;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TapEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TapEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TapEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        TapEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.slap || beat.pop || beat.tap;
        };
        TapEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            var res = renderer.resources;
            if (beat.slap) {
                return new TextGlyph(0, 0, 'S', res.effectFont, TextAlign.Left);
            }
            if (beat.pop) {
                return new TextGlyph(0, 0, 'P', res.effectFont, TextAlign.Left);
            }
            return new TextGlyph(0, 0, 'T', res.effectFont, TextAlign.Left);
        };
        TapEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return TapEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$13 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TempoGlyph = /** @class */ (function (_super) {
        __extends$13(TempoGlyph, _super);
        function TempoGlyph(x, y, tempo) {
            var _this = _super.call(this, x, y) || this;
            _this._tempo = 0;
            _this._tempo = tempo;
            return _this;
        }
        TempoGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 25 * this.scale;
        };
        TempoGlyph.prototype.paint = function (cx, cy, canvas) {
            var res = this.renderer.resources;
            canvas.font = res.markerFont;
            canvas.fillMusicFontSymbol(cx + this.x, cy + this.y + this.height * 0.8, this.scale * NoteHeadGlyph.GraceScale, MusicFontSymbol.NoteQuarterUp, false);
            canvas.fillText('= ' + this._tempo, cx + this.x + this.height / 2, cy + this.y + canvas.font.size / 2);
        };
        return TempoGlyph;
    }(EffectGlyph));

    var __extends$14 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TempoEffectInfo = /** @class */ (function (_super) {
        __extends$14(TempoEffectInfo, _super);
        function TempoEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TempoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectTempo;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TempoEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TempoEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TempoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SinglePreBeat;
            },
            enumerable: false,
            configurable: true
        });
        TempoEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return (beat.voice.bar.staff.index === 0 &&
                beat.voice.index === 0 &&
                beat.index === 0 &&
                (!!beat.voice.bar.masterBar.tempoAutomation || beat.voice.bar.index === 0));
        };
        TempoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            var tempo = 0;
            if (beat.voice.bar.masterBar.tempoAutomation) {
                tempo = beat.voice.bar.masterBar.tempoAutomation.value;
            }
            else {
                tempo = beat.voice.bar.staff.track.score.tempo;
            }
            return new TempoGlyph(0, 0, tempo);
        };
        TempoEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return TempoEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$15 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TextEffectInfo = /** @class */ (function (_super) {
        __extends$15(TextEffectInfo, _super);
        function TextEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TextEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectText;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TextEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        TextEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return !!beat.text;
        };
        TextEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new TextGlyph(0, 0, beat.text, renderer.resources.effectFont, TextAlign.Left);
        };
        TextEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return TextEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$16 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TrillGlyph = /** @class */ (function (_super) {
        __extends$16(TrillGlyph, _super);
        function TrillGlyph(x, y) {
            return _super.call(this, x, y) || this;
        }
        TrillGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 20 * this.scale;
        };
        TrillGlyph.prototype.paint = function (cx, cy, canvas) {
            var res = this.renderer.resources;
            canvas.font = res.markerFont;
            var textw = canvas.measureText('tr');
            canvas.fillText('tr', cx + this.x, cy + this.y + canvas.font.size / 2);
            var startX = textw + 3 * this.scale;
            var endX = this.width - startX;
            var waveScale = 1.2;
            var step = 11 * this.scale * waveScale;
            var loops = Math.max(1, (endX - startX) / step);
            var loopX = startX;
            var loopY = cy + this.y + this.height;
            for (var i = 0; i < loops; i++) {
                canvas.fillMusicFontSymbol(cx + this.x + loopX, loopY, waveScale, MusicFontSymbol.WiggleTrill, false);
                loopX += step;
            }
        };
        return TrillGlyph;
    }(EffectGlyph));

    var __extends$17 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TrillEffectInfo = /** @class */ (function (_super) {
        __extends$17(TrillEffectInfo, _super);
        function TrillEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TrillEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectTrill;
            },
            enumerable: false,
            configurable: true
        });
        TrillEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            return note.isTrill;
        };
        Object.defineProperty(TrillEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        TrillEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new TrillGlyph(0, 0);
        };
        return TrillEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$18 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TripletFeelGlyphBarType;
    (function (TripletFeelGlyphBarType) {
        TripletFeelGlyphBarType[TripletFeelGlyphBarType["Full"] = 0] = "Full";
        TripletFeelGlyphBarType[TripletFeelGlyphBarType["PartialLeft"] = 1] = "PartialLeft";
        TripletFeelGlyphBarType[TripletFeelGlyphBarType["PartialRight"] = 2] = "PartialRight";
    })(TripletFeelGlyphBarType || (TripletFeelGlyphBarType = {}));
    var TripletFeelGlyph = /** @class */ (function (_super) {
        __extends$18(TripletFeelGlyph, _super);
        function TripletFeelGlyph(tripletFeel) {
            var _this = _super.call(this, 0, 0) || this;
            _this._tripletFeel = tripletFeel;
            return _this;
        }
        TripletFeelGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.height = 25 * this.scale;
        };
        TripletFeelGlyph.prototype.paint = function (cx, cy, canvas) {
            cx += this.x;
            cy += this.y;
            var noteY = cy + this.height * NoteHeadGlyph.GraceScale;
            canvas.font = this.renderer.resources.effectFont;
            canvas.fillText('(', cx, cy + this.height * 0.3);
            var leftNoteX = cx + 10 * this.scale;
            var rightNoteX = cx + 40 * this.scale;
            switch (this._tripletFeel) {
                case TripletFeel.NoTripletFeel:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [TripletFeelGlyphBarType.Full]);
                    this.renderBarNote(rightNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [TripletFeelGlyphBarType.Full]);
                    break;
                case TripletFeel.Triplet8th:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [TripletFeelGlyphBarType.Full]);
                    canvas.fillMusicFontSymbol(rightNoteX, noteY, TripletFeelGlyph.NoteScale, MusicFontSymbol.NoteQuarterUp, false);
                    canvas.fillMusicFontSymbol(rightNoteX + TripletFeelGlyph.NoteSeparation * this.scale, noteY, TripletFeelGlyph.NoteScale, MusicFontSymbol.NoteEighthUp, false);
                    this.renderTriplet(rightNoteX, cy, canvas);
                    break;
                case TripletFeel.Triplet16th:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.Full
                    ]);
                    this.renderBarNote(rightNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.PartialRight
                    ]);
                    this.renderTriplet(rightNoteX, cy, canvas);
                    break;
                case TripletFeel.Dotted8th:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [TripletFeelGlyphBarType.Full]);
                    this.renderBarNote(rightNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.PartialRight
                    ]);
                    canvas.fillCircle(rightNoteX + 9 * this.scale, noteY, this.scale);
                    break;
                case TripletFeel.Dotted16th:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.Full
                    ]);
                    this.renderBarNote(rightNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.PartialRight
                    ]);
                    canvas.fillCircle(rightNoteX + 9 * this.scale, noteY, this.scale);
                    break;
                case TripletFeel.Scottish8th:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [TripletFeelGlyphBarType.Full]);
                    this.renderBarNote(rightNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.PartialLeft
                    ]);
                    canvas.fillCircle(rightNoteX + TripletFeelGlyph.NoteSeparation * this.scale + 8 * this.scale, noteY, this.scale);
                    break;
                case TripletFeel.Scottish16th:
                    this.renderBarNote(leftNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.Full
                    ]);
                    this.renderBarNote(rightNoteX, noteY, TripletFeelGlyph.NoteScale, canvas, [
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.Full,
                        TripletFeelGlyphBarType.PartialLeft
                    ]);
                    canvas.fillCircle(rightNoteX + TripletFeelGlyph.NoteSeparation * this.scale + 8 * this.scale, noteY, this.scale);
                    break;
            }
            canvas.fillText('=', cx + 30 * this.scale, cy + 5 * this.scale);
            canvas.fillText(')', cx + 65 * this.scale, cy + this.height * 0.3);
        };
        TripletFeelGlyph.prototype.renderBarNote = function (cx, noteY, noteScale, canvas, bars) {
            canvas.fillMusicFontSymbol(cx, noteY, noteScale, MusicFontSymbol.NoteQuarterUp, false);
            var partialBarWidth = (TripletFeelGlyph.NoteSeparation / 2) * this.scale;
            for (var i = 0; i < bars.length; i++) {
                switch (bars[i]) {
                    case TripletFeelGlyphBarType.Full:
                        canvas.fillRect(cx + 4 * this.scale, noteY - TripletFeelGlyph.NoteHeight * this.scale + TripletFeelGlyph.BarSeparation * this.scale * i, TripletFeelGlyph.NoteSeparation * this.scale, TripletFeelGlyph.BarHeight * this.scale);
                        break;
                    case TripletFeelGlyphBarType.PartialLeft:
                        canvas.fillRect(cx + 4 * this.scale, noteY - TripletFeelGlyph.NoteHeight * this.scale + TripletFeelGlyph.BarSeparation * this.scale * i, partialBarWidth, TripletFeelGlyph.BarHeight * this.scale);
                        break;
                    case TripletFeelGlyphBarType.PartialRight:
                        canvas.fillRect(cx + 4 * this.scale + partialBarWidth, noteY - TripletFeelGlyph.NoteHeight * this.scale + TripletFeelGlyph.BarSeparation * this.scale * i, partialBarWidth, TripletFeelGlyph.BarHeight * this.scale);
                        break;
                }
            }
            canvas.fillMusicFontSymbol(cx + TripletFeelGlyph.NoteSeparation * this.scale, noteY, noteScale, MusicFontSymbol.NoteQuarterUp, false);
        };
        TripletFeelGlyph.prototype.renderTriplet = function (cx, cy, canvas) {
            cy += 2 * this.scale;
            var font = this.renderer.resources.effectFont;
            canvas.font = new Font(font.family, font.size * 0.8, font.style);
            var rightX = cx + TripletFeelGlyph.NoteSeparation * this.scale + 3 * this.scale;
            canvas.beginPath();
            canvas.moveTo(cx, cy + 3 * this.scale);
            canvas.lineTo(cx, cy);
            canvas.lineTo(cx + 5 * this.scale, cy);
            canvas.moveTo(rightX + 5 * this.scale, cy + 3 * this.scale);
            canvas.lineTo(rightX + 5 * this.scale, cy);
            canvas.lineTo(rightX, cy);
            canvas.stroke();
            canvas.fillText('3', cx + 7 * this.scale, cy - 10 * this.scale);
            canvas.font = font;
        };
        TripletFeelGlyph.NoteScale = 0.4;
        TripletFeelGlyph.NoteHeight = 12;
        TripletFeelGlyph.NoteSeparation = 12;
        TripletFeelGlyph.BarHeight = 2;
        TripletFeelGlyph.BarSeparation = 3;
        return TripletFeelGlyph;
    }(EffectGlyph));

    var __extends$19 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TripletFeelEffectInfo = /** @class */ (function (_super) {
        __extends$19(TripletFeelEffectInfo, _super);
        function TripletFeelEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TripletFeelEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectTripletFeel;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TripletFeelEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TripletFeelEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TripletFeelEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SinglePreBeat;
            },
            enumerable: false,
            configurable: true
        });
        TripletFeelEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return (beat.index === 0 &&
                ((beat.voice.bar.masterBar.index === 0 &&
                    beat.voice.bar.masterBar.tripletFeel !== TripletFeel.NoTripletFeel) ||
                    (beat.voice.bar.masterBar.index > 0 &&
                        beat.voice.bar.masterBar.tripletFeel !== beat.voice.bar.masterBar.previousMasterBar.tripletFeel)));
        };
        TripletFeelEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new TripletFeelGlyph(beat.voice.bar.masterBar.tripletFeel);
        };
        TripletFeelEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return TripletFeelEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$1a = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var WhammyBarEffectInfo = /** @class */ (function (_super) {
        __extends$1a(WhammyBarEffectInfo, _super);
        function WhammyBarEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(WhammyBarEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectWhammyBar;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WhammyBarEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WhammyBarEffectInfo.prototype, "canShareBand", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WhammyBarEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        WhammyBarEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.hasWhammyBar;
        };
        WhammyBarEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LineRangedGlyph('w/bar');
        };
        WhammyBarEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return WhammyBarEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$1b = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var WideBeatVibratoEffectInfo = /** @class */ (function (_super) {
        __extends$1b(WideBeatVibratoEffectInfo, _super);
        function WideBeatVibratoEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(WideBeatVibratoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectWideBeatVibrato;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WideBeatVibratoEffectInfo.prototype, "hideOnMultiTrack", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WideBeatVibratoEffectInfo.prototype, "canShareBand", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(WideBeatVibratoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeatToEnd;
            },
            enumerable: false,
            configurable: true
        });
        WideBeatVibratoEffectInfo.prototype.shouldCreateGlyph = function (settings, beat) {
            return beat.vibrato === VibratoType.Wide;
        };
        WideBeatVibratoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new BeatVibratoGlyph(VibratoType.Wide);
        };
        WideBeatVibratoEffectInfo.prototype.canExpand = function (from, to) {
            return true;
        };
        return WideBeatVibratoEffectInfo;
    }(EffectBarRendererInfo));

    var __extends$1c = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var WideNoteVibratoEffectInfo = /** @class */ (function (_super) {
        __extends$1c(WideNoteVibratoEffectInfo, _super);
        function WideNoteVibratoEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(WideNoteVibratoEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectWideNoteVibrato;
            },
            enumerable: false,
            configurable: true
        });
        WideNoteVibratoEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            return (note.vibrato === VibratoType.Wide || (note.isTieDestination && note.tieOrigin.vibrato === VibratoType.Wide));
        };
        Object.defineProperty(WideNoteVibratoEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.GroupedOnBeatToEnd;
            },
            enumerable: false,
            configurable: true
        });
        WideNoteVibratoEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new NoteVibratoGlyph(0, 0, VibratoType.Wide, 1.2);
        };
        return WideNoteVibratoEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$1d = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ChordDiagramGlyph = /** @class */ (function (_super) {
        __extends$1d(ChordDiagramGlyph, _super);
        function ChordDiagramGlyph(x, y, chord) {
            var _this = _super.call(this, x, y) || this;
            _this._textRow = 0;
            _this._fretRow = 0;
            _this._firstFretSpacing = 0;
            _this._chord = chord;
            return _this;
        }
        ChordDiagramGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            var res = this.renderer.resources;
            this._textRow = res.effectFont.size * 1.5;
            this._fretRow = res.effectFont.size * 1.5;
            if (this._chord.firstFret > 1) {
                this._firstFretSpacing = ChordDiagramGlyph.FretSpacing * this.scale;
            }
            else {
                this._firstFretSpacing = 0;
            }
            this.height =
                this._textRow +
                    this._fretRow +
                    (ChordDiagramGlyph.Frets - 1) * ChordDiagramGlyph.FretSpacing * this.scale +
                    2 * ChordDiagramGlyph.Padding;
            this.width =
                this._firstFretSpacing +
                    (this._chord.staff.tuning.length - 1) * ChordDiagramGlyph.StringSpacing * this.scale +
                    2 * ChordDiagramGlyph.Padding;
        };
        ChordDiagramGlyph.prototype.paint = function (cx, cy, canvas) {
            var _this = this;
            cx += this.x + ChordDiagramGlyph.Padding * this.scale + this._firstFretSpacing;
            cy += this.y;
            var w = this.width - 2 * ChordDiagramGlyph.Padding * this.scale + this.scale - this._firstFretSpacing;
            var stringSpacing = ChordDiagramGlyph.StringSpacing * this.scale;
            var fretSpacing = ChordDiagramGlyph.FretSpacing * this.scale;
            var res = this.renderer.resources;
            var circleRadius = ChordDiagramGlyph.CircleRadius * this.scale;
            var align = canvas.textAlign;
            var baseline = canvas.textBaseline;
            canvas.font = res.effectFont;
            canvas.textAlign = TextAlign.Center;
            canvas.textBaseline = TextBaseline.Top;
            if (this._chord.showName) {
                canvas.fillText(this._chord.name, cx + this.width / 2, cy + res.effectFont.size / 2);
            }
            cy += this._textRow;
            cx += stringSpacing / 2;
            canvas.font = res.fretboardNumberFont;
            canvas.textBaseline = TextBaseline.Middle;
            for (var i = 0; i < this._chord.staff.tuning.length; i++) {
                var x = cx + i * stringSpacing;
                var y = cy + this._fretRow / 2;
                var fret = this._chord.strings[this._chord.staff.tuning.length - i - 1];
                if (fret < 0) {
                    canvas.fillMusicFontSymbol(x, y, this.scale, MusicFontSymbol.FretboardX, true);
                }
                else if (fret === 0) {
                    canvas.fillMusicFontSymbol(x, y, this.scale, MusicFontSymbol.FretboardO, true);
                }
                else {
                    fret -= this._chord.firstFret - 1;
                    canvas.fillText(fret.toString(), x, y);
                }
            }
            cy += this._fretRow;
            for (var i = 0; i < this._chord.staff.tuning.length; i++) {
                var x = cx + i * stringSpacing;
                canvas.fillRect(x, cy, 1, fretSpacing * ChordDiagramGlyph.Frets + this.scale);
            }
            if (this._chord.firstFret > 1) {
                canvas.textAlign = TextAlign.Left;
                canvas.fillText(this._chord.firstFret.toString(), cx - this._firstFretSpacing, cy + fretSpacing / 2);
            }
            canvas.fillRect(cx, cy - this.scale, w, 2 * this.scale);
            for (var i = 0; i <= ChordDiagramGlyph.Frets; i++) {
                var y = cy + i * fretSpacing;
                canvas.fillRect(cx, y, w, this.scale);
            }
            var barreLookup = new Map();
            for (var _i = 0, _a = this._chord.barreFrets; _i < _a.length; _i++) {
                var barreFret = _a[_i];
                var strings = [-1, -1];
                barreLookup.set(barreFret - this._chord.firstFret, strings);
            }
            for (var guitarString = 0; guitarString < this._chord.strings.length; guitarString++) {
                var fret = this._chord.strings[guitarString];
                if (fret > 0) {
                    fret -= this._chord.firstFret;
                    if (barreLookup.has(fret)) {
                        var info = barreLookup.get(fret);
                        if (info[0] === -1 || guitarString < info[0]) {
                            info[0] = guitarString;
                        }
                        if (info[1] === -1 || guitarString > info[1]) {
                            info[1] = guitarString;
                        }
                    }
                    var y = cy + fret * fretSpacing + fretSpacing / 2 + 0.5;
                    var x = cx + (this._chord.strings.length - guitarString - 1) * stringSpacing;
                    canvas.fillCircle(x, y, circleRadius);
                }
            }
            barreLookup.forEach(function (strings, fret) {
                var y = cy + fret * fretSpacing + fretSpacing / 2 + _this.scale;
                var xLeft = cx + (_this._chord.strings.length - strings[1] - 1) * stringSpacing;
                var xRight = cx + (_this._chord.strings.length - strings[0] - 1) * stringSpacing;
                canvas.fillRect(xLeft, y - circleRadius, xRight - xLeft, circleRadius * 2);
            });
            canvas.textAlign = align;
            canvas.textBaseline = baseline;
        };
        ChordDiagramGlyph.Padding = 5;
        ChordDiagramGlyph.Frets = 5;
        ChordDiagramGlyph.CircleRadius = 2.5;
        ChordDiagramGlyph.StringSpacing = 10;
        ChordDiagramGlyph.FretSpacing = 12;
        return ChordDiagramGlyph;
    }(EffectGlyph));

    var __extends$1e = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ChordDiagramRowGlyph = /** @class */ (function (_super) {
        __extends$1e(ChordDiagramRowGlyph, _super);
        function ChordDiagramRowGlyph(x, y) {
            var _this = _super.call(this, x, y) || this;
            _this._glyphWidth = 0;
            _this.height = 0;
            _this.glyphs = [];
            return _this;
        }
        ChordDiagramRowGlyph.prototype.doLayout = function () {
            var x = (this.width - this._glyphWidth) / 2;
            for (var _i = 0, _a = this.glyphs; _i < _a.length; _i++) {
                var glyph = _a[_i];
                glyph.x = x;
                x += glyph.width;
            }
        };
        ChordDiagramRowGlyph.prototype.addChord = function (chord) {
            this.glyphs.push(chord);
            this._glyphWidth += chord.width;
            if (chord.height > this.height) {
                this.height = chord.height;
            }
        };
        return ChordDiagramRowGlyph;
    }(GlyphGroup));

    var __extends$1f = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ChordDiagramContainerGlyph = /** @class */ (function (_super) {
        __extends$1f(ChordDiagramContainerGlyph, _super);
        function ChordDiagramContainerGlyph(x, y) {
            var _this = _super.call(this, x, y) || this;
            _this._rows = [];
            _this.height = 0;
            _this.height = 0.0;
            _this.glyphs = [];
            return _this;
        }
        ChordDiagramContainerGlyph.prototype.addChord = function (chord) {
            if (chord.strings.length > 0) {
                var chordDiagram = new ChordDiagramGlyph(0, 0, chord);
                chordDiagram.renderer = this.renderer;
                chordDiagram.doLayout();
                this.glyphs.push(chordDiagram);
            }
        };
        ChordDiagramContainerGlyph.prototype.doLayout = function () {
            var x = 0;
            var y = 0;
            var padding = 2 * ChordDiagramContainerGlyph.Padding * this.scale;
            this._rows = [];
            var row = new ChordDiagramRowGlyph(x, y);
            row.width = this.width;
            for (var _i = 0, _a = this.glyphs; _i < _a.length; _i++) {
                var g = _a[_i];
                if (x + g.width < this.width) {
                    row.addChord(g);
                    x += g.width;
                }
                else {
                    if (!row.isEmpty) {
                        row.doLayout();
                        this._rows.push(row);
                        y += row.height + padding;
                    }
                    x = 0;
                    row = new ChordDiagramRowGlyph(x, y);
                    row.width = this.width;
                    row.addChord(g);
                    x += g.width;
                }
            }
            if (!row.isEmpty) {
                row.doLayout();
                this._rows.push(row);
                y += row.height + padding;
            }
            this.height = y + padding;
        };
        ChordDiagramContainerGlyph.prototype.paint = function (cx, cy, canvas) {
            for (var _i = 0, _a = this._rows; _i < _a.length; _i++) {
                var row = _a[_i];
                row.paint(cx + this.x, cy + this.y + ChordDiagramContainerGlyph.Padding * this.scale, canvas);
            }
        };
        ChordDiagramContainerGlyph.Padding = 3;
        return ChordDiagramContainerGlyph;
    }(GlyphGroup));

    var __extends$1g = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TuningGlyph = /** @class */ (function (_super) {
        __extends$1g(TuningGlyph, _super);
        function TuningGlyph(x, y, scale, resources, tuning) {
            var _this = _super.call(this, x, y) || this;
            _this._scale = 0;
            _this.height = 0;
            _this._scale = scale;
            _this._resources = resources;
            _this.createGlyphs(tuning);
            return _this;
        }
        TuningGlyph.prototype.createGlyphs = function (tuning) {
            // Name
            this.addGlyph(new TextGlyph(0, 0, tuning.name, this._resources.effectFont, TextAlign.Left));
            this.height += 15 * this._scale;
            if (!tuning.isStandard) {
                // Strings
                var stringsPerColumn = Math.ceil(tuning.tunings.length / 2.0) | 0;
                var currentX = 0;
                var currentY = this.height;
                for (var i = 0, j = tuning.tunings.length; i < j; i++) {
                    var str = '(' + (i + 1) + ') = ' + Tuning.getTextForTuning(tuning.tunings[i], false);
                    this.addGlyph(new TextGlyph(currentX, currentY, str, this._resources.effectFont, TextAlign.Left));
                    currentY += this.height;
                    if (i === stringsPerColumn - 1) {
                        currentY = this.height;
                        currentX += 43 * this._scale;
                    }
                }
                this.height += stringsPerColumn * (15 * this._scale);
            }
        };
        return TuningGlyph;
    }(GlyphGroup));

    /**
     * A Staff represents a single line within a StaveGroup.
     * It stores BarRenderer instances created from a given factory.
     */
    var RenderStaff = /** @class */ (function () {
        function RenderStaff(trackIndex, staff, factory) {
            this._sharedLayoutData = new Map();
            this.barRenderers = [];
            this.x = 0;
            this.y = 0;
            this.height = 0;
            this.index = 0;
            this.staffIndex = 0;
            /**
             * This is the index of the track being rendered. This is not the index of the track within the model,
             * but the n-th track being rendered. It is the index of the {@link ScoreRenderer.tracks} array defining
             * which tracks should be rendered.
             * For single-track rendering this will always be zero.
             */
            this.trackIndex = 0;
            /**
             * This is the visual offset from top where the
             * Staff contents actually start. Used for grouping
             * using a accolade
             */
            this.staveTop = 0;
            this.topSpacing = 20;
            this.bottomSpacing = 5;
            /**
             * This is the visual offset from top where the
             * Staff contents actually ends. Used for grouping
             * using a accolade
             */
            this.staveBottom = 0;
            this.isFirstInAccolade = false;
            this.isLastInAccolade = false;
            this._factory = factory;
            this.trackIndex = trackIndex;
            this.modelStaff = staff;
        }
        Object.defineProperty(RenderStaff.prototype, "staveId", {
            get: function () {
                return this._factory.staffId;
            },
            enumerable: false,
            configurable: true
        });
        RenderStaff.prototype.getSharedLayoutData = function (key, def) {
            if (this._sharedLayoutData.has(key)) {
                return this._sharedLayoutData.get(key);
            }
            return def;
        };
        RenderStaff.prototype.setSharedLayoutData = function (key, def) {
            this._sharedLayoutData.set(key, def);
        };
        Object.defineProperty(RenderStaff.prototype, "isInAccolade", {
            get: function () {
                return this._factory.isInAccolade;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RenderStaff.prototype, "isRelevantForBoundsLookup", {
            get: function () {
                return this._factory.isRelevantForBoundsLookup;
            },
            enumerable: false,
            configurable: true
        });
        RenderStaff.prototype.registerStaffTop = function (offset) {
            this.staveTop = offset;
        };
        RenderStaff.prototype.registerStaffBottom = function (offset) {
            this.staveBottom = offset;
        };
        RenderStaff.prototype.addBarRenderer = function (renderer) {
            renderer.staff = this;
            renderer.index = this.barRenderers.length;
            renderer.reLayout();
            this.barRenderers.push(renderer);
            this.staveGroup.layout.registerBarRenderer(this.staveId, renderer);
        };
        RenderStaff.prototype.addBar = function (bar, layoutingInfo) {
            var renderer;
            if (!bar) {
                renderer = new BarRendererBase(this.staveGroup.layout.renderer, bar);
            }
            else {
                renderer = this._factory.create(this.staveGroup.layout.renderer, bar);
            }
            renderer.staff = this;
            renderer.index = this.barRenderers.length;
            renderer.layoutingInfo = layoutingInfo;
            renderer.doLayout();
            renderer.registerLayoutingInfo();
            this.barRenderers.push(renderer);
            if (bar) {
                this.staveGroup.layout.registerBarRenderer(this.staveId, renderer);
            }
        };
        RenderStaff.prototype.revertLastBar = function () {
            var lastBar = this.barRenderers[this.barRenderers.length - 1];
            this.barRenderers.splice(this.barRenderers.length - 1, 1);
            this.staveGroup.layout.unregisterBarRenderer(this.staveId, lastBar);
            return lastBar;
        };
        RenderStaff.prototype.scaleToWidth = function (width) {
            this._sharedLayoutData = new Map();
            // Note: here we could do some "intelligent" distribution of
            // the space over the bar renderers, for now we evenly apply the space to all bars
            var difference = width - this.staveGroup.width;
            var spacePerBar = difference / this.barRenderers.length;
            for (var i = 0, j = this.barRenderers.length; i < j; i++) {
                this.barRenderers[i].scaleToWidth(this.barRenderers[i].width + spacePerBar);
            }
        };
        Object.defineProperty(RenderStaff.prototype, "topOverflow", {
            get: function () {
                var m = 0;
                for (var i = 0, j = this.barRenderers.length; i < j; i++) {
                    var r = this.barRenderers[i];
                    if (r.topOverflow > m) {
                        m = r.topOverflow;
                    }
                }
                return m;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(RenderStaff.prototype, "bottomOverflow", {
            get: function () {
                var m = 0;
                for (var i = 0, j = this.barRenderers.length; i < j; i++) {
                    var r = this.barRenderers[i];
                    if (r.bottomOverflow > m) {
                        m = r.bottomOverflow;
                    }
                }
                return m;
            },
            enumerable: false,
            configurable: true
        });
        RenderStaff.prototype.finalizeStaff = function () {
            var x = 0;
            this.height = 0;
            var topOverflow = this.topOverflow;
            var bottomOverflow = this.bottomOverflow;
            for (var i = 0; i < this.barRenderers.length; i++) {
                this.barRenderers[i].x = x;
                this.barRenderers[i].y = this.topSpacing + topOverflow;
                this.height = Math.max(this.height, this.barRenderers[i].height);
                this.barRenderers[i].finalizeRenderer();
                x += this.barRenderers[i].width;
            }
            if (this.height > 0) {
                this.height += this.topSpacing + topOverflow + bottomOverflow + this.bottomSpacing;
            }
        };
        RenderStaff.prototype.paint = function (cx, cy, canvas, startIndex, count) {
            if (this.height === 0 || count === 0) {
                return;
            }
            for (var i = startIndex, j = Math.min(startIndex + count, this.barRenderers.length); i < j; i++) {
                this.barRenderers[i].paint(cx + this.x, cy + this.y, canvas);
            }
        };
        return RenderStaff;
    }());

    var Spring = /** @class */ (function () {
        function Spring() {
            this.timePosition = 0;
            this.longestDuration = 0;
            this.smallestDuration = 0;
            this.force = 0;
            this.springConstant = 0;
            this.preSpringWidth = 0;
            this.postSpringWidth = 0;
            this.allDurations = [];
        }
        Object.defineProperty(Spring.prototype, "springWidth", {
            get: function () {
                return this.preSpringWidth + this.postSpringWidth;
            },
            enumerable: false,
            configurable: true
        });
        return Spring;
    }());

    /**
     * This public class stores size information about a stave.
     * It is used by the layout engine to collect the sizes of score parts
     * to align the parts across multiple staves.
     */
    var BarLayoutingInfo = /** @class */ (function () {
        function BarLayoutingInfo() {
            this._timeSortedSprings = [];
            this._xMin = 0;
            this._minTime = -1;
            this._onTimePositionsForce = 0;
            this._onTimePositions = new Map();
            /**
             * an internal version number that increments whenever a change was made.
             */
            this.version = 0;
            this.preBeatSizes = new Map();
            this.onBeatSizes = new Map();
            this.onBeatCenterX = new Map();
            this.preBeatSize = 0;
            this.postBeatSize = 0;
            this.voiceSize = 0;
            this.minStretchForce = 0;
            this.totalSpringConstant = 0;
            this.springs = new Map();
            this.height = 0;
        }
        BarLayoutingInfo.prototype.updateVoiceSize = function (size) {
            if (size > this.voiceSize) {
                this.voiceSize = size;
                this.version++;
            }
        };
        BarLayoutingInfo.prototype.setPreBeatSize = function (beat, size) {
            if (!this.preBeatSizes.has(beat.index) || this.preBeatSizes.get(beat.index) < size) {
                this.preBeatSizes.set(beat.index, size);
                this.version++;
            }
        };
        BarLayoutingInfo.prototype.getPreBeatSize = function (beat) {
            if (this.preBeatSizes.has(beat.index)) {
                return this.preBeatSizes.get(beat.index);
            }
            return 0;
        };
        BarLayoutingInfo.prototype.setOnBeatSize = function (beat, size) {
            if (!this.onBeatSizes.has(beat.index) || this.onBeatSizes.get(beat.index) < size) {
                this.onBeatSizes.set(beat.index, size);
                this.version++;
            }
        };
        BarLayoutingInfo.prototype.getOnBeatSize = function (beat) {
            if (this.onBeatSizes.has(beat.index)) {
                return this.onBeatSizes.get(beat.index);
            }
            return 0;
        };
        BarLayoutingInfo.prototype.getBeatCenterX = function (beat) {
            if (this.onBeatCenterX.has(beat.index)) {
                return this.onBeatCenterX.get(beat.index);
            }
            return 0;
        };
        BarLayoutingInfo.prototype.setBeatCenterX = function (beat, x) {
            if (!this.onBeatCenterX.has(beat.index) || this.onBeatCenterX.get(beat.index) < x) {
                this.onBeatCenterX.set(beat.index, x);
                this.version++;
            }
        };
        BarLayoutingInfo.prototype.updateMinStretchForce = function (force) {
            if (this.minStretchForce < force) {
                this.minStretchForce = force;
            }
        };
        BarLayoutingInfo.prototype.addSpring = function (start, duration, preSpringSize, postSpringSize) {
            this.version++;
            var spring;
            if (!this.springs.has(start)) {
                spring = new Spring();
                spring.timePosition = start;
                spring.allDurations.push(duration);
                // check in the previous spring for the shortest duration that overlaps with this spring
                // Gourlay defines that we need the smallest note duration that either starts **or continues** on the current spring.
                if (this._timeSortedSprings.length > 0) {
                    var previousSpring = this._timeSortedSprings[this._timeSortedSprings.length - 1];
                    for (var _i = 0, _a = previousSpring.allDurations; _i < _a.length; _i++) {
                        var prevDuration = _a[_i];
                        var end = previousSpring.timePosition + prevDuration;
                    }
                }
                spring.longestDuration = duration;
                spring.postSpringWidth = postSpringSize;
                spring.preSpringWidth = preSpringSize;
                this.springs.set(start, spring);
                var timeSorted = this._timeSortedSprings;
                var insertPos = timeSorted.length - 1;
                while (insertPos > 0 && timeSorted[insertPos].timePosition > start) {
                    insertPos--;
                }
                this._timeSortedSprings.splice(insertPos + 1, 0, spring);
            }
            else {
                spring = this.springs.get(start);
                if (spring.postSpringWidth < postSpringSize) {
                    spring.postSpringWidth = postSpringSize;
                }
                if (spring.preSpringWidth < preSpringSize) {
                    spring.preSpringWidth = preSpringSize;
                }
                if (duration < spring.smallestDuration) {
                    spring.smallestDuration = duration;
                }
                if (duration > spring.longestDuration) {
                    spring.longestDuration = duration;
                }
                spring.allDurations.push(duration);
            }
            if (this._minTime === -1 || this._minTime > start) {
                this._minTime = start;
            }
            return spring;
        };
        BarLayoutingInfo.prototype.addBeatSpring = function (beat, preBeatSize, postBeatSize) {
            var start = beat.absoluteDisplayStart;
            return this.addSpring(start, beat.displayDuration, preBeatSize, postBeatSize);
        };
        BarLayoutingInfo.prototype.finish = function () {
            this.calculateSpringConstants();
            this.version++;
        };
        BarLayoutingInfo.prototype.calculateSpringConstants = function () {
            var _this = this;
            this._xMin = 0;
            var springs = this.springs;
            springs.forEach(function (spring) {
                if (spring.springWidth < _this._xMin) {
                    _this._xMin = spring.springWidth;
                }
            });
            var totalSpringConstant = 0;
            var sortedSprings = this._timeSortedSprings;
            for (var i = 0; i < sortedSprings.length; i++) {
                var currentSpring = sortedSprings[i];
                var duration = 0;
                if (i === sortedSprings.length - 1) {
                    duration = currentSpring.longestDuration;
                }
                else {
                    var nextSpring = sortedSprings[i + 1];
                    duration = Math.abs(nextSpring.timePosition - currentSpring.timePosition);
                }
                currentSpring.springConstant = this.calculateSpringConstant(currentSpring, duration);
                totalSpringConstant += 1 / currentSpring.springConstant;
            }
            this.totalSpringConstant = 1 / totalSpringConstant;
            // calculate the force required to have at least the minimum size.
            this.minStretchForce = 0;
            // We take the space required between current and next spring
            // and calculate the force needed so that the current spring
            // reserves enough space
            for (var i = 0; i < sortedSprings.length; i++) {
                var currentSpring = sortedSprings[i];
                var requiredSpace = 0;
                if (i === sortedSprings.length - 1) {
                    requiredSpace = currentSpring.postSpringWidth;
                }
                else {
                    var nextSpring = sortedSprings[i + 1];
                    requiredSpace = currentSpring.postSpringWidth + nextSpring.preSpringWidth;
                }
                // for the first spring we need to ensure we take the initial 
                // pre-spring width into account
                if (i === 0) {
                    requiredSpace += currentSpring.preSpringWidth;
                }
                var requiredSpaceForce = requiredSpace * currentSpring.springConstant;
                this.updateMinStretchForce(requiredSpaceForce);
            }
        };
        BarLayoutingInfo.prototype.paint = function (_cx, _cy, _canvas) { };
        // public height: number = 30;
        // public paint(cx: number, cy: number, canvas: ICanvas) {
        //     let sortedSprings: Spring[] = this._timeSortedSprings;
        //     if (sortedSprings.length === 0) {
        //         return;
        //     }
        //     const settings = canvas.settings;
        //     const force = Math.max(settings.display.stretchForce, this.minStretchForce);
        //     const height = this.height * settings.display.scale;
        //     cy -= height;
        //     canvas.color = settings.display.resources.mainGlyphColor;
        //     const font = settings.display.resources.effectFont.clone();
        //     font.size *= 0.8;
        //     canvas.font = font;
        //     canvas.fillText(force.toFixed(2), cx, cy);
        //     cy += settings.display.resources.effectFont.size * 1.5;
        //     let springX: number = sortedSprings[0].preSpringWidth;
        //     for (let i: number = 0; i < sortedSprings.length; i++) {
        //         const spring = sortedSprings[i];
        //         canvas.color = new Color(0, 0, 255, 100);
        //         canvas.fillRect(cx + springX - spring.preSpringWidth, cy, spring.preSpringWidth, height / 2);
        //         canvas.color = new Color(0, 255, 0, 100);
        //         canvas.fillRect(cx + springX, cy, spring.postSpringWidth, height / 2);
        //         canvas.color = settings.display.resources.mainGlyphColor;
        //         canvas.moveTo(cx + springX, cy);
        //         canvas.lineTo(cx + springX, cy + height / 2);
        //         canvas.stroke();
        //         springX += this.calculateWidth(force, spring.springConstant);
        //     }
        // }
        BarLayoutingInfo.prototype.calculateSpringConstant = function (spring, duration) {
            if (duration <= 0) {
                duration = MidiUtils.toTicks(Duration.SixtyFourth);
            }
            if (spring.smallestDuration === 0) {
                spring.smallestDuration = duration;
            }
            var minDuration = spring.smallestDuration;
            var phi = 1 + 0.85 * Math.log2(duration / BarLayoutingInfo.MinDuration);
            return (minDuration / duration) * (1 / (phi * BarLayoutingInfo.MinDurationWidth));
        };
        BarLayoutingInfo.prototype.spaceToForce = function (space) {
            if (this._timeSortedSprings.length > 0) {
                space -= this._timeSortedSprings[0].preSpringWidth;
            }
            return space * this.totalSpringConstant;
        };
        BarLayoutingInfo.prototype.calculateVoiceWidth = function (force) {
            var width = this.calculateWidth(force, this.totalSpringConstant);
            if (this._timeSortedSprings.length > 0) {
                width += this._timeSortedSprings[0].preSpringWidth;
            }
            return width;
        };
        BarLayoutingInfo.prototype.calculateWidth = function (force, springConstant) {
            return force / springConstant;
        };
        BarLayoutingInfo.prototype.buildOnTimePositions = function (force) {
            if (ModelUtils.isAlmostEqualTo(this._onTimePositionsForce, force) && this._onTimePositions) {
                return this._onTimePositions;
            }
            this._onTimePositionsForce = force;
            var positions = (this._onTimePositions = new Map());
            var sortedSprings = this._timeSortedSprings;
            if (sortedSprings.length === 0) {
                return positions;
            }
            var springX = sortedSprings[0].preSpringWidth;
            for (var i = 0; i < sortedSprings.length; i++) {
                positions.set(sortedSprings[i].timePosition, springX);
                springX += this.calculateWidth(force, sortedSprings[i].springConstant);
            }
            return positions;
        };
        BarLayoutingInfo.MinDuration = 30;
        BarLayoutingInfo.MinDurationWidth = 7;
        return BarLayoutingInfo;
    }());

    /**
     * This container represents a single column of bar renderers independent from any staves.
     * This container can be used to reorganize renderers into a new staves.
     */
    var MasterBarsRenderers = /** @class */ (function () {
        function MasterBarsRenderers() {
            this.width = 0;
            this.isLinkedToPrevious = false;
            this.canWrap = true;
            this.renderers = [];
        }
        return MasterBarsRenderers;
    }());

    var StaveTrackGroup = /** @class */ (function () {
        function StaveTrackGroup(staveGroup, track) {
            this.staves = [];
            this.stavesRelevantForBoundsLookup = [];
            this.firstStaffInAccolade = null;
            this.lastStaffInAccolade = null;
            this.staveGroup = staveGroup;
            this.track = track;
        }
        StaveTrackGroup.prototype.addStaff = function (staff) {
            this.staves.push(staff);
            if (staff.isRelevantForBoundsLookup) {
                this.stavesRelevantForBoundsLookup.push(staff);
            }
        };
        return StaveTrackGroup;
    }());

    /**
     * A Staff consists of a list of different staves and groups
     * them using an accolade.
     */
    var StaveGroup = /** @class */ (function () {
        function StaveGroup() {
            this._allStaves = [];
            this._firstStaffInAccolade = null;
            this._lastStaffInAccolade = null;
            this._accoladeSpacingCalculated = false;
            this.x = 0;
            this.y = 0;
            this.index = 0;
            this.accoladeSpacing = 0;
            /**
             * Indicates whether this line is full or not. If the line is full the
             * bars can be aligned to the maximum width. If the line is not full
             * the bars will not get stretched.
             */
            this.isFull = false;
            /**
             * The width that the content bars actually need
             */
            this.width = 0;
            this.isLast = false;
            this.masterBarsRenderers = [];
            this.staves = [];
        }
        Object.defineProperty(StaveGroup.prototype, "firstBarIndex", {
            get: function () {
                return this.masterBarsRenderers[0].masterBar.index;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(StaveGroup.prototype, "lastBarIndex", {
            get: function () {
                return this.masterBarsRenderers[this.masterBarsRenderers.length - 1].masterBar.index;
            },
            enumerable: false,
            configurable: true
        });
        StaveGroup.prototype.addMasterBarRenderers = function (tracks, renderers) {
            if (tracks.length === 0) {
                return null;
            }
            this.masterBarsRenderers.push(renderers);
            this.calculateAccoladeSpacing(tracks);
            renderers.layoutingInfo.preBeatSize = 0;
            var src = 0;
            for (var i = 0, j = this.staves.length; i < j; i++) {
                var g = this.staves[i];
                for (var k = 0, l = g.staves.length; k < l; k++) {
                    var s = g.staves[k];
                    var renderer = renderers.renderers[src++];
                    s.addBarRenderer(renderer);
                }
            }
            // Width += renderers.Width;
            this.updateWidth();
            return renderers;
        };
        StaveGroup.prototype.addBars = function (tracks, barIndex) {
            if (tracks.length === 0) {
                return null;
            }
            var result = new MasterBarsRenderers();
            result.layoutingInfo = new BarLayoutingInfo();
            result.masterBar = tracks[0].score.masterBars[barIndex];
            this.masterBarsRenderers.push(result);
            this.calculateAccoladeSpacing(tracks);
            // add renderers
            var barLayoutingInfo = result.layoutingInfo;
            for (var _i = 0, _a = this.staves; _i < _a.length; _i++) {
                var g = _a[_i];
                for (var _b = 0, _c = g.staves; _b < _c.length; _b++) {
                    var s = _c[_b];
                    var bar = g.track.staves[s.modelStaff.index].bars[barIndex];
                    s.addBar(bar, barLayoutingInfo);
                    var renderer = s.barRenderers[s.barRenderers.length - 1];
                    result.renderers.push(renderer);
                    if (renderer.isLinkedToPrevious) {
                        result.isLinkedToPrevious = true;
                    }
                    if (!renderer.canWrap) {
                        result.canWrap = false;
                    }
                }
            }
            barLayoutingInfo.finish();
            // ensure same widths of new renderer
            result.width = this.updateWidth();
            return result;
        };
        StaveGroup.prototype.revertLastBar = function () {
            if (this.masterBarsRenderers.length > 1) {
                var toRemove = this.masterBarsRenderers[this.masterBarsRenderers.length - 1];
                this.masterBarsRenderers.splice(this.masterBarsRenderers.length - 1, 1);
                var w = 0;
                for (var i = 0, j = this._allStaves.length; i < j; i++) {
                    var s = this._allStaves[i];
                    var lastBar = s.revertLastBar();
                    w = Math.max(w, lastBar.width);
                }
                this.width -= w;
                return toRemove;
            }
            return null;
        };
        StaveGroup.prototype.updateWidth = function () {
            var realWidth = 0;
            for (var i = 0, j = this._allStaves.length; i < j; i++) {
                var s = this._allStaves[i];
                s.barRenderers[s.barRenderers.length - 1].applyLayoutingInfo();
                if (s.barRenderers[s.barRenderers.length - 1].width > realWidth) {
                    realWidth = s.barRenderers[s.barRenderers.length - 1].width;
                }
            }
            this.width += realWidth;
            return realWidth;
        };
        StaveGroup.prototype.calculateAccoladeSpacing = function (tracks) {
            if (!this._accoladeSpacingCalculated && this.index === 0) {
                this._accoladeSpacingCalculated = true;
                if (!this.layout.renderer.settings.notation.isNotationElementVisible(NotationElement.TrackNames)) {
                    this.accoladeSpacing = 0;
                }
                else {
                    var canvas = this.layout.renderer.canvas;
                    var res = this.layout.renderer.settings.display.resources.effectFont;
                    canvas.font = res;
                    for (var _i = 0, tracks_1 = tracks; _i < tracks_1.length; _i++) {
                        var t = tracks_1[_i];
                        this.accoladeSpacing = Math.ceil(Math.max(this.accoladeSpacing, canvas.measureText(t.shortName)));
                    }
                    this.accoladeSpacing *= this.layout.scale;
                    this.accoladeSpacing += 2 * StaveGroup.AccoladeLabelSpacing * this.layout.scale;
                    this.width += this.accoladeSpacing;
                }
            }
        };
        StaveGroup.prototype.getStaveTrackGroup = function (track) {
            for (var i = 0, j = this.staves.length; i < j; i++) {
                var g = this.staves[i];
                if (g.track === track) {
                    return g;
                }
            }
            return null;
        };
        StaveGroup.prototype.addStaff = function (track, staff) {
            var group = this.getStaveTrackGroup(track);
            if (!group) {
                group = new StaveTrackGroup(this, track);
                this.staves.push(group);
            }
            staff.staveTrackGroup = group;
            staff.staveGroup = this;
            staff.index = this._allStaves.length;
            this._allStaves.push(staff);
            group.addStaff(staff);
            if (staff.isInAccolade) {
                if (!this._firstStaffInAccolade) {
                    this._firstStaffInAccolade = staff;
                    staff.isFirstInAccolade = true;
                }
                if (!group.firstStaffInAccolade) {
                    group.firstStaffInAccolade = staff;
                }
                if (!this._lastStaffInAccolade) {
                    this._lastStaffInAccolade = staff;
                    staff.isLastInAccolade = true;
                }
                if (this._lastStaffInAccolade) {
                    this._lastStaffInAccolade.isLastInAccolade = false;
                }
                this._lastStaffInAccolade = staff;
                this._lastStaffInAccolade.isLastInAccolade = true;
                group.lastStaffInAccolade = staff;
            }
        };
        Object.defineProperty(StaveGroup.prototype, "height", {
            get: function () {
                return this._allStaves[this._allStaves.length - 1].y + this._allStaves[this._allStaves.length - 1].height;
            },
            enumerable: false,
            configurable: true
        });
        StaveGroup.prototype.scaleToWidth = function (width) {
            for (var i = 0, j = this._allStaves.length; i < j; i++) {
                this._allStaves[i].scaleToWidth(width);
            }
            this.width = width;
        };
        StaveGroup.prototype.paint = function (cx, cy, canvas) {
            this.paintPartial(cx + this.x, cy + this.y, canvas, 0, this.masterBarsRenderers.length);
        };
        StaveGroup.prototype.paintPartial = function (cx, cy, canvas, startIndex, count) {
            this.buildBoundingsLookup(cx, cy);
            for (var i = 0, j = this._allStaves.length; i < j; i++) {
                this._allStaves[i].paint(cx, cy, canvas, startIndex, count);
            }
            var res = this.layout.renderer.settings.display.resources;
            if (this.staves.length > 0 && startIndex === 0) {
                //
                // Draw start grouping
                //
                canvas.color = res.barSeparatorColor;
                if (this._firstStaffInAccolade && this._lastStaffInAccolade) {
                    //
                    // draw grouping line for all staves
                    //
                    var firstStart = cy +
                        this._firstStaffInAccolade.y +
                        this._firstStaffInAccolade.staveTop +
                        this._firstStaffInAccolade.topSpacing +
                        this._firstStaffInAccolade.topOverflow;
                    var lastEnd = cy +
                        this._lastStaffInAccolade.y +
                        this._lastStaffInAccolade.topSpacing +
                        this._lastStaffInAccolade.topOverflow +
                        this._lastStaffInAccolade.staveBottom;
                    var acooladeX = cx + this._firstStaffInAccolade.x;
                    canvas.beginPath();
                    canvas.moveTo(acooladeX, firstStart);
                    canvas.lineTo(acooladeX, lastEnd);
                    canvas.stroke();
                }
                //
                // Draw accolade for each track group
                //
                canvas.font = res.effectFont;
                for (var i = 0, j = this.staves.length; i < j; i++) {
                    var g = this.staves[i];
                    if (g.firstStaffInAccolade && g.lastStaffInAccolade) {
                        var firstStart = cy +
                            g.firstStaffInAccolade.y +
                            g.firstStaffInAccolade.staveTop +
                            g.firstStaffInAccolade.topSpacing +
                            g.firstStaffInAccolade.topOverflow;
                        var lastEnd = cy +
                            g.lastStaffInAccolade.y +
                            g.lastStaffInAccolade.topSpacing +
                            g.lastStaffInAccolade.topOverflow +
                            g.lastStaffInAccolade.staveBottom;
                        var acooladeX = cx + g.firstStaffInAccolade.x;
                        var barSize = 3 * this.layout.renderer.settings.display.scale;
                        var barOffset = barSize;
                        var accoladeStart = firstStart - barSize * 4;
                        var accoladeEnd = lastEnd + barSize * 4;
                        // text
                        if (this.index === 0 && this.layout.renderer.settings.notation.isNotationElementVisible(NotationElement.TrackNames)) {
                            canvas.fillText(g.track.shortName, cx + StaveGroup.AccoladeLabelSpacing * this.layout.scale, firstStart);
                        }
                        // rect
                        canvas.fillRect(acooladeX - barOffset - barSize, accoladeStart, barSize, accoladeEnd - accoladeStart);
                        var spikeStartX = acooladeX - barOffset - barSize;
                        var spikeEndX = acooladeX + barSize * 2;
                        // top spike
                        canvas.beginPath();
                        canvas.moveTo(spikeStartX, accoladeStart);
                        canvas.bezierCurveTo(spikeStartX, accoladeStart, spikeStartX, accoladeStart, spikeEndX, accoladeStart - barSize);
                        canvas.bezierCurveTo(acooladeX, accoladeStart + barSize, spikeStartX, accoladeStart + barSize, spikeStartX, accoladeStart + barSize);
                        canvas.closePath();
                        canvas.fill();
                        // bottom spike
                        canvas.beginPath();
                        canvas.moveTo(spikeStartX, accoladeEnd);
                        canvas.bezierCurveTo(spikeStartX, accoladeEnd, acooladeX, accoladeEnd, spikeEndX, accoladeEnd + barSize);
                        canvas.bezierCurveTo(acooladeX, accoladeEnd - barSize, spikeStartX, accoladeEnd - barSize, spikeStartX, accoladeEnd - barSize);
                        canvas.closePath();
                        canvas.fill();
                    }
                }
            }
        };
        StaveGroup.prototype.finalizeGroup = function () {
            var currentY = 0;
            for (var _i = 0, _a = this._allStaves; _i < _a.length; _i++) {
                var staff = _a[_i];
                staff.x = this.accoladeSpacing;
                staff.y = currentY;
                staff.finalizeStaff();
                currentY += staff.height;
            }
        };
        StaveGroup.prototype.buildBoundingsLookup = function (cx, cy) {
            if (this.layout.renderer.boundsLookup.isFinished) {
                return;
            }
            if (!this._firstStaffInAccolade || !this._lastStaffInAccolade) {
                return;
            }
            var lastStaff = this._allStaves[this._allStaves.length - 1];
            var visualTop = cy + this.y + this._firstStaffInAccolade.y;
            var visualBottom = cy + this.y + this._lastStaffInAccolade.y + this._lastStaffInAccolade.height;
            var realTop = cy + this.y + this._allStaves[0].y;
            var realBottom = cy + this.y + lastStaff.y + lastStaff.height;
            var lineTop = cy +
                this.y +
                this._firstStaffInAccolade.y +
                this._firstStaffInAccolade.topSpacing +
                this._firstStaffInAccolade.topOverflow +
                (this._firstStaffInAccolade.barRenderers.length > 0
                    ? this._firstStaffInAccolade.barRenderers[0].topPadding
                    : 0);
            var lineBottom = cy +
                this.y +
                lastStaff.y +
                lastStaff.height -
                lastStaff.bottomSpacing -
                lastStaff.bottomOverflow -
                (lastStaff.barRenderers.length > 0 ? lastStaff.barRenderers[0].bottomPadding : 0);
            var visualHeight = visualBottom - visualTop;
            var lineHeight = lineBottom - lineTop;
            var realHeight = realBottom - realTop;
            var x = this.x + this._firstStaffInAccolade.x;
            var staveGroupBounds = new StaveGroupBounds();
            staveGroupBounds.visualBounds = new Bounds();
            staveGroupBounds.visualBounds.x = cx;
            staveGroupBounds.visualBounds.y = cy + this.y;
            staveGroupBounds.visualBounds.w = this.width;
            staveGroupBounds.visualBounds.h = this.height;
            staveGroupBounds.realBounds = new Bounds();
            staveGroupBounds.realBounds.x = cx;
            staveGroupBounds.realBounds.y = cy + this.y;
            staveGroupBounds.realBounds.w = this.width;
            staveGroupBounds.realBounds.h = this.height;
            this.layout.renderer.boundsLookup.addStaveGroup(staveGroupBounds);
            var masterBarBoundsLookup = new Map();
            for (var i = 0; i < this.staves.length; i++) {
                for (var _i = 0, _a = this.staves[i].stavesRelevantForBoundsLookup; _i < _a.length; _i++) {
                    var staff = _a[_i];
                    for (var _b = 0, _c = staff.barRenderers; _b < _c.length; _b++) {
                        var renderer = _c[_b];
                        var masterBarBounds = void 0;
                        if (!masterBarBoundsLookup.has(renderer.bar.masterBar.index)) {
                            masterBarBounds = new MasterBarBounds();
                            masterBarBounds.index = renderer.bar.masterBar.index;
                            masterBarBounds.isFirstOfLine = renderer.isFirstOfLine;
                            masterBarBounds.realBounds = new Bounds();
                            masterBarBounds.realBounds.x = x + renderer.x;
                            masterBarBounds.realBounds.y = realTop;
                            masterBarBounds.realBounds.w = renderer.width;
                            masterBarBounds.realBounds.h = realHeight;
                            masterBarBounds.visualBounds = new Bounds();
                            masterBarBounds.visualBounds.x = x + renderer.x;
                            masterBarBounds.visualBounds.y = visualTop;
                            masterBarBounds.visualBounds.w = renderer.width;
                            masterBarBounds.visualBounds.h = visualHeight;
                            masterBarBounds.lineAlignedBounds = new Bounds();
                            masterBarBounds.lineAlignedBounds.x = x + renderer.x;
                            masterBarBounds.lineAlignedBounds.y = lineTop;
                            masterBarBounds.lineAlignedBounds.w = renderer.width;
                            masterBarBounds.lineAlignedBounds.h = lineHeight;
                            this.layout.renderer.boundsLookup.addMasterBar(masterBarBounds);
                            masterBarBoundsLookup.set(masterBarBounds.index, masterBarBounds);
                        }
                        else {
                            masterBarBounds = masterBarBoundsLookup.get(renderer.bar.masterBar.index);
                        }
                        renderer.buildBoundingsLookup(masterBarBounds, x, cy + this.y + staff.y);
                    }
                }
            }
        };
        StaveGroup.prototype.getBarX = function (index) {
            if (!this._firstStaffInAccolade || this.layout.renderer.tracks.length === 0) {
                return 0;
            }
            var bar = this.layout.renderer.tracks[0].staves[0].bars[index];
            var renderer = this.layout.getRendererForBar(this._firstStaffInAccolade.staveId, bar);
            return renderer.x;
        };
        StaveGroup.AccoladeLabelSpacing = 10;
        return StaveGroup;
    }());

    /**
     * This is the base public class for creating new layouting engines for the score renderer.
     */
    var ScoreLayout = /** @class */ (function () {
        function ScoreLayout(renderer) {
            this._barRendererLookup = new Map();
            this.width = 0;
            this.height = 0;
            this.scoreInfoGlyphs = new Map();
            this.chordDiagrams = null;
            this.tuningGlyph = null;
            this.firstBarIndex = 0;
            this.lastBarIndex = 0;
            this.renderer = renderer;
        }
        ScoreLayout.prototype.layoutAndRender = function () {
            var score = this.renderer.score;
            var startIndex = this.renderer.settings.display.startBar;
            startIndex--; // map to array index
            startIndex = Math.min(score.masterBars.length - 1, Math.max(0, startIndex));
            this.firstBarIndex = startIndex;
            var endBarIndex = this.renderer.settings.display.barCount;
            if (endBarIndex < 0) {
                endBarIndex = score.masterBars.length;
            }
            endBarIndex = startIndex + endBarIndex - 1; // map count to array index
            endBarIndex = Math.min(score.masterBars.length - 1, Math.max(0, endBarIndex));
            this.lastBarIndex = endBarIndex;
            this.createScoreInfoGlyphs();
            this.doLayoutAndRender();
        };
        ScoreLayout.prototype.createScoreInfoGlyphs = function () {
            var _this = this;
            Logger.debug('ScoreLayout', 'Creating score info glyphs');
            var notation = this.renderer.settings.notation;
            var score = this.renderer.score;
            var res = this.renderer.settings.display.resources;
            this.scoreInfoGlyphs = new Map();
            if (score.title && notation.isNotationElementVisible(NotationElement.ScoreTitle)) {
                this.scoreInfoGlyphs.set(NotationElement.ScoreTitle, new TextGlyph(0, 0, score.title, res.titleFont, TextAlign.Center));
            }
            if (score.subTitle && notation.isNotationElementVisible(NotationElement.ScoreSubTitle)) {
                this.scoreInfoGlyphs.set(NotationElement.ScoreSubTitle, new TextGlyph(0, 0, score.subTitle, res.subTitleFont, TextAlign.Center));
            }
            if (score.artist && notation.isNotationElementVisible(NotationElement.ScoreArtist)) {
                this.scoreInfoGlyphs.set(NotationElement.ScoreArtist, new TextGlyph(0, 0, score.artist, res.subTitleFont, TextAlign.Center));
            }
            if (score.album && notation.isNotationElementVisible(NotationElement.ScoreAlbum)) {
                this.scoreInfoGlyphs.set(NotationElement.ScoreAlbum, new TextGlyph(0, 0, score.album, res.subTitleFont, TextAlign.Center));
            }
            if (score.music &&
                score.music === score.words &&
                notation.isNotationElementVisible(NotationElement.ScoreWordsAndMusic)) {
                this.scoreInfoGlyphs.set(NotationElement.ScoreWordsAndMusic, new TextGlyph(0, 0, 'Music and Words by ' + score.words, res.wordsFont, TextAlign.Center));
            }
            else {
                if (score.music && notation.isNotationElementVisible(NotationElement.ScoreMusic)) {
                    this.scoreInfoGlyphs.set(NotationElement.ScoreMusic, new TextGlyph(0, 0, 'Music by ' + score.music, res.wordsFont, TextAlign.Right));
                }
                if (score.words && notation.isNotationElementVisible(NotationElement.ScoreWords)) {
                    this.scoreInfoGlyphs.set(NotationElement.ScoreWords, new TextGlyph(0, 0, 'Words by ' + score.words, res.wordsFont, TextAlign.Left));
                }
            }
            if (notation.isNotationElementVisible(NotationElement.GuitarTuning)) {
                var staffWithTuning = null;
                for (var _i = 0, _a = this.renderer.tracks; _i < _a.length; _i++) {
                    var track = _a[_i];
                    for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                        var staff = _c[_b];
                        if (!staff.isPercussion && staff.isStringed && staff.tuning.length > 0) {
                            staffWithTuning = staff;
                            break;
                        }
                    }
                    if (staffWithTuning) {
                        break;
                    }
                }
                // tuning info
                if (staffWithTuning) {
                    var tuning = Tuning.findTuning(staffWithTuning.tuning);
                    if (!tuning) {
                        tuning = new Tuning('', staffWithTuning.tuning, false);
                    }
                    this.tuningGlyph = new TuningGlyph(0, 0, this.scale, res, tuning);
                }
            }
            // chord diagram glyphs
            if (notation.isNotationElementVisible(NotationElement.ChordDiagrams)) {
                this.chordDiagrams = new ChordDiagramContainerGlyph(0, 0);
                this.chordDiagrams.renderer = new BarRendererBase(this.renderer, this.renderer.tracks[0].staves[0].bars[0]);
                var chords_1 = new Map();
                for (var _d = 0, _e = this.renderer.tracks; _d < _e.length; _d++) {
                    var track = _e[_d];
                    for (var _f = 0, _g = track.staves; _f < _g.length; _f++) {
                        var staff = _g[_f];
                        staff.chords.forEach(function (chord, chordId) {
                            if (!chords_1.has(chordId)) {
                                if (chord.showDiagram) {
                                    chords_1.set(chordId, chord);
                                    _this.chordDiagrams.addChord(chord);
                                }
                            }
                        });
                    }
                }
            }
        };
        Object.defineProperty(ScoreLayout.prototype, "scale", {
            get: function () {
                return this.renderer.settings.display.scale;
            },
            enumerable: false,
            configurable: true
        });
        ScoreLayout.prototype.createEmptyStaveGroup = function () {
            var group = new StaveGroup();
            group.layout = this;
            for (var trackIndex = 0; trackIndex < this.renderer.tracks.length; trackIndex++) {
                var track = this.renderer.tracks[trackIndex];
                var hasScore = false;
                for (var _i = 0, _a = track.staves; _i < _a.length; _i++) {
                    var staff = _a[_i];
                    if (staff.showStandardNotation) {
                        hasScore = true;
                        break;
                    }
                }
                for (var staffIndex = 0; staffIndex < track.staves.length; staffIndex++) {
                    var staff = track.staves[staffIndex];
                    // use optimal profile for track
                    var staveProfile = void 0;
                    if (staff.isPercussion) {
                        staveProfile = exports.StaveProfile.Score;
                    }
                    else if (this.renderer.settings.display.staveProfile !== exports.StaveProfile.Default) {
                        staveProfile = this.renderer.settings.display.staveProfile;
                    }
                    else if (staff.showTablature && staff.showStandardNotation) {
                        staveProfile = exports.StaveProfile.ScoreTab;
                    }
                    else if (staff.showTablature) {
                        staveProfile = hasScore ? exports.StaveProfile.TabMixed : exports.StaveProfile.Tab;
                    }
                    else if (staff.showStandardNotation) {
                        staveProfile = exports.StaveProfile.Score;
                    }
                    else {
                        continue;
                    }
                    var profile = Environment.staveProfiles.get(staveProfile);
                    for (var _b = 0, profile_1 = profile; _b < profile_1.length; _b++) {
                        var factory = profile_1[_b];
                        if (factory.canCreate(track, staff)) {
                            group.addStaff(track, new RenderStaff(trackIndex, staff, factory));
                        }
                    }
                }
            }
            return group;
        };
        ScoreLayout.prototype.registerBarRenderer = function (key, renderer) {
            if (!this._barRendererLookup.has(key)) {
                this._barRendererLookup.set(key, new Map());
            }
            this._barRendererLookup.get(key).set(renderer.bar.id, renderer);
        };
        ScoreLayout.prototype.unregisterBarRenderer = function (key, renderer) {
            if (this._barRendererLookup.has(key)) {
                var lookup = this._barRendererLookup.get(key);
                lookup.delete(renderer.bar.id);
            }
        };
        ScoreLayout.prototype.getRendererForBar = function (key, bar) {
            var barRendererId = bar.id;
            if (this._barRendererLookup.has(key) && this._barRendererLookup.get(key).has(barRendererId)) {
                return this._barRendererLookup.get(key).get(barRendererId);
            }
            return null;
        };
        ScoreLayout.prototype.renderAnnotation = function () {
            // attention, you are not allowed to remove change this notice within any version of this library without permission!
            var msg = 'rendered by alphaTab (https://alphaTab.net)';
            var canvas = this.renderer.canvas;
            var resources = this.renderer.settings.display.resources;
            var size = 12 * this.renderer.settings.display.scale;
            var height = size * 2;
            this.height += height;
            var x = this.width / 2;
            canvas.beginRender(this.width, height);
            canvas.color = resources.mainGlyphColor;
            canvas.font = new Font(resources.copyrightFont.family, size, FontStyle.Bold);
            canvas.textAlign = TextAlign.Center;
            canvas.fillText(msg, x, size);
            var result = canvas.endRender();
            var e = new RenderFinishedEventArgs();
            e.width = this.width;
            e.height = height;
            e.renderResult = result;
            e.totalWidth = this.width;
            e.totalHeight = this.height;
            e.firstMasterBarIndex = -1;
            e.lastMasterBarIndex = -1;
            this.renderer.partialRenderFinished.trigger(e);
        };
        return ScoreLayout;
    }());

    var __extends$1h = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var HorizontalScreenLayoutPartialInfo = /** @class */ (function () {
        function HorizontalScreenLayoutPartialInfo() {
            this.width = 0;
            this.masterBars = [];
        }
        return HorizontalScreenLayoutPartialInfo;
    }());
    /**
     * This layout arranges the bars all horizontally
     */
    var HorizontalScreenLayout = /** @class */ (function (_super) {
        __extends$1h(HorizontalScreenLayout, _super);
        function HorizontalScreenLayout(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this._group = null;
            _this._pagePadding = null;
            return _this;
        }
        Object.defineProperty(HorizontalScreenLayout.prototype, "name", {
            get: function () {
                return 'HorizontalScreen';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(HorizontalScreenLayout.prototype, "supportsResize", {
            get: function () {
                return false;
            },
            enumerable: false,
            configurable: true
        });
        HorizontalScreenLayout.prototype.resize = function () { };
        HorizontalScreenLayout.prototype.doLayoutAndRender = function () {
            this._pagePadding = this.renderer.settings.display.padding;
            if (!this._pagePadding) {
                this._pagePadding = HorizontalScreenLayout.PagePadding;
            }
            if (this._pagePadding.length === 1) {
                this._pagePadding = new Float32Array([
                    this._pagePadding[0],
                    this._pagePadding[0],
                    this._pagePadding[0],
                    this._pagePadding[0]
                ]);
            }
            else if (this._pagePadding.length === 2) {
                this._pagePadding = new Float32Array([
                    this._pagePadding[0],
                    this._pagePadding[1],
                    this._pagePadding[0],
                    this._pagePadding[1]
                ]);
            }
            var score = this.renderer.score;
            var canvas = this.renderer.canvas;
            var startIndex = this.renderer.settings.display.startBar;
            startIndex--; // map to array index
            startIndex = Math.min(score.masterBars.length - 1, Math.max(0, startIndex));
            var currentBarIndex = startIndex;
            var endBarIndex = this.renderer.settings.display.barCount;
            if (endBarIndex <= 0) {
                endBarIndex = score.masterBars.length;
            }
            endBarIndex = startIndex + endBarIndex - 1; // map count to array index
            endBarIndex = Math.min(score.masterBars.length - 1, Math.max(0, endBarIndex));
            this._group = this.createEmptyStaveGroup();
            this._group.isLast = true;
            this._group.x = this._pagePadding[0];
            this._group.y = this._pagePadding[1];
            var countPerPartial = this.renderer.settings.display.barCountPerPartial;
            var partials = [];
            var currentPartial = new HorizontalScreenLayoutPartialInfo();
            while (currentBarIndex <= endBarIndex) {
                var result = this._group.addBars(this.renderer.tracks, currentBarIndex);
                if (result) {
                    // if we detect that the new renderer is linked to the previous
                    // renderer, we need to put it into the previous partial
                    if (currentPartial.masterBars.length === 0 && result.isLinkedToPrevious && partials.length > 0) {
                        var previousPartial = partials[partials.length - 1];
                        previousPartial.masterBars.push(score.masterBars[currentBarIndex]);
                        previousPartial.width += result.width;
                    }
                    else {
                        currentPartial.masterBars.push(score.masterBars[currentBarIndex]);
                        currentPartial.width += result.width;
                        // no targetPartial here because previous partials already handled this code
                        if (currentPartial.masterBars.length >= countPerPartial) {
                            if (partials.length === 0) {
                                currentPartial.width += this._group.x + this._group.accoladeSpacing;
                            }
                            partials.push(currentPartial);
                            Logger.debug(this.name, 'Finished partial from bar ' +
                                currentPartial.masterBars[0].index +
                                ' to ' +
                                currentPartial.masterBars[currentPartial.masterBars.length - 1].index, null);
                            currentPartial = new HorizontalScreenLayoutPartialInfo();
                        }
                    }
                }
                currentBarIndex++;
            }
            // don't miss the last partial if not empty
            if (currentPartial.masterBars.length > 0) {
                if (partials.length === 0) {
                    currentPartial.width += this._group.x + this._group.accoladeSpacing;
                }
                partials.push(currentPartial);
                Logger.debug(this.name, 'Finished partial from bar ' +
                    currentPartial.masterBars[0].index +
                    ' to ' +
                    currentPartial.masterBars[currentPartial.masterBars.length - 1].index, null);
            }
            this._group.finalizeGroup();
            this.height = this._group.y + this._group.height + this._pagePadding[3];
            this.width = this._group.x + this._group.width + this._pagePadding[2];
            currentBarIndex = 0;
            for (var i = 0; i < partials.length; i++) {
                var partial = partials[i];
                canvas.beginRender(partial.width, this.height);
                canvas.color = this.renderer.settings.display.resources.mainGlyphColor;
                canvas.textAlign = TextAlign.Left;
                var renderX = this._group.getBarX(partial.masterBars[0].index) + this._group.accoladeSpacing;
                if (i === 0) {
                    renderX -= this._group.x + this._group.accoladeSpacing;
                }
                Logger.debug(this.name, 'Rendering partial from bar ' +
                    partial.masterBars[0].index +
                    ' to ' +
                    partial.masterBars[partial.masterBars.length - 1].index, null);
                this._group.paintPartial(-renderX, this._group.y, this.renderer.canvas, currentBarIndex, partial.masterBars.length);
                var result = canvas.endRender();
                var e = new RenderFinishedEventArgs();
                e.totalWidth = this.width;
                e.totalHeight = this.height;
                e.width = partial.width;
                e.height = this.height;
                e.renderResult = result;
                e.firstMasterBarIndex = partial.masterBars[0].index;
                e.lastMasterBarIndex = partial.masterBars[partial.masterBars.length - 1].index;
                this.renderer.partialRenderFinished.trigger(e);
                currentBarIndex += partial.masterBars.length;
            }
        };
        HorizontalScreenLayout.PagePadding = new Float32Array([20, 20, 20, 20]);
        HorizontalScreenLayout.GroupSpacing = 20;
        return HorizontalScreenLayout;
    }(ScoreLayout));

    var __extends$1i = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This layout arranges the bars into a fixed width and dynamic height region.
     */
    var PageViewLayout = /** @class */ (function (_super) {
        __extends$1i(PageViewLayout, _super);
        function PageViewLayout(renderer) {
            var _this = _super.call(this, renderer) || this;
            _this._groups = [];
            _this._allMasterBarRenderers = [];
            _this._barsFromPreviousGroup = [];
            _this._pagePadding = null;
            return _this;
        }
        Object.defineProperty(PageViewLayout.prototype, "name", {
            get: function () {
                return 'PageView';
            },
            enumerable: false,
            configurable: true
        });
        PageViewLayout.prototype.doLayoutAndRender = function () {
            this._pagePadding = this.renderer.settings.display.padding;
            if (!this._pagePadding) {
                this._pagePadding = PageViewLayout.PagePadding;
            }
            if (this._pagePadding.length === 1) {
                this._pagePadding = new Float32Array([
                    this._pagePadding[0],
                    this._pagePadding[0],
                    this._pagePadding[0],
                    this._pagePadding[0]
                ]);
            }
            else if (this._pagePadding.length === 2) {
                this._pagePadding = new Float32Array([
                    this._pagePadding[0],
                    this._pagePadding[1],
                    this._pagePadding[0],
                    this._pagePadding[1]
                ]);
            }
            var x = this._pagePadding[0];
            var y = this._pagePadding[1];
            this.width = this.renderer.width;
            this._allMasterBarRenderers = [];
            //
            // 1. Score Info
            y = this.layoutAndRenderScoreInfo(x, y, -1);
            //
            // 2. Chord Diagrms
            y = this.layoutAndRenderChordDiagrams(y, -1);
            //
            // 3. One result per StaveGroup
            y = this.layoutAndRenderScore(x, y);
            this.height = y + this._pagePadding[3];
        };
        Object.defineProperty(PageViewLayout.prototype, "supportsResize", {
            get: function () {
                return true;
            },
            enumerable: false,
            configurable: true
        });
        PageViewLayout.prototype.resize = function () {
            var x = this._pagePadding[0];
            var y = this._pagePadding[1];
            this.width = this.renderer.width;
            var oldHeight = this.height;
            //
            // 1. Score Info
            y = this.layoutAndRenderScoreInfo(x, y, oldHeight);
            //
            // 2. Chord Digrams
            y = this.layoutAndRenderChordDiagrams(y, oldHeight);
            //
            // 2. One result per StaveGroup
            y = this.resizeAndRenderScore(x, y, oldHeight);
            this.height = y + this._pagePadding[3];
        };
        PageViewLayout.prototype.layoutAndRenderChordDiagrams = function (y, totalHeight) {
            if (totalHeight === void 0) { totalHeight = -1; }
            if (!this.chordDiagrams) {
                return y;
            }
            var res = this.renderer.settings.display.resources;
            this.chordDiagrams.width = this.width;
            this.chordDiagrams.doLayout();
            var canvas = this.renderer.canvas;
            canvas.beginRender(this.width, this.chordDiagrams.height);
            canvas.color = res.scoreInfoColor;
            canvas.textAlign = TextAlign.Center;
            this.chordDiagrams.paint(0, 0, canvas);
            var result = canvas.endRender();
            y += this.chordDiagrams.height;
            var e = new RenderFinishedEventArgs();
            e.width = this.width;
            e.height = this.chordDiagrams.height;
            e.renderResult = result;
            e.totalWidth = this.width;
            e.totalHeight = totalHeight < 0 ? y : totalHeight;
            e.firstMasterBarIndex = -1;
            e.lastMasterBarIndex = -1;
            this.renderer.partialRenderFinished.trigger(e);
            return y;
        };
        PageViewLayout.prototype.layoutAndRenderScoreInfo = function (x, y, totalHeight) {
            if (totalHeight === void 0) { totalHeight = -1; }
            Logger.debug(this.name, 'Layouting score info');
            var scale = this.scale;
            var res = this.renderer.settings.display.resources;
            var centeredGlyphs = [
                NotationElement.ScoreTitle,
                NotationElement.ScoreSubTitle,
                NotationElement.ScoreArtist,
                NotationElement.ScoreAlbum,
                NotationElement.ScoreWordsAndMusic
            ];
            for (var i = 0; i < centeredGlyphs.length; i++) {
                if (this.scoreInfoGlyphs.has(centeredGlyphs[i])) {
                    var glyph = this.scoreInfoGlyphs.get(centeredGlyphs[i]);
                    glyph.x = this.width / 2;
                    glyph.y = y;
                    glyph.textAlign = TextAlign.Center;
                    y += glyph.font.size * scale;
                }
            }
            var musicOrWords = false;
            var musicOrWordsHeight = 0;
            if (this.scoreInfoGlyphs.has(NotationElement.ScoreMusic)) {
                var glyph = this.scoreInfoGlyphs.get(NotationElement.ScoreMusic);
                glyph.x = this.width - this._pagePadding[2];
                glyph.y = y;
                glyph.textAlign = TextAlign.Right;
                musicOrWords = true;
                musicOrWordsHeight = glyph.font.size * scale;
            }
            if (this.scoreInfoGlyphs.has(NotationElement.ScoreWords)) {
                var glyph = this.scoreInfoGlyphs.get(NotationElement.ScoreWords);
                glyph.x = x;
                glyph.y = y;
                glyph.textAlign = TextAlign.Left;
                musicOrWords = true;
                musicOrWordsHeight = glyph.font.size * scale;
            }
            if (musicOrWords) {
                y += musicOrWordsHeight;
            }
            if (this.tuningGlyph) {
                y += 20 * scale;
                this.tuningGlyph.x = x;
                this.tuningGlyph.y = y;
                y += this.tuningGlyph.height;
            }
            y += 20 * scale;
            var canvas = this.renderer.canvas;
            canvas.beginRender(this.width, y);
            canvas.color = res.scoreInfoColor;
            canvas.textAlign = TextAlign.Center;
            this.scoreInfoGlyphs.forEach(function (g) {
                g.paint(0, 0, canvas);
            });
            if (this.tuningGlyph) {
                this.tuningGlyph.paint(0, 0, canvas);
            }
            var result = canvas.endRender();
            var e = new RenderFinishedEventArgs();
            e.width = this.width;
            e.height = y;
            e.renderResult = result;
            e.totalWidth = this.width;
            e.totalHeight = totalHeight < 0 ? y : totalHeight;
            e.firstMasterBarIndex = -1;
            e.lastMasterBarIndex = -1;
            this.renderer.partialRenderFinished.trigger(e);
            return y;
        };
        PageViewLayout.prototype.resizeAndRenderScore = function (x, y, oldHeight) {
            var canvas = this.renderer.canvas;
            // if we have a fixed number of bars per row, we only need to refit them.
            if (this.renderer.settings.display.barsPerRow !== -1) {
                for (var i = 0; i < this._groups.length; i++) {
                    var group = this._groups[i];
                    this.fitGroup(group);
                    group.finalizeGroup();
                    y += this.paintGroup(group, oldHeight, canvas);
                }
            }
            else {
                this._groups = [];
                var currentIndex = 0;
                var maxWidth = this.maxWidth;
                var group = this.createEmptyStaveGroup();
                group.index = this._groups.length;
                group.x = x;
                group.y = y;
                while (currentIndex < this._allMasterBarRenderers.length) {
                    // if the current renderer still has space in the current group add it
                    // also force adding in case the group is empty
                    var renderers = this._allMasterBarRenderers[currentIndex];
                    if (group.width + renderers.width <= maxWidth || group.masterBarsRenderers.length === 0) {
                        group.addMasterBarRenderers(this.renderer.tracks, renderers);
                        // move to next group
                        currentIndex++;
                    }
                    else {
                        // if we cannot wrap on the current bar, we remove the last bar
                        // (this might even remove multiple ones until we reach a bar that can wrap);
                        while (renderers && !renderers.canWrap && group.masterBarsRenderers.length > 1) {
                            renderers = group.revertLastBar();
                            currentIndex--;
                        }
                        // in case we do not have space, we create a new group
                        group.isFull = true;
                        group.isLast = this.lastBarIndex === group.lastBarIndex;
                        this._groups.push(group);
                        this.fitGroup(group);
                        group.finalizeGroup();
                        y += this.paintGroup(group, oldHeight, canvas);
                        // note: we do not increase currentIndex here to have it added to the next group
                        group = this.createEmptyStaveGroup();
                        group.index = this._groups.length;
                        group.x = x;
                        group.y = y;
                    }
                }
                group.isLast = this.lastBarIndex === group.lastBarIndex;
                // don't forget to finish the last group
                this.fitGroup(group);
                group.finalizeGroup();
                y += this.paintGroup(group, oldHeight, canvas);
            }
            return y;
        };
        PageViewLayout.prototype.layoutAndRenderScore = function (x, y) {
            var canvas = this.renderer.canvas;
            var startIndex = this.firstBarIndex;
            var currentBarIndex = startIndex;
            var endBarIndex = this.lastBarIndex;
            this._groups = [];
            while (currentBarIndex <= endBarIndex) {
                // create group and align set proper coordinates
                var group = this.createStaveGroup(currentBarIndex, endBarIndex);
                this._groups.push(group);
                group.x = x;
                group.y = y;
                currentBarIndex = group.lastBarIndex + 1;
                // finalize group (sizing etc).
                this.fitGroup(group);
                group.finalizeGroup();
                Logger.debug(this.name, 'Rendering partial from bar ' + group.firstBarIndex + ' to ' + group.lastBarIndex, null);
                y += this.paintGroup(group, y, canvas);
            }
            return y;
        };
        PageViewLayout.prototype.paintGroup = function (group, totalHeight, canvas) {
            // paint into canvas
            var height = group.height + 20 * this.scale;
            canvas.beginRender(this.width, height);
            this.renderer.canvas.color = this.renderer.settings.display.resources.mainGlyphColor;
            this.renderer.canvas.textAlign = TextAlign.Left;
            // NOTE: we use this negation trick to make the group paint itself to 0/0 coordinates
            // since we use partial drawing
            group.paint(0, -group.y, canvas);
            // calculate coordinates for next group
            totalHeight += height;
            var result = canvas.endRender();
            var args = new RenderFinishedEventArgs();
            args.totalWidth = this.width;
            args.totalHeight = totalHeight;
            args.width = this.width;
            args.height = height;
            args.renderResult = result;
            args.firstMasterBarIndex = group.firstBarIndex;
            args.lastMasterBarIndex = group.lastBarIndex;
            this.renderer.partialRenderFinished.trigger(args);
            return height;
        };
        /**
         * Realignes the bars in this line according to the available space
         */
        PageViewLayout.prototype.fitGroup = function (group) {
            if (group.isFull || group.width > this.maxWidth) {
                group.scaleToWidth(this.maxWidth);
            }
            this.width = Math.max(this.width, group.width);
        };
        PageViewLayout.prototype.createStaveGroup = function (currentBarIndex, endIndex) {
            var group = this.createEmptyStaveGroup();
            group.index = this._groups.length;
            var barsPerRow = this.renderer.settings.display.barsPerRow;
            var maxWidth = this.maxWidth;
            var end = endIndex + 1;
            for (var i = currentBarIndex; i < end; i++) {
                if (this._barsFromPreviousGroup.length > 0) {
                    for (var _i = 0, _a = this._barsFromPreviousGroup; _i < _a.length; _i++) {
                        var renderer = _a[_i];
                        group.addMasterBarRenderers(this.renderer.tracks, renderer);
                        i = renderer.masterBar.index;
                    }
                }
                else {
                    var renderers = group.addBars(this.renderer.tracks, i);
                    if (renderers) {
                        this._allMasterBarRenderers.push(renderers);
                    }
                }
                this._barsFromPreviousGroup = [];
                var groupIsFull = false;
                // can bar placed in this line?
                if (barsPerRow === -1 && group.width >= maxWidth && group.masterBarsRenderers.length !== 0) {
                    groupIsFull = true;
                }
                else if (group.masterBarsRenderers.length === barsPerRow + 1) {
                    groupIsFull = true;
                }
                if (groupIsFull) {
                    var reverted = group.revertLastBar();
                    if (reverted) {
                        this._barsFromPreviousGroup.push(reverted);
                        while (reverted && !reverted.canWrap && group.masterBarsRenderers.length > 1) {
                            reverted = group.revertLastBar();
                            if (reverted) {
                                this._barsFromPreviousGroup.push(reverted);
                            }
                        }
                    }
                    group.isFull = true;
                    group.isLast = false;
                    this._barsFromPreviousGroup.reverse();
                    return group;
                }
                group.x = 0;
            }
            group.isLast = endIndex === group.lastBarIndex;
            return group;
        };
        Object.defineProperty(PageViewLayout.prototype, "maxWidth", {
            get: function () {
                return this.renderer.width - this._pagePadding[0] - this._pagePadding[2];
            },
            enumerable: false,
            configurable: true
        });
        PageViewLayout.PagePadding = new Float32Array([40, 40, 40, 40]);
        PageViewLayout.GroupSpacing = 20;
        return PageViewLayout;
    }(ScoreLayout));

    var __extends$1j = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var AccidentalGlyph = /** @class */ (function (_super) {
        __extends$1j(AccidentalGlyph, _super);
        function AccidentalGlyph(x, y, accidentalType, isGrace) {
            if (isGrace === void 0) { isGrace = false; }
            var _this = _super.call(this, x, y, isGrace ? NoteHeadGlyph.GraceScale : 1, AccidentalGlyph.getMusicSymbol(accidentalType)) || this;
            _this._isGrace = isGrace;
            _this._accidentalType = accidentalType;
            return _this;
        }
        AccidentalGlyph.getMusicSymbol = function (accidentalType) {
            switch (accidentalType) {
                case AccidentalType.Natural:
                    return MusicFontSymbol.AccidentalNatural;
                case AccidentalType.Sharp:
                    return MusicFontSymbol.AccidentalSharp;
                case AccidentalType.Flat:
                    return MusicFontSymbol.AccidentalFlat;
                case AccidentalType.NaturalQuarterNoteUp:
                    return MusicFontSymbol.AccidentalQuarterToneNaturalArrowUp;
                case AccidentalType.SharpQuarterNoteUp:
                    return MusicFontSymbol.AccidentalQuarterToneSharpArrowUp;
                case AccidentalType.FlatQuarterNoteUp:
                    return MusicFontSymbol.AccidentalQuarterToneFlatArrowUp;
                case AccidentalType.DoubleSharp:
                    return MusicFontSymbol.AccidentalDoubleSharp;
                case AccidentalType.DoubleFlat:
                    return MusicFontSymbol.AccidentalDoubleFlat;
            }
            return MusicFontSymbol.None;
        };
        AccidentalGlyph.prototype.doLayout = function () {
            switch (this._accidentalType) {
                case AccidentalType.DoubleFlat:
                    this.width = 18;
                    break;
                default:
                    this.width = 8;
                    break;
            }
            this.width = this.width * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
        };
        return AccidentalGlyph;
    }(MusicFontGlyph));

    var __extends$1k = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BarNumberGlyph = /** @class */ (function (_super) {
        __extends$1k(BarNumberGlyph, _super);
        function BarNumberGlyph(x, y, num) {
            var _this = _super.call(this, x, y) || this;
            _this._number = 0;
            _this._number = num;
            return _this;
        }
        BarNumberGlyph.prototype.doLayout = function () {
            this.renderer.scoreRenderer.canvas.font = this.renderer.resources.barNumberFont;
            this.width = this.renderer.scoreRenderer.canvas.measureText(this._number.toString()) + 5 * this.scale;
        };
        BarNumberGlyph.prototype.paint = function (cx, cy, canvas) {
            if (!this.renderer.staff.isFirstInAccolade) {
                return;
            }
            var res = this.renderer.resources;
            var c = canvas.color;
            canvas.color = res.barNumberColor;
            canvas.font = res.barNumberFont;
            canvas.fillText(this._number.toString(), cx + this.x, cy + this.y);
            canvas.color = c;
        };
        return BarNumberGlyph;
    }(Glyph));

    var __extends$1l = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BarSeperatorGlyph = /** @class */ (function (_super) {
        __extends$1l(BarSeperatorGlyph, _super);
        function BarSeperatorGlyph(x, y) {
            return _super.call(this, x, y) || this;
        }
        BarSeperatorGlyph.prototype.doLayout = function () {
            if (this.renderer.isLast) {
                this.width = 15 * this.scale;
            }
            else if (!this.renderer.nextRenderer ||
                this.renderer.nextRenderer.staff !== this.renderer.staff ||
                !this.renderer.nextRenderer.bar.masterBar.isRepeatStart) {
                this.width = 2 * this.scale;
                if (this.renderer.bar.masterBar.isDoubleBar) {
                    this.width += 2 * this.scale;
                }
            }
            else {
                this.width = 2 * this.scale;
            }
        };
        BarSeperatorGlyph.prototype.paint = function (cx, cy, canvas) {
            var blockWidth = 4 * this.scale;
            var top = cy + this.y + this.renderer.topPadding;
            var bottom = cy + this.y + this.renderer.height - this.renderer.bottomPadding;
            var left = cx + this.x;
            var h = bottom - top;
            if (this.renderer.isLast) {
                // small bar
                canvas.fillRect(left + this.width - blockWidth - blockWidth, top, this.scale, h);
                // big bar
                canvas.fillRect(left + this.width - blockWidth, top, blockWidth, h);
            }
            else if (!this.renderer.nextRenderer ||
                this.renderer.nextRenderer.staff !== this.renderer.staff ||
                !this.renderer.nextRenderer.bar.masterBar.isRepeatStart) {
                // small bar
                canvas.fillRect(left + this.width - this.scale, top, this.scale, h);
                if (this.renderer.bar.masterBar.isDoubleBar) {
                    canvas.fillRect(left + this.width - 5 * this.scale, top, this.scale, h);
                }
            }
        };
        return BarSeperatorGlyph;
    }(Glyph));

    var __extends$1m = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ClefGlyph = /** @class */ (function (_super) {
        __extends$1m(ClefGlyph, _super);
        function ClefGlyph(x, y, clef, clefOttava) {
            var _this = _super.call(this, x, y, 1, ClefGlyph.getSymbol(clef)) || this;
            _this._clef = clef;
            _this._clefOttava = clefOttava;
            return _this;
        }
        ClefGlyph.prototype.doLayout = function () {
            switch (this._clef) {
                case Clef.Neutral:
                    this.width = 15 * this.scale;
                    break;
                case Clef.C3:
                case Clef.C4:
                case Clef.F4:
                case Clef.G2:
                    this.width = 28 * this.scale;
                    break;
            }
        };
        ClefGlyph.getSymbol = function (clef) {
            switch (clef) {
                case Clef.Neutral:
                    return MusicFontSymbol.UnpitchedPercussionClef1;
                case Clef.C3:
                    return MusicFontSymbol.CClef;
                case Clef.C4:
                    return MusicFontSymbol.CClef;
                case Clef.F4:
                    return MusicFontSymbol.FClef;
                case Clef.G2:
                    return MusicFontSymbol.GClef;
                default:
                    return MusicFontSymbol.None;
            }
        };
        ClefGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy, canvas);
            var numberGlyph;
            var top = false;
            switch (this._clefOttava) {
                case Ottavia._15ma:
                    numberGlyph = new MusicFontGlyph(-4 * this.scale, 0, 0.5, MusicFontSymbol.Quindicesima);
                    top = true;
                    break;
                case Ottavia._8va:
                    numberGlyph = new MusicFontGlyph(-2 * this.scale, 0, 0.5, MusicFontSymbol.Ottava);
                    top = true;
                    break;
                case Ottavia._8vb:
                    numberGlyph = new MusicFontGlyph(-6 * this.scale, 0, 0.5, MusicFontSymbol.Ottava);
                    break;
                case Ottavia._15mb:
                    numberGlyph = new MusicFontGlyph(-8 * this.scale, 0, 0.5, MusicFontSymbol.Quindicesima);
                    break;
                default:
                    return;
            }
            var offsetY = 0;
            var offsetX = 0;
            switch (this._clef) {
                case Clef.Neutral:
                    offsetY = top ? -12 : 15;
                    offsetX = 0;
                    break;
                case Clef.C3:
                    offsetY = top ? -19 : 27;
                    offsetX = 0;
                    break;
                case Clef.C4:
                    offsetY = top ? -19 : 27;
                    offsetX = 0;
                    break;
                case Clef.F4:
                    offsetY = top ? -9 : 27;
                    offsetX = -4;
                    break;
                case Clef.G2:
                    offsetY = top ? -37 : 30;
                    offsetX = 0;
                    break;
                default:
                    return;
            }
            numberGlyph.renderer = this.renderer;
            numberGlyph.doLayout();
            var x = this.width / 2;
            numberGlyph.paint(cx + this.x + x + offsetX * this.scale, cy + this.y + offsetY * this.scale, canvas);
        };
        return ClefGlyph;
    }(MusicFontGlyph));

    var __extends$1n = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var RepeatCloseGlyph = /** @class */ (function (_super) {
        __extends$1n(RepeatCloseGlyph, _super);
        function RepeatCloseGlyph(x, y) {
            return _super.call(this, x, y) || this;
        }
        RepeatCloseGlyph.prototype.doLayout = function () {
            this.width = 11 * this.scale;
        };
        RepeatCloseGlyph.prototype.paint = function (cx, cy, canvas) {
            var blockWidth = 4 * this.scale;
            var top = cy + this.y + this.renderer.topPadding;
            var bottom = cy + this.y + this.renderer.height - this.renderer.bottomPadding;
            var left = cx + this.x;
            var h = bottom - top;
            // circles
            var circleSize = 1.5 * this.scale;
            var middle = (top + bottom) / 2;
            var dotOffset = 3;
            canvas.fillCircle(left, middle - circleSize * dotOffset, circleSize);
            canvas.fillCircle(left, middle + circleSize * dotOffset, circleSize);
            // line
            left += 4 * this.scale;
            canvas.beginPath();
            canvas.moveTo(left, top);
            canvas.lineTo(left, bottom);
            canvas.stroke();
            // big bar
            left += 3 * this.scale + 0.5;
            canvas.fillRect(left, top, blockWidth, h);
        };
        return RepeatCloseGlyph;
    }(Glyph));

    var __extends$1o = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var RepeatCountGlyph = /** @class */ (function (_super) {
        __extends$1o(RepeatCountGlyph, _super);
        function RepeatCountGlyph(x, y, count) {
            var _this = _super.call(this, x, y) || this;
            _this._count = 0;
            _this._count = 0;
            _this._count = count;
            return _this;
        }
        RepeatCountGlyph.prototype.doLayout = function () {
            this.width = 0;
        };
        RepeatCountGlyph.prototype.paint = function (cx, cy, canvas) {
            var res = this.renderer.resources;
            var oldAlign = canvas.textAlign;
            canvas.font = res.barNumberFont;
            canvas.textAlign = TextAlign.Right;
            var s = 'x' + this._count;
            var w = canvas.measureText(s) / 1.5;
            canvas.fillText(s, cx + this.x - w, cy + this.y);
            canvas.textAlign = oldAlign;
        };
        return RepeatCountGlyph;
    }(Glyph));

    var __extends$1p = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var RepeatOpenGlyph = /** @class */ (function (_super) {
        __extends$1p(RepeatOpenGlyph, _super);
        function RepeatOpenGlyph(x, y, circleSize, dotOffset) {
            var _this = _super.call(this, x, y) || this;
            _this._dotOffset = 0;
            _this._circleSize = 0;
            _this._dotOffset = 0.0;
            _this._circleSize = 0.0;
            _this._dotOffset = dotOffset;
            _this._circleSize = circleSize;
            return _this;
        }
        RepeatOpenGlyph.prototype.doLayout = function () {
            this.width = 13 * this.scale;
        };
        RepeatOpenGlyph.prototype.paint = function (cx, cy, canvas) {
            var blockWidth = 4 * this.scale;
            var top = cy + this.y + this.renderer.topPadding;
            var bottom = cy + this.y + this.renderer.height - this.renderer.bottomPadding;
            var left = cx + this.x + 0.5;
            // big bar
            var h = bottom - top;
            canvas.fillRect(left, top, blockWidth, h);
            // line
            left += blockWidth * 2 - 0.5;
            canvas.beginPath();
            canvas.moveTo(left, top);
            canvas.lineTo(left, bottom);
            canvas.stroke();
            // circles
            left += 3 * this.scale;
            var circleSize = this._circleSize * this.scale;
            var middle = (top + bottom) / 2;
            canvas.fillCircle(left, middle - circleSize * this._dotOffset, circleSize);
            canvas.fillCircle(left, middle + circleSize * this._dotOffset, circleSize);
        };
        return RepeatOpenGlyph;
    }(Glyph));

    var __extends$1q = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var AccentuationGlyph = /** @class */ (function (_super) {
        __extends$1q(AccentuationGlyph, _super);
        function AccentuationGlyph(x, y, accentuation) {
            return _super.call(this, x, y, 1, AccentuationGlyph.getSymbol(accentuation)) || this;
        }
        AccentuationGlyph.getSymbol = function (accentuation) {
            switch (accentuation) {
                case AccentuationType.None:
                    return MusicFontSymbol.None;
                case AccentuationType.Normal:
                    return MusicFontSymbol.ArticAccentAbove;
                case AccentuationType.Heavy:
                    return MusicFontSymbol.ArticMarcatoAbove;
                default:
                    return MusicFontSymbol.None;
            }
        };
        AccentuationGlyph.prototype.doLayout = function () {
            this.width = 9 * this.scale;
            this.height = 9 * this.scale;
        };
        AccentuationGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx - 2 * this.scale, cy + this.height, canvas);
        };
        return AccentuationGlyph;
    }(MusicFontGlyph));

    var __extends$1r = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var CircleGlyph = /** @class */ (function (_super) {
        __extends$1r(CircleGlyph, _super);
        function CircleGlyph(x, y, size) {
            var _this = _super.call(this, x, y) || this;
            _this._size = 0;
            _this._size = size;
            return _this;
        }
        CircleGlyph.prototype.doLayout = function () {
            this.width = this._size + 3 * this.scale;
        };
        CircleGlyph.prototype.paint = function (cx, cy, canvas) {
            canvas.fillCircle(cx + this.x, cy + this.y, this._size);
        };
        return CircleGlyph;
    }(Glyph));

    var __extends$1s = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DeadNoteHeadGlyph = /** @class */ (function (_super) {
        __extends$1s(DeadNoteHeadGlyph, _super);
        function DeadNoteHeadGlyph(x, y, isGrace) {
            var _this = _super.call(this, x, y, isGrace ? NoteHeadGlyph.GraceScale : 1, MusicFontSymbol.NoteheadXOrnate) || this;
            _this._isGrace = isGrace;
            return _this;
        }
        DeadNoteHeadGlyph.prototype.doLayout = function () {
            this.width = 9 * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
            this.height = NoteHeadGlyph.NoteHeadHeight * this.scale;
        };
        return DeadNoteHeadGlyph;
    }(MusicFontGlyph));

    var __extends$1t = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DiamondNoteHeadGlyph = /** @class */ (function (_super) {
        __extends$1t(DiamondNoteHeadGlyph, _super);
        function DiamondNoteHeadGlyph(x, y, duration, isGrace) {
            var _this = _super.call(this, x, y, isGrace ? NoteHeadGlyph.GraceScale : 1, DiamondNoteHeadGlyph.getSymbol(duration)) || this;
            _this._isGrace = isGrace;
            return _this;
        }
        DiamondNoteHeadGlyph.getSymbol = function (duration) {
            switch (duration) {
                case Duration.QuadrupleWhole:
                case Duration.DoubleWhole:
                case Duration.Whole:
                case Duration.Half:
                    return MusicFontSymbol.NoteheadDiamondWhiteWide;
                default:
                    return MusicFontSymbol.NoteheadDiamondBlackWide;
            }
        };
        DiamondNoteHeadGlyph.prototype.doLayout = function () {
            this.width = 9 * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
            this.height = NoteHeadGlyph.NoteHeadHeight * this.scale;
        };
        return DiamondNoteHeadGlyph;
    }(MusicFontGlyph));

    var __extends$1u = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TieGlyph = /** @class */ (function (_super) {
        __extends$1u(TieGlyph, _super);
        function TieGlyph(startBeat, endBeat, forEnd) {
            var _this = _super.call(this, 0, 0) || this;
            _this.yOffset = 0;
            _this.startNoteRenderer = null;
            _this.endNoteRenderer = null;
            _this.tieDirection = BeamDirection.Up;
            _this.startBeat = startBeat;
            _this.endBeat = endBeat;
            _this.forEnd = forEnd;
            return _this;
        }
        TieGlyph.prototype.doLayout = function () {
            this.width = 0;
        };
        TieGlyph.prototype.paint = function (cx, cy, canvas) {
            if (!this.endBeat) {
                return;
            }
            // TODO fix nullability of start/end beat,
            var startNoteRenderer = (this.startNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, this.startBeat.voice.bar));
            var endNoteRenderer = (this.endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, this.endBeat.voice.bar));
            var startX = 0;
            var endX = 0;
            var startY = 0;
            var endY = 0;
            var shouldDraw = false;
            // if we are on the tie start, we check if we
            // either can draw till the end note, or we just can draw till the bar end
            this.tieDirection = !startNoteRenderer
                ? this.getBeamDirection(this.endBeat, endNoteRenderer)
                : this.getBeamDirection(this.startBeat, startNoteRenderer);
            if (!this.forEnd && startNoteRenderer) {
                // line break or bar break
                if (startNoteRenderer !== endNoteRenderer) {
                    startX = cx + startNoteRenderer.x + this.getStartX();
                    startY = cy + startNoteRenderer.y + this.getStartY() + this.yOffset;
                    // line break: to bar end
                    if (!endNoteRenderer || startNoteRenderer.staff !== endNoteRenderer.staff) {
                        endX = cx + startNoteRenderer.x + startNoteRenderer.width;
                        endY = startY;
                    }
                    else {
                        endX = cx + endNoteRenderer.x + this.getEndX();
                        endY = cy + endNoteRenderer.y + this.getEndY() + this.yOffset;
                    }
                }
                else {
                    startX = cx + startNoteRenderer.x + this.getStartX();
                    endX = cx + endNoteRenderer.x + this.getEndX();
                    startY = cy + startNoteRenderer.y + this.getStartY() + this.yOffset;
                    endY = cy + endNoteRenderer.y + this.getEndY() + this.yOffset;
                }
                shouldDraw = true;
            }
            else if (!startNoteRenderer || startNoteRenderer.staff !== endNoteRenderer.staff) {
                startX = cx + endNoteRenderer.x;
                endX = cx + endNoteRenderer.x + this.getEndX();
                startY = cy + endNoteRenderer.y + this.getEndY() + this.yOffset;
                endY = startY;
                shouldDraw = true;
            }
            if (shouldDraw) {
                if (this.shouldDrawBendSlur()) {
                    TieGlyph.drawBendSlur(canvas, startX, startY, endX, endY, this.tieDirection === BeamDirection.Down, this.scale);
                }
                else {
                    TieGlyph.paintTie(canvas, this.scale, startX, startY, endX, endY, this.tieDirection === BeamDirection.Down, this.getTieHeight(startX, startY, endX, endY), 4);
                }
            }
        };
        TieGlyph.prototype.shouldDrawBendSlur = function () {
            return false;
        };
        TieGlyph.prototype.getTieHeight = function (startX, startY, endX, endY) {
            return 22;
        };
        TieGlyph.prototype.getBeamDirection = function (beat, noteRenderer) {
            return BeamDirection.Down;
        };
        TieGlyph.prototype.getStartY = function () {
            return 0;
        };
        TieGlyph.prototype.getEndY = function () {
            return 0;
        };
        TieGlyph.prototype.getStartX = function () {
            return 0;
        };
        TieGlyph.prototype.getEndX = function () {
            return 0;
        };
        TieGlyph.paintTie = function (canvas, scale, x1, y1, x2, y2, down, offset, size) {
            if (down === void 0) { down = false; }
            if (offset === void 0) { offset = 22; }
            if (size === void 0) { size = 4; }
            if (x1 === x2 && y1 === y2) {
                return;
            }
            // ensure endX > startX
            if (x2 < x1) {
                var t = x1;
                x1 = x2;
                x2 = t;
                t = y1;
                y1 = y2;
                y2 = t;
            }
            //
            // calculate control points
            //
            offset *= scale;
            size *= scale;
            // normal vector
            var normalVectorX = y2 - y1;
            var normalVectorY = x2 - x1;
            var length = Math.sqrt(normalVectorX * normalVectorX + normalVectorY * normalVectorY);
            if (down) {
                normalVectorX *= -1;
            }
            else {
                normalVectorY *= -1;
            }
            // make to unit vector
            normalVectorX /= length;
            normalVectorY /= length;
            // center of connection
            var centerX = (x2 + x1) / 2;
            var centerY = (y2 + y1) / 2;
            // control points
            var cp1X = centerX + offset * normalVectorX;
            var cp1Y = centerY + offset * normalVectorY;
            var cp2X = centerX + (offset - size) * normalVectorX;
            var cp2Y = centerY + (offset - size) * normalVectorY;
            canvas.beginPath();
            canvas.moveTo(x1, y1);
            canvas.quadraticCurveTo(cp1X, cp1Y, x2, y2);
            canvas.quadraticCurveTo(cp2X, cp2Y, x1, y1);
            canvas.closePath();
            canvas.fill();
        };
        TieGlyph.drawBendSlur = function (canvas, x1, y1, x2, y2, down, scale, slurText) {
            var normalVectorX = y2 - y1;
            var normalVectorY = x2 - x1;
            var length = Math.sqrt(normalVectorX * normalVectorX + normalVectorY * normalVectorY);
            if (down) {
                normalVectorX *= -1;
            }
            else {
                normalVectorY *= -1;
            }
            // make to unit vector
            normalVectorX /= length;
            normalVectorY /= length;
            // center of connection
            // TODO: should be 1/3
            var centerX = (x2 + x1) / 2;
            var centerY = (y2 + y1) / 2;
            var offset = TieGlyph.BendSlurHeight * scale;
            if (x2 - x1 < 20) {
                offset /= 2;
            }
            var cp1X = centerX + offset * normalVectorX;
            var cp1Y = centerY + offset * normalVectorY;
            canvas.beginPath();
            canvas.moveTo(x1, y1);
            canvas.lineTo(cp1X, cp1Y);
            canvas.lineTo(x2, y2);
            canvas.stroke();
            if (slurText) {
                var w = canvas.measureText(slurText);
                var textOffset = down ? 0 : -canvas.font.size;
                canvas.fillText(slurText, cp1X - w / 2, cp1Y + textOffset);
            }
        };
        TieGlyph.BendSlurHeight = 11;
        return TieGlyph;
    }(Glyph));

    var __extends$1v = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GhostParenthesisGlyph = /** @class */ (function (_super) {
        __extends$1v(GhostParenthesisGlyph, _super);
        function GhostParenthesisGlyph(isOpen) {
            var _this = _super.call(this, 0, 0) || this;
            _this.height = 0;
            _this._isOpen = isOpen;
            return _this;
        }
        GhostParenthesisGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.width = GhostParenthesisGlyph.Size * this.scale;
        };
        GhostParenthesisGlyph.prototype.paint = function (cx, cy, canvas) {
            if (this._isOpen) {
                TieGlyph.paintTie(canvas, this.scale, cx + this.x + this.width, cy + this.y + this.height, cx + this.x + this.width, cy + this.y, false, 6, 3);
            }
            else {
                TieGlyph.paintTie(canvas, this.scale, cx + this.x, cy + this.y, cx + this.x, cy + this.y + this.height, false, 6, 3);
            }
        };
        GhostParenthesisGlyph.Size = 6;
        return GhostParenthesisGlyph;
    }(Glyph));

    var __extends$1w = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GhostNoteInfo = /** @class */ (function () {
        function GhostNoteInfo(line, isGhost) {
            this.line = 0;
            this.line = line;
            this.isGhost = isGhost;
        }
        return GhostNoteInfo;
    }());
    var GhostNoteContainerGlyph = /** @class */ (function (_super) {
        __extends$1w(GhostNoteContainerGlyph, _super);
        function GhostNoteContainerGlyph(isOpen) {
            var _this = _super.call(this, 0, 0) || this;
            _this._infos = [];
            _this._glyphs = [];
            _this.isEmpty = true;
            _this._isOpen = isOpen;
            return _this;
        }
        GhostNoteContainerGlyph.prototype.addParenthesis = function (n) {
            var sr = this.renderer;
            var line = sr.getNoteLine(n);
            var hasParenthesis = n.isGhost || (this.isTiedBend(n) && sr.settings.notation.isNotationElementVisible(NotationElement.ParenthesisOnTiedBends));
            this.addParenthesisOnLine(line, hasParenthesis);
        };
        GhostNoteContainerGlyph.prototype.addParenthesisOnLine = function (line, hasParenthesis) {
            var info = new GhostNoteInfo(line, hasParenthesis);
            this._infos.push(info);
            if (hasParenthesis) {
                this.isEmpty = false;
            }
        };
        GhostNoteContainerGlyph.prototype.isTiedBend = function (note) {
            if (note.isTieDestination) {
                if (note.tieOrigin.hasBend) {
                    return true;
                }
                return this.isTiedBend(note.tieOrigin);
            }
            return false;
        };
        GhostNoteContainerGlyph.prototype.doLayout = function () {
            var sr = this.renderer;
            this._infos.sort(function (a, b) {
                return a.line - b.line;
            });
            var previousGlyph = null;
            var sizePerLine = sr.getScoreHeight(1);
            for (var i = 0, j = this._infos.length; i < j; i++) {
                var g = void 0;
                if (!this._infos[i].isGhost) {
                    previousGlyph = null;
                }
                else if (!previousGlyph) {
                    g = new GhostParenthesisGlyph(this._isOpen);
                    g.renderer = this.renderer;
                    g.y = sr.getScoreY(this._infos[i].line, 0) - sizePerLine;
                    g.height = sizePerLine * 2;
                    g.doLayout();
                    this._glyphs.push(g);
                    previousGlyph = g;
                }
                else {
                    var y = sr.getScoreY(this._infos[i].line, 0) + sizePerLine;
                    previousGlyph.height = y - previousGlyph.y;
                }
            }
            this.width = this._glyphs.length > 0 ? this._glyphs[0].width : 0;
        };
        GhostNoteContainerGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy, canvas);
            for (var _i = 0, _a = this._glyphs; _i < _a.length; _i++) {
                var g = _a[_i];
                g.paint(cx + this.x, cy + this.y, canvas);
            }
        };
        return GhostNoteContainerGlyph;
    }(Glyph));

    var ScoreNoteGlyphInfo = /** @class */ (function () {
        function ScoreNoteGlyphInfo(glyph, line) {
            this.line = 0;
            this.glyph = glyph;
            this.line = line;
        }
        return ScoreNoteGlyphInfo;
    }());

    var __extends$1x = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreNoteChordGlyphBase = /** @class */ (function (_super) {
        __extends$1x(ScoreNoteChordGlyphBase, _super);
        function ScoreNoteChordGlyphBase() {
            var _this = _super.call(this, 0, 0) || this;
            _this._infos = [];
            _this._noteHeadPadding = 0;
            _this.minNote = null;
            _this.maxNote = null;
            _this.spacingChanged = new EventEmitter();
            _this.upLineX = 0;
            _this.downLineX = 0;
            _this.displacedX = 0;
            _this.noteStartX = 0;
            return _this;
        }
        ScoreNoteChordGlyphBase.prototype.add = function (noteGlyph, noteLine) {
            var info = new ScoreNoteGlyphInfo(noteGlyph, noteLine);
            this._infos.push(info);
            if (!this.minNote || this.minNote.line > info.line) {
                this.minNote = info;
            }
            if (!this.maxNote || this.maxNote.line < info.line) {
                this.maxNote = info;
            }
        };
        Object.defineProperty(ScoreNoteChordGlyphBase.prototype, "hasTopOverflow", {
            get: function () {
                return !!this.minNote && this.minNote.line <= 0;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScoreNoteChordGlyphBase.prototype, "hasBottomOverflow", {
            get: function () {
                return !!this.maxNote && this.maxNote.line > 8;
            },
            enumerable: false,
            configurable: true
        });
        ScoreNoteChordGlyphBase.prototype.doLayout = function () {
            this._infos.sort(function (a, b) {
                return b.line - a.line;
            });
            var displacedX = 0;
            var lastDisplaced = false;
            var lastLine = 0;
            var anyDisplaced = false;
            var direction = this.direction;
            var w = 0;
            for (var i = 0, j = this._infos.length; i < j; i++) {
                var g = this._infos[i].glyph;
                g.renderer = this.renderer;
                g.doLayout();
                var displace = false;
                if (i === 0) {
                    displacedX = g.width;
                }
                else {
                    // check if note needs to be repositioned
                    if (Math.abs(lastLine - this._infos[i].line) <= 1) {
                        // reposition if needed
                        if (!lastDisplaced) {
                            displace = true;
                            g.x = displacedX;
                            anyDisplaced = true;
                            lastDisplaced = true; // let next iteration know we are displace now
                        }
                        else {
                            lastDisplaced = false; // let next iteration know that we weren't displaced now
                        }
                    }
                    else {
                        lastDisplaced = false;
                    }
                }
                // for beat direction down we invert the displacement.
                // this means: displaced is on the left side of the stem and not displaced is right
                if (direction === BeamDirection.Down) {
                    g.x = displace ? 0 : displacedX;
                }
                else {
                    g.x = displace ? displacedX : 0;
                }
                g.x += this.noteStartX;
                lastLine = this._infos[i].line;
                w = Math.max(w, g.x + g.width);
            }
            if (anyDisplaced) {
                this._noteHeadPadding = 0;
                this.upLineX = displacedX;
                this.downLineX = displacedX;
            }
            else {
                this._noteHeadPadding = direction === BeamDirection.Down ? -displacedX : 0;
                w += this._noteHeadPadding;
                this.upLineX = w;
                this.downLineX = 0;
            }
            this.displacedX = displacedX;
            this.width = w;
        };
        ScoreNoteChordGlyphBase.prototype.paint = function (cx, cy, canvas) {
            cx += this.x;
            cy += this.y;
            // TODO: this method seems to be quite heavy according to the profiler, why?
            var scoreRenderer = this.renderer;
            // TODO: Take care of beateffects in overflow
            var linePadding = 3 * this.scale;
            var lineWidth = this.width - this.noteStartX + linePadding * 2;
            if (this.hasTopOverflow) {
                var color = canvas.color;
                canvas.color = scoreRenderer.resources.staffLineColor;
                var l = -2;
                while (l >= this.minNote.line) {
                    // + 1 Because we want to place the line in the center of the note, not at the top
                    var lY = cy + scoreRenderer.getScoreY(l, 0);
                    canvas.fillRect(cx - linePadding + this.noteStartX, lY, lineWidth, this.scale);
                    l -= 2;
                }
                canvas.color = color;
            }
            if (this.hasBottomOverflow) {
                var color = canvas.color;
                canvas.color = scoreRenderer.resources.staffLineColor;
                var l = 10;
                while (l <= this.maxNote.line) {
                    var lY = cy + scoreRenderer.getScoreY(l, 0);
                    canvas.fillRect(cx - linePadding + this.noteStartX, lY, lineWidth, this.scale);
                    l += 2;
                }
                canvas.color = color;
            }
            var infos = this._infos;
            var x = cx + this._noteHeadPadding;
            for (var _i = 0, infos_1 = infos; _i < infos_1.length; _i++) {
                var g = infos_1[_i];
                g.glyph.renderer = this.renderer;
                g.glyph.paint(x, cy, canvas);
            }
        };
        return ScoreNoteChordGlyphBase;
    }(Glyph));

    var __extends$1y = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TremoloPickingGlyph = /** @class */ (function (_super) {
        __extends$1y(TremoloPickingGlyph, _super);
        function TremoloPickingGlyph(x, y, duration) {
            return _super.call(this, x, y, 1, TremoloPickingGlyph.getSymbol(duration)) || this;
        }
        TremoloPickingGlyph.prototype.doLayout = function () {
            this.width = 12 * this.scale;
        };
        TremoloPickingGlyph.getSymbol = function (duration) {
            switch (duration) {
                case Duration.ThirtySecond:
                    return MusicFontSymbol.Tremolo3;
                case Duration.Sixteenth:
                    return MusicFontSymbol.Tremolo2;
                case Duration.Eighth:
                    return MusicFontSymbol.Tremolo1;
                default:
                    return MusicFontSymbol.None;
            }
        };
        return TremoloPickingGlyph;
    }(MusicFontGlyph));

    var __extends$1z = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreNoteChordGlyph = /** @class */ (function (_super) {
        __extends$1z(ScoreNoteChordGlyph, _super);
        function ScoreNoteChordGlyph() {
            var _this = _super.call(this) || this;
            _this._noteGlyphLookup = new Map();
            _this._notes = [];
            _this._tremoloPicking = null;
            _this.aboveBeatEffects = new Map();
            _this.belowBeatEffects = new Map();
            return _this;
        }
        Object.defineProperty(ScoreNoteChordGlyph.prototype, "direction", {
            get: function () {
                return this.beamingHelper.direction;
            },
            enumerable: false,
            configurable: true
        });
        ScoreNoteChordGlyph.prototype.getNoteX = function (note, requestedPosition) {
            if (this._noteGlyphLookup.has(note.id)) {
                var n = this._noteGlyphLookup.get(note.id);
                var pos = this.x + n.x + this._noteHeadPadding;
                switch (requestedPosition) {
                    case NoteXPosition.Left:
                        break;
                    case NoteXPosition.Center:
                        pos += n.width / 2;
                        break;
                    case NoteXPosition.Right:
                        pos += n.width;
                        break;
                }
                return pos;
            }
            return 0;
        };
        ScoreNoteChordGlyph.prototype.getNoteY = function (note, requestedPosition) {
            if (this._noteGlyphLookup.has(note.id)) {
                var n = this._noteGlyphLookup.get(note.id);
                var pos = this.y + n.y;
                switch (requestedPosition) {
                    case NoteYPosition.TopWithStem:
                        pos -= this.renderer.getStemSize(this.beamingHelper);
                        break;
                    case NoteYPosition.Top:
                        pos -= n.height / 2;
                        break;
                    case NoteYPosition.Center:
                        break;
                    case NoteYPosition.Bottom:
                        pos += n.height / 2;
                        break;
                    case NoteYPosition.BottomWithStem:
                        pos += this.renderer.getStemSize(this.beamingHelper);
                        break;
                }
                return pos;
            }
            return 0;
        };
        ScoreNoteChordGlyph.prototype.addNoteGlyph = function (noteGlyph, note, noteLine) {
            _super.prototype.add.call(this, noteGlyph, noteLine);
            this._noteGlyphLookup.set(note.id, noteGlyph);
            this._notes.push(note);
        };
        ScoreNoteChordGlyph.prototype.updateBeamingHelper = function (cx) {
            if (this.beamingHelper) {
                this.beamingHelper.registerBeatLineX('score', this.beat, cx + this.x + this.upLineX, cx + this.x + this.downLineX);
            }
        };
        ScoreNoteChordGlyph.prototype.doLayout = function () {
            var _this = this;
            _super.prototype.doLayout.call(this);
            var direction = this.direction;
            this.aboveBeatEffects.forEach(function (effect) {
                effect.renderer = _this.renderer;
                effect.doLayout();
            });
            this.belowBeatEffects.forEach(function (effect) {
                effect.renderer = _this.renderer;
                effect.doLayout();
            });
            if (this.beat.isTremolo) {
                var offset = 0;
                var baseNote = direction === BeamDirection.Up ? this.minNote : this.maxNote;
                var tremoloX = direction === BeamDirection.Up ? this.displacedX : 0;
                var speed = this.beat.tremoloSpeed;
                switch (speed) {
                    case Duration.ThirtySecond:
                        offset = direction === BeamDirection.Up ? -15 : 15;
                        break;
                    case Duration.Sixteenth:
                        offset = direction === BeamDirection.Up ? -12 : 15;
                        break;
                    case Duration.Eighth:
                        offset = direction === BeamDirection.Up ? -10 : 10;
                        break;
                    default:
                        offset = direction === BeamDirection.Up ? -10 : 15;
                        break;
                }
                this._tremoloPicking = new TremoloPickingGlyph(tremoloX, baseNote.glyph.y + offset * this.scale, speed);
                this._tremoloPicking.renderer = this.renderer;
                this._tremoloPicking.doLayout();
            }
        };
        ScoreNoteChordGlyph.prototype.buildBoundingsLookup = function (beatBounds, cx, cy) {
            for (var _i = 0, _a = this._notes; _i < _a.length; _i++) {
                var note = _a[_i];
                if (this._noteGlyphLookup.has(note.id)) {
                    var glyph = this._noteGlyphLookup.get(note.id);
                    var noteBounds = new NoteBounds();
                    noteBounds.note = note;
                    noteBounds.noteHeadBounds = new Bounds();
                    noteBounds.noteHeadBounds.x = cx + this.x + this._noteHeadPadding + glyph.x;
                    noteBounds.noteHeadBounds.y = cy + this.y + glyph.y - glyph.height / 2;
                    noteBounds.noteHeadBounds.w = glyph.width;
                    noteBounds.noteHeadBounds.h = glyph.height;
                    beatBounds.addNote(noteBounds);
                }
            }
        };
        ScoreNoteChordGlyph.prototype.paint = function (cx, cy, canvas) {
            var _this = this;
            // TODO: this method seems to be quite heavy according to the profiler, why?
            var scoreRenderer = this.renderer;
            //
            // Note Effects only painted once
            //
            var aboveBeatEffectsY = 0;
            var belowBeatEffectsY = 0;
            var belowEffectSpacing = 1;
            var aboveEffectSpacing = -belowEffectSpacing;
            if (this.beamingHelper.direction === BeamDirection.Up) {
                belowBeatEffectsY = scoreRenderer.getScoreY(this.minNote.line);
                aboveBeatEffectsY = scoreRenderer.getScoreY(this.maxNote.line - 2);
            }
            else {
                belowBeatEffectsY = scoreRenderer.getScoreY(this.maxNote.line - 1);
                aboveBeatEffectsY = scoreRenderer.getScoreY(this.minNote.line + 1);
                aboveEffectSpacing *= -1;
                belowEffectSpacing *= -1;
            }
            this.aboveBeatEffects.forEach(function (g) {
                aboveBeatEffectsY += aboveEffectSpacing * g.height;
                g.paint(cx + _this.x + 2 * _this.scale, cy + _this.y + aboveBeatEffectsY, canvas);
            });
            this.belowBeatEffects.forEach(function (g) {
                belowBeatEffectsY += belowEffectSpacing * g.height;
                g.paint(cx + _this.x + 2 * _this.scale, cy + _this.y + belowBeatEffectsY, canvas);
            });
            _super.prototype.paint.call(this, cx, cy, canvas);
            if (this._tremoloPicking) {
                this._tremoloPicking.paint(cx, cy, canvas);
            }
        };
        return ScoreNoteChordGlyph;
    }(ScoreNoteChordGlyphBase));

    var __extends$1A = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreRestGlyph = /** @class */ (function (_super) {
        __extends$1A(ScoreRestGlyph, _super);
        function ScoreRestGlyph(x, y, duration) {
            var _this = _super.call(this, x, y, 1, ScoreRestGlyph.getSymbol(duration)) || this;
            _this._duration = duration;
            return _this;
        }
        ScoreRestGlyph.getSymbol = function (duration) {
            switch (duration) {
                case Duration.QuadrupleWhole:
                    return MusicFontSymbol.RestLonga;
                case Duration.DoubleWhole:
                    return MusicFontSymbol.RestDoubleWhole;
                case Duration.Whole:
                    return MusicFontSymbol.RestWhole;
                case Duration.Half:
                    return MusicFontSymbol.RestHalf;
                case Duration.Quarter:
                    return MusicFontSymbol.RestQuarter;
                case Duration.Eighth:
                    return MusicFontSymbol.RestEighth;
                case Duration.Sixteenth:
                    return MusicFontSymbol.RestSixteenth;
                case Duration.ThirtySecond:
                    return MusicFontSymbol.RestThirtySecond;
                case Duration.SixtyFourth:
                    return MusicFontSymbol.RestSixtyFourth;
                case Duration.OneHundredTwentyEighth:
                    return MusicFontSymbol.RestOneHundredTwentyEighth;
                case Duration.TwoHundredFiftySixth:
                    return MusicFontSymbol.RestTwoHundredFiftySixth;
                default:
                    return MusicFontSymbol.None;
            }
        };
        ScoreRestGlyph.getSize = function (duration) {
            switch (duration) {
                case Duration.QuadrupleWhole:
                case Duration.DoubleWhole:
                case Duration.Whole:
                case Duration.Half:
                case Duration.Quarter:
                case Duration.Eighth:
                case Duration.Sixteenth:
                    return 9;
                case Duration.ThirtySecond:
                    return 12;
                case Duration.SixtyFourth:
                    return 14;
                case Duration.OneHundredTwentyEighth:
                case Duration.TwoHundredFiftySixth:
                    return 20;
            }
            return 10;
        };
        ScoreRestGlyph.prototype.doLayout = function () {
            this.width = ScoreRestGlyph.getSize(this._duration) * this.scale;
        };
        ScoreRestGlyph.prototype.updateBeamingHelper = function (cx) {
            if (this.beamingHelper) {
                this.beamingHelper.registerBeatLineX('score', this.beat, cx + this.x + this.width / 2, cx + this.x + this.width / 2);
            }
        };
        return ScoreRestGlyph;
    }(MusicFontGlyph));

    var __extends$1B = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var AccidentalColumnInfo = /** @class */ (function () {
        function AccidentalColumnInfo() {
            this.x = 0;
            this.y = -3000;
            this.width = 0;
        }
        return AccidentalColumnInfo;
    }());
    var AccidentalGroupGlyph = /** @class */ (function (_super) {
        __extends$1B(AccidentalGroupGlyph, _super);
        function AccidentalGroupGlyph() {
            return _super.call(this, 0, 0) || this;
        }
        AccidentalGroupGlyph.prototype.doLayout = function () {
            if (!this.glyphs || this.glyphs.length === 0) {
                this.width = 0;
                return;
            }
            //
            // Determine Columns for accidentals
            //
            this.glyphs.sort(function (a, b) {
                if (a.y < b.y) {
                    return -1;
                }
                if (a.y > b.y) {
                    return 1;
                }
                return 0;
            });
            // defines the reserved y position of the columns
            var columns = [];
            columns.push(new AccidentalColumnInfo());
            var accidentalHeight = 21 * this.scale;
            for (var i = 0, j = this.glyphs.length; i < j; i++) {
                var g = this.glyphs[i];
                g.renderer = this.renderer;
                g.doLayout();
                // find column where glyph fits into
                // as long the glyph does not fit into the current column
                var gColumn = 0;
                while (columns[gColumn].y > g.y) {
                    // move to next column
                    gColumn++;
                    // and create the new column if needed
                    if (gColumn === columns.length) {
                        columns.push(new AccidentalColumnInfo());
                    }
                }
                // temporary save column as X
                g.x = gColumn;
                columns[gColumn].y = g.y + accidentalHeight;
                if (columns[gColumn].width < g.width) {
                    columns[gColumn].width = g.width;
                }
            }
            //
            // Place accidentals in columns
            //
            this.width = 0;
            for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                var column = columns_1[_i];
                this.width += column.width;
                column.x = this.width;
            }
            for (var i = 0, j = this.glyphs.length; i < j; i++) {
                var g = this.glyphs[i];
                var column = columns[g.x];
                g.x = (this.width - column.x);
            }
        };
        return AccidentalGroupGlyph;
    }(GlyphGroup));

    var __extends$1C = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var BendNoteHeadGroupGlyph = /** @class */ (function (_super) {
        __extends$1C(BendNoteHeadGroupGlyph, _super);
        function BendNoteHeadGroupGlyph(beat, showParenthesis) {
            if (showParenthesis === void 0) { showParenthesis = false; }
            var _this = _super.call(this) || this;
            _this._showParenthesis = false;
            _this._noteValueLookup = new Map();
            _this._accidentals = new AccidentalGroupGlyph();
            _this._preNoteParenthesis = null;
            _this._postNoteParenthesis = null;
            _this.isEmpty = true;
            _this.noteHeadOffset = 0;
            _this._beat = beat;
            _this._showParenthesis = showParenthesis;
            if (showParenthesis) {
                _this._preNoteParenthesis = new GhostNoteContainerGlyph(true);
                _this._postNoteParenthesis = new GhostNoteContainerGlyph(false);
            }
            return _this;
        }
        Object.defineProperty(BendNoteHeadGroupGlyph.prototype, "direction", {
            get: function () {
                return BeamDirection.Up;
            },
            enumerable: false,
            configurable: true
        });
        BendNoteHeadGroupGlyph.prototype.containsNoteValue = function (noteValue) {
            return this._noteValueLookup.has(noteValue);
        };
        BendNoteHeadGroupGlyph.prototype.getNoteValueY = function (noteValue) {
            if (this._noteValueLookup.has(noteValue)) {
                return (this.y +
                    this._noteValueLookup.get(noteValue).y);
            }
            return 0;
        };
        BendNoteHeadGroupGlyph.prototype.addGlyph = function (noteValue, quarterBend) {
            if (quarterBend === void 0) { quarterBend = false; }
            var sr = this.renderer;
            var noteHeadGlyph = new NoteHeadGlyph(0, 0, Duration.Quarter, true);
            var accidental = sr.accidentalHelper.applyAccidentalForValue(this._beat, noteValue, quarterBend, true);
            var line = sr.accidentalHelper.getNoteLineForValue(noteValue, false);
            noteHeadGlyph.y = sr.getScoreY(line, 0);
            if (this._showParenthesis) {
                this._preNoteParenthesis.renderer = this.renderer;
                this._postNoteParenthesis.renderer = this.renderer;
                this._preNoteParenthesis.addParenthesisOnLine(line, true);
                this._postNoteParenthesis.addParenthesisOnLine(line, true);
            }
            if (accidental !== AccidentalType.None) {
                var g = new AccidentalGlyph(0, noteHeadGlyph.y, accidental, true);
                g.renderer = this.renderer;
                this._accidentals.addGlyph(g);
            }
            this._noteValueLookup.set(noteValue, noteHeadGlyph);
            this.add(noteHeadGlyph, line);
            this.isEmpty = false;
        };
        BendNoteHeadGroupGlyph.prototype.doLayout = function () {
            var x = 0;
            if (this._showParenthesis) {
                this._preNoteParenthesis.x = x;
                this._preNoteParenthesis.renderer = this.renderer;
                this._preNoteParenthesis.doLayout();
                x += this._preNoteParenthesis.width + BendNoteHeadGroupGlyph.ElementPadding * this.scale;
            }
            if (!this._accidentals.isEmpty) {
                x += this._accidentals.width + BendNoteHeadGroupGlyph.ElementPadding * this.scale;
                this._accidentals.x = x;
                this._accidentals.renderer = this.renderer;
                this._accidentals.doLayout();
                x += this._accidentals.width + BendNoteHeadGroupGlyph.ElementPadding * this.scale;
            }
            this.noteStartX = x;
            _super.prototype.doLayout.call(this);
            this.noteHeadOffset = this.noteStartX + (this.width - this.noteStartX) / 2;
            if (this._showParenthesis) {
                this._postNoteParenthesis.x = this.width + BendNoteHeadGroupGlyph.ElementPadding * this.scale;
                this._postNoteParenthesis.renderer = this.renderer;
                this._postNoteParenthesis.doLayout();
                this.width += this._postNoteParenthesis.width + BendNoteHeadGroupGlyph.ElementPadding * this.scale;
            }
        };
        BendNoteHeadGroupGlyph.prototype.paint = function (cx, cy, canvas) {
            // canvas.Color = Color.Random();
            // canvas.FillRect(cx + X, cy + Y, Width, 10);
            // canvas.Color = Renderer.Resources.MainGlyphColor;
            if (!this._accidentals.isEmpty) {
                this._accidentals.paint(cx + this.x, cy + this.y, canvas);
            }
            if (this._showParenthesis) {
                this._preNoteParenthesis.paint(cx + this.x, cy + this.y, canvas);
                this._postNoteParenthesis.paint(cx + this.x, cy + this.y, canvas);
            }
            _super.prototype.paint.call(this, cx, cy, canvas);
        };
        BendNoteHeadGroupGlyph.ElementPadding = 2;
        return BendNoteHeadGroupGlyph;
    }(ScoreNoteChordGlyphBase));

    var __extends$1D = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreHelperNotesBaseGlyph = /** @class */ (function (_super) {
        __extends$1D(ScoreHelperNotesBaseGlyph, _super);
        function ScoreHelperNotesBaseGlyph() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.BendNoteHeads = [];
            return _this;
        }
        ScoreHelperNotesBaseGlyph.prototype.drawBendSlur = function (canvas, x1, y1, x2, y2, down, scale, slurText) {
            TieGlyph.drawBendSlur(canvas, x1, y1, x2, y2, down, scale, slurText);
        };
        ScoreHelperNotesBaseGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this.width = 0;
            for (var _i = 0, _a = this.BendNoteHeads; _i < _a.length; _i++) {
                var noteHeads = _a[_i];
                noteHeads.doLayout();
                this.width += noteHeads.width + 10 * this.scale;
            }
        };
        ScoreHelperNotesBaseGlyph.prototype.getTieDirection = function (beat, noteRenderer) {
            // invert direction (if stems go up, ties go down to not cross them)
            switch (noteRenderer.getBeatDirection(beat)) {
                case BeamDirection.Up:
                    return BeamDirection.Down;
                default:
                    return BeamDirection.Up;
            }
        };
        ScoreHelperNotesBaseGlyph.EndPadding = ((10 / 2) | 0) + 3;
        return ScoreHelperNotesBaseGlyph;
    }(Glyph));

    var __extends$1E = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabBendRenderPoint = /** @class */ (function (_super) {
        __extends$1E(TabBendRenderPoint, _super);
        function TabBendRenderPoint(offset, value) {
            if (offset === void 0) { offset = 0; }
            if (value === void 0) { value = 0; }
            var _this = _super.call(this, offset, value) || this;
            _this.lineValue = 0;
            _this.lineValue = value;
            return _this;
        }
        return TabBendRenderPoint;
    }(BendPoint));

    var __extends$1F = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabBendGlyph = /** @class */ (function (_super) {
        __extends$1F(TabBendGlyph, _super);
        function TabBendGlyph() {
            var _this = _super.call(this, 0, 0) || this;
            _this._notes = [];
            _this._renderPoints = new Map();
            _this._preBendMinValue = -1;
            _this._bendMiddleMinValue = -1;
            _this._bendEndMinValue = -1;
            _this._bendEndContinuedMinValue = -1;
            _this._releaseMinValue = -1;
            _this._releaseContinuedMinValue = -1;
            _this._maxBendValue = -1;
            return _this;
        }
        TabBendGlyph.prototype.addBends = function (note) {
            this._notes.push(note);
            var renderPoints = this.createRenderingPoints(note);
            this._renderPoints.set(note.id, renderPoints);
            if (this._maxBendValue === -1 || this._maxBendValue < note.maxBendPoint.value) {
                this._maxBendValue = note.maxBendPoint.value;
            }
            // compute arrow end values for common bend types
            var value = 0;
            switch (note.bendType) {
                case BendType.Bend:
                    value = renderPoints[1].value;
                    if (note.isTieOrigin) {
                        if (this._bendEndContinuedMinValue === -1 || value < this._bendEndContinuedMinValue) {
                            this._bendEndContinuedMinValue = value;
                        }
                    }
                    else {
                        if (this._bendEndMinValue === -1 || value < this._bendEndMinValue) {
                            this._bendEndMinValue = value;
                        }
                    }
                    break;
                case BendType.Release:
                    value = renderPoints[1].value;
                    if (note.isTieOrigin) {
                        if (this._releaseContinuedMinValue === -1 || value < this._releaseContinuedMinValue) {
                            this._releaseContinuedMinValue = value;
                        }
                    }
                    else {
                        if (value > 0 && (this._releaseMinValue === -1 || value < this._releaseMinValue)) {
                            this._releaseMinValue = value;
                        }
                    }
                    break;
                case BendType.BendRelease:
                    value = renderPoints[1].value;
                    if (this._bendMiddleMinValue === -1 || value < this._bendMiddleMinValue) {
                        this._bendMiddleMinValue = value;
                    }
                    value = renderPoints[2].value;
                    if (note.isTieOrigin) {
                        if (this._releaseContinuedMinValue === -1 || value < this._releaseContinuedMinValue) {
                            this._releaseContinuedMinValue = value;
                        }
                    }
                    else {
                        if (value > 0 && (this._releaseMinValue === -1 || value < this._releaseMinValue)) {
                            this._releaseMinValue = value;
                        }
                    }
                    break;
                case BendType.Prebend:
                    value = renderPoints[0].value;
                    if (this._preBendMinValue === -1 || value < this._preBendMinValue) {
                        this._preBendMinValue = value;
                    }
                    break;
                case BendType.PrebendBend:
                    value = renderPoints[0].value;
                    if (this._preBendMinValue === -1 || value < this._preBendMinValue) {
                        this._preBendMinValue = value;
                    }
                    value = renderPoints[1].value;
                    if (note.isTieOrigin) {
                        if (this._bendEndContinuedMinValue === -1 || value < this._bendEndContinuedMinValue) {
                            this._bendEndContinuedMinValue = value;
                        }
                    }
                    else {
                        if (this._bendEndMinValue === -1 || value < this._bendEndMinValue) {
                            this._bendEndMinValue = value;
                        }
                    }
                    break;
                case BendType.PrebendRelease:
                    value = renderPoints[0].value;
                    if (this._preBendMinValue === -1 || value < this._preBendMinValue) {
                        this._preBendMinValue = value;
                    }
                    value = renderPoints[1].value;
                    if (note.isTieOrigin) {
                        if (this._releaseContinuedMinValue === -1 || value < this._releaseContinuedMinValue) {
                            this._releaseContinuedMinValue = value;
                        }
                    }
                    else {
                        if (value > 0 && (this._releaseMinValue === -1 || value < this._releaseMinValue)) {
                            this._releaseMinValue = value;
                        }
                    }
                    break;
            }
        };
        TabBendGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            var bendHeight = this._maxBendValue * TabBendGlyph.BendValueHeight * this.scale;
            this.renderer.registerOverflowTop(bendHeight);
            var value = 0;
            for (var _i = 0, _a = this._notes; _i < _a.length; _i++) {
                var note = _a[_i];
                var renderPoints = this._renderPoints.get(note.id);
                switch (note.bendType) {
                    case BendType.Bend:
                        renderPoints[1].lineValue = note.isTieOrigin
                            ? this._bendEndContinuedMinValue
                            : this._bendEndMinValue;
                        break;
                    case BendType.Release:
                        value = note.isTieOrigin ? this._releaseContinuedMinValue : this._releaseMinValue;
                        if (value >= 0) {
                            renderPoints[1].lineValue = value;
                        }
                        break;
                    case BendType.BendRelease:
                        renderPoints[1].lineValue = this._bendMiddleMinValue;
                        value = note.isTieOrigin ? this._releaseContinuedMinValue : this._releaseMinValue;
                        if (value >= 0) {
                            renderPoints[2].lineValue = value;
                        }
                        break;
                    case BendType.Prebend:
                        renderPoints[0].lineValue = this._preBendMinValue;
                        break;
                    case BendType.PrebendBend:
                        renderPoints[0].lineValue = this._preBendMinValue;
                        renderPoints[1].lineValue = note.isTieOrigin
                            ? this._bendEndContinuedMinValue
                            : this._bendEndMinValue;
                        break;
                    case BendType.PrebendRelease:
                        renderPoints[0].lineValue = this._preBendMinValue;
                        value = note.isTieOrigin ? this._releaseContinuedMinValue : this._releaseMinValue;
                        if (value >= 0) {
                            renderPoints[1].lineValue = value;
                        }
                        break;
                }
            }
            this.width = 0;
            this._notes.sort(function (a, b) {
                if (a.isStringed) {
                    return a.string - b.string;
                }
                return a.realValue - b.realValue;
            });
        };
        TabBendGlyph.prototype.createRenderingPoints = function (note) {
            var renderingPoints = [];
            // Guitar Pro Rendering Note:
            // Last point of bend is always at end of the note even
            // though it might not be 100% correct from timing perspective.
            switch (note.bendType) {
                case BendType.Custom:
                    for (var _i = 0, _a = note.bendPoints; _i < _a.length; _i++) {
                        var bendPoint = _a[_i];
                        renderingPoints.push(new TabBendRenderPoint(bendPoint.offset, bendPoint.value));
                    }
                    break;
                case BendType.BendRelease:
                    renderingPoints.push(new TabBendRenderPoint(0, note.bendPoints[0].value));
                    renderingPoints.push(new TabBendRenderPoint((BendPoint.MaxPosition / 2) | 0, note.bendPoints[1].value));
                    renderingPoints.push(new TabBendRenderPoint(BendPoint.MaxPosition, note.bendPoints[3].value));
                    break;
                case BendType.Bend:
                case BendType.Hold:
                case BendType.Prebend:
                case BendType.PrebendBend:
                case BendType.PrebendRelease:
                case BendType.Release:
                    renderingPoints.push(new TabBendRenderPoint(0, note.bendPoints[0].value));
                    renderingPoints.push(new TabBendRenderPoint(BendPoint.MaxPosition, note.bendPoints[1].value));
                    break;
            }
            return renderingPoints;
        };
        TabBendGlyph.prototype.paint = function (cx, cy, canvas) {
            var color = canvas.color;
            if (this._notes.length > 1) {
                canvas.color = this.renderer.resources.secondaryGlyphColor;
            }
            for (var _i = 0, _a = this._notes; _i < _a.length; _i++) {
                var note = _a[_i];
                var renderPoints = this._renderPoints.get(note.id);
                var startNoteRenderer = this.renderer;
                var endNote = note;
                var isMultiBeatBend = false;
                var endNoteRenderer = null;
                var endNoteHasBend = false;
                var slurText = note.bendStyle === BendStyle.Gradual ? 'grad.' : '';
                var endBeat = null;
                while (endNote.isTieOrigin) {
                    var nextNote = endNote.tieDestination;
                    endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, nextNote.beat.voice.bar);
                    if (!endNoteRenderer || startNoteRenderer.staff !== endNoteRenderer.staff) {
                        break;
                    }
                    endNote = nextNote;
                    isMultiBeatBend = true;
                    if (endNote.hasBend || !this.renderer.settings.notation.extendBendArrowsOnTiedNotes) {
                        endNoteHasBend = true;
                        break;
                    }
                }
                endBeat = endNote.beat;
                endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, endBeat.voice.bar);
                if (endBeat.isLastOfVoice &&
                    !endNote.hasBend &&
                    this.renderer.settings.notation.extendBendArrowsOnTiedNotes) {
                    endBeat = null;
                }
                var startX = 0;
                var endX = 0;
                var topY = cy + startNoteRenderer.y;
                // float bottomY = cy + startNoteRenderer.Y + startNoteRenderer.GetNoteY(note);
                startX = cx + startNoteRenderer.x;
                if (renderPoints[0].value > 0 || note.isContinuedBend) {
                    startX += startNoteRenderer.getBeatX(note.beat, BeatXPosition.MiddleNotes);
                }
                else {
                    startX += startNoteRenderer.getNoteX(note, NoteXPosition.Right);
                }
                // canvas.Color = Color.Random();
                // canvas.FillRect(
                //    cx + startNoteRenderer.X + startNoteRenderer.GetBeatX(_note.Beat, BeatXPosition.MiddleNotes),
                //    cy + startNoteRenderer.Y, 10, 10);
                // canvas.FillRect(
                //    cx + startNoteRenderer.X + startNoteRenderer.GetBeatX(_note.Beat, BeatXPosition.EndBeat),
                //    cy + startNoteRenderer.Y + 10, 10, 10);
                if (!endBeat || (endBeat.isLastOfVoice && !endNoteHasBend)) {
                    endX = cx + endNoteRenderer.x + endNoteRenderer.postBeatGlyphsStart;
                }
                else if (endNoteHasBend || !endBeat.nextBeat) {
                    endX = cx + endNoteRenderer.x + endNoteRenderer.getBeatX(endBeat, BeatXPosition.MiddleNotes);
                }
                else if (note.bendType === BendType.Hold) {
                    endX = cx + endNoteRenderer.x + endNoteRenderer.getBeatX(endBeat.nextBeat, BeatXPosition.OnNotes);
                }
                else {
                    endX = cx + endNoteRenderer.x + endNoteRenderer.getBeatX(endBeat.nextBeat, BeatXPosition.PreNotes);
                }
                if (!isMultiBeatBend) {
                    endX -= TabBendGlyph.ArrowSize * this.scale;
                }
                // we need some pixels for the arrow. otherwise we might draw into the next
                // note
                var width = endX - startX;
                // calculate offsets per step
                var dX = width / BendPoint.MaxPosition;
                canvas.beginPath();
                for (var i = 0, j = renderPoints.length - 1; i < j; i++) {
                    var firstPt = renderPoints[i];
                    var secondPt = renderPoints[i + 1];
                    // draw pre-bend if previous
                    if (i === 0 && firstPt.value !== 0 && !note.isTieDestination) {
                        this.paintBend(note, new TabBendRenderPoint(0, 0), firstPt, startX, topY, dX, slurText, canvas);
                    }
                    if (note.bendType !== BendType.Prebend) {
                        if (i === 0) {
                            startX += 2 * this.scale;
                        }
                        this.paintBend(note, firstPt, secondPt, startX, topY, dX, slurText, canvas);
                    }
                    else if (note.isTieOrigin && note.tieDestination.hasBend) {
                        secondPt = new TabBendRenderPoint(BendPoint.MaxPosition, firstPt.value);
                        secondPt.lineValue = firstPt.lineValue;
                        this.paintBend(note, firstPt, secondPt, startX, topY, dX, slurText, canvas);
                    }
                }
                canvas.color = color;
            }
        };
        TabBendGlyph.prototype.paintBend = function (note, firstPt, secondPt, cx, cy, dX, slurText, canvas) {
            var r = this.renderer;
            var res = this.renderer.resources;
            var overflowOffset = r.lineOffset / 2;
            var x1 = cx + dX * firstPt.offset;
            var bendValueHeight = TabBendGlyph.BendValueHeight * this.scale;
            var y1 = cy - bendValueHeight * firstPt.lineValue;
            if (firstPt.value === 0) {
                if (secondPt.offset === firstPt.offset) {
                    y1 += r.getNoteY(note.beat.maxStringNote, NoteYPosition.Top);
                }
                else {
                    y1 += r.getNoteY(note, NoteYPosition.Center);
                }
            }
            else {
                y1 += overflowOffset;
            }
            var x2 = cx + dX * secondPt.offset;
            var y2 = cy - bendValueHeight * secondPt.lineValue;
            if (secondPt.lineValue === 0) {
                y2 += r.getNoteY(note, NoteYPosition.Center);
            }
            else {
                y2 += overflowOffset;
            }
            // what type of arrow? (up/down)
            var arrowOffset = 0;
            var arrowSize = TabBendGlyph.ArrowSize * this.scale;
            if (secondPt.value > firstPt.value) {
                if (y2 + arrowSize > y1) {
                    y2 = y1 - arrowSize;
                }
                canvas.beginPath();
                canvas.moveTo(x2, y2);
                canvas.lineTo(x2 - arrowSize * 0.5, y2 + arrowSize);
                canvas.lineTo(x2 + arrowSize * 0.5, y2 + arrowSize);
                canvas.closePath();
                canvas.fill();
                arrowOffset = arrowSize;
            }
            else if (secondPt.value !== firstPt.value) {
                if (y2 < y1) {
                    y2 = y1 + arrowSize;
                }
                canvas.beginPath();
                canvas.moveTo(x2, y2);
                canvas.lineTo(x2 - arrowSize * 0.5, y2 - arrowSize);
                canvas.lineTo(x2 + arrowSize * 0.5, y2 - arrowSize);
                canvas.closePath();
                canvas.fill();
                arrowOffset = -arrowSize;
            }
            canvas.stroke();
            if (firstPt.value === secondPt.value) {
                // draw horizontal dashed line
                // to really have the line ending at the right position
                // we draw from right to left. it's okay if the space is at the beginning
                if (firstPt.lineValue > 0) {
                    var dashX = x2;
                    var dashSize = TabBendGlyph.DashSize * this.scale;
                    var end = x1 + dashSize;
                    var dashes = (dashX - x1) / (dashSize * 2);
                    if (dashes < 1) {
                        canvas.moveTo(dashX, y1);
                        canvas.lineTo(x1, y1);
                    }
                    else {
                        while (dashX > end) {
                            canvas.moveTo(dashX, y1);
                            canvas.lineTo(dashX - dashSize, y1);
                            dashX -= dashSize * 2;
                        }
                    }
                    canvas.stroke();
                }
            }
            else {
                if (x2 > x1) {
                    // draw bezier lien from first to second point
                    canvas.moveTo(x1, y1);
                    canvas.bezierCurveTo((x1 + x2) / 2, y1, x2, y1, x2, y2 + arrowOffset);
                    canvas.stroke();
                }
                else {
                    canvas.moveTo(x1, y1);
                    canvas.lineTo(x2, y2);
                    canvas.stroke();
                }
            }
            if (slurText && firstPt.offset < secondPt.offset) {
                canvas.font = res.graceFont;
                var size = canvas.measureText(slurText);
                var y = 0;
                var x = 0;
                if (y1 > y2) {
                    var h = Math.abs(y1 - y2);
                    y = h > canvas.font.size * 1.3 ? y1 - h / 2 : y1;
                    x = (x1 + x2 - size) / 2;
                }
                else {
                    y = y1;
                    x = x2 - size;
                }
                canvas.fillText(slurText, x, y);
            }
            if (secondPt.value !== 0 && firstPt.value !== secondPt.value) {
                var dV = secondPt.value;
                var up = secondPt.value > firstPt.value;
                dV = Math.abs(dV);
                // calculate label
                var s = '';
                // Full Steps
                if (dV === 4) {
                    s = 'full';
                    dV -= 4;
                }
                else if (dV >= 4 || dV <= -4) {
                    var steps = (dV / 4) | 0;
                    s += steps;
                    // Quaters
                    dV -= steps * 4;
                }
                if (dV > 0) {
                    s += TabBendGlyph.getFractionSign(dV);
                }
                if (s !== '') {
                    y2 = cy - bendValueHeight * secondPt.value;
                    var startY = y2;
                    if (!up) {
                        startY = y1 + (Math.abs(y2 - y1) * 1) / 3;
                    }
                    // draw label
                    canvas.font = res.tablatureFont;
                    var size = canvas.measureText(s);
                    var y = startY - res.tablatureFont.size * 0.5 - 2 * this.scale;
                    var x = x2 - size / 2;
                    canvas.fillText(s, x, y);
                }
            }
        };
        TabBendGlyph.getFractionSign = function (steps) {
            switch (steps) {
                case 1:
                    return 'Â¼';
                case 2:
                    return 'Â½';
                case 3:
                    return 'Â¾';
                default:
                    return steps + '/ 4';
            }
        };
        TabBendGlyph.ArrowSize = 6;
        TabBendGlyph.DashSize = 3;
        TabBendGlyph.BendValueHeight = 6;
        return TabBendGlyph;
    }(Glyph));

    var __extends$1G = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabWhammyBarGlyph = /** @class */ (function (_super) {
        __extends$1G(TabWhammyBarGlyph, _super);
        function TabWhammyBarGlyph(beat) {
            var _this = _super.call(this, 0, 0) || this;
            _this._isSimpleDip = false;
            _this._beat = beat;
            _this._renderPoints = _this.createRenderingPoints(beat);
            return _this;
        }
        TabWhammyBarGlyph.prototype.createRenderingPoints = function (beat) {
            // advanced rendering
            if (beat.whammyBarType === WhammyType.Custom) {
                return beat.whammyBarPoints;
            }
            var renderingPoints = [];
            // Guitar Pro Rendering Note:
            // Last point of bend is always at end of the beat even
            // though it might not be 100% correct from timing perspective.
            switch (beat.whammyBarType) {
                case WhammyType.Dive:
                case WhammyType.Hold:
                case WhammyType.PrediveDive:
                case WhammyType.Predive:
                    renderingPoints.push(new BendPoint(0, beat.whammyBarPoints[0].value));
                    renderingPoints.push(new BendPoint(BendPoint.MaxPosition, beat.whammyBarPoints[1].value));
                    break;
                case WhammyType.Dip:
                    renderingPoints.push(new BendPoint(0, beat.whammyBarPoints[0].value));
                    renderingPoints.push(new BendPoint((BendPoint.MaxPosition / 2) | 0, beat.whammyBarPoints[1].value));
                    renderingPoints.push(new BendPoint(BendPoint.MaxPosition, beat.whammyBarPoints[beat.whammyBarPoints.length - 1].value));
                    break;
            }
            return renderingPoints;
        };
        TabWhammyBarGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            this._isSimpleDip =
                this.renderer.settings.notation.notationMode === exports.NotationMode.SongBook &&
                    this._beat.whammyBarType === WhammyType.Dip;
            //
            // Get the min and max values for all combined whammys
            var minValue = null;
            var maxValue = null;
            var beat = this._beat;
            while (beat && beat.hasWhammyBar) {
                if (!minValue || minValue.value > beat.minWhammyPoint.value) {
                    minValue = beat.minWhammyPoint;
                }
                if (!maxValue || maxValue.value < beat.maxWhammyPoint.value) {
                    maxValue = beat.maxWhammyPoint;
                }
                beat = beat.nextBeat;
            }
            var topOffset = maxValue.value > 0 ? Math.abs(this.getOffset(maxValue.value)) : 0;
            if (topOffset > 0 ||
                this._beat.whammyBarPoints[0].value !== 0 ||
                this.renderer.settings.notation.isNotationElementVisible(NotationElement.ZerosOnDiveWhammys)) {
                topOffset += this.renderer.resources.tablatureFont.size * 2;
            }
            var bottomOffset = minValue.value < 0 ? Math.abs(this.getOffset(minValue.value)) : 0;
            this.renderer.registerOverflowTop(topOffset + bottomOffset);
            var currentOffset = this.renderer.staff.getSharedLayoutData(TabWhammyBarGlyph.TopOffsetSharedDataKey, -1);
            if (topOffset > currentOffset) {
                this.renderer.staff.setSharedLayoutData(TabWhammyBarGlyph.TopOffsetSharedDataKey, topOffset);
            }
        };
        TabWhammyBarGlyph.prototype.getOffset = function (value) {
            if (value === 0) {
                return 0;
            }
            var offset = TabWhammyBarGlyph.PerHalfSize * this.scale +
                Math.log2(Math.abs(value) / 2) * TabWhammyBarGlyph.PerHalfSize * this.scale;
            if (value < 0) {
                offset = -offset;
            }
            return offset;
        };
        TabWhammyBarGlyph.prototype.paint = function (cx, cy, canvas) {
            var startNoteRenderer = this.renderer;
            var endBeat = this._beat.nextBeat;
            var endNoteRenderer = null;
            var endXPositionType = BeatXPosition.PreNotes;
            if (endBeat) {
                endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, endBeat.voice.bar);
                if (!endNoteRenderer || endNoteRenderer.staff !== startNoteRenderer.staff) {
                    endBeat = null;
                    endNoteRenderer = null;
                }
                else if (endNoteRenderer !== startNoteRenderer && !endBeat.hasWhammyBar) {
                    endBeat = null;
                    endNoteRenderer = null;
                }
                else {
                    endXPositionType =
                        endBeat.hasWhammyBar &&
                            (startNoteRenderer.settings.notation.notationMode !== exports.NotationMode.SongBook ||
                                endBeat.whammyBarType !== WhammyType.Dip)
                            ? BeatXPosition.MiddleNotes
                            : BeatXPosition.PreNotes;
                }
            }
            var startX = 0;
            var endX = 0;
            if (this._isSimpleDip) {
                startX =
                    cx +
                        startNoteRenderer.x +
                        startNoteRenderer.getBeatX(this._beat, BeatXPosition.OnNotes) -
                        2 * this.scale;
                endX =
                    cx +
                        startNoteRenderer.x +
                        startNoteRenderer.getBeatX(this._beat, BeatXPosition.PostNotes) +
                        2 * this.scale;
            }
            else {
                startX = cx + startNoteRenderer.x + startNoteRenderer.getBeatX(this._beat, BeatXPosition.MiddleNotes);
                endX = !endNoteRenderer
                    ? cx + startNoteRenderer.x + startNoteRenderer.width - 2 * this.scale
                    : cx + endNoteRenderer.x + endNoteRenderer.getBeatX(endBeat, endXPositionType);
            }
            var old = canvas.textAlign;
            canvas.textAlign = TextAlign.Center;
            if (this._renderPoints.length >= 2) {
                var dx = (endX - startX) / BendPoint.MaxPosition;
                canvas.beginPath();
                var zeroY = cy + this.renderer.staff.getSharedLayoutData(TabWhammyBarGlyph.TopOffsetSharedDataKey, 0);
                var slurText = this._beat.whammyStyle === BendStyle.Gradual ? 'grad.' : '';
                for (var i = 0, j = this._renderPoints.length - 1; i < j; i++) {
                    var firstPt = this._renderPoints[i];
                    var secondPt = this._renderPoints[i + 1];
                    var nextPt = i < j - 2 ? this._renderPoints[i + 2] : null;
                    var isFirst = i === 0;
                    // draw pre-bend if previous
                    if (i === 0 && firstPt.value !== 0 && !this._beat.isContinuedWhammy) {
                        this.paintWhammy(false, new BendPoint(0, 0), firstPt, secondPt, startX, zeroY, dx, canvas);
                        isFirst = false;
                    }
                    this.paintWhammy(isFirst, firstPt, secondPt, nextPt, startX, zeroY, dx, canvas, slurText);
                    slurText = '';
                }
                canvas.stroke();
            }
            canvas.textAlign = old;
        };
        TabWhammyBarGlyph.prototype.paintWhammy = function (isFirst, firstPt, secondPt, nextPt, cx, cy, dx, canvas, slurText) {
            var x1 = cx + dx * firstPt.offset;
            var x2 = cx + dx * secondPt.offset;
            var y1 = cy - this.getOffset(firstPt.value);
            var y2 = cy - this.getOffset(secondPt.value);
            if (firstPt.offset === secondPt.offset) {
                var dashSize = TabWhammyBarGlyph.DashSize * this.scale;
                var dashes = Math.abs(y2 - y1) / (dashSize * 2);
                if (dashes < 1) {
                    canvas.moveTo(x1, y1);
                    canvas.lineTo(x2, y2);
                }
                else {
                    var dashEndY = Math.max(y1, y2);
                    var dashStartY = Math.min(y1, y2);
                    while (dashEndY > dashStartY) {
                        canvas.moveTo(x1, dashStartY);
                        canvas.lineTo(x1, dashStartY + dashSize);
                        dashStartY += dashSize * 2;
                    }
                }
                canvas.stroke();
            }
            else if (firstPt.value === secondPt.value) {
                var dashSize = TabWhammyBarGlyph.DashSize * this.scale;
                var dashes = Math.abs(x2 - x1) / (dashSize * 2);
                if (dashes < 1) {
                    canvas.moveTo(x1, y1);
                    canvas.lineTo(x2, y2);
                }
                else {
                    var dashEndX = Math.max(x1, x2);
                    var dashStartX = Math.min(x1, x2);
                    while (dashEndX > dashStartX) {
                        canvas.moveTo(dashEndX, y1);
                        canvas.lineTo(dashEndX - dashSize, y1);
                        dashEndX -= dashSize * 2;
                    }
                }
                canvas.stroke();
            }
            else {
                canvas.moveTo(x1, y1);
                canvas.lineTo(x2, y2);
            }
            var res = this.renderer.resources;
            if (isFirst && !this._beat.isContinuedWhammy && !this._isSimpleDip) {
                var y = y1;
                y -= res.tablatureFont.size + 2 * this.scale;
                if (this.renderer.settings.notation.isNotationElementVisible(NotationElement.ZerosOnDiveWhammys)) {
                    canvas.fillText('0', x1, y);
                }
                if (slurText) {
                    y -= res.tablatureFont.size + 2 * this.scale;
                    canvas.fillText(slurText, x1, y);
                }
            }
            var dV = Math.abs(secondPt.value);
            if ((dV !== 0 || (this.renderer.settings.notation.isNotationElementVisible(NotationElement.ZerosOnDiveWhammys) && !this._isSimpleDip)) &&
                firstPt.value !== secondPt.value) {
                var s = '';
                if (secondPt.value < 0) {
                    s += '-';
                }
                if (dV >= 4) {
                    var steps = (dV / 4) | 0;
                    s += steps;
                    // Quaters
                    dV -= steps * 4;
                }
                else if (dV === 0) {
                    s += '0';
                }
                if (dV > 0) {
                    s += TabBendGlyph.getFractionSign(dV);
                }
                var y = 0;
                if (this._isSimpleDip) {
                    y = Math.min(y1, y2) - res.tablatureFont.size - 2 * this.scale;
                }
                else {
                    y = firstPt.offset === secondPt.offset ? Math.min(y1, y2) : y2;
                    y -= res.tablatureFont.size + 2 * this.scale;
                    if (nextPt && nextPt.value > secondPt.value) {
                        y -= 2 * this.scale;
                    }
                }
                var x = x2;
                canvas.fillText(s, x, y);
            }
        };
        TabWhammyBarGlyph.TopOffsetSharedDataKey = 'tab.whammy.topoffset';
        TabWhammyBarGlyph.PerHalfSize = 6;
        TabWhammyBarGlyph.DashSize = 3;
        return TabWhammyBarGlyph;
    }(Glyph));

    var __extends$1H = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreWhammyBarGlyph = /** @class */ (function (_super) {
        __extends$1H(ScoreWhammyBarGlyph, _super);
        function ScoreWhammyBarGlyph(beat) {
            var _this = _super.call(this, 0, 0) || this;
            _this._beat = beat;
            return _this;
        }
        ScoreWhammyBarGlyph.prototype.doLayout = function () {
            var whammyMode = this.renderer.settings.notation.notationMode;
            switch (this._beat.whammyBarType) {
                case WhammyType.None:
                case WhammyType.Custom:
                case WhammyType.Hold:
                    return;
                case WhammyType.Dive:
                case WhammyType.PrediveDive:
                    {
                        var endGlyphs = new BendNoteHeadGroupGlyph(this._beat, false);
                        endGlyphs.renderer = this.renderer;
                        var lastWhammyPoint = this._beat.whammyBarPoints[this._beat.whammyBarPoints.length - 1];
                        for (var _i = 0, _a = this._beat.notes; _i < _a.length; _i++) {
                            var note = _a[_i];
                            if (!note.isTieOrigin) {
                                endGlyphs.addGlyph(this.getBendNoteValue(note, lastWhammyPoint), lastWhammyPoint.value % 2 !== 0);
                            }
                        }
                        endGlyphs.doLayout();
                        this.BendNoteHeads.push(endGlyphs);
                    }
                    break;
                case WhammyType.Dip:
                    {
                        if (whammyMode === exports.NotationMode.SongBook) {
                            var res = this.renderer.resources;
                            this.renderer.simpleWhammyOverflow =
                                res.tablatureFont.size * 1.5 +
                                    ScoreWhammyBarGlyph.SimpleDipHeight * this.scale +
                                    ScoreWhammyBarGlyph.SimpleDipPadding * this.scale;
                        }
                        else {
                            var middleGlyphs = new BendNoteHeadGroupGlyph(this._beat, false);
                            middleGlyphs.renderer = this.renderer;
                            if (this.renderer.settings.notation.notationMode === exports.NotationMode.GuitarPro) {
                                var middleBendPoint = this._beat.whammyBarPoints[1];
                                for (var _b = 0, _c = this._beat.notes; _b < _c.length; _b++) {
                                    var note = _c[_b];
                                    middleGlyphs.addGlyph(this.getBendNoteValue(note, this._beat.whammyBarPoints[1]), middleBendPoint.value % 2 !== 0);
                                }
                            }
                            middleGlyphs.doLayout();
                            this.BendNoteHeads.push(middleGlyphs);
                            var endGlyphs = new BendNoteHeadGroupGlyph(this._beat, false);
                            endGlyphs.renderer = this.renderer;
                            if (this.renderer.settings.notation.notationMode === exports.NotationMode.GuitarPro) {
                                var lastBendPoint = this._beat.whammyBarPoints[this._beat.whammyBarPoints.length - 1];
                                for (var _d = 0, _e = this._beat.notes; _d < _e.length; _d++) {
                                    var note = _e[_d];
                                    endGlyphs.addGlyph(this.getBendNoteValue(note, lastBendPoint), lastBendPoint.value % 2 !== 0);
                                }
                            }
                            endGlyphs.doLayout();
                            this.BendNoteHeads.push(endGlyphs);
                        }
                    }
                    break;
                case WhammyType.Predive:
                    break;
            }
            _super.prototype.doLayout.call(this);
        };
        ScoreWhammyBarGlyph.prototype.paint = function (cx, cy, canvas) {
            var beat = this._beat;
            switch (beat.whammyBarType) {
                case WhammyType.None:
                case WhammyType.Custom:
                    return;
            }
            var whammyMode = this.renderer.settings.notation.notationMode;
            var startNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, beat.voice.bar);
            var startX = cx + startNoteRenderer.x + startNoteRenderer.getBeatX(beat, BeatXPosition.MiddleNotes);
            var beatDirection = this.getTieDirection(beat, startNoteRenderer);
            var direction = this._beat.notes.length === 1 ? beatDirection : BeamDirection.Up;
            var textalign = canvas.textAlign;
            for (var i = 0; i < beat.notes.length; i++) {
                var note = beat.notes[i];
                var startY = cy + startNoteRenderer.y;
                if (i > 0 && i >= ((this._beat.notes.length / 2) | 0)) {
                    direction = BeamDirection.Down;
                }
                if (direction === BeamDirection.Down) {
                    startY += startNoteRenderer.getNoteY(note, NoteYPosition.Bottom);
                }
                else {
                    startY += startNoteRenderer.getNoteY(note, NoteYPosition.Top);
                }
                var endX = cx + startNoteRenderer.x;
                if (beat.isLastOfVoice) {
                    endX += startNoteRenderer.width;
                }
                else {
                    endX += startNoteRenderer.getBeatX(beat, BeatXPosition.EndBeat);
                }
                endX -= 8 * this.scale;
                var slurText = beat.whammyStyle === BendStyle.Gradual && i === 0 ? 'grad.' : '';
                var endNoteRenderer = null;
                if (note.isTieOrigin) {
                    endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, note.tieDestination.beat.voice.bar);
                    if (endNoteRenderer && endNoteRenderer.staff === startNoteRenderer.staff) {
                        endX =
                            cx +
                                endNoteRenderer.x +
                                endNoteRenderer.getBeatX(note.tieDestination.beat, BeatXPosition.MiddleNotes);
                    }
                    else {
                        endNoteRenderer = null;
                    }
                }
                var heightOffset = NoteHeadGlyph.NoteHeadHeight * this.scale * NoteHeadGlyph.GraceScale * 0.5;
                if (direction === BeamDirection.Up) {
                    heightOffset = -heightOffset;
                }
                var endValue = beat.whammyBarPoints.length > 0
                    ? this.getBendNoteValue(note, beat.whammyBarPoints[beat.whammyBarPoints.length - 1])
                    : 0;
                var endY = 0;
                var bendTie = false;
                if (this.BendNoteHeads.length > 0 && this.BendNoteHeads[0].containsNoteValue(endValue)) {
                    endY = this.BendNoteHeads[0].getNoteValueY(endValue) + heightOffset;
                    bendTie = true;
                }
                else if (endNoteRenderer &&
                    ((note.isTieOrigin && note.tieDestination.beat.hasWhammyBar) || note.beat.isContinuedWhammy)) {
                    endY = cy + endNoteRenderer.y + endNoteRenderer.getNoteY(note.tieDestination, NoteYPosition.Top);
                    bendTie = true;
                    if (direction === BeamDirection.Down) {
                        endY += NoteHeadGlyph.NoteHeadHeight * this.scale;
                    }
                }
                else if (note.isTieOrigin) {
                    if (!endNoteRenderer) {
                        endY = startY;
                    }
                    else {
                        endY = cy + endNoteRenderer.y + endNoteRenderer.getNoteY(note.tieDestination, NoteYPosition.Top);
                    }
                    if (direction === BeamDirection.Down) {
                        endY += NoteHeadGlyph.NoteHeadHeight * this.scale;
                    }
                }
                switch (beat.whammyBarType) {
                    case WhammyType.Hold:
                        if (note.isTieOrigin) {
                            TieGlyph.paintTie(canvas, this.scale, startX, startY, endX, endY, beatDirection === BeamDirection.Down, 22, 4);
                        }
                        break;
                    case WhammyType.Dive:
                        if (i === 0) {
                            this.BendNoteHeads[0].x = endX - this.BendNoteHeads[0].noteHeadOffset;
                            this.BendNoteHeads[0].y = cy + startNoteRenderer.y;
                            this.BendNoteHeads[0].paint(0, 0, canvas);
                            if (this.BendNoteHeads[0].containsNoteValue(endValue)) {
                                endY += this.BendNoteHeads[0].y;
                            }
                        }
                        if (bendTie) {
                            this.drawBendSlur(canvas, startX, startY, endX, endY, direction === BeamDirection.Down, this.scale, slurText);
                        }
                        else if (note.isTieOrigin) {
                            TieGlyph.paintTie(canvas, this.scale, startX, startY, endX, endY, beatDirection === BeamDirection.Down, 22, 4);
                        }
                        break;
                    case WhammyType.Dip:
                        if (whammyMode === exports.NotationMode.SongBook) {
                            if (i === 0) {
                                var simpleStartX = cx +
                                    startNoteRenderer.x +
                                    startNoteRenderer.getBeatX(this._beat, BeatXPosition.OnNotes) -
                                    2 * this.scale;
                                var simpleEndX = cx +
                                    startNoteRenderer.x +
                                    startNoteRenderer.getBeatX(this._beat, BeatXPosition.PostNotes) +
                                    2 * this.scale;
                                var middleX = (simpleStartX + simpleEndX) / 2;
                                var text = (((this._beat.whammyBarPoints[1].value - this._beat.whammyBarPoints[0].value) / 4) |
                                    0).toString();
                                canvas.font = this.renderer.resources.tablatureFont;
                                canvas.fillText(text, middleX, cy + this.y);
                                var simpleStartY = cy + this.y + canvas.font.size + 2 * this.scale;
                                var simpleEndY = simpleStartY + ScoreWhammyBarGlyph.SimpleDipHeight * this.scale;
                                if (this._beat.whammyBarPoints[1].value > this._beat.whammyBarPoints[0].value) {
                                    canvas.moveTo(simpleStartX, simpleEndY);
                                    canvas.lineTo(middleX, simpleStartY);
                                    canvas.lineTo(simpleEndX, simpleEndY);
                                }
                                else {
                                    canvas.moveTo(simpleStartX, simpleStartY);
                                    canvas.lineTo(middleX, simpleEndY);
                                    canvas.lineTo(simpleEndX, simpleStartY);
                                }
                                canvas.stroke();
                            }
                            if (note.isTieOrigin) {
                                TieGlyph.paintTie(canvas, this.scale, startX, startY, endX, endY, beatDirection === BeamDirection.Down, 22, 4);
                            }
                        }
                        else {
                            var middleX = (startX + endX) / 2;
                            this.BendNoteHeads[0].x = middleX - this.BendNoteHeads[0].noteHeadOffset;
                            this.BendNoteHeads[0].y = cy + startNoteRenderer.y;
                            this.BendNoteHeads[0].paint(0, 0, canvas);
                            var middleValue = this.getBendNoteValue(note, beat.whammyBarPoints[1]);
                            var middleY = this.BendNoteHeads[0].getNoteValueY(middleValue) + heightOffset;
                            this.drawBendSlur(canvas, startX, startY, middleX, middleY, direction === BeamDirection.Down, this.scale, slurText);
                            this.BendNoteHeads[1].x = endX - this.BendNoteHeads[1].noteHeadOffset;
                            this.BendNoteHeads[1].y = cy + startNoteRenderer.y;
                            this.BendNoteHeads[1].paint(0, 0, canvas);
                            endY = this.BendNoteHeads[1].getNoteValueY(endValue) + heightOffset;
                            this.drawBendSlur(canvas, middleX, middleY, endX, endY, direction === BeamDirection.Down, this.scale, slurText);
                        }
                        break;
                    case WhammyType.PrediveDive:
                    case WhammyType.Predive:
                        var preX = cx + startNoteRenderer.x + startNoteRenderer.getBeatX(note.beat, BeatXPosition.PreNotes);
                        preX += startNoteRenderer.getPreNotesGlyphForBeat(note.beat)
                            .prebendNoteHeadOffset;
                        var preY = cy +
                            startNoteRenderer.y +
                            startNoteRenderer.getScoreY(startNoteRenderer.accidentalHelper.getNoteLineForValue(note.displayValue - ((note.beat.whammyBarPoints[0].value / 2) | 0), false), 0) +
                            heightOffset;
                        this.drawBendSlur(canvas, preX, preY, startX, startY, direction === BeamDirection.Down, this.scale, slurText);
                        if (this.BendNoteHeads.length > 0) {
                            this.BendNoteHeads[0].x = endX - this.BendNoteHeads[0].noteHeadOffset;
                            this.BendNoteHeads[0].y = cy + startNoteRenderer.y;
                            this.BendNoteHeads[0].paint(0, 0, canvas);
                            this.drawBendSlur(canvas, startX, startY, endX, endY, direction === BeamDirection.Down, this.scale, slurText);
                        }
                        break;
                }
            }
            canvas.textAlign = textalign;
        };
        ScoreWhammyBarGlyph.prototype.getBendNoteValue = function (note, bendPoint) {
            // NOTE: bendpoints are in 1/4 tones, but the note values are in 1/2 notes.
            return note.displayValueWithoutBend + ((bendPoint.value / 2) | 0);
        };
        ScoreWhammyBarGlyph.SimpleDipHeight = TabWhammyBarGlyph.PerHalfSize * 2;
        ScoreWhammyBarGlyph.SimpleDipPadding = 2;
        return ScoreWhammyBarGlyph;
    }(ScoreHelperNotesBaseGlyph));

    var __extends$1I = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This simple glyph allows to put an empty region in to a BarRenderer.
     */
    var SpacingGlyph = /** @class */ (function (_super) {
        __extends$1I(SpacingGlyph, _super);
        function SpacingGlyph(x, y, width) {
            var _this = _super.call(this, x, y) || this;
            _this.width = width;
            return _this;
        }
        return SpacingGlyph;
    }(Glyph));

    var __extends$1J = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PercussionNoteHeadGlyph = /** @class */ (function (_super) {
        __extends$1J(PercussionNoteHeadGlyph, _super);
        function PercussionNoteHeadGlyph(x, y, articulation, duration, isGrace) {
            var _this = _super.call(this, x, y, isGrace ? NoteHeadGlyph.GraceScale : 1, articulation.getSymbol(duration)) || this;
            _this._isGrace = isGrace;
            _this._articulation = articulation;
            return _this;
        }
        PercussionNoteHeadGlyph.prototype.paint = function (cx, cy, canvas) {
            var offset = this._isGrace ? this.scale : 0;
            canvas.fillMusicFontSymbol(cx + this.x, cy + this.y + offset, this.glyphScale * this.scale, this.symbol, false);
            if (this._articulation.techniqueSymbol !== MusicFontSymbol.None && this._articulation.techniqueSymbolPlacement === TextBaseline.Middle) {
                canvas.fillMusicFontSymbol(cx + this.x, cy + this.y + offset, this.glyphScale * this.scale, this._articulation.techniqueSymbol, false);
            }
        };
        PercussionNoteHeadGlyph.prototype.doLayout = function () {
            var scale = (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
            switch (this.symbol) {
                case MusicFontSymbol.NoteheadWhole:
                    this.width = 14;
                    break;
                case MusicFontSymbol.NoteheadCircleX:
                case MusicFontSymbol.NoteheadDiamondWhite:
                    this.width = 9;
                    break;
                case MusicFontSymbol.NoteheadHeavyXHat:
                case MusicFontSymbol.NoteheadHeavyX:
                    this.width = 13;
                    break;
                default:
                    this.width = 10;
                    break;
            }
            this.width = this.width * (this._isGrace ? NoteHeadGlyph.GraceScale : 1) * this.scale;
            this.height = NoteHeadGlyph.NoteHeadHeight * scale;
        };
        return PercussionNoteHeadGlyph;
    }(MusicFontGlyph));

    var __extends$1K = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ArticStaccatoAboveGlyph = /** @class */ (function (_super) {
        __extends$1K(ArticStaccatoAboveGlyph, _super);
        function ArticStaccatoAboveGlyph(x, y) {
            return _super.call(this, x, y, NoteHeadGlyph.GraceScale, MusicFontSymbol.ArticStaccatoAbove) || this;
        }
        ArticStaccatoAboveGlyph.prototype.doLayout = function () {
            this.width = NoteHeadGlyph.QuarterNoteHeadWidth * this.scale;
            this.height = 7 * this.scale;
        };
        ArticStaccatoAboveGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx + 3 * this.scale, cy + 5 * this.scale, canvas);
        };
        return ArticStaccatoAboveGlyph;
    }(MusicFontGlyph));

    var __extends$1L = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var PictEdgeOfCymbalGlyph = /** @class */ (function (_super) {
        __extends$1L(PictEdgeOfCymbalGlyph, _super);
        function PictEdgeOfCymbalGlyph(x, y) {
            return _super.call(this, x, y, 0.5, MusicFontSymbol.PictEdgeOfCymbal) || this;
        }
        PictEdgeOfCymbalGlyph.prototype.doLayout = function () {
            this.width = 22 * this.scale;
            this.height = 15 * this.scale;
        };
        PictEdgeOfCymbalGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx - 3 * this.scale, cy + this.height, canvas);
        };
        return PictEdgeOfCymbalGlyph;
    }(MusicFontGlyph));

    var __extends$1M = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var GuitarGolpeGlyph = /** @class */ (function (_super) {
        __extends$1M(GuitarGolpeGlyph, _super);
        function GuitarGolpeGlyph(x, y) {
            return _super.call(this, x, y, NoteHeadGlyph.GraceScale, MusicFontSymbol.GuitarGolpe) || this;
        }
        GuitarGolpeGlyph.prototype.doLayout = function () {
            this.width = 9 * this.scale;
            this.height = 10 * this.scale;
        };
        GuitarGolpeGlyph.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy + this.height, canvas);
        };
        return GuitarGolpeGlyph;
    }(MusicFontGlyph));

    var __extends$1N = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreBeatGlyph = /** @class */ (function (_super) {
        __extends$1N(ScoreBeatGlyph, _super);
        function ScoreBeatGlyph() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.noteHeads = null;
            _this.restGlyph = null;
            return _this;
        }
        ScoreBeatGlyph.prototype.getNoteX = function (note, requestedPosition) {
            return this.noteHeads ? this.noteHeads.getNoteX(note, requestedPosition) : 0;
        };
        ScoreBeatGlyph.prototype.buildBoundingsLookup = function (beatBounds, cx, cy) {
            if (this.noteHeads) {
                this.noteHeads.buildBoundingsLookup(beatBounds, cx + this.x, cy + this.y);
            }
        };
        ScoreBeatGlyph.prototype.getNoteY = function (note, requestedPosition) {
            return this.noteHeads ? this.noteHeads.getNoteY(note, requestedPosition) : 0;
        };
        ScoreBeatGlyph.prototype.updateBeamingHelper = function () {
            if (this.noteHeads) {
                this.noteHeads.updateBeamingHelper(this.container.x + this.x);
            }
            else if (this.restGlyph) {
                this.restGlyph.updateBeamingHelper(this.container.x + this.x);
            }
        };
        ScoreBeatGlyph.prototype.doLayout = function () {
            // create glyphs
            var sr = this.renderer;
            if (!this.container.beat.isEmpty) {
                if (!this.container.beat.isRest) {
                    //
                    // Note heads
                    //
                    this.noteHeads = new ScoreNoteChordGlyph();
                    this.noteHeads.beat = this.container.beat;
                    this.noteHeads.beamingHelper = this.beamingHelper;
                    var ghost = new GhostNoteContainerGlyph(false);
                    ghost.renderer = this.renderer;
                    for (var _i = 0, _a = this.container.beat.notes; _i < _a.length; _i++) {
                        var note = _a[_i];
                        if (note.isVisible) {
                            this.createNoteGlyph(note);
                            ghost.addParenthesis(note);
                        }
                    }
                    this.addGlyph(this.noteHeads);
                    if (!ghost.isEmpty) {
                        this.addGlyph(new SpacingGlyph(0, 0, 4 *
                            (this.container.beat.graceType !== GraceType.None ? NoteHeadGlyph.GraceScale : 1) *
                            this.scale));
                        this.addGlyph(ghost);
                    }
                    //
                    // Whammy Bar
                    if (this.container.beat.hasWhammyBar) {
                        var whammy = new ScoreWhammyBarGlyph(this.container.beat);
                        whammy.renderer = this.renderer;
                        whammy.doLayout();
                        this.container.ties.push(whammy);
                    }
                    //
                    // Note dots
                    //
                    if (this.container.beat.dots > 0) {
                        this.addGlyph(new SpacingGlyph(0, 0, 5 * this.scale));
                        for (var i = 0; i < this.container.beat.dots; i++) {
                            var group = new GlyphGroup(0, 0);
                            for (var _b = 0, _c = this.container.beat.notes; _b < _c.length; _b++) {
                                var note = _c[_b];
                                this.createBeatDot(sr.getNoteLine(note), group);
                            }
                            this.addGlyph(group);
                        }
                    }
                }
                else {
                    var offset = 0;
                    var line = Math.ceil((this.renderer.bar.staff.standardNotationLineCount - 1) / 2) * 2;
                    // this positioning is quite strange, for most staff line counts
                    // the whole/rest are aligned as half below the whole rest. 
                    // but for staff line count 1 and 3 they are aligned centered on the same line. 
                    if (this.container.beat.duration === Duration.Whole &&
                        this.renderer.bar.staff.standardNotationLineCount !== 1 &&
                        this.renderer.bar.staff.standardNotationLineCount !== 3) {
                        line -= 2;
                    }
                    var y = sr.getScoreY(line, offset);
                    this.restGlyph = new ScoreRestGlyph(0, y, this.container.beat.duration);
                    this.restGlyph.beat = this.container.beat;
                    this.restGlyph.beamingHelper = this.beamingHelper;
                    this.addGlyph(this.restGlyph);
                    //
                    // Note dots
                    //
                    if (this.container.beat.dots > 0) {
                        this.addGlyph(new SpacingGlyph(0, 0, 5 * this.scale));
                        for (var i = 0; i < this.container.beat.dots; i++) {
                            var group = new GlyphGroup(0, 0);
                            this.createBeatDot(line, group);
                            this.addGlyph(group);
                        }
                    }
                }
            }
            _super.prototype.doLayout.call(this);
            if (this.container.beat.isEmpty) {
                this.centerX = this.width / 2;
            }
            else if (this.container.beat.isRest) {
                this.centerX = this.restGlyph.x + this.restGlyph.width / 2;
            }
            else {
                this.centerX = this.noteHeads.x + this.noteHeads.width / 2;
            }
        };
        ScoreBeatGlyph.prototype.createBeatDot = function (line, group) {
            var sr = this.renderer;
            group.addGlyph(new CircleGlyph(0, sr.getScoreY(line, 0), 1.5 * this.scale));
        };
        ScoreBeatGlyph.prototype.createNoteHeadGlyph = function (n) {
            var isGrace = this.container.beat.graceType !== GraceType.None;
            if (n.beat.voice.bar.staff.isPercussion) {
                var articulation = PercussionMapper.getArticulation(n);
                if (articulation) {
                    return new PercussionNoteHeadGlyph(0, 0, articulation, n.beat.duration, isGrace);
                }
                else {
                    Logger.warning('Rendering', "No articulation found for percussion instrument " + n.percussionArticulation);
                }
            }
            if (n.isDead) {
                return new DeadNoteHeadGlyph(0, 0, isGrace);
            }
            if (n.beat.graceType === GraceType.BendGrace) {
                return new NoteHeadGlyph(0, 0, Duration.Quarter, true);
            }
            if (n.harmonicType === HarmonicType.Natural) {
                return new DiamondNoteHeadGlyph(0, 0, n.beat.duration, isGrace);
            }
            return new NoteHeadGlyph(0, 0, n.beat.duration, isGrace);
        };
        ScoreBeatGlyph.prototype.createNoteGlyph = function (n) {
            if (n.beat.graceType === GraceType.BendGrace && !n.hasBend) {
                return;
            }
            var sr = this.renderer;
            var noteHeadGlyph = this.createNoteHeadGlyph(n);
            // calculate y position
            var line = sr.getNoteLine(n);
            noteHeadGlyph.y = sr.getScoreY(line, 0);
            this.noteHeads.addNoteGlyph(noteHeadGlyph, n, line);
            if (n.harmonicType !== HarmonicType.None && n.harmonicType !== HarmonicType.Natural) {
                // create harmonic note head.
                var harmonicFret = n.displayValue + n.harmonicPitch;
                noteHeadGlyph = new DiamondNoteHeadGlyph(0, 0, n.beat.duration, this.container.beat.graceType !== GraceType.None);
                line = sr.accidentalHelper.getNoteLineForValue(harmonicFret, false);
                noteHeadGlyph.y = sr.getScoreY(line, 0);
                this.noteHeads.addNoteGlyph(noteHeadGlyph, n, line);
            }
            if (n.isStaccato && !this.noteHeads.aboveBeatEffects.has('Staccato')) {
                this.noteHeads.belowBeatEffects.set('Staccato', new ArticStaccatoAboveGlyph(0, 0));
            }
            if (n.accentuated === AccentuationType.Normal && !this.noteHeads.aboveBeatEffects.has('Accent')) {
                this.noteHeads.belowBeatEffects.set('Accent', new AccentuationGlyph(0, 0, AccentuationType.Normal));
            }
            if (n.accentuated === AccentuationType.Heavy && !this.noteHeads.aboveBeatEffects.has('HAccent')) {
                this.noteHeads.belowBeatEffects.set('HAccent', new AccentuationGlyph(0, 0, AccentuationType.Heavy));
            }
            if (n.isPercussion) {
                var articulation = PercussionMapper.getArticulation(n);
                if (articulation && articulation.techniqueSymbolPlacement !== TextBaseline.Middle) {
                    var effectContainer = articulation.techniqueSymbolPlacement === TextBaseline.Top
                        ? this.noteHeads.aboveBeatEffects
                        : this.noteHeads.belowBeatEffects;
                    switch (articulation.techniqueSymbol) {
                        case MusicFontSymbol.PictEdgeOfCymbal:
                            effectContainer.set('PictEdgeOfCymbal', new PictEdgeOfCymbalGlyph(0, 0));
                            break;
                        case MusicFontSymbol.ArticStaccatoAbove:
                            effectContainer.set('ArticStaccatoAbove', new ArticStaccatoAboveGlyph(0, 0));
                            break;
                        case MusicFontSymbol.StringsUpBow:
                            effectContainer.set('StringsUpBow', new PickStrokeGlyph(0, 0, PickStroke.Up));
                            break;
                        case MusicFontSymbol.StringsDownBow:
                            effectContainer.set('StringsDownBow', new PickStrokeGlyph(0, 0, PickStroke.Down));
                            break;
                        case MusicFontSymbol.GuitarGolpe:
                            effectContainer.set('GuitarGolpe', new GuitarGolpeGlyph(0, 0));
                            break;
                    }
                }
            }
        };
        return ScoreBeatGlyph;
    }(BeatOnNoteGlyphBase));

    var __extends$1O = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreBrushGlyph = /** @class */ (function (_super) {
        __extends$1O(ScoreBrushGlyph, _super);
        function ScoreBrushGlyph(beat) {
            var _this = _super.call(this, 0, 0) || this;
            _this._beat = beat;
            return _this;
        }
        ScoreBrushGlyph.prototype.doLayout = function () {
            this.width = 10 * this.scale;
        };
        ScoreBrushGlyph.prototype.paint = function (cx, cy, canvas) {
            var scoreBarRenderer = this.renderer;
            var lineSize = scoreBarRenderer.lineOffset;
            var startY = cy + this.y + (scoreBarRenderer.getNoteY(this._beat.maxNote, NoteYPosition.Bottom) - lineSize);
            var endY = cy + this.y + scoreBarRenderer.getNoteY(this._beat.minNote, NoteYPosition.Top) + lineSize;
            var arrowX = cx + this.x + this.width / 2;
            var arrowSize = 8 * this.scale;
            if (this._beat.brushType !== BrushType.None) {
                var glyph = new NoteVibratoGlyph(0, 0, VibratoType.Slight, 1.2, true);
                glyph.renderer = this.renderer;
                glyph.doLayout();
                var waveOffset = -glyph.height / 2;
                if (this._beat.brushType === BrushType.ArpeggioUp) {
                    var lineStartY = startY + arrowSize;
                    var lineEndY = endY - arrowSize;
                    glyph.width = Math.abs(lineEndY - lineStartY);
                    canvas.beginRotate(cx + this.x + 5 * this.scale, lineEndY, -90);
                    glyph.paint(0, waveOffset, canvas);
                    canvas.endRotate();
                    canvas.beginPath();
                    canvas.moveTo(arrowX, endY);
                    canvas.lineTo(arrowX + arrowSize / 2, endY - arrowSize);
                    canvas.lineTo(arrowX - arrowSize / 2, endY - arrowSize);
                    canvas.closePath();
                    canvas.fill();
                }
                else if (this._beat.brushType === BrushType.ArpeggioDown) {
                    var lineStartY = startY + arrowSize;
                    var lineEndY = endY;
                    glyph.width = Math.abs(lineEndY - lineStartY);
                    canvas.beginRotate(cx + this.x + 5 * this.scale, lineStartY, 90);
                    glyph.paint(0, waveOffset, canvas);
                    canvas.endRotate();
                    canvas.beginPath();
                    canvas.moveTo(arrowX, startY);
                    canvas.lineTo(arrowX + arrowSize / 2, startY + arrowSize);
                    canvas.lineTo(arrowX - arrowSize / 2, startY + arrowSize);
                    canvas.closePath();
                    canvas.fill();
                }
            }
        };
        return ScoreBrushGlyph;
    }(Glyph));

    var __extends$1P = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreBeatPreNotesGlyph = /** @class */ (function (_super) {
        __extends$1P(ScoreBeatPreNotesGlyph, _super);
        function ScoreBeatPreNotesGlyph() {
            var _this = _super.call(this) || this;
            _this._prebends = null;
            _this.accidentals = null;
            return _this;
        }
        Object.defineProperty(ScoreBeatPreNotesGlyph.prototype, "prebendNoteHeadOffset", {
            get: function () {
                return this._prebends ? this._prebends.x + this._prebends.noteHeadOffset : 0;
            },
            enumerable: false,
            configurable: true
        });
        ScoreBeatPreNotesGlyph.prototype.doLayout = function () {
            if (!this.container.beat.isRest) {
                var accidentals = new AccidentalGroupGlyph();
                var ghost = new GhostNoteContainerGlyph(true);
                ghost.renderer = this.renderer;
                this._prebends = new BendNoteHeadGroupGlyph(this.container.beat, true);
                this._prebends.renderer = this.renderer;
                for (var _i = 0, _a = this.container.beat.notes; _i < _a.length; _i++) {
                    var note = _a[_i];
                    if (note.isVisible) {
                        if (note.hasBend) {
                            switch (note.bendType) {
                                case BendType.PrebendBend:
                                case BendType.Prebend:
                                case BendType.PrebendRelease:
                                    this._prebends.addGlyph(note.displayValue - ((note.bendPoints[0].value / 2) | 0), false);
                                    break;
                            }
                        }
                        else if (note.beat.hasWhammyBar) {
                            switch (note.beat.whammyBarType) {
                                case WhammyType.PrediveDive:
                                case WhammyType.Predive:
                                    this._prebends.addGlyph(note.displayValue - ((note.beat.whammyBarPoints[0].value / 2) | 0), false);
                                    break;
                            }
                        }
                        this.createAccidentalGlyph(note, accidentals);
                        ghost.addParenthesis(note);
                    }
                }
                if (!this._prebends.isEmpty) {
                    this.addGlyph(this._prebends);
                    this.addGlyph(new SpacingGlyph(0, 0, 4 * (this.container.beat.graceType !== GraceType.None ? NoteHeadGlyph.GraceScale : 1) * this.scale));
                }
                if (this.container.beat.brushType !== BrushType.None) {
                    this.addGlyph(new ScoreBrushGlyph(this.container.beat));
                    this.addGlyph(new SpacingGlyph(0, 0, 4 * this.scale));
                }
                if (!ghost.isEmpty) {
                    this.addGlyph(ghost);
                    this.addGlyph(new SpacingGlyph(0, 0, 4 * (this.container.beat.graceType !== GraceType.None ? NoteHeadGlyph.GraceScale : 1) * this.scale));
                }
                if (!accidentals.isEmpty) {
                    this.accidentals = accidentals;
                    this.addGlyph(new SpacingGlyph(0, 0, 2 * (this.container.beat.graceType !== GraceType.None ? NoteHeadGlyph.GraceScale : 1) * this.scale));
                    this.addGlyph(accidentals);
                    this.addGlyph(new SpacingGlyph(0, 0, 2 * (this.container.beat.graceType !== GraceType.None ? NoteHeadGlyph.GraceScale : 1) * this.scale));
                }
            }
            _super.prototype.doLayout.call(this);
        };
        ScoreBeatPreNotesGlyph.prototype.createAccidentalGlyph = function (n, accidentals) {
            var sr = this.renderer;
            var accidental = sr.accidentalHelper.applyAccidental(n);
            var noteLine = sr.getNoteLine(n);
            var isGrace = this.container.beat.graceType !== GraceType.None;
            if (accidental !== AccidentalType.None) {
                var g = new AccidentalGlyph(0, sr.getScoreY(noteLine, 0), accidental, isGrace);
                g.renderer = this.renderer;
                accidentals.addGlyph(g);
            }
            if (n.harmonicType !== HarmonicType.None && n.harmonicType !== HarmonicType.Natural) {
                var harmonicFret = n.displayValue + n.harmonicPitch;
                accidental = sr.accidentalHelper.applyAccidentalForValue(n.beat, harmonicFret, isGrace, false);
                noteLine = sr.accidentalHelper.getNoteLineForValue(harmonicFret, false);
                var g = new AccidentalGlyph(0, sr.getScoreY(noteLine, 0), accidental, isGrace);
                g.renderer = this.renderer;
                accidentals.addGlyph(g);
            }
        };
        return ScoreBeatPreNotesGlyph;
    }(BeatGlyphBase));

    var __extends$1Q = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DigitGlyph = /** @class */ (function (_super) {
        __extends$1Q(DigitGlyph, _super);
        function DigitGlyph(x, y, digit, scale) {
            var _this = _super.call(this, x, y, scale, DigitGlyph.getSymbol(digit)) || this;
            _this._digit = 0;
            _this._scale = 0;
            _this._digit = digit;
            _this._scale = scale;
            return _this;
        }
        DigitGlyph.prototype.doLayout = function () {
            this.width = this.getDigitWidth(this._digit) * this.scale * this._scale;
        };
        DigitGlyph.prototype.getDigitWidth = function (digit) {
            switch (digit) {
                case 0:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                    return 14;
                case 1:
                    return 10;
                default:
                    return 0;
            }
        };
        DigitGlyph.getSymbol = function (digit) {
            switch (digit) {
                case 0:
                    return MusicFontSymbol.TimeSig0;
                case 1:
                    return MusicFontSymbol.TimeSig1;
                case 2:
                    return MusicFontSymbol.TimeSig2;
                case 3:
                    return MusicFontSymbol.TimeSig3;
                case 4:
                    return MusicFontSymbol.TimeSig4;
                case 5:
                    return MusicFontSymbol.TimeSig5;
                case 6:
                    return MusicFontSymbol.TimeSig6;
                case 7:
                    return MusicFontSymbol.TimeSig7;
                case 8:
                    return MusicFontSymbol.TimeSig8;
                case 9:
                    return MusicFontSymbol.TimeSig9;
                default:
                    return MusicFontSymbol.None;
            }
        };
        return DigitGlyph;
    }(MusicFontGlyph));

    var __extends$1R = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var NumberGlyph = /** @class */ (function (_super) {
        __extends$1R(NumberGlyph, _super);
        function NumberGlyph(x, y, num, scale) {
            if (scale === void 0) { scale = 1.0; }
            var _this = _super.call(this, x, y) || this;
            _this._number = 0;
            _this._scale = 0;
            _this._number = num;
            _this._scale = scale;
            return _this;
        }
        NumberGlyph.prototype.doLayout = function () {
            var i = this._number;
            while (i > 0) {
                var num = i % 10;
                var gl = new DigitGlyph(0, 0, num, this._scale);
                this.addGlyph(gl);
                i = (i / 10) | 0;
            }
            if (this.glyphs) {
                this.glyphs.reverse();
                var cx = 0;
                for (var j = 0, k = this.glyphs.length; j < k; j++) {
                    var g = this.glyphs[j];
                    g.x = cx;
                    g.y = 0;
                    g.renderer = this.renderer;
                    g.doLayout();
                    cx += g.width;
                }
                this.width = cx;
            }
        };
        NumberGlyph.height = 18;
        return NumberGlyph;
    }(GlyphGroup));

    var __extends$1S = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TimeSignatureGlyph = /** @class */ (function (_super) {
        __extends$1S(TimeSignatureGlyph, _super);
        function TimeSignatureGlyph(x, y, numerator, denominator, isCommon) {
            var _this = _super.call(this, x, y) || this;
            _this._numerator = 0;
            _this._denominator = 0;
            _this._numerator = numerator;
            _this._denominator = denominator;
            _this._isCommon = isCommon;
            return _this;
        }
        TimeSignatureGlyph.prototype.doLayout = function () {
            if (this._isCommon && this._numerator === 2 && this._denominator === 2) {
                var common = new MusicFontGlyph(0, 0, this.commonScale, MusicFontSymbol.TimeSigCutCommon);
                common.width = 14 * this.scale;
                this.addGlyph(common);
                _super.prototype.doLayout.call(this);
            }
            else if (this._isCommon && this._numerator === 4 && this._denominator === 4) {
                var common = new MusicFontGlyph(0, 0, this.commonScale, MusicFontSymbol.TimeSigCommon);
                common.width = 14 * this.scale;
                this.addGlyph(common);
                _super.prototype.doLayout.call(this);
            }
            else {
                var numberHeight = NumberGlyph.height * this.scale;
                var numerator = new NumberGlyph(0, -numberHeight / 2, this._numerator, this.numberScale);
                var denominator = new NumberGlyph(0, numberHeight / 2, this._denominator, this.numberScale);
                this.addGlyph(numerator);
                this.addGlyph(denominator);
                _super.prototype.doLayout.call(this);
                for (var i = 0, j = this.glyphs.length; i < j; i++) {
                    var g = this.glyphs[i];
                    g.x = (this.width - g.width) / 2;
                }
            }
        };
        return TimeSignatureGlyph;
    }(GlyphGroup));

    var __extends$1T = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreTimeSignatureGlyph = /** @class */ (function (_super) {
        __extends$1T(ScoreTimeSignatureGlyph, _super);
        function ScoreTimeSignatureGlyph() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(ScoreTimeSignatureGlyph.prototype, "commonScale", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ScoreTimeSignatureGlyph.prototype, "numberScale", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        return ScoreTimeSignatureGlyph;
    }(TimeSignatureGlyph));

    var __extends$1U = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreBendGlyph = /** @class */ (function (_super) {
        __extends$1U(ScoreBendGlyph, _super);
        function ScoreBendGlyph(beat) {
            var _this = _super.call(this, 0, 0) || this;
            _this._notes = [];
            _this._endNoteGlyph = null;
            _this._middleNoteGlyph = null;
            _this._beat = beat;
            return _this;
        }
        ScoreBendGlyph.prototype.addBends = function (note) {
            this._notes.push(note);
            if (note.isTieOrigin) {
                return;
            }
            switch (note.bendType) {
                case BendType.Bend:
                case BendType.PrebendRelease:
                case BendType.PrebendBend:
                    {
                        var endGlyphs = this._endNoteGlyph;
                        if (!endGlyphs) {
                            endGlyphs = this._endNoteGlyph = new BendNoteHeadGroupGlyph(note.beat, false);
                            endGlyphs.renderer = this.renderer;
                            this.BendNoteHeads.push(endGlyphs);
                        }
                        var lastBendPoint = note.bendPoints[note.bendPoints.length - 1];
                        endGlyphs.addGlyph(this.getBendNoteValue(note, lastBendPoint), lastBendPoint.value % 2 !== 0);
                    }
                    break;
                case BendType.Release:
                    {
                        if (!note.isTieOrigin) {
                            var endGlyphs = this._endNoteGlyph;
                            if (!endGlyphs) {
                                endGlyphs = this._endNoteGlyph = new BendNoteHeadGroupGlyph(note.beat, false);
                                endGlyphs.renderer = this.renderer;
                                this.BendNoteHeads.push(endGlyphs);
                            }
                            var lastBendPoint = note.bendPoints[note.bendPoints.length - 1];
                            endGlyphs.addGlyph(this.getBendNoteValue(note, lastBendPoint), lastBendPoint.value % 2 !== 0);
                        }
                    }
                    break;
                case BendType.BendRelease:
                    {
                        var middleGlyphs = this._middleNoteGlyph;
                        if (!middleGlyphs) {
                            middleGlyphs = this._middleNoteGlyph = new BendNoteHeadGroupGlyph(note.beat, false);
                            middleGlyphs.renderer = this.renderer;
                            this.BendNoteHeads.push(middleGlyphs);
                        }
                        var middleBendPoint = note.bendPoints[1];
                        middleGlyphs.addGlyph(this.getBendNoteValue(note, note.bendPoints[1]), middleBendPoint.value % 2 !== 0);
                        var endGlyphs = this._endNoteGlyph;
                        if (!endGlyphs) {
                            endGlyphs = this._endNoteGlyph = new BendNoteHeadGroupGlyph(note.beat, false);
                            endGlyphs.renderer = this.renderer;
                            this.BendNoteHeads.push(endGlyphs);
                        }
                        var lastBendPoint = note.bendPoints[note.bendPoints.length - 1];
                        endGlyphs.addGlyph(this.getBendNoteValue(note, lastBendPoint), lastBendPoint.value % 2 !== 0);
                    }
                    break;
            }
        };
        ScoreBendGlyph.prototype.paint = function (cx, cy, canvas) {
            // Draw note heads
            var startNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, this._beat.voice.bar);
            var startX = cx + startNoteRenderer.x + startNoteRenderer.getBeatX(this._beat, BeatXPosition.MiddleNotes);
            var endBeatX = cx + startNoteRenderer.x;
            if (this._beat.isLastOfVoice) {
                endBeatX += startNoteRenderer.postBeatGlyphsStart;
            }
            else {
                endBeatX += startNoteRenderer.getBeatX(this._beat.nextBeat, BeatXPosition.PreNotes);
            }
            endBeatX -= 8 * this.scale;
            var middleX = (startX + endBeatX) / 2;
            if (this._middleNoteGlyph) {
                this._middleNoteGlyph.x = middleX - this._middleNoteGlyph.noteHeadOffset;
                this._middleNoteGlyph.y = cy + startNoteRenderer.y;
                this._middleNoteGlyph.paint(0, 0, canvas);
            }
            if (this._endNoteGlyph) {
                this._endNoteGlyph.x = endBeatX - this._endNoteGlyph.noteHeadOffset;
                this._endNoteGlyph.y = cy + startNoteRenderer.y;
                this._endNoteGlyph.paint(0, 0, canvas);
            }
            this._notes.sort(function (a, b) {
                return b.displayValue - a.displayValue;
            });
            var directionBeat = this._beat.graceType === GraceType.BendGrace ? this._beat.nextBeat : this._beat;
            var direction = this._notes.length === 1 ? this.getTieDirection(directionBeat, startNoteRenderer) : BeamDirection.Up;
            // draw slurs
            for (var i = 0; i < this._notes.length; i++) {
                var note = this._notes[i];
                if (i > 0 && i >= ((this._notes.length / 2) | 0)) {
                    direction = BeamDirection.Down;
                }
                var startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(note, NoteYPosition.Top);
                var heightOffset = NoteHeadGlyph.NoteHeadHeight * this.scale * NoteHeadGlyph.GraceScale * 0.5;
                if (direction === BeamDirection.Down) {
                    startY += NoteHeadGlyph.NoteHeadHeight * this.scale;
                }
                var slurText = note.bendStyle === BendStyle.Gradual ? 'grad.' : '';
                if (note.isTieOrigin) {
                    var endNote = note.tieDestination;
                    var endNoteRenderer = !endNote
                        ? null
                        : this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, endNote.beat.voice.bar);
                    // if we have a line break we draw only a line until the end
                    if (!endNoteRenderer || endNoteRenderer.staff !== startNoteRenderer.staff) {
                        var endX = cx + startNoteRenderer.x + startNoteRenderer.width;
                        var noteValueToDraw = note.tieDestination.realValue;
                        startNoteRenderer.accidentalHelper.applyAccidentalForValue(note.beat, noteValueToDraw, false, true);
                        var endY = cy +
                            startNoteRenderer.y +
                            startNoteRenderer.getScoreY(startNoteRenderer.accidentalHelper.getNoteLineForValue(noteValueToDraw, false), 0);
                        if (note.bendType === BendType.Hold || note.bendType === BendType.Prebend) {
                            TieGlyph.paintTie(canvas, this.scale, startX, startY, endX, endY, direction === BeamDirection.Down, 22, 4);
                        }
                        else {
                            this.drawBendSlur(canvas, startX, startY, endX, endY, direction === BeamDirection.Down, this.scale, slurText);
                        }
                    }
                    else {
                        var endX = cx + endNoteRenderer.x + endNoteRenderer.getBeatX(endNote.beat, BeatXPosition.MiddleNotes);
                        var endY = cy + endNoteRenderer.y + endNoteRenderer.getNoteY(endNote, NoteYPosition.Top);
                        if (direction === BeamDirection.Down) {
                            endY += NoteHeadGlyph.NoteHeadHeight * this.scale;
                        }
                        if (note.bendType === BendType.Hold || note.bendType === BendType.Prebend) {
                            TieGlyph.paintTie(canvas, this.scale, startX, startY, endX, endY, direction === BeamDirection.Down, 22, 4);
                        }
                        else {
                            this.drawBendSlur(canvas, startX, startY, endX, endY, direction === BeamDirection.Down, this.scale, slurText);
                        }
                    }
                    switch (note.bendType) {
                        case BendType.Prebend:
                        case BendType.PrebendBend:
                        case BendType.PrebendRelease:
                            var preX = cx + startNoteRenderer.x + startNoteRenderer.getBeatX(note.beat, BeatXPosition.PreNotes);
                            preX += startNoteRenderer.getPreNotesGlyphForBeat(note.beat)
                                .prebendNoteHeadOffset;
                            var preY = cy +
                                startNoteRenderer.y +
                                startNoteRenderer.getScoreY(startNoteRenderer.accidentalHelper.getNoteLineForValue(note.displayValue - ((note.bendPoints[0].value / 2) | 0), false), 0) +
                                heightOffset;
                            this.drawBendSlur(canvas, preX, preY, startX, startY, direction === BeamDirection.Down, this.scale);
                            break;
                    }
                }
                else {
                    if (direction === BeamDirection.Up) {
                        heightOffset = -heightOffset;
                    }
                    var endValue = 0;
                    var endY = 0;
                    switch (note.bendType) {
                        case BendType.Bend:
                            endValue = this.getBendNoteValue(note, note.bendPoints[note.bendPoints.length - 1]);
                            endY = this._endNoteGlyph.getNoteValueY(endValue) + heightOffset;
                            this.drawBendSlur(canvas, startX, startY, endBeatX, endY, direction === BeamDirection.Down, this.scale, slurText);
                            break;
                        case BendType.BendRelease:
                            var middleValue = this.getBendNoteValue(note, note.bendPoints[1]);
                            var middleY = this._middleNoteGlyph.getNoteValueY(middleValue) + heightOffset;
                            this.drawBendSlur(canvas, startX, startY, middleX, middleY, direction === BeamDirection.Down, this.scale, slurText);
                            endValue = this.getBendNoteValue(note, note.bendPoints[note.bendPoints.length - 1]);
                            endY = this._endNoteGlyph.getNoteValueY(endValue) + heightOffset;
                            this.drawBendSlur(canvas, middleX, middleY, endBeatX, endY, direction === BeamDirection.Down, this.scale, slurText);
                            break;
                        case BendType.Release:
                            if (this.BendNoteHeads.length > 0) {
                                endValue = this.getBendNoteValue(note, note.bendPoints[note.bendPoints.length - 1]);
                                endY = this.BendNoteHeads[0].getNoteValueY(endValue) + heightOffset;
                                this.drawBendSlur(canvas, startX, startY, endBeatX, endY, direction === BeamDirection.Down, this.scale, slurText);
                            }
                            break;
                        case BendType.Prebend:
                        case BendType.PrebendBend:
                        case BendType.PrebendRelease:
                            var preX = cx + startNoteRenderer.x + startNoteRenderer.getBeatX(note.beat, BeatXPosition.PreNotes);
                            preX += startNoteRenderer.getPreNotesGlyphForBeat(note.beat)
                                .prebendNoteHeadOffset;
                            var preY = cy +
                                startNoteRenderer.y +
                                startNoteRenderer.getScoreY(startNoteRenderer.accidentalHelper.getNoteLineForValue(note.displayValue - ((note.bendPoints[0].value / 2) | 0), false), 0) +
                                heightOffset;
                            this.drawBendSlur(canvas, preX, preY, startX, startY, direction === BeamDirection.Down, this.scale);
                            if (this.BendNoteHeads.length > 0) {
                                endValue = this.getBendNoteValue(note, note.bendPoints[note.bendPoints.length - 1]);
                                endY = this.BendNoteHeads[0].getNoteValueY(endValue) + heightOffset;
                                this.drawBendSlur(canvas, startX, startY, endBeatX, endY, direction === BeamDirection.Down, this.scale, slurText);
                            }
                            break;
                    }
                }
            }
        };
        ScoreBendGlyph.prototype.getBendNoteValue = function (note, bendPoint) {
            // NOTE: bendpoints are in 1/4 tones, but the note values are in 1/2 notes.
            return note.displayValueWithoutBend + ((bendPoint.value / 2) | 0);
        };
        return ScoreBendGlyph;
    }(ScoreHelperNotesBaseGlyph));

    var __extends$1V = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreLegatoGlyph = /** @class */ (function (_super) {
        __extends$1V(ScoreLegatoGlyph, _super);
        function ScoreLegatoGlyph(startBeat, endBeat, forEnd) {
            if (forEnd === void 0) { forEnd = false; }
            return _super.call(this, startBeat, endBeat, forEnd) || this;
        }
        ScoreLegatoGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
        };
        ScoreLegatoGlyph.prototype.getBeamDirection = function (beat, noteRenderer) {
            if (beat.isRest) {
                return BeamDirection.Up;
            }
            // invert direction (if stems go up, ties go down to not cross them)
            switch (noteRenderer.getBeatDirection(beat)) {
                case BeamDirection.Up:
                    return BeamDirection.Down;
                default:
                    return BeamDirection.Up;
            }
        };
        ScoreLegatoGlyph.prototype.getStartY = function () {
            if (this.startBeat.isRest) {
                // below all lines
                return this.startNoteRenderer.getScoreY(9, 0);
            }
            switch (this.tieDirection) {
                case BeamDirection.Up:
                    // below lowest note
                    return this.startNoteRenderer.getNoteY(this.startBeat.maxNote, NoteYPosition.Top);
                default:
                    return this.startNoteRenderer.getNoteY(this.startBeat.minNote, NoteYPosition.Bottom);
            }
        };
        ScoreLegatoGlyph.prototype.getEndY = function () {
            var endNoteScoreRenderer = this.endNoteRenderer;
            if (this.endBeat.isRest) {
                switch (this.tieDirection) {
                    case BeamDirection.Up:
                        return endNoteScoreRenderer.getScoreY(9, 0);
                    default:
                        return endNoteScoreRenderer.getScoreY(0, 0);
                }
            }
            var startBeamDirection = this.startNoteRenderer.getBeatDirection(this.startBeat);
            var endBeamDirection = endNoteScoreRenderer.getBeatDirection(this.endBeat);
            if (startBeamDirection !== endBeamDirection && this.startBeat.graceType === GraceType.None) {
                if (endBeamDirection === this.tieDirection) {
                    switch (this.tieDirection) {
                        case BeamDirection.Up:
                            // stem upper end
                            return endNoteScoreRenderer.getNoteY(this.endBeat.maxNote, NoteYPosition.TopWithStem);
                        default:
                            // stem lower end
                            return endNoteScoreRenderer.getNoteY(this.endBeat.minNote, NoteYPosition.BottomWithStem);
                    }
                }
                else {
                    switch (this.tieDirection) {
                        case BeamDirection.Up:
                            // stem upper end
                            return endNoteScoreRenderer.getNoteY(this.endBeat.maxNote, NoteYPosition.BottomWithStem);
                        default:
                            // stem lower end
                            return endNoteScoreRenderer.getNoteY(this.endBeat.minNote, NoteYPosition.TopWithStem);
                    }
                }
            }
            switch (this.tieDirection) {
                case BeamDirection.Up:
                    // below lowest note
                    return endNoteScoreRenderer.getNoteY(this.endBeat.maxNote, NoteYPosition.Top);
                default:
                    // above highest note
                    return endNoteScoreRenderer.getNoteY(this.endBeat.minNote, NoteYPosition.Bottom);
            }
        };
        ScoreLegatoGlyph.prototype.getStartX = function () {
            return this.startNoteRenderer.getBeatX(this.startBeat, BeatXPosition.MiddleNotes);
        };
        ScoreLegatoGlyph.prototype.getEndX = function () {
            var endBeamDirection = this.endNoteRenderer.getBeatDirection(this.endBeat);
            return this.endNoteRenderer.getBeatX(this.endBeat, this.endBeat.duration > Duration.Whole &&
                endBeamDirection === this.tieDirection ? BeatXPosition.Stem : BeatXPosition.MiddleNotes);
        };
        return ScoreLegatoGlyph;
    }(TieGlyph));

    var __extends$1W = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreSlideLineGlyph = /** @class */ (function (_super) {
        __extends$1W(ScoreSlideLineGlyph, _super);
        function ScoreSlideLineGlyph(inType, outType, startNote, parent) {
            var _this = _super.call(this, 0, 0) || this;
            _this._outType = outType;
            _this._inType = inType;
            _this._startNote = startNote;
            _this._parent = parent;
            return _this;
        }
        ScoreSlideLineGlyph.prototype.doLayout = function () {
            this.width = 0;
        };
        ScoreSlideLineGlyph.prototype.paint = function (cx, cy, canvas) {
            this.paintSlideIn(cx, cy, canvas);
            this.drawSlideOut(cx, cy, canvas);
        };
        ScoreSlideLineGlyph.prototype.paintSlideIn = function (cx, cy, canvas) {
            var startNoteRenderer = this.renderer;
            var sizeX = 12 * this.scale;
            var endX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Left) - 2 * this.scale;
            var endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
            var startX = endX - sizeX;
            var startY = cy + startNoteRenderer.y;
            switch (this._inType) {
                case SlideInType.IntoFromBelow:
                    startY += startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Bottom);
                    break;
                case SlideInType.IntoFromAbove:
                    startY += startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Top);
                    break;
                default:
                    return;
            }
            var accidentalsWidth = this.getAccidentalsWidth(startNoteRenderer, this._startNote.beat);
            startX -= accidentalsWidth;
            endX -= accidentalsWidth;
            this.paintSlideLine(canvas, false, startX, endX, startY, endY);
        };
        ScoreSlideLineGlyph.prototype.getAccidentalsWidth = function (renderer, beat) {
            var preNotes = renderer.getPreNotesGlyphForBeat(beat);
            if (preNotes && preNotes.accidentals) {
                return preNotes.accidentals.width;
            }
            return 0;
        };
        ScoreSlideLineGlyph.prototype.drawSlideOut = function (cx, cy, canvas) {
            var startNoteRenderer = this.renderer;
            var sizeX = 12 * this.scale;
            var startOffsetX = 3 * this.scale;
            var endOffsetX = 1 * this.scale;
            var offsetY = 2 * this.scale;
            var startX = 0;
            var startY = 0;
            var endX = 0;
            var endY = 0;
            var waves = false;
            switch (this._outType) {
                case SlideOutType.Shift:
                case SlideOutType.Legato:
                    startX =
                        cx +
                            startNoteRenderer.x +
                            startNoteRenderer.getBeatX(this._startNote.beat, BeatXPosition.PostNotes) +
                            startOffsetX;
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    if (this._startNote.slideTarget) {
                        var endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, this._startNote.slideTarget.beat.voice.bar);
                        if (!endNoteRenderer || endNoteRenderer.staff !== startNoteRenderer.staff) {
                            endX = cx + startNoteRenderer.x + this._parent.x;
                            endY = startY;
                        }
                        else {
                            endX =
                                cx +
                                    endNoteRenderer.x +
                                    endNoteRenderer.getBeatX(this._startNote.slideTarget.beat, BeatXPosition.PreNotes) -
                                    endOffsetX;
                            endY = cy + endNoteRenderer.y + endNoteRenderer.getNoteY(this._startNote.slideTarget, NoteYPosition.Center);
                        }
                        if (this._startNote.slideTarget.realValue > this._startNote.realValue) {
                            startY += offsetY;
                            endY -= offsetY;
                        }
                        else {
                            startY -= offsetY;
                            endY += offsetY;
                        }
                    }
                    else {
                        endX = cx + startNoteRenderer.x + this._parent.x;
                        endY = startY;
                    }
                    break;
                case SlideOutType.OutUp:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endX = startX + sizeX;
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Top);
                    break;
                case SlideOutType.OutDown:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endX = startX + sizeX;
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Bottom);
                    break;
                case SlideOutType.PickSlideUp:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right) + startOffsetX;
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Top);
                    endX = cx + startNoteRenderer.x + startNoteRenderer.width;
                    if (this._startNote.beat.nextBeat &&
                        this._startNote.beat.nextBeat.voice === this._startNote.beat.voice) {
                        endX =
                            cx +
                                startNoteRenderer.x +
                                startNoteRenderer.getBeatX(this._startNote.beat.nextBeat, BeatXPosition.PreNotes);
                    }
                    waves = true;
                    break;
                case SlideOutType.PickSlideDown:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right) + startOffsetX;
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Bottom);
                    endX = cx + startNoteRenderer.x + startNoteRenderer.width;
                    if (this._startNote.beat.nextBeat &&
                        this._startNote.beat.nextBeat.voice === this._startNote.beat.voice) {
                        endX =
                            cx +
                                startNoteRenderer.x +
                                startNoteRenderer.getBeatX(this._startNote.beat.nextBeat, BeatXPosition.PreNotes);
                    }
                    waves = true;
                    break;
                default:
                    return;
            }
            this.paintSlideLine(canvas, waves, startX, endX, startY, endY);
        };
        ScoreSlideLineGlyph.prototype.paintSlideLine = function (canvas, waves, startX, endX, startY, endY) {
            if (waves) {
                var glyph = new NoteVibratoGlyph(0, 0, VibratoType.Slight, 1.2);
                glyph.renderer = this.renderer;
                glyph.doLayout();
                startY -= glyph.height / 2;
                endY -= glyph.height / 2;
                var b = endX - startX;
                var a = endY - startY;
                var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
                glyph.width = b;
                var angle = Math.asin(a / c) * (180 / Math.PI);
                canvas.beginRotate(startX, startY, angle);
                glyph.paint(0, 0, canvas);
                canvas.endRotate();
            }
            else {
                canvas.beginPath();
                canvas.moveTo(startX, startY);
                canvas.lineTo(endX, endY);
                canvas.stroke();
            }
        };
        return ScoreSlideLineGlyph;
    }(Glyph));

    var __extends$1X = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreSlurGlyph = /** @class */ (function (_super) {
        __extends$1X(ScoreSlurGlyph, _super);
        function ScoreSlurGlyph(startNote, endNote, forEnd) {
            if (forEnd === void 0) { forEnd = false; }
            var _this = _super.call(this, startNote.beat, endNote.beat, forEnd) || this;
            _this._startNote = startNote;
            _this._endNote = endNote;
            return _this;
        }
        ScoreSlurGlyph.prototype.getTieHeight = function (startX, startY, endX, endY) {
            return Math.log2(endX - startX + 1) * this.renderer.settings.notation.slurHeight;
        };
        ScoreSlurGlyph.prototype.getStartY = function () {
            if (this.isStartCentered()) {
                switch (this.tieDirection) {
                    case BeamDirection.Up:
                        // below lowest note
                        return this.startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Top);
                    default:
                        return this.startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Bottom);
                }
            }
            return this.startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
        };
        ScoreSlurGlyph.prototype.getEndY = function () {
            if (this.isEndCentered()) {
                if (this.isEndOnStem()) {
                    switch (this.tieDirection) {
                        case BeamDirection.Up:
                            return this.endNoteRenderer.getNoteY(this._endNote, NoteYPosition.TopWithStem);
                        default:
                            return this.endNoteRenderer.getNoteY(this._endNote, NoteYPosition.BottomWithStem);
                    }
                }
                else {
                    switch (this.tieDirection) {
                        case BeamDirection.Up:
                            return this.endNoteRenderer.getNoteY(this._endNote, NoteYPosition.Top);
                        default:
                            return this.endNoteRenderer.getNoteY(this._endNote, NoteYPosition.Bottom);
                    }
                }
            }
            else {
                return this.endNoteRenderer.getNoteY(this._endNote, NoteYPosition.Center);
            }
        };
        ScoreSlurGlyph.prototype.isStartCentered = function () {
            return ((this._startNote === this._startNote.beat.maxNote && this.tieDirection === BeamDirection.Up) ||
                (this._startNote === this._startNote.beat.minNote && this.tieDirection === BeamDirection.Down));
        };
        ScoreSlurGlyph.prototype.isEndCentered = function () {
            return this._startNote.beat.graceType === GraceType.None && ((this._endNote === this._endNote.beat.maxNote && this.tieDirection === BeamDirection.Up) ||
                (this._endNote === this._endNote.beat.minNote && this.tieDirection === BeamDirection.Down));
        };
        ScoreSlurGlyph.prototype.isEndOnStem = function () {
            var endNoteScoreRenderer = this.endNoteRenderer;
            var startBeamDirection = this.startNoteRenderer.getBeatDirection(this.startBeat);
            var endBeamDirection = endNoteScoreRenderer.getBeatDirection(this.endBeat);
            return startBeamDirection !== endBeamDirection && this.startBeat.graceType === GraceType.None;
        };
        ScoreSlurGlyph.prototype.getStartX = function () {
            return this.isStartCentered()
                ? this.startNoteRenderer.getBeatX(this._startNote.beat, BeatXPosition.MiddleNotes)
                : this.startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
        };
        ScoreSlurGlyph.prototype.getEndX = function () {
            if (this.isEndCentered()) {
                if (this.isEndOnStem()) {
                    return this.endNoteRenderer.getBeatX(this._endNote.beat, BeatXPosition.Stem);
                }
                else {
                    return this.endNoteRenderer.getNoteX(this._endNote, NoteXPosition.Center);
                }
            }
            else {
                return this.endNoteRenderer.getBeatX(this._endNote.beat, BeatXPosition.PreNotes);
            }
        };
        return ScoreSlurGlyph;
    }(ScoreLegatoGlyph));

    var __extends$1Y = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreTieGlyph = /** @class */ (function (_super) {
        __extends$1Y(ScoreTieGlyph, _super);
        function ScoreTieGlyph(startNote, endNote, forEnd) {
            if (forEnd === void 0) { forEnd = false; }
            var _this = _super.call(this, !startNote ? null : startNote.beat, !endNote ? null : endNote.beat, forEnd) || this;
            _this.startNote = startNote;
            _this.endNote = endNote;
            return _this;
        }
        ScoreTieGlyph.prototype.shouldDrawBendSlur = function () {
            return this.renderer.settings.notation.extendBendArrowsOnTiedNotes && !!this.startNote.bendOrigin && this.startNote.isTieOrigin;
        };
        ScoreTieGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
        };
        ScoreTieGlyph.prototype.getBeamDirection = function (beat, noteRenderer) {
            // invert direction (if stems go up, ties go down to not cross them)
            switch (noteRenderer.getBeatDirection(beat)) {
                case BeamDirection.Up:
                    return BeamDirection.Down;
                default:
                    return BeamDirection.Up;
            }
        };
        ScoreTieGlyph.prototype.getStartY = function () {
            if (this.startBeat.isRest) {
                // below all lines
                return this.startNoteRenderer.getScoreY(9, 0);
            }
            switch (this.tieDirection) {
                case BeamDirection.Up:
                    // below lowest note
                    return this.startNoteRenderer.getNoteY(this.startNote, NoteYPosition.Top);
                default:
                    return this.startNoteRenderer.getNoteY(this.startNote, NoteYPosition.Bottom);
            }
        };
        ScoreTieGlyph.prototype.getEndY = function () {
            var endNoteScoreRenderer = this.endNoteRenderer;
            if (this.endBeat.isRest) {
                switch (this.tieDirection) {
                    case BeamDirection.Up:
                        return endNoteScoreRenderer.getScoreY(9, 0);
                    default:
                        return endNoteScoreRenderer.getScoreY(0, 0);
                }
            }
            switch (this.tieDirection) {
                case BeamDirection.Up:
                    return endNoteScoreRenderer.getNoteY(this.endNote, NoteYPosition.Top);
                default:
                    return endNoteScoreRenderer.getNoteY(this.endNote, NoteYPosition.Bottom);
            }
        };
        ScoreTieGlyph.prototype.getStartX = function () {
            return this.startNoteRenderer.getBeatX(this.startNote.beat, BeatXPosition.PostNotes);
        };
        ScoreTieGlyph.prototype.getEndX = function () {
            return this.endNoteRenderer.getBeatX(this.endNote.beat, BeatXPosition.PreNotes);
        };
        return ScoreTieGlyph;
    }(TieGlyph));

    var __extends$1Z = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var ScoreBeatContainerGlyph = /** @class */ (function (_super) {
        __extends$1Z(ScoreBeatContainerGlyph, _super);
        function ScoreBeatContainerGlyph(beat, voiceContainer) {
            var _this = _super.call(this, beat, voiceContainer) || this;
            _this._bend = null;
            _this._effectSlur = null;
            _this._effectEndSlur = null;
            return _this;
        }
        ScoreBeatContainerGlyph.prototype.doLayout = function () {
            this._effectSlur = null;
            this._effectEndSlur = null;
            _super.prototype.doLayout.call(this);
            if (this.beat.isLegatoOrigin) {
                // only create slur for very first origin of "group"
                if (!this.beat.previousBeat || !this.beat.previousBeat.isLegatoOrigin) {
                    // tie with end beat
                    var destination = this.beat.nextBeat;
                    while (destination.nextBeat && destination.nextBeat.isLegatoDestination) {
                        destination = destination.nextBeat;
                    }
                    this.ties.push(new ScoreLegatoGlyph(this.beat, destination, false));
                }
            }
            else if (this.beat.isLegatoDestination) {
                // only create slur for last destination of "group"
                if (!this.beat.isLegatoOrigin) {
                    var origin_1 = this.beat.previousBeat;
                    while (origin_1.previousBeat && origin_1.previousBeat.isLegatoOrigin) {
                        origin_1 = origin_1.previousBeat;
                    }
                    this.ties.push(new ScoreLegatoGlyph(origin_1, this.beat, true));
                }
            }
            if (this._bend) {
                this._bend.renderer = this.renderer;
                this._bend.doLayout();
                this.updateWidth();
            }
        };
        ScoreBeatContainerGlyph.prototype.createTies = function (n) {
            // create a tie if any effect requires it
            if (!n.isVisible) {
                return;
            }
            // NOTE: we create 2 tie glyphs if we have a line break inbetween
            // the two notes
            if (n.isTieOrigin &&
                !n.hasBend &&
                !n.beat.hasWhammyBar &&
                n.beat.graceType !== GraceType.BendGrace &&
                n.tieDestination &&
                n.tieDestination.isVisible) {
                var tie = new ScoreTieGlyph(n, n.tieDestination, false);
                this.ties.push(tie);
            }
            if (n.isTieDestination && !n.tieOrigin.hasBend && !n.beat.hasWhammyBar) {
                var tie = new ScoreTieGlyph(n.tieOrigin, n, true);
                this.ties.push(tie);
            }
            // TODO: depending on the type we have other positioning
            // we should place glyphs in the preNotesGlyph or postNotesGlyph if needed
            if (n.slideInType !== SlideInType.None || n.slideOutType !== SlideOutType.None) {
                var l = new ScoreSlideLineGlyph(n.slideInType, n.slideOutType, n, this);
                this.ties.push(l);
            }
            if (n.isSlurOrigin && n.slurDestination && n.slurDestination.isVisible) {
                var tie = new ScoreSlurGlyph(n, n.slurDestination, false);
                this.ties.push(tie);
            }
            if (n.isSlurDestination) {
                var tie = new ScoreSlurGlyph(n.slurOrigin, n, true);
                this.ties.push(tie);
            }
            // start effect slur on first beat
            if (!this._effectSlur && n.isEffectSlurOrigin && n.effectSlurDestination) {
                this._effectSlur = new ScoreSlurGlyph(n, n.effectSlurDestination, false);
                this.ties.push(this._effectSlur);
            }
            // end effect slur on last beat
            if (!this._effectEndSlur && n.beat.isEffectSlurDestination && n.beat.effectSlurOrigin) {
                var direction = this.onNotes.beamingHelper.direction;
                var startNote = direction === BeamDirection.Up ? n.beat.effectSlurOrigin.minNote : n.beat.effectSlurOrigin.maxNote;
                var endNote = direction === BeamDirection.Up ? n.beat.minNote : n.beat.maxNote;
                this._effectEndSlur = new ScoreSlurGlyph(startNote, endNote, true);
                this.ties.push(this._effectEndSlur);
            }
            if (n.hasBend) {
                if (!this._bend) {
                    this._bend = new ScoreBendGlyph(n.beat);
                    this._bend.renderer = this.renderer;
                    this.ties.push(this._bend);
                }
                this._bend.addBends(n);
            }
        };
        return ScoreBeatContainerGlyph;
    }(BeatContainerGlyph));

    var __extends$1_ = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This BarRenderer renders a bar using standard music notation.
     */
    var ScoreBarRenderer = /** @class */ (function (_super) {
        __extends$1_(ScoreBarRenderer, _super);
        function ScoreBarRenderer(renderer, bar) {
            var _this = _super.call(this, renderer, bar) || this;
            _this.simpleWhammyOverflow = 0;
            _this._firstLineY = 0;
            _this._startSpacing = false;
            _this.accidentalHelper = new AccidentalHelper(bar);
            return _this;
        }
        ScoreBarRenderer.prototype.getBeatDirection = function (beat) {
            return this.helpers.getBeamingHelperForBeat(beat).direction;
        };
        Object.defineProperty(ScoreBarRenderer.prototype, "lineOffset", {
            get: function () {
                return (BarRendererBase.LineSpacing + 1) * this.scale;
            },
            enumerable: false,
            configurable: true
        });
        ScoreBarRenderer.prototype.updateSizes = function () {
            var res = this.resources;
            var glyphOverflow = res.tablatureFont.size / 2 + res.tablatureFont.size * 0.2;
            this.topPadding = glyphOverflow * this.scale;
            this.bottomPadding = glyphOverflow * this.scale;
            this.height = this.lineOffset * 4 + this.topPadding + this.bottomPadding;
            this.updateFirstLineY();
            _super.prototype.updateSizes.call(this);
        };
        ScoreBarRenderer.prototype.updateFirstLineY = function () {
            var fullLineHeight = this.lineOffset * 4;
            var actualLineHeight = (this.bar.staff.standardNotationLineCount - 1) * this.lineOffset;
            this._firstLineY = (fullLineHeight - actualLineHeight) / 2;
        };
        ScoreBarRenderer.prototype.doLayout = function () {
            this.updateFirstLineY();
            _super.prototype.doLayout.call(this);
            if (!this.bar.isEmpty && this.accidentalHelper.maxLineBeat) {
                var top_1 = this.getScoreY(-2, 0);
                var bottom = this.getScoreY(6, 0);
                var whammyOffset = this.simpleWhammyOverflow;
                this.registerOverflowTop(whammyOffset);
                var maxNoteY = this.getScoreY(this.accidentalHelper.maxLine, 0);
                var maxNoteHelper = this.helpers.getBeamingHelperForBeat(this.accidentalHelper.maxLineBeat);
                if (maxNoteHelper.direction === BeamDirection.Up) {
                    maxNoteY -= this.getStemSize(maxNoteHelper);
                    maxNoteY -= maxNoteHelper.fingeringCount * this.resources.graceFont.size;
                    if (maxNoteHelper.hasTuplet) {
                        maxNoteY -= this.resources.effectFont.size * 2;
                    }
                }
                if (maxNoteHelper.hasTuplet) {
                    maxNoteY -= this.resources.effectFont.size * 1.5;
                }
                if (maxNoteY < top_1) {
                    this.registerOverflowTop(Math.abs(maxNoteY) + whammyOffset);
                }
                var minNoteY = this.getScoreY(this.accidentalHelper.minLine, 0);
                var minNoteHelper = this.helpers.getBeamingHelperForBeat(this.accidentalHelper.minLineBeat);
                if (minNoteHelper.direction === BeamDirection.Down) {
                    minNoteY += this.getStemSize(minNoteHelper);
                    minNoteY += minNoteHelper.fingeringCount * this.resources.graceFont.size;
                }
                if (minNoteY > bottom) {
                    this.registerOverflowBottom(Math.abs(minNoteY) - bottom);
                }
            }
        };
        ScoreBarRenderer.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy, canvas);
            this.paintBeams(cx, cy, canvas);
            this.paintTuplets(cx, cy, canvas);
        };
        ScoreBarRenderer.prototype.paintTuplets = function (cx, cy, canvas) {
            for (var _i = 0, _a = this.bar.voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                if (this.hasVoiceContainer(voice)) {
                    var container = this.getVoiceContainer(voice);
                    for (var _b = 0, _c = container.tupletGroups; _b < _c.length; _b++) {
                        var tupletGroup = _c[_b];
                        this.paintTupletHelper(cx + this.beatGlyphsStart, cy, canvas, tupletGroup);
                    }
                }
            }
        };
        ScoreBarRenderer.prototype.paintBeams = function (cx, cy, canvas) {
            for (var i = 0, j = this.helpers.beamHelpers.length; i < j; i++) {
                var v = this.helpers.beamHelpers[i];
                for (var k = 0, l = v.length; k < l; k++) {
                    var h = v[k];
                    this.paintBeamHelper(cx + this.beatGlyphsStart, cy, canvas, h);
                }
            }
        };
        ScoreBarRenderer.prototype.paintBeamHelper = function (cx, cy, canvas, h) {
            canvas.color = h.voice.index === 0 ? this.resources.mainGlyphColor : this.resources.secondaryGlyphColor;
            // TODO: draw stem at least at the center of the score staff.
            // check if we need to paint simple footer
            if (h.beats.length === 1) {
                this.paintFlag(cx, cy, canvas, h);
            }
            else {
                this.paintBar(cx, cy, canvas, h);
            }
        };
        ScoreBarRenderer.prototype.paintTupletHelper = function (cx, cy, canvas, h) {
            var res = this.resources;
            var oldAlign = canvas.textAlign;
            canvas.color = h.voice.index === 0 ? this.resources.mainGlyphColor : this.resources.secondaryGlyphColor;
            canvas.textAlign = TextAlign.Center;
            var s;
            var num = h.beats[0].tupletNumerator;
            var den = h.beats[0].tupletDenominator;
            // list as in Guitar Pro 7. for certain tuplets only the numerator is shown
            if (num === 2 && den === 3) {
                s = '2';
            }
            else if (num === 3 && den === 2) {
                s = '3';
            }
            else if (num === 4 && den === 6) {
                s = '4';
            }
            else if (num === 5 && den === 4) {
                s = '5';
            }
            else if (num === 6 && den === 4) {
                s = '6';
            }
            else if (num === 7 && den === 4) {
                s = '7';
            }
            else if (num === 9 && den === 8) {
                s = '9';
            }
            else if (num === 10 && den === 8) {
                s = '10';
            }
            else if (num === 11 && den === 8) {
                s = '11';
            }
            else if (num === 12 && den === 8) {
                s = '12';
            }
            else if (num === 13 && den === 8) {
                s = '13';
            }
            else {
                s = num + ':' + den;
            }
            // check if we need to paint simple footer
            if (h.beats.length === 1 || !h.isFull) {
                for (var i = 0, j = h.beats.length; i < j; i++) {
                    var beat = h.beats[i];
                    var beamingHelper = this.helpers.beamHelperLookup[h.voice.index].get(beat.index);
                    if (!beamingHelper) {
                        continue;
                    }
                    var direction = beamingHelper.direction;
                    var tupletX = beamingHelper.getBeatLineX(beat);
                    var tupletY = cy + this.y + this.calculateBeamY(beamingHelper, tupletX);
                    var offset = direction === BeamDirection.Up ? res.effectFont.size * 1.5 : -3 * this.scale;
                    canvas.font = res.effectFont;
                    canvas.fillText(s, cx + this.x + tupletX, tupletY - offset);
                }
            }
            else {
                var firstBeat = h.beats[0];
                var lastBeat = h.beats[h.beats.length - 1];
                var firstBeamingHelper = this.helpers.beamHelperLookup[h.voice.index].get(firstBeat.index);
                var lastBeamingHelper = this.helpers.beamHelperLookup[h.voice.index].get(lastBeat.index);
                if (firstBeamingHelper && lastBeamingHelper) {
                    var direction = firstBeamingHelper.direction;
                    //
                    // Calculate the overall area of the tuplet bracket
                    var startX = firstBeamingHelper.getBeatLineX(firstBeat);
                    var endX = lastBeamingHelper.getBeatLineX(lastBeat);
                    //
                    // Calculate how many space the text will need
                    canvas.font = res.effectFont;
                    var sw = canvas.measureText(s);
                    var sp = 3 * this.scale;
                    //
                    // Calculate the offsets where to break the bracket
                    var middleX = (startX + endX) / 2;
                    var offset1X = middleX - sw / 2 - sp;
                    var offset2X = middleX + sw / 2 + sp;
                    //
                    // calculate the y positions for our bracket
                    var startY = this.calculateBeamYWithDirection(firstBeamingHelper, startX, firstBeamingHelper.direction);
                    var endY = this.calculateBeamYWithDirection(lastBeamingHelper, endX, firstBeamingHelper.direction);
                    var k = (endY - startY) / (endX - startX);
                    var d = startY - k * startX;
                    var offset1Y = k * offset1X + d;
                    var middleY = k * middleX + d;
                    var offset2Y = k * offset2X + d;
                    var offset = 10 * this.scale;
                    var size = 5 * this.scale;
                    if (direction === BeamDirection.Down) {
                        offset *= -1;
                        size *= -1;
                    }
                    //
                    // draw the bracket
                    canvas.beginPath();
                    canvas.moveTo(cx + this.x + startX, (cy + this.y + startY - offset) | 0);
                    canvas.lineTo(cx + this.x + startX, (cy + this.y + startY - offset - size) | 0);
                    canvas.lineTo(cx + this.x + offset1X, (cy + this.y + offset1Y - offset - size) | 0);
                    canvas.stroke();
                    canvas.beginPath();
                    canvas.moveTo(cx + this.x + offset2X, (cy + this.y + offset2Y - offset - size) | 0);
                    canvas.lineTo(cx + this.x + endX, (cy + this.y + endY - offset - size) | 0);
                    canvas.lineTo(cx + this.x + endX, (cy + this.y + endY - offset) | 0);
                    canvas.stroke();
                    //
                    // Draw the string
                    canvas.fillText(s, cx + this.x + middleX, cy + this.y + middleY - offset - size - res.effectFont.size / 2);
                }
            }
            canvas.textAlign = oldAlign;
        };
        ScoreBarRenderer.prototype.getStemSize = function (helper) {
            var size = helper.beats.length === 1
                ? this.getFlagStemSize(helper.shortestDuration)
                : this.getBarStemSize(helper.shortestDuration);
            if (helper.isGrace) {
                size = size * NoteHeadGlyph.GraceScale;
            }
            return size;
        };
        ScoreBarRenderer.prototype.getBarStemSize = function (duration) {
            var size = 0;
            switch (duration) {
                case Duration.QuadrupleWhole:
                case Duration.Half:
                case Duration.Quarter:
                case Duration.Eighth:
                case Duration.Sixteenth:
                    size = 6;
                    break;
                case Duration.ThirtySecond:
                    size = 8;
                    break;
                case Duration.SixtyFourth:
                    size = 9;
                    break;
                case Duration.OneHundredTwentyEighth:
                    size = 9;
                    break;
                case Duration.TwoHundredFiftySixth:
                    size = 10;
                    break;
                default:
                    size = 0;
                    break;
            }
            return this.getScoreHeight(size);
        };
        ScoreBarRenderer.prototype.getFlagStemSize = function (duration) {
            var size = 0;
            switch (duration) {
                case Duration.QuadrupleWhole:
                case Duration.Half:
                case Duration.Quarter:
                case Duration.Eighth:
                case Duration.Sixteenth:
                case Duration.ThirtySecond:
                case Duration.SixtyFourth:
                case Duration.OneHundredTwentyEighth:
                case Duration.TwoHundredFiftySixth:
                    size = 6;
                    break;
                default:
                    size = 0;
                    break;
            }
            return this.getScoreHeight(size);
        };
        Object.defineProperty(ScoreBarRenderer.prototype, "middleYPosition", {
            get: function () {
                return this.getScoreY(this.bar.staff.standardNotationLineCount - 1);
            },
            enumerable: false,
            configurable: true
        });
        ScoreBarRenderer.prototype.getNoteY = function (note, requestedPosition) {
            var y = _super.prototype.getNoteY.call(this, note, requestedPosition);
            if (isNaN(y)) {
                // NOTE: some might request the note position before the glyphs have been created
                // e.g. the beaming helper, for these we just need a rough
                // estimate on the position
                var line = AccidentalHelper.computeLineWithoutAccidentals(this.bar, note);
                y = this.getScoreY(line);
            }
            return y;
        };
        ScoreBarRenderer.prototype.calculateBeamY = function (h, x) {
            return this.calculateBeamYWithDirection(h, x, h.direction);
        };
        ScoreBarRenderer.prototype.calculateBeamYWithDirection = function (h, x, direction) {
            var stemSize = this.getStemSize(h);
            var firstBeat = h.beats[0];
            // create a line between the min and max note of the group
            if (h.beats.length === 1) {
                if (direction === BeamDirection.Up) {
                    return this.getScoreY(this.accidentalHelper.getMinLine(firstBeat)) - stemSize;
                }
                return this.getScoreY(this.accidentalHelper.getMaxLine(firstBeat)) + stemSize;
            }
            var lastBeat = h.beats[h.beats.length - 1];
            // we use the min/max notes to place the beam along their real position
            // we only want a maximum of 10 offset for their gradient
            var maxDistance = 10 * this.scale;
            // if the min note is not first or last, we can align notes directly to the position
            // of the min note
            var beatOfLowestNote = h.beatOfLowestNote;
            var beatOfHighestNote = h.beatOfHighestNote;
            if (direction === BeamDirection.Down &&
                beatOfLowestNote !== firstBeat &&
                beatOfLowestNote !== lastBeat) {
                return this.getScoreY(this.accidentalHelper.getMaxLine(beatOfLowestNote)) + stemSize;
            }
            if (direction === BeamDirection.Up &&
                beatOfHighestNote !== firstBeat &&
                beatOfHighestNote !== lastBeat) {
                return this.getScoreY(this.accidentalHelper.getMinLine(beatOfHighestNote)) - stemSize;
            }
            var startX = h.getBeatLineX(firstBeat);
            var startY = direction === BeamDirection.Up
                ? this.getScoreY(this.accidentalHelper.getMinLine(firstBeat)) - stemSize
                : this.getScoreY(this.accidentalHelper.getMaxLine(firstBeat)) + stemSize;
            var endX = h.getBeatLineX(lastBeat);
            var endY = direction === BeamDirection.Up
                ? this.getScoreY(this.accidentalHelper.getMinLine(lastBeat)) - stemSize
                : this.getScoreY(this.accidentalHelper.getMaxLine(lastBeat)) + stemSize;
            // ensure the maxDistance
            if (direction === BeamDirection.Down && startY > endY && startY - endY > maxDistance) {
                endY = startY - maxDistance;
            }
            if (direction === BeamDirection.Down && endY > startY && endY - startY > maxDistance) {
                startY = endY - maxDistance;
            }
            if (direction === BeamDirection.Up && startY < endY && endY - startY > maxDistance) {
                endY = startY + maxDistance;
            }
            if (direction === BeamDirection.Up && endY < startY && startY - endY > maxDistance) {
                startY = endY + maxDistance;
            }
            // get the y position of the given beat on this curve
            if (startX === endX) {
                return startY;
            }
            // y(x)  = ( (y2 - y1) / (x2 - x1) )  * (x - x1) + y1;
            return ((endY - startY) / (endX - startX)) * (x - startX) + startY;
        };
        ScoreBarRenderer.prototype.paintBar = function (cx, cy, canvas, h) {
            for (var i = 0, j = h.beats.length; i < j; i++) {
                var beat = h.beats[i];
                var isGrace = beat.graceType !== GraceType.None;
                var scaleMod = isGrace ? NoteHeadGlyph.GraceScale : 1;
                //
                // draw line
                //
                var beatLineX = h.getBeatLineX(beat);
                var direction = h.direction;
                var y1 = cy + this.y;
                y1 +=
                    direction === BeamDirection.Up
                        ? this.getScoreY(this.accidentalHelper.getMaxLine(beat))
                        : this.getScoreY(this.accidentalHelper.getMinLine(beat));
                var y2 = cy + this.y;
                y2 += this.calculateBeamY(h, beatLineX);
                canvas.lineWidth = ScoreBarRenderer.StemWidth * this.scale;
                canvas.beginPath();
                canvas.moveTo(cx + this.x + beatLineX, y1);
                canvas.lineTo(cx + this.x + beatLineX, y2);
                canvas.stroke();
                canvas.lineWidth = this.scale;
                var fingeringY = y2;
                if (direction === BeamDirection.Down) {
                    fingeringY += canvas.font.size * 2;
                }
                else if (i !== 0) {
                    fingeringY -= canvas.font.size * 1.5;
                }
                this.paintFingering(canvas, beat, cx + this.x + beatLineX, direction, fingeringY);
                var brokenBarOffset = 6 * this.scale * scaleMod;
                var barSpacing = (BarRendererBase.BeamSpacing + BarRendererBase.BeamThickness) * this.scale * scaleMod;
                var barSize = BarRendererBase.BeamThickness * this.scale * scaleMod;
                var barCount = ModelUtils.getIndex(beat.duration) - 2;
                var barStart = cy + this.y;
                if (direction === BeamDirection.Down) {
                    barSpacing = -barSpacing;
                    barSize = -barSize;
                }
                for (var barIndex = 0; barIndex < barCount; barIndex++) {
                    var barStartX = 0;
                    var barEndX = 0;
                    var barStartY = 0;
                    var barEndY = 0;
                    var barY = barStart + barIndex * barSpacing;
                    //
                    // Bar to Next?
                    //
                    if (i < h.beats.length - 1) {
                        // full bar?
                        if (BeamingHelper.isFullBarJoin(beat, h.beats[i + 1], barIndex)) {
                            barStartX = beatLineX;
                            barEndX = h.getBeatLineX(h.beats[i + 1]);
                        }
                        else if (i === 0 || !BeamingHelper.isFullBarJoin(h.beats[i - 1], beat, barIndex)) {
                            barStartX = beatLineX;
                            barEndX = barStartX + brokenBarOffset;
                        }
                        else {
                            continue;
                        }
                        barStartY = barY + this.calculateBeamY(h, barStartX);
                        barEndY = barY + this.calculateBeamY(h, barEndX);
                        ScoreBarRenderer.paintSingleBar(canvas, cx + this.x + barStartX, barStartY, cx + this.x + barEndX, barEndY, barSize);
                    }
                    else if (i > 0 && !BeamingHelper.isFullBarJoin(beat, h.beats[i - 1], barIndex)) {
                        barStartX = beatLineX - brokenBarOffset;
                        barEndX = beatLineX;
                        barStartY = barY + this.calculateBeamY(h, barStartX);
                        barEndY = barY + this.calculateBeamY(h, barEndX);
                        ScoreBarRenderer.paintSingleBar(canvas, cx + this.x + barStartX, barStartY, cx + this.x + barEndX, barEndY, barSize);
                    }
                }
            }
        };
        ScoreBarRenderer.paintSingleBar = function (canvas, x1, y1, x2, y2, size) {
            canvas.beginPath();
            canvas.moveTo(x1, y1);
            canvas.lineTo(x2, y2);
            canvas.lineTo(x2, y2 + size);
            canvas.lineTo(x1, y1 + size);
            canvas.closePath();
            canvas.fill();
        };
        ScoreBarRenderer.prototype.paintFlag = function (cx, cy, canvas, h) {
            var beat = h.beats[0];
            if (beat.graceType === GraceType.BendGrace ||
                (beat.graceType !== GraceType.None && this.settings.notation.notationMode === exports.NotationMode.SongBook)) {
                return;
            }
            var isGrace = beat.graceType !== GraceType.None;
            var scaleMod = isGrace ? NoteHeadGlyph.GraceScale : 1;
            //
            // draw line
            //
            var stemSize = this.getFlagStemSize(h.shortestDuration);
            var beatLineX = h.getBeatLineX(beat);
            var direction = h.direction;
            var topY = this.getScoreY(this.accidentalHelper.getMinLine(beat));
            var bottomY = this.getScoreY(this.accidentalHelper.getMaxLine(beat));
            var beamY = 0;
            var fingeringY = 0;
            if (direction === BeamDirection.Down) {
                bottomY += stemSize * scaleMod;
                beamY = bottomY;
                fingeringY = cy + this.y + bottomY;
            }
            else {
                topY -= stemSize * scaleMod;
                beamY = topY;
                fingeringY = cy + this.y + topY;
            }
            this.paintFingering(canvas, beat, cx + this.x + beatLineX, direction, fingeringY);
            if (!h.hasLine) {
                return;
            }
            canvas.lineWidth = BarRendererBase.StemWidth * this.scale;
            canvas.beginPath();
            canvas.moveTo(cx + this.x + beatLineX, cy + this.y + topY);
            canvas.lineTo(cx + this.x + beatLineX, cy + this.y + bottomY);
            canvas.stroke();
            canvas.lineWidth = this.scale;
            if (beat.graceType === GraceType.BeforeBeat) {
                var graceSizeY = 15 * this.scale;
                var graceSizeX = 12 * this.scale;
                canvas.beginPath();
                if (direction === BeamDirection.Down) {
                    canvas.moveTo(cx + this.x + beatLineX - graceSizeX / 2, cy + this.y + bottomY - graceSizeY);
                    canvas.lineTo(cx + this.x + beatLineX + graceSizeX / 2, cy + this.y + bottomY);
                }
                else {
                    canvas.moveTo(cx + this.x + beatLineX - graceSizeX / 2, cy + this.y + topY + graceSizeY);
                    canvas.lineTo(cx + this.x + beatLineX + graceSizeX / 2, cy + this.y + topY);
                }
                canvas.stroke();
            }
            //
            // Draw flag
            //
            if (h.hasFlag) {
                var glyph = new FlagGlyph(beatLineX - this.scale / 2, beamY, beat.duration, direction, isGrace);
                glyph.renderer = this;
                glyph.doLayout();
                glyph.paint(cx + this.x, cy + this.y, canvas);
            }
        };
        ScoreBarRenderer.prototype.paintFingering = function (canvas, beat, beatLineX, direction, topY) {
            var settings = this.settings;
            if (settings.notation.fingeringMode !== exports.FingeringMode.ScoreDefault &&
                settings.notation.fingeringMode !== exports.FingeringMode.ScoreForcePiano) {
                return;
            }
            if (direction === BeamDirection.Up) {
                beatLineX -= 10 * this.scale;
            }
            else {
                beatLineX += 3 * this.scale;
            }
            // sort notes ascending in their value to ensure
            // we are drawing the numbers according to their order on the stave
            var noteList = beat.notes.slice(0);
            noteList.sort(function (a, b) {
                return a.realValue - b.realValue;
            });
            for (var n = 0; n < noteList.length; n++) {
                var note = noteList[n];
                var text = null;
                if (note.leftHandFinger !== Fingers.Unknown) {
                    text = ModelUtils.fingerToString(settings, beat, note.leftHandFinger, true);
                }
                else if (note.rightHandFinger !== Fingers.Unknown) {
                    text = ModelUtils.fingerToString(settings, beat, note.rightHandFinger, false);
                }
                if (!text) {
                    continue;
                }
                canvas.fillText(text, beatLineX, topY);
                topY -= canvas.font.size | 0;
            }
        };
        ScoreBarRenderer.prototype.createPreBeatGlyphs = function () {
            _super.prototype.createPreBeatGlyphs.call(this);
            if (this.bar.masterBar.isRepeatStart) {
                this.addPreBeatGlyph(new RepeatOpenGlyph(0, 0, 1.5, 3));
            }
            // Clef
            if (this.isFirstOfLine ||
                this.bar.clef !== this.bar.previousBar.clef ||
                this.bar.clefOttava !== this.bar.previousBar.clefOttava) {
                var offset = 0;
                var correction = 0.5;
                switch (this.bar.clef) {
                    case Clef.Neutral:
                        offset = this.bar.staff.standardNotationLineCount - 1;
                        break;
                    case Clef.F4:
                        offset = 2;
                        break;
                    case Clef.C3:
                        offset = 4;
                        break;
                    case Clef.C4:
                        offset = 2;
                        break;
                    case Clef.G2:
                        offset = 6;
                        break;
                }
                this.createStartSpacing();
                this.addPreBeatGlyph(new ClefGlyph(0, this.getScoreY(offset, correction), this.bar.clef, this.bar.clefOttava));
            }
            // Key signature
            if ((this.index === 0 && this.bar.masterBar.keySignature !== 0) ||
                (this.bar.previousBar && this.bar.masterBar.keySignature !== this.bar.previousBar.masterBar.keySignature)) {
                this.createStartSpacing();
                this.createKeySignatureGlyphs();
            }
            // Time Signature
            if (!this.bar.previousBar ||
                (this.bar.previousBar &&
                    this.bar.masterBar.timeSignatureNumerator !== this.bar.previousBar.masterBar.timeSignatureNumerator) ||
                (this.bar.previousBar &&
                    this.bar.masterBar.timeSignatureDenominator !== this.bar.previousBar.masterBar.timeSignatureDenominator)) {
                this.createStartSpacing();
                this.createTimeSignatureGlyphs();
            }
            this.addPreBeatGlyph(new BarNumberGlyph(0, this.getScoreHeight(-0.5), this.bar.index + 1));
        };
        ScoreBarRenderer.prototype.createBeatGlyphs = function () {
            for (var v = 0; v < this.bar.voices.length; v++) {
                var voice = this.bar.voices[v];
                if (this.hasVoiceContainer(voice)) {
                    this.createVoiceGlyphs(voice);
                }
            }
        };
        ScoreBarRenderer.prototype.createPostBeatGlyphs = function () {
            _super.prototype.createPostBeatGlyphs.call(this);
            if (this.bar.masterBar.isRepeatEnd) {
                this.addPostBeatGlyph(new RepeatCloseGlyph(this.x, 0));
                if (this.bar.masterBar.repeatCount > 2) {
                    this.addPostBeatGlyph(new RepeatCountGlyph(0, this.getScoreY(-4), this.bar.masterBar.repeatCount));
                }
            }
            else {
                this.addPostBeatGlyph(new BarSeperatorGlyph(0, 0));
            }
        };
        ScoreBarRenderer.prototype.createStartSpacing = function () {
            if (this._startSpacing) {
                return;
            }
            this.addPreBeatGlyph(new SpacingGlyph(0, 0, 2 * this.scale));
            this._startSpacing = true;
        };
        ScoreBarRenderer.prototype.createKeySignatureGlyphs = function () {
            var offsetClef = 0;
            var currentKey = this.bar.masterBar.keySignature;
            var previousKey = !this.bar.previousBar ? 0 : this.bar.previousBar.masterBar.keySignature;
            switch (this.bar.clef) {
                case Clef.Neutral:
                    offsetClef = 0;
                    break;
                case Clef.G2:
                    offsetClef = 1;
                    break;
                case Clef.F4:
                    offsetClef = 2;
                    break;
                case Clef.C3:
                    offsetClef = -1;
                    break;
                case Clef.C4:
                    offsetClef = 1;
                    break;
            }
            var newLines = new Map();
            var newGlyphs = [];
            // how many symbols do we need to get from a C-keysignature
            // to the new one
            // var offsetSymbols = (currentKey <= 7) ? currentKey : currentKey - 7;
            // a sharp keysignature
            if (ModelUtils.keySignatureIsSharp(currentKey)) {
                for (var i = 0; i < Math.abs(currentKey); i++) {
                    var step = ScoreBarRenderer.SharpKsSteps[i] + offsetClef;
                    newGlyphs.push(new AccidentalGlyph(0, this.getScoreY(step, 0), AccidentalType.Sharp, false));
                    newLines.set(step, true);
                }
            }
            else {
                for (var i = 0; i < Math.abs(currentKey); i++) {
                    var step = ScoreBarRenderer.FlatKsSteps[i] + offsetClef;
                    newGlyphs.push(new AccidentalGlyph(0, this.getScoreY(step, 0), AccidentalType.Flat, false));
                    newLines.set(step, true);
                }
            }
            // naturalize previous key
            var naturalizeSymbols = Math.abs(previousKey);
            var previousKeyPositions = ModelUtils.keySignatureIsSharp(previousKey)
                ? ScoreBarRenderer.SharpKsSteps
                : ScoreBarRenderer.FlatKsSteps;
            for (var i = 0; i < naturalizeSymbols; i++) {
                var step = previousKeyPositions[i] + offsetClef;
                if (!newLines.has(step)) {
                    this.addPreBeatGlyph(new AccidentalGlyph(0, this.getScoreY(previousKeyPositions[i] + offsetClef, 0), AccidentalType.Natural, false));
                }
            }
            for (var _i = 0, newGlyphs_1 = newGlyphs; _i < newGlyphs_1.length; _i++) {
                var newGlyph = newGlyphs_1[_i];
                this.addPreBeatGlyph(newGlyph);
            }
        };
        ScoreBarRenderer.prototype.createTimeSignatureGlyphs = function () {
            this.addPreBeatGlyph(new SpacingGlyph(0, 0, 5 * this.scale));
            var lines = this.bar.staff.standardNotationLineCount - 1;
            this.addPreBeatGlyph(new ScoreTimeSignatureGlyph(0, this.getScoreY(lines, 0), this.bar.masterBar.timeSignatureNumerator, this.bar.masterBar.timeSignatureDenominator, this.bar.masterBar.timeSignatureCommon));
        };
        ScoreBarRenderer.prototype.createVoiceGlyphs = function (v) {
            for (var i = 0, j = v.beats.length; i < j; i++) {
                var b = v.beats[i];
                var container = new ScoreBeatContainerGlyph(b, this.getVoiceContainer(v));
                container.preNotes = new ScoreBeatPreNotesGlyph();
                container.onNotes = new ScoreBeatGlyph();
                this.addBeatGlyph(container);
            }
        };
        // TODO[performance]: Maybe we should cache this (check profiler)
        ScoreBarRenderer.prototype.getNoteLine = function (n) {
            return this.accidentalHelper.getNoteLine(n);
        };
        /**
         * Gets the relative y position of the given steps relative to first line.
         * @param steps the amount of steps while 2 steps are one line
         * @param correction
         * @returns
         */
        ScoreBarRenderer.prototype.getScoreY = function (steps, correction) {
            if (correction === void 0) { correction = 0; }
            return (this._firstLineY +
                this.lineOffset +
                this.getScoreHeight(steps) +
                correction * this.scale * BarRendererBase.StaffLineThickness);
        };
        /**
         * Gets the height of an element that spans the given amount of steps.
         * @param steps the amount of steps while 2 steps are one line
         * @param correction
         * @returns
         */
        ScoreBarRenderer.prototype.getScoreHeight = function (steps) {
            return (this.lineOffset / 2) * steps;
        };
        // private static readonly Random Random = new Random();
        ScoreBarRenderer.prototype.paintBackground = function (cx, cy, canvas) {
            _super.prototype.paintBackground.call(this, cx, cy, canvas);
            var res = this.resources;
            // canvas.color = Color.random(100);
            // canvas.fillRect(cx + this.x, cy + this.y, this.width, this.height);
            //
            // draw string lines
            //
            canvas.color = res.staffLineColor;
            for (var i = 0; i < this.bar.staff.standardNotationLineCount; i++) {
                var lineY = cy + this.y + this.getScoreY(i * 2);
                canvas.fillRect(cx + this.x, lineY | 0, this.width, this.scale * BarRendererBase.StaffLineThickness);
            }
            canvas.color = res.mainGlyphColor;
            this.paintSimileMark(cx, cy, canvas);
        };
        ScoreBarRenderer.StaffId = 'score';
        ScoreBarRenderer.SharpKsSteps = [-1, 2, -2, 1, 4, 0, 3];
        ScoreBarRenderer.FlatKsSteps = [3, 0, 4, 1, 5, 2, 6];
        return ScoreBarRenderer;
    }(BarRendererBase));

    var __extends$1$ = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This Factory procudes ScoreBarRenderer instances
     */
    var ScoreBarRendererFactory = /** @class */ (function (_super) {
        __extends$1$(ScoreBarRendererFactory, _super);
        function ScoreBarRendererFactory() {
            return _super.call(this) || this;
        }
        Object.defineProperty(ScoreBarRendererFactory.prototype, "staffId", {
            get: function () {
                return ScoreBarRenderer.StaffId;
            },
            enumerable: false,
            configurable: true
        });
        ScoreBarRendererFactory.prototype.create = function (renderer, bar) {
            return new ScoreBarRenderer(renderer, bar);
        };
        return ScoreBarRendererFactory;
    }(BarRendererFactory));

    var __extends$20 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabSlideLineGlyph = /** @class */ (function (_super) {
        __extends$20(TabSlideLineGlyph, _super);
        function TabSlideLineGlyph(inType, outType, startNote, parent) {
            var _this = _super.call(this, 0, 0) || this;
            _this._inType = inType;
            _this._outType = outType;
            _this._startNote = startNote;
            _this._parent = parent;
            return _this;
        }
        TabSlideLineGlyph.prototype.doLayout = function () {
            this.width = 0;
        };
        TabSlideLineGlyph.prototype.paint = function (cx, cy, canvas) {
            this.paintSlideIn(cx, cy, canvas);
            this.paintSlideOut(cx, cy, canvas);
        };
        TabSlideLineGlyph.prototype.paintSlideIn = function (cx, cy, canvas) {
            var startNoteRenderer = this.renderer;
            var sizeX = 12 * this.scale;
            var sizeY = 3 * this.scale;
            var startX = 0;
            var startY = 0;
            var endX = 0;
            var endY = 0;
            switch (this._inType) {
                case SlideInType.IntoFromBelow:
                    endX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Left);
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    startX = endX - sizeX;
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center) + sizeY;
                    break;
                case SlideInType.IntoFromAbove:
                    endX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Left);
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    startX = endX - sizeX;
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center) - sizeY;
                    break;
                default:
                    return;
            }
            this.paintSlideLine(canvas, false, startX, endX, startY, endY);
        };
        TabSlideLineGlyph.prototype.paintSlideOut = function (cx, cy, canvas) {
            var startNoteRenderer = this.renderer;
            var sizeX = 12 * this.scale;
            var sizeY = 3 * this.scale;
            var startX = 0;
            var startY = 0;
            var endX = 0;
            var endY = 0;
            var waves = false;
            var endXOffset = 2 * this.scale;
            switch (this._outType) {
                case SlideOutType.Shift:
                case SlideOutType.Legato:
                    startX =
                        cx +
                            startNoteRenderer.x +
                            startNoteRenderer.getBeatX(this._startNote.beat, BeatXPosition.PostNotes);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    if (this._startNote.slideTarget) {
                        var endNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, this._startNote.slideTarget.beat.voice.bar);
                        if (!endNoteRenderer || endNoteRenderer.staff !== startNoteRenderer.staff) {
                            endX = cx + startNoteRenderer.x + this._parent.x;
                            endY = startY;
                        }
                        else {
                            endX =
                                cx +
                                    endNoteRenderer.x +
                                    endNoteRenderer.getBeatX(this._startNote.slideTarget.beat, BeatXPosition.OnNotes)
                                    - endXOffset;
                            endY =
                                cy +
                                    endNoteRenderer.y +
                                    endNoteRenderer.getNoteY(this._startNote.slideTarget, NoteYPosition.Center);
                        }
                        if (this._startNote.slideTarget.fret > this._startNote.fret) {
                            startY += sizeY;
                            endY -= sizeY;
                        }
                        else {
                            startY -= sizeY;
                            endY += sizeY;
                        }
                    }
                    else {
                        endX = cx + startNoteRenderer.x + this._parent.x;
                        endY = startY;
                    }
                    break;
                case SlideOutType.OutUp:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endX = startX + sizeX - endXOffset;
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center) - sizeY;
                    break;
                case SlideOutType.OutDown:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endX = startX + sizeX - endXOffset;
                    endY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center) + sizeY;
                    break;
                case SlideOutType.PickSlideDown:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endX =
                        cx + startNoteRenderer.x + startNoteRenderer.getBeatX(this._startNote.beat, BeatXPosition.EndBeat);
                    endY = startY + sizeY * 3;
                    waves = true;
                    break;
                case SlideOutType.PickSlideUp:
                    startX = cx + startNoteRenderer.x + startNoteRenderer.getNoteX(this._startNote, NoteXPosition.Right);
                    startY = cy + startNoteRenderer.y + startNoteRenderer.getNoteY(this._startNote, NoteYPosition.Center);
                    endX =
                        cx + startNoteRenderer.x + startNoteRenderer.getBeatX(this._startNote.beat, BeatXPosition.EndBeat);
                    endY = startY - sizeY * 3;
                    waves = true;
                    break;
                default:
                    return;
            }
            this.paintSlideLine(canvas, waves, startX, endX, startY, endY);
        };
        TabSlideLineGlyph.prototype.paintSlideLine = function (canvas, waves, startX, endX, startY, endY) {
            if (waves) {
                var glyph = new NoteVibratoGlyph(0, 0, VibratoType.Slight, 1.2);
                glyph.renderer = this.renderer;
                glyph.doLayout();
                startY -= glyph.height / 2;
                endY -= glyph.height / 2;
                var b = endX - startX;
                var a = endY - startY;
                var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
                glyph.width = b;
                var angle = Math.asin(a / c) * (180 / Math.PI);
                canvas.beginRotate(startX, startY, angle);
                glyph.paint(0, 0, canvas);
                canvas.endRotate();
            }
            else {
                canvas.beginPath();
                canvas.moveTo(startX, startY);
                canvas.lineTo(endX, endY);
                canvas.stroke();
            }
        };
        return TabSlideLineGlyph;
    }(Glyph));

    var __extends$21 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabTieGlyph = /** @class */ (function (_super) {
        __extends$21(TabTieGlyph, _super);
        function TabTieGlyph(startNote, endNote, forEnd) {
            if (forEnd === void 0) { forEnd = false; }
            var _this = _super.call(this, startNote.beat, endNote.beat, forEnd) || this;
            _this.startNote = startNote;
            _this.endNote = endNote;
            return _this;
        }
        TabTieGlyph.prototype.getTieHeight = function (startX, startY, endX, endY) {
            if (this.startNote === this.endNote) {
                return 15;
            }
            return _super.prototype.getTieHeight.call(this, startX, startY, endX, endY);
        };
        TabTieGlyph.prototype.getBeamDirection = function (beat, noteRenderer) {
            if (this.startNote === this.endNote) {
                return BeamDirection.Up;
            }
            return TabTieGlyph.getBeamDirectionForNote(this.startNote);
        };
        TabTieGlyph.getBeamDirectionForNote = function (note) {
            return note.string > 3 ? BeamDirection.Up : BeamDirection.Down;
        };
        TabTieGlyph.prototype.getStartY = function () {
            if (this.startNote === this.endNote) {
                return this.startNoteRenderer.getNoteY(this.startNote, NoteYPosition.Center);
            }
            if (this.tieDirection === BeamDirection.Up) {
                return this.startNoteRenderer.getNoteY(this.startNote, NoteYPosition.Top);
            }
            return this.startNoteRenderer.getNoteY(this.startNote, NoteYPosition.Bottom);
        };
        TabTieGlyph.prototype.getEndY = function () {
            return this.getStartY();
        };
        TabTieGlyph.prototype.getStartX = function () {
            if (this.startNote === this.endNote) {
                return this.getEndX() - 20 * this.scale;
            }
            return this.startNoteRenderer.getNoteX(this.startNote, NoteXPosition.Center);
        };
        TabTieGlyph.prototype.getEndX = function () {
            if (this.startNote === this.endNote) {
                return this.endNoteRenderer.getNoteX(this.endNote, NoteXPosition.Left);
            }
            return this.endNoteRenderer.getNoteX(this.endNote, NoteXPosition.Center);
        };
        return TabTieGlyph;
    }(TieGlyph));

    var __extends$22 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabSlurGlyph = /** @class */ (function (_super) {
        __extends$22(TabSlurGlyph, _super);
        function TabSlurGlyph(startNote, endNote, forSlide, forEnd) {
            if (forEnd === void 0) { forEnd = false; }
            var _this = _super.call(this, startNote, endNote, forEnd) || this;
            _this._direction = TabTieGlyph.getBeamDirectionForNote(startNote);
            _this._forSlide = forSlide;
            return _this;
        }
        TabSlurGlyph.prototype.getTieHeight = function (startX, startY, endX, endY) {
            return Math.log(endX - startX + 1) * this.renderer.settings.notation.slurHeight;
        };
        TabSlurGlyph.prototype.tryExpand = function (startNote, endNote, forSlide, forEnd) {
            // same type required
            if (this._forSlide !== forSlide) {
                return false;
            }
            if (this.forEnd !== forEnd) {
                return false;
            }
            // same start and endbeat
            if (this.startNote.beat.id !== startNote.beat.id) {
                return false;
            }
            if (this.endNote.beat.id !== endNote.beat.id) {
                return false;
            }
            // same draw direction
            if (this._direction !== TabTieGlyph.getBeamDirectionForNote(startNote)) {
                return false;
            }
            // if we can expand, expand in correct direction
            switch (this._direction) {
                case BeamDirection.Up:
                    if (startNote.realValue > this.startNote.realValue) {
                        this.startNote = startNote;
                        this.startBeat = startNote.beat;
                    }
                    if (endNote.realValue > this.endNote.realValue) {
                        this.endNote = endNote;
                        this.endBeat = endNote.beat;
                    }
                    break;
                case BeamDirection.Down:
                    if (startNote.realValue < this.startNote.realValue) {
                        this.startNote = startNote;
                        this.startBeat = startNote.beat;
                    }
                    if (endNote.realValue < this.endNote.realValue) {
                        this.endNote = endNote;
                        this.endBeat = endNote.beat;
                    }
                    break;
            }
            return true;
        };
        TabSlurGlyph.prototype.paint = function (cx, cy, canvas) {
            var startNoteRenderer = this.renderer.scoreRenderer.layout.getRendererForBar(this.renderer.staff.staveId, this.startBeat.voice.bar);
            var direction = this.getBeamDirection(this.startBeat, startNoteRenderer);
            var slurId = 'tab.slur.' + this.startNote.beat.id + '.' + this.endNote.beat.id + '.' + direction;
            var renderer = this.renderer;
            var isSlurRendered = renderer.staff.getSharedLayoutData(slurId, false);
            if (!isSlurRendered) {
                renderer.staff.setSharedLayoutData(slurId, true);
                _super.prototype.paint.call(this, cx, cy, canvas);
            }
        };
        return TabSlurGlyph;
    }(TabTieGlyph));

    var __extends$23 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabBeatContainerGlyph = /** @class */ (function (_super) {
        __extends$23(TabBeatContainerGlyph, _super);
        function TabBeatContainerGlyph(beat, voiceContainer) {
            var _this = _super.call(this, beat, voiceContainer) || this;
            _this._bend = null;
            _this._effectSlurs = [];
            return _this;
        }
        TabBeatContainerGlyph.prototype.doLayout = function () {
            this._effectSlurs = [];
            _super.prototype.doLayout.call(this);
            if (this._bend) {
                this._bend.renderer = this.renderer;
                this._bend.doLayout();
                this.updateWidth();
            }
        };
        TabBeatContainerGlyph.prototype.createTies = function (n) {
            if (!n.isVisible) {
                return;
            }
            var renderer = this.renderer;
            if (n.isTieOrigin && renderer.showTiedNotes && n.tieDestination.isVisible) {
                var tie = new TabTieGlyph(n, n.tieDestination, false);
                this.ties.push(tie);
            }
            if (n.isTieDestination && renderer.showTiedNotes) {
                var tie = new TabTieGlyph(n.tieOrigin, n, true);
                this.ties.push(tie);
            }
            if (n.isLeftHandTapped && !n.isHammerPullDestination) {
                var tapSlur = new TabTieGlyph(n, n, false);
                this.ties.push(tapSlur);
            }
            // start effect slur on first beat
            if (n.isEffectSlurOrigin && n.effectSlurDestination) {
                var expanded = false;
                for (var _i = 0, _a = this._effectSlurs; _i < _a.length; _i++) {
                    var slur = _a[_i];
                    if (slur.tryExpand(n, n.effectSlurDestination, false, false)) {
                        expanded = true;
                        break;
                    }
                }
                if (!expanded) {
                    var effectSlur = new TabSlurGlyph(n, n.effectSlurDestination, false, false);
                    this._effectSlurs.push(effectSlur);
                    this.ties.push(effectSlur);
                }
            }
            // end effect slur on last beat
            if (n.isEffectSlurDestination && n.effectSlurOrigin) {
                var expanded = false;
                for (var _b = 0, _c = this._effectSlurs; _b < _c.length; _b++) {
                    var slur = _c[_b];
                    if (slur.tryExpand(n.effectSlurOrigin, n, false, true)) {
                        expanded = true;
                        break;
                    }
                }
                if (!expanded) {
                    var effectSlur = new TabSlurGlyph(n.effectSlurOrigin, n, false, true);
                    this._effectSlurs.push(effectSlur);
                    this.ties.push(effectSlur);
                }
            }
            if (n.slideInType !== SlideInType.None || n.slideOutType !== SlideOutType.None) {
                var l = new TabSlideLineGlyph(n.slideInType, n.slideOutType, n, this);
                this.ties.push(l);
            }
            if (n.hasBend) {
                if (!this._bend) {
                    this._bend = new TabBendGlyph();
                    this._bend.renderer = this.renderer;
                    this.ties.push(this._bend);
                }
                this._bend.addBends(n);
            }
        };
        return TabBeatContainerGlyph;
    }(BeatContainerGlyph));

    var __extends$24 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var NoteNumberGlyph = /** @class */ (function (_super) {
        __extends$24(NoteNumberGlyph, _super);
        function NoteNumberGlyph(x, y, note) {
            var _this = _super.call(this, x, y) || this;
            _this._noteString = null;
            _this._trillNoteString = null;
            _this._trillNoteStringWidth = 0;
            _this.isEmpty = false;
            _this.height = 0;
            _this.noteStringWidth = 0;
            _this._note = note;
            return _this;
        }
        NoteNumberGlyph.prototype.doLayout = function () {
            var n = this._note;
            var fret = n.fret - n.beat.voice.bar.staff.transpositionPitch;
            if (n.harmonicType === HarmonicType.Natural && n.harmonicValue !== 0) {
                fret = n.harmonicValue - n.beat.voice.bar.staff.transpositionPitch;
            }
            if (!n.isTieDestination) {
                this._noteString = n.isDead ? 'x' : fret.toString();
                if (n.isGhost) {
                    this._noteString = '(' + this._noteString + ')';
                }
                else if (n.harmonicType === HarmonicType.Natural) {
                    // only first decimal char
                    var i = this._noteString.indexOf(String.fromCharCode(46));
                    if (i >= 0) {
                        this._noteString = this._noteString.substr(0, i + 2);
                    }
                    this._noteString = '<' + this._noteString + '>';
                }
            }
            else if ((n.beat.index === 0 && this.renderer.settings.notation.notationMode == exports.NotationMode.GuitarPro) ||
                ((n.bendType === BendType.Bend || n.bendType === BendType.BendRelease) &&
                    this.renderer.settings.notation.isNotationElementVisible(NotationElement.TabNotesOnTiedBends))) {
                this._noteString = '(' + (n.tieOrigin.fret - n.beat.voice.bar.staff.transpositionPitch) + ')';
            }
            else {
                this._noteString = '';
            }
            if (n.isTrill) {
                this._trillNoteString = '(' + (n.trillFret - n.beat.voice.bar.staff.transpositionPitch) + ')';
            }
            else if (!ModelUtils.isAlmostEqualTo(n.harmonicValue, 0)) {
                switch (n.harmonicType) {
                    case HarmonicType.Artificial:
                    case HarmonicType.Pinch:
                    case HarmonicType.Tap:
                    case HarmonicType.Semi:
                    case HarmonicType.Feedback:
                        var s = (fret + n.harmonicValue).toString();
                        // only first decimal char
                        var i = s.indexOf(String.fromCharCode(46));
                        if (i >= 0) {
                            s = s.substr(0, i + 2);
                        }
                        this._trillNoteString = '<' + s + '>';
                        break;
                    default:
                        this._trillNoteString = '';
                        break;
                }
            }
            else {
                this._trillNoteString = '';
            }
            this.isEmpty = !this._noteString;
            if (!this.isEmpty) {
                this.renderer.scoreRenderer.canvas.font = this.renderer.resources.tablatureFont;
                this.width = this.noteStringWidth = this.renderer.scoreRenderer.canvas.measureText(this._noteString);
                this.height = this.renderer.scoreRenderer.canvas.font.size;
                var hasTrill = !!this._trillNoteString;
                if (hasTrill) {
                    this.renderer.scoreRenderer.canvas.font = this.renderer.resources.graceFont;
                    this._trillNoteStringWidth =
                        3 * this.scale + this.renderer.scoreRenderer.canvas.measureText(this._trillNoteString);
                    this.width += this._trillNoteStringWidth;
                }
            }
        };
        NoteNumberGlyph.prototype.paint = function (cx, cy, canvas) {
            if (this.isEmpty) {
                return;
            }
            var textWidth = this.noteStringWidth + this._trillNoteStringWidth;
            var x = cx + this.x + (this.width - textWidth) / 2;
            var prevFont = this.renderer.scoreRenderer.canvas.font;
            this.renderer.scoreRenderer.canvas.font = this.renderer.resources.graceFont;
            canvas.fillText(this._trillNoteString, x + this.noteStringWidth + 3 * this.scale, cy + this.y);
            this.renderer.scoreRenderer.canvas.font = prevFont;
            canvas.fillText(this._noteString, x, cy + this.y);
        };
        NoteNumberGlyph.prototype.buildBoundingsLookup = function (beatBounds, cx, cy) {
            var noteBounds = new NoteBounds();
            noteBounds.note = this._note;
            noteBounds.noteHeadBounds = new Bounds();
            noteBounds.noteHeadBounds.x = cx + this.x;
            noteBounds.noteHeadBounds.y = cy + this.y - this.height / 2;
            noteBounds.noteHeadBounds.w = this.width;
            noteBounds.noteHeadBounds.h = this.height;
            this.renderer.scoreRenderer.boundsLookup.addNote(noteBounds);
        };
        return NoteNumberGlyph;
    }(Glyph));

    var __extends$25 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabNoteChordGlyph = /** @class */ (function (_super) {
        __extends$25(TabNoteChordGlyph, _super);
        function TabNoteChordGlyph(x, y, isGrace) {
            var _this = _super.call(this, x, y) || this;
            _this._notes = [];
            _this.minStringNote = null;
            _this.beatEffects = new Map();
            _this.notesPerString = new Map();
            _this.noteStringWidth = 0;
            _this._isGrace = isGrace;
            return _this;
        }
        TabNoteChordGlyph.prototype.buildBoundingsLookup = function (beatBounds, cx, cy) {
            for (var _i = 0, _a = this._notes; _i < _a.length; _i++) {
                var note = _a[_i];
                note.buildBoundingsLookup(beatBounds, cx + this.x, cy + this.y);
            }
        };
        TabNoteChordGlyph.prototype.getNoteX = function (note, requestedPosition) {
            if (this.notesPerString.has(note.string)) {
                var n = this.notesPerString.get(note.string);
                var pos = this.x + n.x;
                switch (requestedPosition) {
                    case NoteXPosition.Left:
                        break;
                    case NoteXPosition.Center:
                        pos += n.noteStringWidth / 2;
                        break;
                    case NoteXPosition.Right:
                        pos += n.width;
                        break;
                }
                return pos;
            }
            return 0;
        };
        TabNoteChordGlyph.prototype.getNoteY = function (note, requestedPosition) {
            if (this.notesPerString.has(note.string)) {
                var n = this.notesPerString.get(note.string);
                var pos = this.y + n.y;
                switch (requestedPosition) {
                    case NoteYPosition.Top:
                    case NoteYPosition.TopWithStem:
                        pos -= n.height / 2 + 2 * this.scale;
                        break;
                    case NoteYPosition.Center:
                        break;
                    case NoteYPosition.Bottom:
                    case NoteYPosition.BottomWithStem:
                        pos += n.height / 2;
                        break;
                }
                return pos;
            }
            return 0;
        };
        TabNoteChordGlyph.prototype.doLayout = function () {
            var _this = this;
            var w = 0;
            var noteStringWidth = 0;
            for (var i = 0, j = this._notes.length; i < j; i++) {
                var g = this._notes[i];
                g.renderer = this.renderer;
                g.doLayout();
                if (g.width > w) {
                    w = g.width;
                }
                if (g.noteStringWidth > noteStringWidth) {
                    noteStringWidth = g.noteStringWidth;
                }
            }
            this.noteStringWidth = noteStringWidth;
            var tabHeight = this.renderer.resources.tablatureFont.size;
            var effectY = this.getNoteY(this.minStringNote, NoteYPosition.Center) + tabHeight / 2;
            // TODO: take care of actual glyph height
            var effectSpacing = 7 * this.scale;
            this.beatEffects.forEach(function (g) {
                g.y += effectY;
                g.x += _this.width / 2;
                g.renderer = _this.renderer;
                effectY += effectSpacing;
                g.doLayout();
            });
            this.width = w;
        };
        TabNoteChordGlyph.prototype.addNoteGlyph = function (noteGlyph, note) {
            this._notes.push(noteGlyph);
            this.notesPerString.set(note.string, noteGlyph);
            if (!this.minStringNote || note.string < this.minStringNote.string) {
                this.minStringNote = note;
            }
        };
        TabNoteChordGlyph.prototype.paint = function (cx, cy, canvas) {
            cx += this.x;
            cy += this.y;
            var res = this.renderer.resources;
            var oldBaseLine = canvas.textBaseline;
            canvas.textBaseline = TextBaseline.Middle;
            canvas.font = this._isGrace ? res.graceFont : res.tablatureFont;
            var notes = this._notes;
            var w = this.width;
            for (var _i = 0, notes_1 = notes; _i < notes_1.length; _i++) {
                var g = notes_1[_i];
                g.renderer = this.renderer;
                g.width = w;
                g.paint(cx, cy, canvas);
            }
            canvas.textBaseline = oldBaseLine;
            this.beatEffects.forEach(function (g) {
                g.paint(cx, cy, canvas);
            });
        };
        TabNoteChordGlyph.prototype.updateBeamingHelper = function (cx) {
            if (this.beamingHelper && this.beamingHelper.isPositionFrom('tab', this.beat)) {
                this.beamingHelper.registerBeatLineX('tab', this.beat, cx + this.x + this.width, cx + this.x);
            }
        };
        return TabNoteChordGlyph;
    }(Glyph));

    var __extends$26 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabRestGlyph = /** @class */ (function (_super) {
        __extends$26(TabRestGlyph, _super);
        function TabRestGlyph(x, y, isVisibleRest, duration) {
            var _this = _super.call(this, x, y, 1, ScoreRestGlyph.getSymbol(duration)) || this;
            _this._isVisibleRest = isVisibleRest;
            _this._duration = duration;
            return _this;
        }
        TabRestGlyph.prototype.doLayout = function () {
            if (this._isVisibleRest) {
                this.width = ScoreRestGlyph.getSize(this._duration) * this.scale;
            }
            else {
                this.width = 10 * this.scale;
            }
        };
        TabRestGlyph.prototype.updateBeamingHelper = function (cx) {
            if (this.beamingHelper && this.beamingHelper.isPositionFrom('tab', this.beat)) {
                this.beamingHelper.registerBeatLineX('tab', this.beat, cx + this.x + this.width, cx + this.x);
            }
        };
        TabRestGlyph.prototype.paint = function (cx, cy, canvas) {
            if (this._isVisibleRest) {
                _super.prototype.paint.call(this, cx, cy, canvas);
            }
        };
        return TabRestGlyph;
    }(MusicFontGlyph));

    var __extends$27 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabBeatGlyph = /** @class */ (function (_super) {
        __extends$27(TabBeatGlyph, _super);
        function TabBeatGlyph() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.noteNumbers = null;
            _this.restGlyph = null;
            return _this;
        }
        TabBeatGlyph.prototype.getNoteX = function (note, requestedPosition) {
            return this.noteNumbers ? this.noteNumbers.getNoteX(note, requestedPosition) : 0;
        };
        TabBeatGlyph.prototype.getNoteY = function (note, requestedPosition) {
            return this.noteNumbers ? this.noteNumbers.getNoteY(note, requestedPosition) : 0;
        };
        TabBeatGlyph.prototype.buildBoundingsLookup = function (beatBounds, cx, cy) {
            if (this.noteNumbers) {
                this.noteNumbers.buildBoundingsLookup(beatBounds, cx + this.x, cy + this.y);
            }
        };
        TabBeatGlyph.prototype.doLayout = function () {
            var tabRenderer = this.renderer;
            if (!this.container.beat.isRest) {
                //
                // Note numbers
                var isGrace = this.renderer.settings.notation.smallGraceTabNotes && this.container.beat.graceType !== GraceType.None;
                this.noteNumbers = new TabNoteChordGlyph(0, 0, isGrace);
                this.noteNumbers.beat = this.container.beat;
                this.noteNumbers.beamingHelper = this.beamingHelper;
                for (var _i = 0, _a = this.container.beat.notes; _i < _a.length; _i++) {
                    var note = _a[_i];
                    if (note.isVisible) {
                        this.createNoteGlyph(note);
                    }
                }
                this.addGlyph(this.noteNumbers);
                //
                // Whammy Bar
                if (this.container.beat.hasWhammyBar) {
                    var whammy = new TabWhammyBarGlyph(this.container.beat);
                    whammy.renderer = this.renderer;
                    whammy.doLayout();
                    this.container.ties.push(whammy);
                }
                //
                // Tremolo Picking
                if (this.container.beat.isTremolo && !this.noteNumbers.beatEffects.has('tremolo')) {
                    var offset = 0;
                    var speed = this.container.beat.tremoloSpeed;
                    switch (speed) {
                        case Duration.ThirtySecond:
                            offset = 10;
                            break;
                        case Duration.Sixteenth:
                            offset = 5;
                            break;
                        case Duration.Eighth:
                            offset = 0;
                            break;
                    }
                    this.noteNumbers.beatEffects.set('tremolo', new TremoloPickingGlyph(5 * this.scale, offset * this.scale, speed));
                }
                //
                // Note dots
                //
                if (this.container.beat.dots > 0 && tabRenderer.settings.notation.rhythmMode !== exports.TabRhythmMode.Hidden) {
                    this.addGlyph(new SpacingGlyph(0, 0, 5 * this.scale));
                    for (var i = 0; i < this.container.beat.dots; i++) {
                        this.addGlyph(new CircleGlyph(0, tabRenderer.lineOffset * tabRenderer.bar.staff.tuning.length +
                            tabRenderer.settings.notation.rhythmHeight * tabRenderer.scale, 1.5 * this.scale));
                    }
                }
            }
            else {
                var line = 0;
                var offset = 0;
                switch (this.container.beat.duration) {
                    case Duration.QuadrupleWhole:
                        line = 3;
                        break;
                    case Duration.DoubleWhole:
                        line = 3;
                        break;
                    case Duration.Whole:
                        line = 2;
                        break;
                    case Duration.Half:
                        line = 3;
                        break;
                    case Duration.Quarter:
                        line = 3;
                        break;
                    case Duration.Eighth:
                        line = 2;
                        offset = 5;
                        break;
                    case Duration.Sixteenth:
                        line = 2;
                        offset = 5;
                        break;
                    case Duration.ThirtySecond:
                        line = 3;
                        break;
                    case Duration.SixtyFourth:
                        line = 3;
                        break;
                    case Duration.OneHundredTwentyEighth:
                        line = 3;
                        break;
                    case Duration.TwoHundredFiftySixth:
                        line = 3;
                        break;
                }
                var y = tabRenderer.getTabY(line, offset);
                this.restGlyph = new TabRestGlyph(0, y, tabRenderer.showRests, this.container.beat.duration);
                this.restGlyph.beat = this.container.beat;
                this.restGlyph.beamingHelper = this.beamingHelper;
                this.addGlyph(this.restGlyph);
                //
                // Note dots
                //
                if (this.container.beat.dots > 0 && tabRenderer.showRests) {
                    this.addGlyph(new SpacingGlyph(0, 0, 5 * this.scale));
                    for (var i = 0; i < this.container.beat.dots; i++) {
                        this.addGlyph(new CircleGlyph(0, y, 1.5 * this.scale));
                    }
                }
            }
            // left to right layout
            if (!this.glyphs) {
                return;
            }
            var w = 0;
            for (var i = 0, j = this.glyphs.length; i < j; i++) {
                var g = this.glyphs[i];
                g.x = w;
                g.renderer = this.renderer;
                g.doLayout();
                w += g.width;
            }
            this.width = w;
            if (this.container.beat.isEmpty) {
                this.centerX = this.width / 2;
            }
            else if (this.container.beat.isRest) {
                this.centerX = this.restGlyph.x + this.restGlyph.width / 2;
            }
            else {
                this.centerX = this.noteNumbers.x + this.noteNumbers.noteStringWidth / 2;
            }
        };
        TabBeatGlyph.prototype.updateBeamingHelper = function () {
            if (!this.container.beat.isRest) {
                this.noteNumbers.updateBeamingHelper(this.container.x + this.x);
            }
            else {
                this.restGlyph.updateBeamingHelper(this.container.x + this.x);
            }
        };
        TabBeatGlyph.prototype.createNoteGlyph = function (n) {
            var tr = this.renderer;
            var noteNumberGlyph = new NoteNumberGlyph(0, 0, n);
            var l = n.beat.voice.bar.staff.tuning.length - n.string + 1;
            noteNumberGlyph.y = tr.getTabY(l, -2);
            noteNumberGlyph.renderer = this.renderer;
            noteNumberGlyph.doLayout();
            this.noteNumbers.addNoteGlyph(noteNumberGlyph, n);
        };
        return TabBeatGlyph;
    }(BeatOnNoteGlyphBase));

    var __extends$28 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabBrushGlyph = /** @class */ (function (_super) {
        __extends$28(TabBrushGlyph, _super);
        function TabBrushGlyph(beat) {
            var _this = _super.call(this, 0, 0) || this;
            _this._beat = beat;
            return _this;
        }
        TabBrushGlyph.prototype.doLayout = function () {
            this.width = 10 * this.scale;
        };
        TabBrushGlyph.prototype.paint = function (cx, cy, canvas) {
            var tabBarRenderer = this.renderer;
            var startY = cy + this.x + (tabBarRenderer.getNoteY(this._beat.maxNote, NoteYPosition.Top));
            var endY = cy + this.y + tabBarRenderer.getNoteY(this._beat.minNote, NoteYPosition.Bottom);
            var arrowX = (cx + this.x + this.width / 2) | 0;
            var arrowSize = 8 * this.scale;
            if (this._beat.brushType !== BrushType.None) {
                if (this._beat.brushType === BrushType.BrushUp || this._beat.brushType === BrushType.BrushDown) {
                    canvas.beginPath();
                    canvas.moveTo(arrowX, startY);
                    canvas.lineTo(arrowX, endY);
                    canvas.stroke();
                }
                else if (this._beat.brushType === BrushType.ArpeggioUp) {
                    var glyph = new NoteVibratoGlyph(0, 0, VibratoType.Slight, 1.2, true);
                    glyph.renderer = this.renderer;
                    glyph.doLayout();
                    var lineStartY = startY;
                    var lineEndY = endY - arrowSize;
                    glyph.width = Math.abs(lineEndY - lineStartY);
                    canvas.beginRotate(cx + this.x + 4 * this.scale, lineEndY, -90);
                    glyph.paint(0, -glyph.height / 2, canvas);
                    canvas.endRotate();
                }
                else if (this._beat.brushType === BrushType.ArpeggioDown) {
                    var glyph = new NoteVibratoGlyph(0, 0, VibratoType.Slight, 1.2, true);
                    glyph.renderer = this.renderer;
                    glyph.doLayout();
                    var lineStartY = startY + arrowSize;
                    var lineEndY = endY;
                    glyph.width = Math.abs(lineEndY - lineStartY);
                    canvas.beginRotate(cx + this.x + 4 * this.scale, lineStartY, 90);
                    glyph.paint(0, -glyph.height / 2, canvas);
                    canvas.endRotate();
                }
                if (this._beat.brushType === BrushType.BrushUp || this._beat.brushType === BrushType.ArpeggioUp) {
                    canvas.beginPath();
                    canvas.moveTo(arrowX, endY);
                    canvas.lineTo(arrowX + arrowSize / 2, endY - arrowSize);
                    canvas.lineTo(arrowX - arrowSize / 2, endY - arrowSize);
                    canvas.closePath();
                    canvas.fill();
                }
                else {
                    canvas.beginPath();
                    canvas.moveTo(arrowX, startY);
                    canvas.lineTo(arrowX + arrowSize / 2, startY + arrowSize);
                    canvas.lineTo(arrowX - arrowSize / 2, startY + arrowSize);
                    canvas.closePath();
                    canvas.fill();
                }
            }
        };
        return TabBrushGlyph;
    }(Glyph));

    var __extends$29 = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabBeatPreNotesGlyph = /** @class */ (function (_super) {
        __extends$29(TabBeatPreNotesGlyph, _super);
        function TabBeatPreNotesGlyph() {
            return _super.call(this) || this;
        }
        TabBeatPreNotesGlyph.prototype.doLayout = function () {
            if (this.container.beat.brushType !== BrushType.None && !this.container.beat.isRest) {
                this.addGlyph(new TabBrushGlyph(this.container.beat));
                this.addGlyph(new SpacingGlyph(0, 0, 4 * this.scale));
            }
            _super.prototype.doLayout.call(this);
        };
        return TabBeatPreNotesGlyph;
    }(BeatGlyphBase));

    var __extends$2a = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabClefGlyph = /** @class */ (function (_super) {
        __extends$2a(TabClefGlyph, _super);
        function TabClefGlyph(x, y) {
            return _super.call(this, x, y) || this;
        }
        TabClefGlyph.prototype.doLayout = function () {
            this.width = 28 * this.scale;
        };
        TabClefGlyph.prototype.paint = function (cx, cy, canvas) {
            var strings = this.renderer.bar.staff.tuning.length;
            var correction = strings * this.scale * 0.5;
            var symbol = strings <= 4 ? MusicFontSymbol.FourStringTabClef : MusicFontSymbol.SixStringTabClef;
            var scale = strings <= 4 ? strings / 4.5 : strings / 6.5;
            canvas.fillMusicFontSymbol(cx + this.x + 5 * this.scale, cy + this.y - correction, scale * this.scale, symbol, false);
        };
        return TabClefGlyph;
    }(Glyph));

    var __extends$2b = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var TabTimeSignatureGlyph = /** @class */ (function (_super) {
        __extends$2b(TabTimeSignatureGlyph, _super);
        function TabTimeSignatureGlyph() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(TabTimeSignatureGlyph.prototype, "commonScale", {
            get: function () {
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TabTimeSignatureGlyph.prototype, "numberScale", {
            get: function () {
                var renderer = this.renderer;
                if (renderer.bar.staff.tuning.length <= 4) {
                    return NoteHeadGlyph.GraceScale;
                }
                return 1;
            },
            enumerable: false,
            configurable: true
        });
        return TabTimeSignatureGlyph;
    }(TimeSignatureGlyph));

    var __extends$2c = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This BarRenderer renders a bar using guitar tablature notation
     */
    var TabBarRenderer = /** @class */ (function (_super) {
        __extends$2c(TabBarRenderer, _super);
        function TabBarRenderer(renderer, bar) {
            var _this = _super.call(this, renderer, bar) || this;
            _this._tupletSize = 0;
            _this.showTimeSignature = false;
            _this.showRests = false;
            _this.showTiedNotes = false;
            _this._startSpacing = false;
            return _this;
        }
        Object.defineProperty(TabBarRenderer.prototype, "lineOffset", {
            get: function () {
                return (TabBarRenderer.LineSpacing + 1) * this.scale;
            },
            enumerable: false,
            configurable: true
        });
        TabBarRenderer.prototype.updateSizes = function () {
            var res = this.resources;
            var numberOverflow = res.tablatureFont.size / 2 + res.tablatureFont.size * 0.2;
            this.topPadding = numberOverflow;
            this.bottomPadding = numberOverflow;
            this.height = this.lineOffset * (this.bar.staff.tuning.length - 1) + numberOverflow * 2;
            if (this.settings.notation.rhythmMode !== exports.TabRhythmMode.Hidden) {
                this.height += this.settings.notation.rhythmHeight * this.settings.display.scale;
                this.bottomPadding += this.settings.notation.rhythmHeight * this.settings.display.scale;
            }
            _super.prototype.updateSizes.call(this);
        };
        TabBarRenderer.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            if (this.settings.notation.rhythmMode !== exports.TabRhythmMode.Hidden) {
                var hasTuplets = false;
                for (var _i = 0, _a = this.bar.voices; _i < _a.length; _i++) {
                    var voice = _a[_i];
                    if (this.hasVoiceContainer(voice)) {
                        var c = this.getVoiceContainer(voice);
                        if (c.tupletGroups.length > 0) {
                            hasTuplets = true;
                            break;
                        }
                    }
                }
                if (hasTuplets) {
                    this._tupletSize = this.resources.effectFont.size * 0.8;
                    this.registerOverflowBottom(this._tupletSize);
                }
            }
        };
        TabBarRenderer.prototype.createPreBeatGlyphs = function () {
            _super.prototype.createPreBeatGlyphs.call(this);
            if (this.bar.masterBar.isRepeatStart) {
                this.addPreBeatGlyph(new RepeatOpenGlyph(0, 0, 1.5, 3));
            }
            // Clef
            if (this.isFirstOfLine) {
                var center = (this.bar.staff.tuning.length + 1) / 2;
                this.addPreBeatGlyph(new TabClefGlyph(5 * this.scale, this.getTabY(center, 0)));
            }
            // Time Signature
            if (this.showTimeSignature &&
                (!this.bar.previousBar ||
                    (this.bar.previousBar &&
                        this.bar.masterBar.timeSignatureNumerator !==
                            this.bar.previousBar.masterBar.timeSignatureNumerator) ||
                    (this.bar.previousBar &&
                        this.bar.masterBar.timeSignatureDenominator !==
                            this.bar.previousBar.masterBar.timeSignatureDenominator))) {
                this.createStartSpacing();
                this.createTimeSignatureGlyphs();
            }
            this.addPreBeatGlyph(new BarNumberGlyph(0, this.getTabY(-0.5, 0), this.bar.index + 1));
        };
        TabBarRenderer.prototype.createStartSpacing = function () {
            if (this._startSpacing) {
                return;
            }
            this.addPreBeatGlyph(new SpacingGlyph(0, 0, 2 * this.scale));
            this._startSpacing = true;
        };
        TabBarRenderer.prototype.createTimeSignatureGlyphs = function () {
            this.addPreBeatGlyph(new SpacingGlyph(0, 0, 5 * this.scale));
            var lines = (this.bar.staff.tuning.length + 1) / 2;
            this.addPreBeatGlyph(new TabTimeSignatureGlyph(0, this.getTabY(lines, 0), this.bar.masterBar.timeSignatureNumerator, this.bar.masterBar.timeSignatureDenominator, this.bar.masterBar.timeSignatureCommon));
        };
        TabBarRenderer.prototype.createVoiceGlyphs = function (v) {
            for (var i = 0, j = v.beats.length; i < j; i++) {
                var b = v.beats[i];
                var container = new TabBeatContainerGlyph(b, this.getVoiceContainer(v));
                container.preNotes = new TabBeatPreNotesGlyph();
                container.onNotes = new TabBeatGlyph();
                this.addBeatGlyph(container);
            }
        };
        TabBarRenderer.prototype.createPostBeatGlyphs = function () {
            _super.prototype.createPostBeatGlyphs.call(this);
            if (this.bar.masterBar.isRepeatEnd) {
                this.addPostBeatGlyph(new RepeatCloseGlyph(this.x, 0));
                if (this.bar.masterBar.repeatCount > 2) {
                    this.addPostBeatGlyph(new RepeatCountGlyph(0, this.getTabY(-0.5, -3), this.bar.masterBar.repeatCount));
                }
            }
            else {
                this.addPostBeatGlyph(new BarSeperatorGlyph(0, 0));
            }
        };
        /**
         * Gets the relative y position of the given steps relative to first line.
         * @param line the amount of steps while 2 steps are one line
         * @param correction
         * @returns
         */
        TabBarRenderer.prototype.getTabY = function (line, correction) {
            if (correction === void 0) { correction = 0; }
            return this.lineOffset * line + correction * this.scale;
        };
        Object.defineProperty(TabBarRenderer.prototype, "middleYPosition", {
            get: function () {
                return this.getTabY(this.bar.staff.tuning.length - 1);
            },
            enumerable: false,
            configurable: true
        });
        TabBarRenderer.prototype.paintBackground = function (cx, cy, canvas) {
            var _this = this;
            _super.prototype.paintBackground.call(this, cx, cy, canvas);
            var res = this.resources;
            //
            // draw string lines
            //
            canvas.color = res.staffLineColor;
            var lineY = cy + this.y + this.topPadding;
            var padding = this.scale;
            // collect tab note position for spaces
            var tabNotes = [];
            for (var i = 0, j = this.bar.staff.tuning.length; i < j; i++) {
                tabNotes.push([]);
            }
            var _loop_1 = function (voice) {
                if (this_1.hasVoiceContainer(voice)) {
                    var vc_1 = this_1.getVoiceContainer(voice);
                    var _loop_2 = function (bg) {
                        var notes = bg.onNotes;
                        var noteNumbers = notes.noteNumbers;
                        if (noteNumbers) {
                            noteNumbers.notesPerString.forEach(function (noteNumber, str) {
                                if (!noteNumber.isEmpty) {
                                    tabNotes[_this.bar.staff.tuning.length - str].push(new Float32Array([
                                        vc_1.x + bg.x + notes.x + noteNumbers.x,
                                        noteNumbers.width + padding
                                    ]));
                                }
                            });
                        }
                    };
                    for (var _i = 0, _a = vc_1.beatGlyphs; _i < _a.length; _i++) {
                        var bg = _a[_i];
                        _loop_2(bg);
                    }
                }
            };
            var this_1 = this;
            for (var _i = 0, _a = this.bar.voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                _loop_1(voice);
            }
            // if we have multiple voices we need to sort by X-position, otherwise have a wild mix in the list
            // but painting relies on ascending X-position
            for (var _b = 0, tabNotes_1 = tabNotes; _b < tabNotes_1.length; _b++) {
                var line = tabNotes_1[_b];
                line.sort(function (a, b) {
                    return a[0] > b[0] ? 1 : a[0] < b[0] ? -1 : 0;
                });
            }
            var lineOffset = this.lineOffset;
            for (var i = 0, j = this.bar.staff.tuning.length; i < j; i++) {
                if (i > 0) {
                    lineY += lineOffset;
                }
                var lineX = 0;
                for (var _c = 0, _d = tabNotes[i]; _c < _d.length; _c++) {
                    var line = _d[_c];
                    canvas.fillRect(cx + this.x + lineX, lineY | 0, line[0] - lineX, this.scale * BarRendererBase.StaffLineThickness);
                    lineX = line[0] + line[1];
                }
                canvas.fillRect(cx + this.x + lineX, lineY | 0, this.width - lineX, this.scale * BarRendererBase.StaffLineThickness);
            }
            canvas.color = res.mainGlyphColor;
            this.paintSimileMark(cx, cy, canvas);
        };
        TabBarRenderer.prototype.paint = function (cx, cy, canvas) {
            _super.prototype.paint.call(this, cx, cy, canvas);
            if (this.settings.notation.rhythmMode !== exports.TabRhythmMode.Hidden) {
                this.paintBeams(cx, cy, canvas);
                this.paintTuplets(cx, cy, canvas);
            }
        };
        TabBarRenderer.prototype.paintBeams = function (cx, cy, canvas) {
            for (var i = 0, j = this.helpers.beamHelpers.length; i < j; i++) {
                var v = this.helpers.beamHelpers[i];
                for (var k = 0, l = v.length; k < l; k++) {
                    var h = v[k];
                    this.paintBeamHelper(cx + this.beatGlyphsStart, cy, canvas, h);
                }
            }
        };
        TabBarRenderer.prototype.paintTuplets = function (cx, cy, canvas) {
            for (var _i = 0, _a = this.bar.voices; _i < _a.length; _i++) {
                var voice = _a[_i];
                if (this.hasVoiceContainer(voice)) {
                    var container = this.getVoiceContainer(voice);
                    for (var _b = 0, _c = container.tupletGroups; _b < _c.length; _b++) {
                        var tupletGroup = _c[_b];
                        this.paintTupletHelper(cx + this.beatGlyphsStart, cy, canvas, tupletGroup);
                    }
                }
            }
        };
        TabBarRenderer.prototype.paintBeamHelper = function (cx, cy, canvas, h) {
            canvas.color = h.voice.index === 0 ? this.resources.mainGlyphColor : this.resources.secondaryGlyphColor;
            // check if we need to paint simple footer
            if (h.beats.length === 1 || this.settings.notation.rhythmMode === exports.TabRhythmMode.ShowWithBeams) {
                this.paintFooter(cx, cy, canvas, h);
            }
            else {
                this.paintBar(cx, cy, canvas, h);
            }
        };
        TabBarRenderer.prototype.paintBar = function (cx, cy, canvas, h) {
            for (var i = 0, j = h.beats.length; i < j; i++) {
                var beat = h.beats[i];
                if (h.hasBeatLineX(beat)) {
                    //
                    // draw line
                    //
                    var beatLineX = h.getBeatLineX(beat);
                    var y1 = cy + this.y;
                    var y2 = cy + this.y + this.height - this._tupletSize;
                    var startGlyph = this.getOnNotesGlyphForBeat(beat);
                    if (!startGlyph.noteNumbers) {
                        y1 +=
                            this.height -
                                this.settings.notation.rhythmHeight * this.settings.display.scale -
                                this._tupletSize;
                    }
                    else {
                        y1 +=
                            startGlyph.noteNumbers.getNoteY(startGlyph.noteNumbers.minStringNote, NoteYPosition.Bottom) +
                                this.lineOffset / 2;
                    }
                    if (h.direction === BeamDirection.Up) {
                        beatLineX -= startGlyph.width / 2;
                    }
                    else {
                        beatLineX += startGlyph.width / 2;
                    }
                    canvas.beginPath();
                    canvas.moveTo(cx + this.x + beatLineX, y1);
                    canvas.lineTo(cx + this.x + beatLineX, y2);
                    canvas.stroke();
                    var brokenBarOffset = 6 * this.scale;
                    var barSpacing = -6 * this.scale;
                    var barSize = 3 * this.scale;
                    var barCount = ModelUtils.getIndex(beat.duration) - 2;
                    var barStart = y2;
                    for (var barIndex = 0; barIndex < barCount; barIndex++) {
                        var barStartX = 0;
                        var barEndX = 0;
                        var barStartY = 0;
                        var barEndY = 0;
                        var barY = barStart + barIndex * barSpacing;
                        //
                        // Broken Bar to Next
                        //
                        if (h.beats.length === 1) {
                            barStartX = beatLineX;
                            barEndX = beatLineX + brokenBarOffset;
                            barStartY = barY;
                            barEndY = barY;
                            TabBarRenderer.paintSingleBar(canvas, cx + this.x + barStartX, barStartY, cx + this.x + barEndX, barEndY, barSize);
                        }
                        else if (i < h.beats.length - 1) {
                            // full bar?
                            if (BeamingHelper.isFullBarJoin(beat, h.beats[i + 1], barIndex)) {
                                barStartX = beatLineX;
                                barEndX = h.getBeatLineX(h.beats[i + 1]);
                                var endGlyph = this.getOnNotesGlyphForBeat(h.beats[i + 1]);
                                if (h.direction === BeamDirection.Up) {
                                    barEndX -= endGlyph.width / 2;
                                }
                                else {
                                    barEndX += endGlyph.width / 2;
                                }
                            }
                            else if (i === 0 || !BeamingHelper.isFullBarJoin(h.beats[i - 1], beat, barIndex)) {
                                barStartX = beatLineX;
                                barEndX = barStartX + brokenBarOffset;
                            }
                            else {
                                continue;
                            }
                            barStartY = barY;
                            barEndY = barY;
                            TabBarRenderer.paintSingleBar(canvas, cx + this.x + barStartX, barStartY, cx + this.x + barEndX, barEndY, barSize);
                        }
                        else if (i > 0 && !BeamingHelper.isFullBarJoin(beat, h.beats[i - 1], barIndex)) {
                            barStartX = beatLineX - brokenBarOffset;
                            barEndX = beatLineX;
                            barStartY = barY;
                            barEndY = barY;
                            TabBarRenderer.paintSingleBar(canvas, cx + this.x + barStartX, barStartY, cx + this.x + barEndX, barEndY, barSize);
                        }
                    }
                }
            }
        };
        TabBarRenderer.prototype.paintTupletHelper = function (cx, cy, canvas, h) {
            var res = this.resources;
            var oldAlign = canvas.textAlign;
            canvas.color = h.voice.index === 0 ? this.resources.mainGlyphColor : this.resources.secondaryGlyphColor;
            canvas.textAlign = TextAlign.Center;
            var s;
            var num = h.beats[0].tupletNumerator;
            var den = h.beats[0].tupletDenominator;
            // list as in Guitar Pro 7. for certain tuplets only the numerator is shown
            if (num === 2 && den === 3) {
                s = '2';
            }
            else if (num === 3 && den === 2) {
                s = '3';
            }
            else if (num === 4 && den === 6) {
                s = '4';
            }
            else if (num === 5 && den === 4) {
                s = '5';
            }
            else if (num === 6 && den === 4) {
                s = '6';
            }
            else if (num === 7 && den === 4) {
                s = '7';
            }
            else if (num === 9 && den === 8) {
                s = '9';
            }
            else if (num === 10 && den === 8) {
                s = '10';
            }
            else if (num === 11 && den === 8) {
                s = '11';
            }
            else if (num === 12 && den === 8) {
                s = '12';
            }
            else if (num === 13 && den === 8) {
                s = '13';
            }
            else {
                s = num + ':' + den;
            }
            // check if we need to paint simple footer
            if (h.beats.length === 1 || !h.isFull) {
                for (var i = 0, j = h.beats.length; i < j; i++) {
                    var beat = h.beats[i];
                    var beamingHelper = this.helpers.beamHelperLookup[h.voice.index].get(beat.index);
                    if (!beamingHelper) {
                        continue;
                    }
                    var tupletX = beamingHelper.getBeatLineX(beat);
                    var startGlyph = this.getOnNotesGlyphForBeat(beat);
                    if (beamingHelper.direction === BeamDirection.Up) {
                        tupletX -= startGlyph.width / 2;
                    }
                    else {
                        tupletX += startGlyph.width / 2;
                    }
                    var tupletY = cy + this.y + this.height - this._tupletSize + res.effectFont.size * 0.5;
                    canvas.font = res.effectFont;
                    canvas.fillText(s, cx + this.x + tupletX, tupletY);
                }
            }
            else {
                var firstBeat = h.beats[0];
                var lastBeat = h.beats[h.beats.length - 1];
                var firstBeamingHelper = this.helpers.beamHelperLookup[h.voice.index].get(firstBeat.index);
                var lastBeamingHelper = this.helpers.beamHelperLookup[h.voice.index].get(lastBeat.index);
                if (firstBeamingHelper && lastBeamingHelper) {
                    //
                    // Calculate the overall area of the tuplet bracket
                    var startX = firstBeamingHelper.getBeatLineX(firstBeat);
                    var endX = lastBeamingHelper.getBeatLineX(lastBeat);
                    var startGlyph = this.getOnNotesGlyphForBeat(firstBeat);
                    var endGlyph = this.getOnNotesGlyphForBeat(firstBeat);
                    if (firstBeamingHelper.direction === BeamDirection.Up) {
                        startX -= startGlyph.width / 2;
                        endX -= endGlyph.width / 2;
                    }
                    else {
                        startX += startGlyph.width / 2;
                        endX += endGlyph.width / 2;
                    }
                    //
                    // Calculate how many space the text will need
                    canvas.font = res.effectFont;
                    var sw = canvas.measureText(s);
                    var sp = 3 * this.scale;
                    //
                    // Calculate the offsets where to break the bracket
                    var middleX = (startX + endX) / 2;
                    var offset1X = middleX - sw / 2 - sp;
                    var offset2X = middleX + sw / 2 + sp;
                    //
                    // calculate the y positions for our bracket
                    var startY = cy + this.y + this.height - this._tupletSize + res.effectFont.size * 0.5;
                    var offset = -res.effectFont.size * 0.25;
                    var size = -5 * this.scale;
                    //
                    // draw the bracket
                    canvas.beginPath();
                    canvas.moveTo(cx + this.x + startX, (startY - offset) | 0);
                    canvas.lineTo(cx + this.x + startX, (startY - offset - size) | 0);
                    canvas.lineTo(cx + this.x + offset1X, (startY - offset - size) | 0);
                    canvas.stroke();
                    canvas.beginPath();
                    canvas.moveTo(cx + this.x + offset2X, (startY - offset - size) | 0);
                    canvas.lineTo(cx + this.x + endX, (startY - offset - size) | 0);
                    canvas.lineTo(cx + this.x + endX, (startY - offset) | 0);
                    canvas.stroke();
                    //
                    // Draw the string
                    canvas.fillText(s, cx + this.x + middleX, startY);
                }
            }
            canvas.textAlign = oldAlign;
        };
        TabBarRenderer.paintSingleBar = function (canvas, x1, y1, x2, y2, size) {
            canvas.beginPath();
            canvas.moveTo(x1, y1);
            canvas.lineTo(x2, y2);
            canvas.lineTo(x2, y2 - size);
            canvas.lineTo(x1, y1 - size);
            canvas.closePath();
            canvas.fill();
        };
        TabBarRenderer.prototype.paintFooter = function (cx, cy, canvas, h) {
            for (var _i = 0, _a = h.beats; _i < _a.length; _i++) {
                var beat = _a[_i];
                if (beat.graceType !== GraceType.None ||
                    beat.duration === Duration.Whole ||
                    beat.duration === Duration.DoubleWhole ||
                    beat.duration === Duration.QuadrupleWhole) {
                    return;
                }
                //
                // draw line
                //
                var beatLineX = h.getBeatLineX(beat);
                var y1 = cy + this.y;
                var y2 = cy + this.y + this.height - this._tupletSize;
                var startGlyph = this.getOnNotesGlyphForBeat(beat);
                if (!startGlyph.noteNumbers) {
                    y1 +=
                        this.height - this.settings.notation.rhythmHeight * this.settings.display.scale - this._tupletSize;
                }
                else {
                    y1 +=
                        startGlyph.noteNumbers.getNoteY(startGlyph.noteNumbers.minStringNote, NoteYPosition.Bottom);
                }
                if (h.direction === BeamDirection.Up) {
                    beatLineX -= startGlyph.width / 2;
                }
                else {
                    beatLineX += startGlyph.width / 2;
                }
                canvas.beginPath();
                canvas.moveTo(cx + this.x + beatLineX, y1);
                canvas.lineTo(cx + this.x + beatLineX, y2);
                canvas.stroke();
                //
                // Draw Flag
                //
                if (beat.duration > Duration.Quarter) {
                    var glyph = new FlagGlyph(0, 0, beat.duration, BeamDirection.Down, false);
                    glyph.renderer = this;
                    glyph.doLayout();
                    glyph.paint(cx + this.x + beatLineX, y2, canvas);
                }
            }
        };
        TabBarRenderer.StaffId = 'tab';
        TabBarRenderer.LineSpacing = 10;
        return TabBarRenderer;
    }(BarRendererBase));

    var __extends$2d = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This Factory produces TabBarRenderer instances
     */
    var TabBarRendererFactory = /** @class */ (function (_super) {
        __extends$2d(TabBarRendererFactory, _super);
        function TabBarRendererFactory(showTimeSignature, showRests, showTiedNotes) {
            var _this = _super.call(this) || this;
            _this._showTimeSignature = showTimeSignature;
            _this._showRests = showRests;
            _this._showTiedNotes = showTiedNotes;
            _this.hideOnPercussionTrack = true;
            return _this;
        }
        Object.defineProperty(TabBarRendererFactory.prototype, "staffId", {
            get: function () {
                return TabBarRenderer.StaffId;
            },
            enumerable: false,
            configurable: true
        });
        TabBarRendererFactory.prototype.canCreate = function (track, staff) {
            return staff.tuning.length > 0 && _super.prototype.canCreate.call(this, track, staff);
        };
        TabBarRendererFactory.prototype.create = function (renderer, bar) {
            var tabBarRenderer = new TabBarRenderer(renderer, bar);
            tabBarRenderer.showRests = this._showRests;
            tabBarRenderer.showTimeSignature = this._showTimeSignature;
            tabBarRenderer.showTiedNotes = this._showTiedNotes;
            return tabBarRenderer;
        };
        return TabBarRendererFactory;
    }(BarRendererFactory));

    var __extends$2e = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LeftHandTapGlyph = /** @class */ (function (_super) {
        __extends$2e(LeftHandTapGlyph, _super);
        function LeftHandTapGlyph() {
            return _super.call(this, 0, 0) || this;
        }
        LeftHandTapGlyph.prototype.doLayout = function () {
            _super.prototype.doLayout.call(this);
            var font = this.renderer.resources.effectFont;
            this.height = font.size + LeftHandTapGlyph.Padding * this.scale;
        };
        LeftHandTapGlyph.prototype.paint = function (cx, cy, canvas) {
            var res = this.renderer.resources;
            canvas.font = res.effectFont;
            var old = canvas.textAlign;
            canvas.textAlign = TextAlign.Center;
            canvas.fillText('T', cx + this.x, cy + this.y + canvas.font.size / 2);
            canvas.textAlign = old;
            canvas.strokeCircle(cx + this.x, cy + this.y + canvas.font.size / 2 + (LeftHandTapGlyph.Padding - 1) * this.scale, canvas.font.size / 1.6);
        };
        LeftHandTapGlyph.Padding = 4;
        return LeftHandTapGlyph;
    }(EffectGlyph));

    var __extends$2f = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var LeftHandTapEffectInfo = /** @class */ (function (_super) {
        __extends$2f(LeftHandTapEffectInfo, _super);
        function LeftHandTapEffectInfo() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(LeftHandTapEffectInfo.prototype, "notationElement", {
            get: function () {
                return NotationElement.EffectTap;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LeftHandTapEffectInfo.prototype, "sizingMode", {
            get: function () {
                return EffectBarGlyphSizing.SingleOnBeat;
            },
            enumerable: false,
            configurable: true
        });
        LeftHandTapEffectInfo.prototype.shouldCreateGlyphForNote = function (note) {
            return note.isLeftHandTapped;
        };
        LeftHandTapEffectInfo.prototype.createNewGlyph = function (renderer, beat) {
            return new LeftHandTapGlyph();
        };
        return LeftHandTapEffectInfo;
    }(NoteEffectInfoBase));

    var __extends$2g = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var DrawObject = /** @class */ (function () {
        function DrawObject() {
            this.noteRange = 1;
            this.x = 0;
            this.y = 0;
        }
        return DrawObject;
    }());
    var FrameType;
    (function (FrameType) {
        FrameType[FrameType["None"] = 0] = "None";
        FrameType[FrameType["Rectangle"] = 1] = "Rectangle";
        FrameType[FrameType["Ellipse"] = 2] = "Ellipse";
        FrameType[FrameType["Circle"] = 3] = "Circle";
    })(FrameType || (FrameType = {}));
    var TextDrawObject = /** @class */ (function (_super) {
        __extends$2g(TextDrawObject, _super);
        function TextDrawObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.align = TextAlign.Left;
            _this.frame = FrameType.None;
            _this.text = '';
            _this.fontFace = '';
            _this.weight = 0;
            _this.height = 0;
            return _this;
        }
        return TextDrawObject;
    }(DrawObject));
    var GuitarDrawObject = /** @class */ (function (_super) {
        __extends$2g(GuitarDrawObject, _super);
        function GuitarDrawObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.chord = new Chord();
            return _this;
        }
        return GuitarDrawObject;
    }(DrawObject));
    var SlurDrawObject = /** @class */ (function (_super) {
        __extends$2g(SlurDrawObject, _super);
        function SlurDrawObject() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SlurDrawObject;
    }(DrawObject));
    var WavyLineDrawObject = /** @class */ (function (_super) {
        __extends$2g(WavyLineDrawObject, _super);
        function WavyLineDrawObject() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return WavyLineDrawObject;
    }(DrawObject));
    var TupletBracketDrawObject = /** @class */ (function (_super) {
        __extends$2g(TupletBracketDrawObject, _super);
        function TupletBracketDrawObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.number = 0;
            return _this;
        }
        return TupletBracketDrawObject;
    }(DrawObject));
    var WedgeDrawObject = /** @class */ (function (_super) {
        __extends$2g(WedgeDrawObject, _super);
        function WedgeDrawObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.decrescendo = false;
            return _this;
        }
        return WedgeDrawObject;
    }(DrawObject));
    var VoltaDrawObject = /** @class */ (function (_super) {
        __extends$2g(VoltaDrawObject, _super);
        function VoltaDrawObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allNumbers = false;
            _this.firstNumber = 0;
            _this.lastNumber = 0;
            return _this;
        }
        return VoltaDrawObject;
    }(DrawObject));
    var OctaveClefDrawObject = /** @class */ (function (_super) {
        __extends$2g(OctaveClefDrawObject, _super);
        function OctaveClefDrawObject() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.octave = 1;
            return _this;
        }
        return OctaveClefDrawObject;
    }(DrawObject));
    var TrillDrawObject = /** @class */ (function (_super) {
        __extends$2g(TrillDrawObject, _super);
        function TrillDrawObject() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return TrillDrawObject;
    }(DrawObject));
    var StaffLayout = /** @class */ (function () {
        function StaffLayout() {
            this.defaultClef = Clef.G2;
            this.description = '';
            this.percussion = false;
            this.instrument = 0;
            this.volume = 0;
            this.transpose = 0;
            this.index = 0;
        }
        return StaffLayout;
    }());
    var Bracket = /** @class */ (function () {
        function Bracket() {
            this.from = 0;
            this.to = 0;
            this.curly = false;
        }
        return Bracket;
    }());
    var CapellaVoiceState = /** @class */ (function () {
        function CapellaVoiceState() {
            this.currentBarIndex = -1;
            this.currentBarComplete = true;
            this.currentBarDuration = 0;
            this.currentPosition = 0;
            this.voiceStemDir = null;
            this.repeatCount = 0;
            this.repeatEnd = null;
        }
        return CapellaVoiceState;
    }());
    var CapellaParser = /** @class */ (function () {
        function CapellaParser() {
            this._trackChannel = 0;
            this._beamingMode = BeatBeamingMode.Auto;
            this._isFirstSystem = true;
            this._staffLookup = new Map();
            this._brackets = [];
            this._staffLayoutLookup = new Map();
            this._staffLayouts = [];
            this._timeSignature = new MasterBar();
            this._voiceStates = new Map();
        }
        CapellaParser.prototype.parseXml = function (xml, settings) {
            this._galleryObjects = new Map();
            this._tieStarts = [];
            this._tieStartIds = new Map();
            this._voiceCounts = new Map();
            this._slurs = new Map();
            this._crescendo = new Map();
            this._isFirstSystem = true;
            var dom;
            try {
                dom = new XmlDocument(xml);
            }
            catch (e) {
                throw new UnsupportedFormatError('Could not parse XML', e);
            }
            this.parseDom(dom);
            this.consolidate();
            this.score.finish(settings);
        };
        CapellaParser.prototype.consolidate = function () {
            // voice counts and contents might be inconsistent
            // we need to ensure we have an equal amount of voices across all bars
            // and voices must contain an empty beat at minimum
            var tempo = this.score.tempo;
            for (var _i = 0, _a = this.score.tracks; _i < _a.length; _i++) {
                var track = _a[_i];
                var trackVoiceCount = this._voiceCounts.get(track.index);
                for (var _b = 0, _c = track.staves; _b < _c.length; _b++) {
                    var staff = _c[_b];
                    while (staff.bars.length < this.score.masterBars.length) {
                        this.addNewBar(staff);
                    }
                    for (var _d = 0, _e = staff.bars; _d < _e.length; _d++) {
                        var bar = _e[_d];
                        while (bar.voices.length < trackVoiceCount) {
                            bar.addVoice(new Voice());
                        }
                        for (var _f = 0, _g = bar.voices; _f < _g.length; _f++) {
                            var voice = _g[_f];
                            if (voice.beats.length === 0) {
                                var emptyBeat = new Beat();
                                emptyBeat.isEmpty = true;
                                voice.addBeat(emptyBeat);
                            }
                        }
                        var mb = bar.masterBar;
                        if (mb.tempoAutomation) {
                            if (mb.tempoAutomation.value !== tempo) {
                                tempo = mb.tempoAutomation.value;
                            }
                            else {
                                mb.tempoAutomation = null;
                            }
                        }
                    }
                }
            }
            CapellaParser.applyEffectRange(this._slurs, function (_, beat) {
                beat.isLegatoOrigin = true;
            });
            CapellaParser.applyEffectRange(this._crescendo, function (cre, beat) {
                beat.crescendo = cre.decrescendo ? CrescendoType.Decrescendo : CrescendoType.Crescendo;
            });
        };
        CapellaParser.applyEffectRange = function (effects, applyEffect) {
            effects.forEach(function (effect, startBeat) {
                var noteRange = effect.noteRange;
                var endBeat = startBeat;
                for (var i = 0; i < noteRange; i++) {
                    applyEffect(effect, endBeat);
                    // advance to next
                    if (endBeat.index + 1 < endBeat.voice.beats.length) {
                        endBeat = endBeat.voice.beats[endBeat.index + 1];
                    }
                    else if (endBeat.voice.bar.index + 1 < endBeat.voice.bar.staff.bars.length) {
                        var nextBar = endBeat.voice.bar.staff.bars[endBeat.voice.bar.index + 1];
                        endBeat = nextBar.voices[endBeat.voice.index].beats[0];
                    }
                    else {
                        break;
                    }
                }
            });
        };
        CapellaParser.prototype.parseDom = function (dom) {
            var root = dom.documentElement;
            if (!root) {
                return;
            }
            if (root.localName === 'score') {
                this.score = new Score();
                this.score.tempo = 120;
                // parse all children
                for (var _i = 0, _a = root.childNodes; _i < _a.length; _i++) {
                    var n = _a[_i];
                    if (n.nodeType === XmlNodeType.Element) {
                        switch (n.localName) {
                            case 'info':
                                this.parseInfo(n);
                                break;
                            case 'layout':
                                this.parseLayout(n);
                                break;
                            case 'gallery':
                                this.parseGallery(n);
                                break;
                            case 'pageObjects':
                                this.parsePageObjects(n);
                                break;
                            // barCount ignored
                            case 'systems':
                                this.parseSystems(n);
                                break;
                        }
                    }
                }
            }
            else {
                throw new UnsupportedFormatError('Root node of XML was not GPIF');
            }
        };
        CapellaParser.prototype.parseLayout = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'staves':
                            this.parseLayoutStaves(c);
                            break;
                        case 'brackets':
                            this.parseBrackets(c);
                            break;
                    }
                }
            }
            // after the layout is parsed we can build up the
            // track > staff structure for later use
            // curly brackets define which staves go together into a track
            var curlyBrackets = this._brackets.filter(function (b) { return b.curly; });
            curlyBrackets.sort(function (a, b) { return a.from - b.from; });
            var currentBracketIndex = 0;
            var currentTrack = null;
            for (var i = 0; i < this._staffLayouts.length; i++) {
                var staffLayout = this._staffLayouts[i];
                // advance to next bracket according to the staff index
                while (currentBracketIndex < curlyBrackets.length && i > curlyBrackets[currentBracketIndex].to) {
                    currentBracketIndex++;
                }
                if (currentTrack &&
                    currentBracketIndex < curlyBrackets.length &&
                    i > curlyBrackets[currentBracketIndex].from &&
                    i <= curlyBrackets[currentBracketIndex].to) {
                    // if we still fit into the current bracket, we just add another staff to the
                    // track
                    currentTrack.ensureStaveCount(currentTrack.staves.length + 1);
                }
                else {
                    currentTrack = new Track();
                    currentTrack.ensureStaveCount(1);
                    currentTrack.name = staffLayout.description;
                    currentTrack.playbackInfo.volume = Math.floor((staffLayout.volume / 128) * 16);
                    currentTrack.playbackInfo.program = staffLayout.instrument;
                    if (staffLayout.percussion) {
                        currentTrack.playbackInfo.primaryChannel = 9;
                        currentTrack.playbackInfo.secondaryChannel = 9;
                    }
                    else {
                        currentTrack.playbackInfo.primaryChannel = this._trackChannel++;
                        currentTrack.playbackInfo.secondaryChannel = this._trackChannel++;
                    }
                    this.score.addTrack(currentTrack);
                }
                var staff = currentTrack.staves[currentTrack.staves.length - 1];
                staff.isPercussion = staffLayout.percussion;
                staff.transpositionPitch = staffLayout.transpose;
                staff.displayTranspositionPitch = 0;
                staff.showTablature = false; // capella does not have tabs
                this._staffLookup.set(staffLayout.index, staff);
            }
        };
        CapellaParser.prototype.parseBrackets = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'bracket':
                            this.parseBracket(c);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseBracket = function (element) {
            var bracket = new Bracket();
            bracket.from = parseInt(element.getAttribute('from'));
            bracket.to = parseInt(element.getAttribute('to'));
            if (element.attributes.has('curly')) {
                bracket.curly = element.attributes.get('curly') === 'true';
            }
            this._brackets.push(bracket);
        };
        CapellaParser.prototype.parseLayoutStaves = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'staffLayout':
                            this.parseStaffLayout(c);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseStaffLayout = function (element) {
            var layout = new StaffLayout();
            layout.description = element.getAttribute('description');
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'notation':
                            if (c.attributes.has('defaultClef')) {
                                layout.defaultClef = this.parseClef(c.attributes.get('defaultClef'));
                            }
                            break;
                        case 'sound':
                            if (c.attributes.has('percussion')) {
                                layout.percussion = c.attributes.get('percussion') === 'true';
                            }
                            if (c.attributes.has('instr')) {
                                layout.instrument = parseInt(c.attributes.get('instr'));
                            }
                            if (c.attributes.has('volume')) {
                                layout.volume = parseInt(c.attributes.get('volume'));
                            }
                            if (c.attributes.has('transpose')) {
                                layout.transpose = parseInt(c.attributes.get('transpose'));
                            }
                            break;
                    }
                }
            }
            this._staffLayoutLookup.set(layout.description, layout);
            layout.index = this._staffLayouts.length;
            this._staffLayouts.push(layout);
        };
        CapellaParser.prototype.parseClef = function (v) {
            switch (v) {
                case 'treble':
                    return Clef.G2;
                case 'bass':
                    return Clef.F4;
                case 'alto':
                    return Clef.C4;
                case 'tenor':
                    return Clef.C4;
            }
            return Clef.G2;
        };
        CapellaParser.prototype.parseClefOttava = function (v) {
            if (v.endsWith('-')) {
                return Ottavia._8vb;
            }
            else if (v.endsWith('+')) {
                return Ottavia._8va;
            }
            return Ottavia.Regular;
        };
        CapellaParser.prototype.parseSystems = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'system':
                            this.parseSystem(c);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseSystem = function (element) {
            if (element.attributes.has('tempo')) {
                if (this.score.masterBars.length === 0) {
                    this.score.tempo = parseInt(element.attributes.get('tempo'));
                }
            }
            if (element.getAttribute('beamGrouping') === '0') {
                this._beamingMode = BeatBeamingMode.ForceSplitToNext;
            }
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'staves':
                            this.parseStaves(element, c);
                            break;
                    }
                }
            }
            this._isFirstSystem = false;
        };
        CapellaParser.prototype.parseStaves = function (systemElement, element) {
            var firstBarIndex = this.score.masterBars.length;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'staff':
                            this.parseStaff(systemElement, firstBarIndex, c);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseStaff = function (systemElement, firstBarIndex, element) {
            var staffId = element.getAttribute('layout');
            this._currentStaffLayout = this._staffLayoutLookup.get(staffId);
            this._timeSignature.timeSignatureNumerator = 4;
            this._timeSignature.timeSignatureDenominator = 4;
            this._timeSignature.timeSignatureCommon = false;
            this.parseTime(element.getAttribute('defaultTime'));
            var staff = this._staffLookup.get(this._currentStaffLayout.index);
            // there might be systems where this staff is not contained
            // so we create bars until the current staff to ensure the right
            // alignment
            while (staff.bars.length < firstBarIndex) {
                this.addNewBar(staff);
            }
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'voices':
                            this.parseVoices(staffId, staff, systemElement, firstBarIndex, c);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseTime = function (value) {
            switch (value) {
                case 'allaBreve':
                case 'C':
                    this._timeSignature.timeSignatureNumerator = 2;
                    this._timeSignature.timeSignatureDenominator = 2;
                    this._timeSignature.timeSignatureCommon = true;
                    break;
                case 'longAllaBreve':
                    this._timeSignature.timeSignatureNumerator = 4;
                    this._timeSignature.timeSignatureDenominator = 4;
                    this._timeSignature.timeSignatureCommon = true;
                    break;
                default:
                    if (value.indexOf('/') > 0) {
                        var parts = value.split('/');
                        this._timeSignature.timeSignatureNumerator = parseInt(parts[0]);
                        this._timeSignature.timeSignatureDenominator = parseInt(parts[1]);
                        this._timeSignature.timeSignatureCommon = false;
                    }
                    break;
            }
        };
        CapellaParser.prototype.parseVoices = function (staffId, staff, systemElement, firstBarIndex, element) {
            var voiceIndex = 0;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'voice':
                            this.parseVoice(staffId, staff, systemElement, voiceIndex, firstBarIndex, c);
                            voiceIndex++;
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.getOrCreateBar = function (staff, barIndex) {
            if (barIndex < staff.bars.length) {
                return staff.bars[barIndex];
            }
            return this.addNewBar(staff);
        };
        CapellaParser.prototype.addNewBar = function (staff) {
            // voice tags always start a new bar
            var currentBar = new Bar();
            if (staff.bars.length > 0) {
                currentBar.clef = staff.bars[staff.bars.length - 1].clef;
                currentBar.clefOttava = staff.bars[staff.bars.length - 1].clefOttava;
            }
            else {
                currentBar.clef = this._currentStaffLayout.defaultClef;
            }
            staff.addBar(currentBar);
            // create masterbar if needed
            if (staff.bars.length > this.score.masterBars.length) {
                var master = new MasterBar();
                this.score.addMasterBar(master);
                if (master.index > 0) {
                    master.keySignature = master.previousMasterBar.keySignature;
                    master.keySignatureType = master.previousMasterBar.keySignatureType;
                    master.tripletFeel = master.previousMasterBar.tripletFeel;
                }
                master.timeSignatureDenominator = this._timeSignature.timeSignatureDenominator;
                master.timeSignatureNumerator = this._timeSignature.timeSignatureNumerator;
                master.timeSignatureCommon = this._timeSignature.timeSignatureCommon;
            }
            return currentBar;
        };
        CapellaParser.prototype.newBar = function (staff, voiceIndex) {
            this._currentVoiceState.currentBarIndex++;
            this._currentBar = this.getOrCreateBar(staff, this._currentVoiceState.currentBarIndex);
            this._currentVoiceState.currentBarDuration = this._currentBar.masterBar.calculateDuration(false);
            this._currentVoiceState.currentBarComplete = false;
            this._currentVoiceState.currentPosition = 0;
            this.ensureVoice(staff, voiceIndex);
        };
        CapellaParser.prototype.parseVoice = function (staffId, staff, systemElement, voiceIndex, firstBarIndex, element) {
            var voiceStateKey = staffId + '_' + voiceIndex;
            if (this._currentVoiceState && !this._currentVoiceState.currentBarComplete) {
                this._currentBar.masterBar.isAnacrusis = true;
            }
            if (!this._voiceStates.has(voiceStateKey)) {
                this._currentVoiceState = new CapellaVoiceState();
                this._currentVoiceState.currentBarIndex = firstBarIndex - 1;
                this._voiceStates.set(voiceStateKey, this._currentVoiceState);
                this.newBar(staff, voiceIndex);
            }
            else {
                this._currentVoiceState = this._voiceStates.get(voiceStateKey);
                this._currentBar = this.getOrCreateBar(staff, this._currentVoiceState.currentBarIndex);
                this.ensureVoice(staff, voiceIndex);
            }
            // voice tags always start a new bar
            if (element.attributes.has('stemDir')) {
                switch (element.attributes.get('stemDir')) {
                    case 'up':
                        this._currentVoiceState.voiceStemDir = BeamDirection.Up;
                        break;
                    case 'down':
                        this._currentVoiceState.voiceStemDir = BeamDirection.Down;
                        break;
                    default:
                        this._currentVoiceState.voiceStemDir = null;
                        break;
                }
            }
            else {
                this._currentVoiceState.voiceStemDir = null;
            }
            var noteObjects = element.findChildElement('noteObjects');
            if (systemElement.attributes.has('tempo')) {
                this._currentBar.masterBar.tempoAutomation = new Automation();
                this._currentBar.masterBar.tempoAutomation.isLinear = true;
                this._currentBar.masterBar.tempoAutomation.type = AutomationType.Tempo;
                this._currentBar.masterBar.tempoAutomation.value = parseInt(systemElement.attributes.get('tempo'));
            }
            if (noteObjects) {
                for (var _i = 0, _a = noteObjects.childNodes; _i < _a.length; _i++) {
                    var c = _a[_i];
                    if (c.nodeType === XmlNodeType.Element) {
                        if (this._currentVoiceState.currentBarComplete && c.localName !== 'barline') {
                            this.newBar(staff, voiceIndex);
                        }
                        switch (c.localName) {
                            case 'clefSign':
                                this._currentBar.clef = this.parseClef(c.getAttribute('clef'));
                                this._currentBar.clefOttava = this.parseClefOttava(c.getAttribute('clef'));
                                break;
                            case 'keySign':
                                this._currentBar.masterBar.keySignature = parseInt(c.getAttribute('fifths'));
                                break;
                            case 'timeSign':
                                this.parseTime(c.getAttribute('time'));
                                this._currentBar.masterBar.timeSignatureDenominator = this._timeSignature.timeSignatureDenominator;
                                this._currentBar.masterBar.timeSignatureNumerator = this._timeSignature.timeSignatureNumerator;
                                this._currentBar.masterBar.timeSignatureCommon = this._timeSignature.timeSignatureCommon;
                                // NOTE: capella resets the current bar position to 0 whenever a timeSign is placed
                                this._currentVoiceState.currentPosition = 0;
                                this._currentVoiceState.currentBarDuration = this._currentBar.masterBar.calculateDuration(false);
                                break;
                            case 'barline':
                                switch (c.getAttribute('type')) {
                                    case 'double':
                                        this._currentBar.masterBar.isDoubleBar = true;
                                        if (!this._currentVoiceState.currentBarComplete) {
                                            this._currentBar.masterBar.isAnacrusis = true;
                                        }
                                        this._currentVoiceState.currentBarComplete = true;
                                        break;
                                    case 'end':
                                        if (!this._currentVoiceState.currentBarComplete) {
                                            this._currentBar.masterBar.isAnacrusis = true;
                                        }
                                        break;
                                    case 'repEnd':
                                        this._currentVoiceState.repeatEnd = this._currentBar.masterBar;
                                        if (this._currentBar.masterBar.repeatCount < this._currentVoiceState.repeatCount) {
                                            this._currentBar.masterBar.repeatCount = this._currentVoiceState.repeatCount;
                                        }
                                        this.parseBarDrawObject(c);
                                        if (!this._currentVoiceState.currentBarComplete) {
                                            this._currentBar.masterBar.isAnacrusis = true;
                                        }
                                        this._currentVoiceState.currentBarComplete = true;
                                        break;
                                    case 'repBegin':
                                        this.newBar(staff, voiceIndex); // repeat-start requires instant new bar
                                        this._currentBar.masterBar.isRepeatStart = true;
                                        this._currentVoiceState.repeatEnd = null;
                                        this._currentVoiceState.repeatCount = 0;
                                        break;
                                    case 'repEndBegin':
                                        this._currentVoiceState.repeatEnd = this._currentBar.masterBar;
                                        if (this._currentBar.masterBar.repeatCount < this._currentVoiceState.repeatCount) {
                                            this._currentBar.masterBar.repeatCount = this._currentVoiceState.repeatCount;
                                        }
                                        this.parseBarDrawObject(c);
                                        this.newBar(staff, voiceIndex); // end-begin requires instant new bar
                                        this._currentBar.masterBar.isRepeatStart = true;
                                        break;
                                    case 'dashed':
                                        if (!this._currentVoiceState.currentBarComplete) {
                                            this._currentBar.masterBar.isAnacrusis = true;
                                        }
                                        this._currentVoiceState.currentBarComplete = true;
                                        break;
                                    case 'single':
                                    default:
                                        if (!this._currentVoiceState.currentBarComplete) {
                                            this._currentBar.masterBar.isAnacrusis = true;
                                        }
                                        this._currentVoiceState.currentBarComplete = true;
                                        break;
                                }
                                break;
                            case 'chord':
                                var chordBeat = new Beat();
                                this.initFromPreviousBeat(chordBeat, this._currentVoice);
                                chordBeat.beamingMode = this._beamingMode;
                                if (this._currentVoiceState.voiceStemDir) {
                                    chordBeat.preferredBeamDirection = this._currentVoiceState.voiceStemDir;
                                }
                                this.parseDuration(this._currentBar, chordBeat, c.findChildElement('duration'));
                                chordBeat.updateDurations();
                                this._currentVoiceState.currentPosition += chordBeat.playbackDuration;
                                this._currentVoice.addBeat(chordBeat);
                                this.parseChord(chordBeat, c);
                                if (this._currentVoiceState.currentPosition >= this._currentVoiceState.currentBarDuration) {
                                    this._currentVoiceState.currentBarComplete = true;
                                }
                                break;
                            case 'rest':
                                var restBeats = this.parseRestDurations(this._currentBar, c.findChildElement('duration'));
                                for (var _b = 0, restBeats_1 = restBeats; _b < restBeats_1.length; _b++) {
                                    var restBeat = restBeats_1[_b];
                                    this.initFromPreviousBeat(restBeat, this._currentVoice);
                                    restBeat.updateDurations();
                                    this._currentVoiceState.currentPosition += restBeat.playbackDuration;
                                    this._currentVoice.addBeat(restBeat);
                                    if (this._currentVoiceState.currentPosition >=
                                        this._currentVoiceState.currentBarDuration) {
                                        this._currentVoiceState.currentBarComplete = true;
                                    }
                                }
                                break;
                        }
                    }
                }
            }
        };
        CapellaParser.prototype.initFromPreviousBeat = function (chordBeat, currentVoice) {
            var previousBeat = this.getLastBeat(currentVoice);
            if (previousBeat) {
                chordBeat.dynamics = previousBeat.dynamics;
            }
        };
        CapellaParser.prototype.getLastBeat = function (voice) {
            if (voice.beats.length > 0) {
                return voice.beats[voice.beats.length - 1];
            }
            else if (voice.bar.index > 0) {
                var previousBar = voice.bar.staff.bars[voice.bar.index - 1];
                if (voice.index < previousBar.voices.length) {
                    var previousVoice = previousBar.voices[voice.index];
                    return this.getLastBeat(previousVoice);
                }
            }
            return null;
        };
        CapellaParser.prototype.ensureVoice = function (staff, voiceIndex) {
            while (this._currentBar.voices.length < voiceIndex + 1) {
                this._currentBar.addVoice(new Voice());
            }
            if (!this._voiceCounts.has(staff.track.index) ||
                this._voiceCounts.get(staff.track.index) < this._currentBar.voices.length) {
                this._voiceCounts.set(staff.track.index, this._currentBar.voices.length);
            }
            this._currentVoice = this._currentBar.voices[voiceIndex];
        };
        CapellaParser.prototype.parseChord = function (beat, element) {
            var articulation = new Note();
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'stem':
                            switch (c.getAttribute('dir')) {
                                case 'up':
                                    beat.preferredBeamDirection = BeamDirection.Up;
                                    break;
                                case 'down':
                                    beat.preferredBeamDirection = BeamDirection.Down;
                                    break;
                            }
                            break;
                        case 'articulation':
                            switch (c.getAttribute('type')) {
                                case 'staccato':
                                    articulation.isStaccato = true;
                                    break;
                                case 'normalAccent':
                                    articulation.accentuated = AccentuationType.Normal;
                                    break;
                                case 'strongAccent':
                                    articulation.accentuated = AccentuationType.Heavy;
                                    break;
                            }
                            break;
                        case 'lyric':
                            this.parseLyric(beat, c);
                            break;
                        case 'drawObjects':
                            this.parseBeatDrawObject(beat, c);
                            break;
                        case 'heads':
                            this.parseHeads(beat, articulation, c);
                            break;
                        case 'beam':
                            switch (c.getAttribute('group')) {
                                case 'force':
                                    beat.beamingMode = BeatBeamingMode.ForceMergeWithNext;
                                    break;
                                case 'divide':
                                    beat.beamingMode = BeatBeamingMode.ForceSplitToNext;
                                    break;
                            }
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseHeads = function (beat, articulation, element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'head':
                            this.parseHead(beat, articulation, c);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseHead = function (beat, articulation, element) {
            var note = new Note();
            var pitch = ModelUtils.parseTuning(element.getAttribute('pitch'));
            note.octave = pitch.octave - 1;
            note.tone = pitch.noteValue;
            note.isStaccato = articulation.isStaccato;
            note.accentuated = articulation.accentuated;
            beat.addNote(note);
            // TODO: based on the shape attribute apply effects or
            // right percussion value
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'alter':
                            if (c.attributes.has('step')) {
                                note.tone += parseInt(c.attributes.get('step'));
                            }
                            break;
                        case 'tie':
                            if (c.attributes.has('begin')) {
                                if (!this._tieStartIds.has(note.id)) {
                                    this._tieStartIds.set(note.id, true);
                                    this._tieStarts.push(note);
                                }
                            }
                            else if (c.attributes.has('end') && this._tieStarts.length > 0 && !note.isTieDestination) {
                                note.isTieDestination = true;
                                note.tieOrigin = this._tieStarts[0];
                                this._tieStarts.splice(0, 1);
                                this._tieStartIds.delete(note.id);
                            }
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseBeatDrawObject = function (beat, element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'drawObj':
                            var obj = this.parseDrawObj(c);
                            if (obj) {
                                if (obj instanceof TextDrawObject) {
                                    if (obj.fontFace.startsWith('capella')) {
                                        if (obj.text === 'u') {
                                            beat.fermata = new Fermata();
                                            beat.fermata.type = FermataType.Medium;
                                        }
                                        else if (obj.text === 'f') {
                                            beat.dynamics = DynamicValue.F;
                                        }
                                        else if (obj.text === 'j') {
                                            beat.dynamics = DynamicValue.MF;
                                        }
                                    }
                                    else if (this._isFirstSystem &&
                                        this.score.title === '' &&
                                        obj.align === TextAlign.Center &&
                                        obj.height > 16 &&
                                        obj.weight > 400) {
                                        // bold large centered text is very likely the title
                                        this.score.title = obj.text;
                                    }
                                    else if (this._isFirstSystem &&
                                        this.score.artist === '' &&
                                        obj.align === TextAlign.Center &&
                                        obj.y < 0) {
                                        this.score.artist = obj.text;
                                    }
                                    else if (this._isFirstSystem &&
                                        this.score.music === '' &&
                                        obj.align === TextAlign.Right &&
                                        obj.y < 0) {
                                        this.score.music = obj.text;
                                    }
                                    else if (!obj.text.startsWith('by capella')) {
                                        beat.text = obj.text;
                                    }
                                }
                                else if (obj instanceof GuitarDrawObject) ;
                                else if (obj instanceof WavyLineDrawObject) {
                                    beat.vibrato = VibratoType.Slight;
                                }
                                else if (obj instanceof WedgeDrawObject) {
                                    beat.crescendo = obj.decrescendo ? CrescendoType.Decrescendo : CrescendoType.Crescendo;
                                    obj.noteRange++;
                                    this._crescendo.set(beat, obj);
                                }
                                else if (obj instanceof SlurDrawObject) {
                                    // NOTE: casting needed for C#
                                    var slur = obj;
                                    this._slurs.set(beat, slur);
                                }
                                else if (obj instanceof VoltaDrawObject) {
                                    this.applyVolta(obj);
                                }
                            }
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseBarDrawObject = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'drawObj':
                            var obj = this.parseDrawObj(c);
                            if (obj) {
                                if (obj instanceof VoltaDrawObject) {
                                    this.applyVolta(obj);
                                }
                            }
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.applyVolta = function (obj) {
            if (obj.lastNumber > 0) {
                this._currentVoiceState.repeatCount = obj.lastNumber;
                if (this._currentVoiceState.repeatEnd &&
                    this._currentVoiceState.repeatEnd.repeatCount < this._currentVoiceState.repeatCount) {
                    this._currentVoiceState.repeatEnd.repeatCount = this._currentVoiceState.repeatCount;
                }
            }
            else if (obj.firstNumber > 0) {
                this._currentVoiceState.repeatCount = obj.firstNumber;
                if (this._currentVoiceState.repeatEnd &&
                    this._currentVoiceState.repeatEnd.repeatCount < this._currentVoiceState.repeatCount) {
                    this._currentVoiceState.repeatEnd.repeatCount = this._currentVoiceState.repeatCount;
                }
            }
            if (obj.lastNumber > 0 && obj.firstNumber > 0) {
                var alternateEndings = 0;
                for (var i = obj.firstNumber; i <= obj.lastNumber; i++) {
                    alternateEndings |= 0x01 << (i - 1);
                }
                this._currentBar.masterBar.alternateEndings = alternateEndings;
            }
            else if (obj.lastNumber > 0) {
                this._currentBar.masterBar.alternateEndings = 0x01 << (obj.lastNumber - 1);
            }
            else if (obj.firstNumber > 0) {
                this._currentBar.masterBar.alternateEndings = 0x01 << (obj.firstNumber - 1);
            }
        };
        CapellaParser.prototype.parseLyric = function (beat, element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'verse':
                            if (!beat.lyrics) {
                                beat.lyrics = [];
                            }
                            var text = c.innerText;
                            if (c.getAttribute('hyphen') === 'true') {
                                text += '-';
                            }
                            beat.lyrics.push(text);
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseRestDurations = function (bar, element) {
            var durationBase = element.getAttribute('base');
            if (durationBase.indexOf('/') !== -1) {
                var restBeat = new Beat();
                restBeat.beamingMode = this._beamingMode;
                this.parseDuration(bar, restBeat, element);
                return [restBeat];
            }
            // for
            var fullBars = parseInt(durationBase);
            if (fullBars === 1) {
                var restBeats = [];
                var remainingTicks = bar.masterBar.calculateDuration(false) * fullBars;
                var currentRestDuration = Duration.Whole;
                var currentRestDurationTicks = MidiUtils.toTicks(currentRestDuration);
                while (remainingTicks > 0) {
                    // reduce to the duration that fits into the remaining time
                    while (currentRestDurationTicks > remainingTicks &&
                        currentRestDuration < Duration.TwoHundredFiftySixth) {
                        currentRestDuration = (currentRestDuration * 2);
                        currentRestDurationTicks = MidiUtils.toTicks(currentRestDuration);
                    }
                    // no duration will fit anymore
                    if (currentRestDurationTicks > remainingTicks) {
                        break;
                    }
                    var restBeat = new Beat();
                    restBeat.beamingMode = this._beamingMode;
                    restBeat.duration = currentRestDuration;
                    restBeats.push(restBeat);
                    remainingTicks -= currentRestDurationTicks;
                }
                return restBeats;
            }
            else {
                // TODO: multibar rests
                Logger.warning('Importer', "Multi-Bar rests are not supported");
                return [];
            }
        };
        CapellaParser.prototype.parseDurationValue = function (s) {
            switch (s) {
                case '2/1':
                    return Duration.DoubleWhole;
                case '1/1':
                    return Duration.Whole;
                case '1/2':
                    return Duration.Half;
                case '1/4':
                    return Duration.Quarter;
                case '1/8':
                    return Duration.Eighth;
                case '1/16':
                    return Duration.Sixteenth;
                case '1/32':
                    return Duration.ThirtySecond;
                case '1/64':
                    return Duration.SixtyFourth;
                case '1/128':
                    return Duration.OneHundredTwentyEighth;
                default:
                    Logger.warning('Importer', 'Unsupported duration');
                    return Duration.Quarter;
            }
        };
        CapellaParser.prototype.parseDuration = function (bar, beat, element) {
            var durationBase = element.getAttribute('base');
            beat.duration = this.parseDurationValue(durationBase);
            if (element.attributes.has('dots')) {
                beat.dots = parseInt(element.attributes.get('dots'));
            }
            var tuplet = element.findChildElement('tuplet');
            if (tuplet) {
                beat.tupletNumerator = parseInt(tuplet.getAttribute('count'));
                var tripartiteMultiplicator = tuplet.getAttribute('tripartite') === 'true' ? 3 : 1;
                var prolongDiff = tuplet.getAttribute('prolong') === 'true' ? 0 : 1;
                var power = 0;
                while (tripartiteMultiplicator * Math.pow(2, power + prolongDiff) < beat.tupletNumerator) {
                    power++;
                }
                beat.tupletDenominator = tripartiteMultiplicator * Math.pow(2, power);
            }
        };
        CapellaParser.prototype.parsePageObjects = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'drawObj':
                            var obj = this.parseDrawObj(c);
                            if (obj) {
                                if (obj instanceof TextDrawObject) {
                                    switch (obj.align) {
                                        case TextAlign.Center:
                                            if (!this.score.title) {
                                                this.score.title = c.innerText;
                                            }
                                            else if (!this.score.subTitle) {
                                                this.score.subTitle = c.innerText;
                                            }
                                            break;
                                        case TextAlign.Right:
                                            if (!this.score.artist) {
                                                this.score.artist = c.innerText;
                                            }
                                            break;
                                    }
                                }
                            }
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseGallery = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'drawObj':
                            var obj = this.parseDrawObj(c);
                            if (obj) {
                                this._galleryObjects.set(c.getAttribute('name'), obj);
                            }
                            break;
                    }
                }
            }
        };
        CapellaParser.prototype.parseDrawObj = function (element) {
            var obj = null;
            var noteRange = 1;
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        case 'text':
                            obj = this.parseText(c);
                            break;
                        case 'guitar':
                            obj = this.parseGuitar(c);
                            break;
                        case 'slur':
                            obj = this.parseSlur(c);
                            break;
                        case 'wavyLine':
                            obj = this.parseWavyLine(c);
                            break;
                        case 'bracket':
                            obj = this.parseTupletBracket(c);
                            break;
                        case 'wedge':
                            obj = this.parseWedge(c);
                            break;
                        case 'volta':
                            obj = this.parseVolta(c);
                            break;
                        case 'octaveClef':
                            obj = this.parseOctaveClef(c);
                            break;
                        case 'trill':
                            obj = this.parseTrill(c);
                            break;
                        case 'basic':
                            if (c.attributes.has('noteRange')) {
                                noteRange = parseInt(c.attributes.get('noteRange'));
                            }
                            break;
                    }
                }
            }
            if (obj) {
                obj.noteRange = noteRange;
            }
            return obj;
        };
        CapellaParser.prototype.parseTrill = function (_) {
            var obj = new TrillDrawObject();
            return obj;
        };
        CapellaParser.prototype.parseOctaveClef = function (element) {
            var obj = new OctaveClefDrawObject();
            if (element.attributes.has('octave')) {
                obj.octave = parseInt(element.attributes.get('octave'));
            }
            return obj;
        };
        CapellaParser.prototype.parseVolta = function (element) {
            var obj = new VoltaDrawObject();
            obj.allNumbers = element.attributes.get('allNumbers') === 'true';
            if (element.attributes.has('firstNumber')) {
                obj.firstNumber = parseInt(element.attributes.get('firstNumber'));
            }
            if (element.attributes.has('lastNumber')) {
                obj.lastNumber = parseInt(element.attributes.get('lastNumber'));
            }
            return obj;
        };
        CapellaParser.prototype.parseWedge = function (element) {
            var obj = new WedgeDrawObject();
            obj.decrescendo = element.attributes.get('decrescendo') === 'true';
            return obj;
        };
        CapellaParser.prototype.parseTupletBracket = function (element) {
            var obj = new TupletBracketDrawObject();
            if (element.attributes.has('number')) {
                obj.number = parseInt(element.attributes.get('number'));
            }
            return obj;
        };
        CapellaParser.prototype.parseWavyLine = function (_) {
            var obj = new WavyLineDrawObject();
            return obj;
        };
        CapellaParser.prototype.parseSlur = function (_) {
            var obj = new SlurDrawObject();
            return obj;
        };
        CapellaParser.prototype.parseGuitar = function (element) {
            var obj = new GuitarDrawObject();
            var strings = element.innerText.trim();
            for (var i = 0; i < strings.length; i++) {
                if (strings.charAt(i) === '/') {
                    obj.chord.strings.push(0);
                }
                else {
                    obj.chord.strings.push(parseInt(strings.charAt(i)));
                }
            }
            return obj;
        };
        CapellaParser.prototype.parseText = function (element) {
            var obj = new TextDrawObject();
            if (element.attributes.has('x')) {
                obj.x = parseFloat(element.attributes.get('x'));
            }
            if (element.attributes.has('x')) {
                obj.y = parseFloat(element.attributes.get('y'));
            }
            switch (element.getAttribute('align')) {
                case 'left':
                    obj.align = TextAlign.Left;
                    break;
                case 'center':
                    obj.align = TextAlign.Center;
                    break;
                case 'right':
                    obj.align = TextAlign.Right;
                    break;
            }
            switch (element.getAttribute('frame')) {
                case 'rectangle':
                    obj.frame = FrameType.Rectangle;
                    break;
                case 'ellipse':
                    obj.frame = FrameType.Ellipse;
                    break;
                case 'circle':
                    obj.frame = FrameType.Circle;
                    break;
                case 'none':
                    obj.frame = FrameType.None;
                    break;
            }
            if (element.firstElement) {
                for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                    var c = _a[_i];
                    if (c.nodeType === XmlNodeType.Element) {
                        switch (c.localName) {
                            case 'font':
                                obj.fontFace = c.getAttribute('face');
                                if (c.attributes.has('weight')) {
                                    obj.weight = parseInt(c.attributes.get('weight'));
                                }
                                if (c.attributes.has('height')) {
                                    obj.height = parseInt(c.attributes.get('height'));
                                }
                                break;
                            case 'content':
                                obj.text = c.innerText;
                                break;
                        }
                    }
                }
            }
            else {
                obj.text = element.innerText;
            }
            return obj;
        };
        CapellaParser.prototype.parseInfo = function (element) {
            for (var _i = 0, _a = element.childNodes; _i < _a.length; _i++) {
                var c = _a[_i];
                if (c.nodeType === XmlNodeType.Element) {
                    switch (c.localName) {
                        // encodingSoftware ignored
                        case 'author':
                            this.score.tab = c.firstChild.innerText;
                            break;
                        // keywords ignored
                        case 'comment':
                            this.score.notices = c.firstChild.innerText;
                            break;
                    }
                }
            }
        };
        return CapellaParser;
    }());

    var __extends$2h = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /**
     * This ScoreImporter can read Capella (cap/capx) files.
     */
    var CapellaImporter = /** @class */ (function (_super) {
        __extends$2h(CapellaImporter, _super);
        function CapellaImporter() {
            return _super.call(this) || this;
        }
        Object.defineProperty(CapellaImporter.prototype, "name", {
            get: function () {
                return 'Capella';
            },
            enumerable: false,
            configurable: true
        });
        CapellaImporter.prototype.readScore = function () {
            Logger.debug(this.name, 'Loading ZIP entries');
            var fileSystem = new ZipReader(this.data);
            var entries;
            var xml = null;
            entries = fileSystem.read();
            Logger.debug(this.name, 'Zip entries loaded');
            if (entries.length > 0) {
                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                    var entry = entries_1[_i];
                    switch (entry.fileName) {
                        case 'score.xml':
                            xml = IOHelper.toString(entry.data, this.settings.importer.encoding);
                            break;
                    }
                }
            }
            else {
                this.data.reset();
                xml = IOHelper.toString(this.data.readAll(), this.settings.importer.encoding);
            }
            if (!xml) {
                throw new UnsupportedFormatError('No valid capella file');
            }
            Logger.debug(this.name, 'Start Parsing score.xml');
            try {
                var capellaParser = new CapellaParser();
                capellaParser.parseXml(xml, this.settings);
                Logger.debug(this.name, 'score.xml parsed');
                var score = capellaParser.score;
                return score;
            }
            catch (e) {
                throw new UnsupportedFormatError('Failed to parse CapXML', e);
            }
        };
        return CapellaImporter;
    }(ScoreImporter));

    var LayoutEngineFactory = /** @class */ (function () {
        function LayoutEngineFactory(vertical, createLayout) {
            this.vertical = vertical;
            this.createLayout = createLayout;
        }
        return LayoutEngineFactory;
    }());
    var RenderEngineFactory = /** @class */ (function () {
        function RenderEngineFactory(supportsWorkers, canvas) {
            this.supportsWorkers = supportsWorkers;
            this.createCanvas = canvas;
        }
        return RenderEngineFactory;
    }());
    /**
     * This public class represents the global alphaTab environment where
     * alphaTab looks for information like available layout engines
     * staves etc.
     * This public class represents the global alphaTab environment where
     * alphaTab looks for information like available layout engines
     * staves etc.
     * @partial
     */
    var Environment = /** @class */ (function () {
        function Environment() {
        }
        /**
         * @target web
         */
        Environment.createStyleElement = function (elementDocument, fontDirectory) {
            var styleElement = elementDocument.getElementById('alphaTabStyle');
            if (!styleElement) {
                if (!fontDirectory) {
                    Logger.error('AlphaTab', 'Font directory could not be detected, cannot create style element');
                    return;
                }
                styleElement = elementDocument.createElement('style');
                styleElement.id = 'alphaTabStyle';
                var css = "\n            @font-face {\n                font-family: 'alphaTab';\n                 src: url('" + fontDirectory + "Bravura.eot');\n                 src: url('" + fontDirectory + "Bravura.eot?#iefix') format('embedded-opentype')\n                      , url('" + fontDirectory + "Bravura.woff') format('woff')\n                      , url('" + fontDirectory + "Bravura.otf') format('opentype')\n                      , url('" + fontDirectory + "Bravura.svg#Bravura') format('svg');\n                 font-weight: normal;\n                 font-style: normal;\n            }\n            .at-surface * {\n                cursor: default;\n                vertical-align: top;\n                overflow: visible;\n            }\n            .at {\n                 font-family: 'alphaTab';\n                 speak: none;\n                 font-style: normal;\n                 font-weight: normal;\n                 font-variant: normal;\n                 text-transform: none;\n                 line-height: 1;\n                 line-height: 1;\n                 -webkit-font-smoothing: antialiased;\n                 -moz-osx-font-smoothing: grayscale;\n                 font-size: " + Environment.MusicFontSize + "px;\n                 overflow: visible !important;\n            }";
                styleElement.innerHTML = css;
                elementDocument.getElementsByTagName('head').item(0).appendChild(styleElement);
                Environment.bravuraFontChecker.checkForFontAvailability();
            }
        };
        Object.defineProperty(Environment, "globalThis", {
            /**
             * @target web
             */
            get: function () {
                if (Environment._globalThis === undefined) {
                    try {
                        Environment._globalThis = globalThis;
                    }
                    catch (e) {
                        // global this not available
                    }
                    if (typeof Environment._globalThis === 'undefined') {
                        Environment._globalThis = self;
                    }
                    if (typeof Environment._globalThis === 'undefined') {
                        Environment._globalThis = window;
                    }
                    if (typeof Environment._globalThis === 'undefined') {
                        Environment._globalThis = Function('return this')();
                    }
                }
                return this._globalThis;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment, "isRunningInWorker", {
            /**
             * @target web
             */
            get: function () {
                return 'WorkerGlobalScope' in Environment.globalThis;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment, "supportsFontsApi", {
            /**
             * @target web
             */
            get: function () {
                return 'fonts' in document && 'load' in document.fonts;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment, "supportsTextDecoder", {
            /**
             * @target web
             */
            get: function () {
                return 'TextDecoder' in Environment.globalThis;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * @target web
         */
        Environment.throttle = function (action, delay) {
            var timeoutId = 0;
            return function () {
                window.clearTimeout(timeoutId);
                timeoutId = window.setTimeout(action, delay);
            };
        };
        /**
         * @target web
         */
        Environment.detectScriptFile = function () {
            if (Environment.isRunningInWorker) {
                return null;
            }
            // try to build the find the alphaTab script url in case we are not in the webworker already
            var scriptElement = document.currentScript;
            var scriptFile = null;
            if (!scriptElement) {
                // try to get javascript from exception stack
                try {
                    var error = new Error();
                    var stack = error.stack;
                    if (!stack) {
                        throw error;
                    }
                    scriptFile = Environment.scriptFileFromStack(stack);
                }
                catch (e) {
                    if (e instanceof Error) {
                        var stack = e.stack;
                        if (!stack) {
                            scriptElement = document.querySelector('script[data-alphatab]');
                        }
                        else {
                            scriptFile = Environment.scriptFileFromStack(stack);
                        }
                    }
                    else {
                        throw e;
                    }
                }
            }
            // failed to automatically resolve
            if (!scriptFile) {
                if (!scriptElement) {
                    Logger.warning('Environment', 'Could not automatically find alphaTab script file for worker, please add the data-alphatab attribute to the script tag that includes alphaTab or provide it when initializing alphaTab', null);
                }
                else {
                    scriptFile = scriptElement.src;
                }
            }
            return scriptFile;
        };
        /**
         * @target web
         */
        Environment.registerJQueryPlugin = function () {
            if (!Environment.isRunningInWorker && Environment.globalThis && 'jQuery' in Environment.globalThis) {
                var jquery = Environment.globalThis['jQuery'];
                var api_1 = new JQueryAlphaTab();
                jquery.fn.alphaTab = function (method) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    // if only a single element is affected, we use this
                    if (this.length === 1) {
                        return api_1.exec(this[0], method, args);
                    }
                    // if multiple elements are affected we provide chaining
                    return this.each(function (_i, e) {
                        api_1.exec(e, method, args);
                    });
                };
                jquery.alphaTab = {
                    restore: JQueryAlphaTab.restore
                };
                jquery.fn.alphaTab.fn = api_1;
            }
        };
        /**
         * based on https://github.com/JamesMGreene/currentExecutingScript
         * @target web
         */
        Environment.scriptFileFromStack = function (stack) {
            var matches = stack.match('(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?');
            if (!matches) {
                matches = stack.match('^(?:|[^:@]*@|.+\\)@(?=data:text\\/javascript|blob|http[s]?|file)|.+?\\s+(?: at |@)(?:[^:\\(]+ )*[\\(]?)(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?');
                if (!matches) {
                    matches = stack.match('\\)@(data:text\\/javascript(?:;[^,]+)?,.+?|(?:|blob:)(?:http[s]?|file):\\/\\/[\\/]?.+?\\/[^:\\)]*?)(?::\\d+)(?::\\d+)?');
                    if (!matches) {
                        return null;
                    }
                }
            }
            return matches[1];
        };
        Environment.createScoreRenderer = function (settings) {
            return new ScoreRenderer(settings);
        };
        Environment.getRenderEngineFactory = function (settings) {
            if (!settings.core.engine || !Environment.renderEngines.has(settings.core.engine)) {
                return Environment.renderEngines.get('default');
            }
            return Environment.renderEngines.get(settings.core.engine);
        };
        Environment.getLayoutEngineFactory = function (settings) {
            if (!settings.display.layoutMode || !Environment.layoutEngines.has(settings.display.layoutMode)) {
                return Environment.layoutEngines.get(exports.LayoutMode.Page);
            }
            return Environment.layoutEngines.get(settings.display.layoutMode);
        };
        /**
         * Gets all default ScoreImporters
         * @returns
         */
        Environment.buildImporters = function () {
            return [
                new Gp3To5Importer(),
                new GpxImporter(),
                new Gp7Importer(),
                new MusicXmlImporter(),
                new CapellaImporter(),
                new AlphaTexImporter()
            ];
        };
        Environment.createDefaultRenderEngines = function () {
            var renderEngines = new Map();
            renderEngines.set('svg', new RenderEngineFactory(true, function () {
                return new CssFontSvgCanvas();
            }));
            renderEngines.set('default', renderEngines.get('svg'));
            Environment.createPlatformSpecificRenderEngines(renderEngines);
            return renderEngines;
        };
        /**
         * @target web
         */
        Environment.createPlatformSpecificRenderEngines = function (renderEngines) {
            renderEngines.set('html5', new RenderEngineFactory(false, function () {
                return new Html5Canvas();
            }));
        };
        Environment.createDefaultStaveProfiles = function () {
            var staveProfiles = new Map();
            // default combinations of stave textprofiles
            staveProfiles.set(exports.StaveProfile.ScoreTab, [
                new EffectBarRendererFactory('score-effects', [
                    new TempoEffectInfo(),
                    new TripletFeelEffectInfo(),
                    new MarkerEffectInfo(),
                    new TextEffectInfo(),
                    new ChordsEffectInfo(),
                    new FermataEffectInfo(),
                    new WhammyBarEffectInfo(),
                    new TrillEffectInfo(),
                    new OttaviaEffectInfo(true),
                    new WideBeatVibratoEffectInfo(),
                    new SlightBeatVibratoEffectInfo(),
                    new WideNoteVibratoEffectInfo(),
                    new SlightNoteVibratoEffectInfo(),
                    new LeftHandTapEffectInfo(),
                    new AlternateEndingsEffectInfo()
                ]),
                new ScoreBarRendererFactory(),
                new EffectBarRendererFactory('tab-effects', [
                    new CrescendoEffectInfo(),
                    new OttaviaEffectInfo(false),
                    new DynamicsEffectInfo(),
                    new LyricsEffectInfo(),
                    new TrillEffectInfo(),
                    new WideBeatVibratoEffectInfo(),
                    new SlightBeatVibratoEffectInfo(),
                    new WideNoteVibratoEffectInfo(),
                    new SlightNoteVibratoEffectInfo(),
                    new TapEffectInfo(),
                    new FadeInEffectInfo(),
                    new HarmonicsEffectInfo(HarmonicType.Natural),
                    new HarmonicsEffectInfo(HarmonicType.Artificial),
                    new HarmonicsEffectInfo(HarmonicType.Pinch),
                    new HarmonicsEffectInfo(HarmonicType.Tap),
                    new HarmonicsEffectInfo(HarmonicType.Semi),
                    new HarmonicsEffectInfo(HarmonicType.Feedback),
                    new LetRingEffectInfo(),
                    new CapoEffectInfo(),
                    new FingeringEffectInfo(),
                    new PalmMuteEffectInfo(),
                    new PickStrokeEffectInfo(),
                    new PickSlideEffectInfo(),
                    new LeftHandTapEffectInfo()
                ]),
                new TabBarRendererFactory(false, false, false)
            ]);
            staveProfiles.set(exports.StaveProfile.Score, [
                new EffectBarRendererFactory('score-effects', [
                    new TempoEffectInfo(),
                    new TripletFeelEffectInfo(),
                    new MarkerEffectInfo(),
                    new TextEffectInfo(),
                    new ChordsEffectInfo(),
                    new FermataEffectInfo(),
                    new WhammyBarEffectInfo(),
                    new TrillEffectInfo(),
                    new OttaviaEffectInfo(true),
                    new WideBeatVibratoEffectInfo(),
                    new SlightBeatVibratoEffectInfo(),
                    new WideNoteVibratoEffectInfo(),
                    new SlightNoteVibratoEffectInfo(),
                    new FadeInEffectInfo(),
                    new LetRingEffectInfo(),
                    new PalmMuteEffectInfo(),
                    new PickStrokeEffectInfo(),
                    new PickSlideEffectInfo(),
                    new LeftHandTapEffectInfo(),
                    new AlternateEndingsEffectInfo()
                ]),
                new ScoreBarRendererFactory(),
                new EffectBarRendererFactory('score-bottom-effects', [
                    new CrescendoEffectInfo(),
                    new OttaviaEffectInfo(false),
                    new DynamicsEffectInfo(),
                    new LyricsEffectInfo()
                ])
            ]);
            var tabEffectInfos = [
                new TempoEffectInfo(),
                new TripletFeelEffectInfo(),
                new MarkerEffectInfo(),
                new TextEffectInfo(),
                new ChordsEffectInfo(),
                new FermataEffectInfo(),
                new TrillEffectInfo(),
                new WideBeatVibratoEffectInfo(),
                new SlightBeatVibratoEffectInfo(),
                new WideNoteVibratoEffectInfo(),
                new SlightNoteVibratoEffectInfo(),
                new TapEffectInfo(),
                new FadeInEffectInfo(),
                new HarmonicsEffectInfo(HarmonicType.Artificial),
                new HarmonicsEffectInfo(HarmonicType.Pinch),
                new HarmonicsEffectInfo(HarmonicType.Tap),
                new HarmonicsEffectInfo(HarmonicType.Semi),
                new HarmonicsEffectInfo(HarmonicType.Feedback),
                new LetRingEffectInfo(),
                new CapoEffectInfo(),
                new FingeringEffectInfo(),
                new PalmMuteEffectInfo(),
                new PickStrokeEffectInfo(),
                new PickSlideEffectInfo(),
                new LeftHandTapEffectInfo(),
                new AlternateEndingsEffectInfo()
            ];
            staveProfiles.set(exports.StaveProfile.Tab, [
                new EffectBarRendererFactory('tab-effects', tabEffectInfos),
                new TabBarRendererFactory(true, true, true),
                new EffectBarRendererFactory('tab-bottom-effects', [new LyricsEffectInfo()])
            ]);
            staveProfiles.set(exports.StaveProfile.TabMixed, [
                new EffectBarRendererFactory('tab-effects', tabEffectInfos),
                new TabBarRendererFactory(false, false, false),
                new EffectBarRendererFactory('tab-bottom-effects', [new LyricsEffectInfo()])
            ]);
            return staveProfiles;
        };
        Environment.createDefaultLayoutEngines = function () {
            var engines = new Map();
            // default layout engines
            engines.set(exports.LayoutMode.Page, new LayoutEngineFactory(true, function (r) {
                return new PageViewLayout(r);
            }));
            engines.set(exports.LayoutMode.Horizontal, new LayoutEngineFactory(false, function (r) {
                return new HorizontalScreenLayout(r);
            }));
            return engines;
        };
        /**
         * @target web
         */
        Environment.platformInit = function () {
            Environment.registerJQueryPlugin();
            // polyfills
            Math.log2 = Math.log2
                ? Math.log2
                : function (x) {
                    return Math.log(x) * Math.LOG2E;
                };
            if (!Environment.isRunningInWorker) {
                var vbAjaxLoader = '';
                vbAjaxLoader += 'Function VbAjaxLoader(method, fileName)' + '\r\n';
                vbAjaxLoader += '    Dim xhr' + '\r\n';
                vbAjaxLoader += '    Set xhr = CreateObject("Microsoft.XMLHTTP")' + '\r\n';
                vbAjaxLoader += '    xhr.Open method, fileName, False' + '\r\n';
                vbAjaxLoader += '    xhr.setRequestHeader "Accept-Charset", "x-user-defined"' + '\r\n';
                vbAjaxLoader += '    xhr.send' + '\r\n';
                vbAjaxLoader += '    Dim byteArray()' + '\r\n';
                vbAjaxLoader += '    if xhr.Status = 200 Then' + '\r\n';
                vbAjaxLoader += '        Dim byteString' + '\r\n';
                vbAjaxLoader += '        Dim i' + '\r\n';
                vbAjaxLoader += '        byteString=xhr.responseBody' + '\r\n';
                vbAjaxLoader += '        ReDim byteArray(LenB(byteString))' + '\r\n';
                vbAjaxLoader += '        For i = 1 To LenB(byteString)' + '\r\n';
                vbAjaxLoader += '            byteArray(i-1) = AscB(MidB(byteString, i, 1))' + '\r\n';
                vbAjaxLoader += '        Next' + '\r\n';
                vbAjaxLoader += '    End If' + '\r\n';
                vbAjaxLoader += '    VbAjaxLoader=byteArray' + '\r\n';
                vbAjaxLoader += 'End Function' + '\r\n';
                var vbAjaxLoaderScript_1 = document.createElement('script');
                vbAjaxLoaderScript_1.setAttribute('type', 'text/vbscript');
                var inlineScript = document.createTextNode(vbAjaxLoader);
                vbAjaxLoaderScript_1.appendChild(inlineScript);
                document.addEventListener('DOMContentLoaded', function () {
                    document.body.appendChild(vbAjaxLoaderScript_1);
                }, false);
            }
            else {
                AlphaTabWebWorker.init();
                AlphaSynthWebWorker.init();
            }
        };
        /**
         * The font size of the music font in pixel.
         */
        Environment.MusicFontSize = 34;
        /**
         * @target web
         */
        Environment._globalThis = undefined;
        /**
         * @target web
         */
        Environment.scriptFile = Environment.detectScriptFile();
        /**
         * @target web
         */
        Environment.bravuraFontChecker = new FontLoadingChecker('alphaTab', "&#" + MusicFontSymbol.GClef + ";");
        Environment.renderEngines = Environment.createDefaultRenderEngines();
        Environment.layoutEngines = Environment.createDefaultLayoutEngines();
        Environment.staveProfiles = Environment.createDefaultStaveProfiles();
        return Environment;
    }());
    Environment.platformInit();

    /**
     * @json
     */
    var CoreSettings = /** @class */ (function () {
        /**
         * @target web
         */
        function CoreSettings() {
            /**
             * Gets or sets the script file url that will be used to spawn the workers.
             * @target web
             */
            this.scriptFile = null;
            /**
             * Gets or sets the url to the fonts that will be used to generate the alphaTab font style.
             * @target web
             */
            this.fontDirectory = null;
            /**
             * Gets or sets the file to load directly after initializing alphaTab.
             * @target web
             */
            this.file = null;
            /**
             * Gets or sets whether the UI element contains alphaTex code that should be
             * used to initialize alphaTab.
             * @target web
             */
            this.tex = false;
            /**
             * Gets or sets the initial tracks that should be loaded for the score.
             * @target web
             */
            this.tracks = null;
            /**
             * Gets or sets the interval in which alphaTab should check whether the
             * target element for rendering is already visible.
             * @target web
             */
            this.visibilityCheckInterval = 500;
            /**
             * Gets or sets whether lazy loading for displayed elements is enabled.
             */
            this.enableLazyLoading = true;
            /**
             * The engine which should be used to render the the tablature.
             *
             * - **default**- Platform specific default engine
             * - **html5**- HTML5 Canvas
             * - **svg**- SVG
             */
            this.engine = 'default';
            /**
             * The log level to use within alphaTab
             */
            this.logLevel = exports.LogLevel.Info;
            /**
             * Gets or sets whether the rendering should be done in a worker if possible.
             */
            this.useWorkers = true;
            /**
             * Gets or sets whether in the {@link BoundsLookup} also the
             * position and area of each individual note is provided.
             */
            this.includeNoteBounds = false;
            if (!Environment.isRunningInWorker && Environment.globalThis.ALPHATAB_ROOT) {
                this.scriptFile = Environment.globalThis.ALPHATAB_ROOT;
                this.scriptFile = CoreSettings.ensureFullUrl(this.scriptFile);
                this.scriptFile = CoreSettings.appendScriptName(this.scriptFile);
            }
            else {
                this.scriptFile = Environment.scriptFile;
            }
            if (!Environment.isRunningInWorker && Environment.globalThis.ALPHATAB_FONT) {
                this.fontDirectory = Environment.globalThis['ALPHATAB_FONT'];
                this.fontDirectory = CoreSettings.ensureFullUrl(this.fontDirectory);
            }
            else {
                this.fontDirectory = this.scriptFile;
                if (this.fontDirectory) {
                    var lastSlash = this.fontDirectory.lastIndexOf(String.fromCharCode(47));
                    if (lastSlash >= 0) {
                        this.fontDirectory = this.fontDirectory.substr(0, lastSlash) + '/font/';
                    }
                }
            }
        }
        /**
         * @target web
         */
        CoreSettings.ensureFullUrl = function (relativeUrl) {
            var _a, _b, _c;
            if (!relativeUrl) {
                return '';
            }
            if (!relativeUrl.startsWith('http') && !relativeUrl.startsWith('https') && !relativeUrl.startsWith('file')) {
                var root = '';
                var location_1 = Environment.globalThis['location'];
                root += (_a = location_1.protocol) === null || _a === void 0 ? void 0 : _a.toString();
                root +=  '//'.toString();
                if (location_1.hostname) {
                    root += (_b = location_1.hostname) === null || _b === void 0 ? void 0 : _b.toString();
                }
                if (location_1.port) {
                    root +=  ':'.toString();
                    root += (_c = location_1.port) === null || _c === void 0 ? void 0 : _c.toString();
                }
                // as it is not clearly defined how slashes are treated in the location object
                // better be safe than sorry here
                if (!relativeUrl.startsWith('/')) {
                    var directory = location_1.pathname.split('/').slice(0, -1).join('/');
                    if (directory.length > 0) {
                        if (!directory.startsWith('/')) {
                            root +=  '/'.toString();
                        }
                        root += directory === null || directory === void 0 ? void 0 : directory.toString();
                    }
                }
                if (!relativeUrl.startsWith('/')) {
                    root +=  '/'.toString();
                }
                root += relativeUrl === null || relativeUrl === void 0 ? void 0 : relativeUrl.toString();
                return root;
            }
            return relativeUrl;
        };
        CoreSettings.appendScriptName = function (url) {
            // append script name
            if (url && !url.endsWith('.js')) {
                if (!url.endsWith('/')) {
                    url += '/';
                }
                url += 'alphaTab.js';
            }
            return url;
        };
        CoreSettings.toJson = function (obj) { var json = {}; obj.fillToJson(json); return json; };
        CoreSettings.prototype.fillToJson = function (json) { json.scriptFile = this.scriptFile; json.fontDirectory = this.fontDirectory; json.file = this.file; json.tex = this.tex; json.tracks = this.tracks; json.visibilityCheckInterval = this.visibilityCheckInterval; json.enableLazyLoading = this.enableLazyLoading; json.engine = this.engine; json.logLevel = this.logLevel; json.useWorkers = this.useWorkers; json.includeNoteBounds = this.includeNoteBounds; };
        CoreSettings.fromJson = function (json) { if (!json)
            return null; var obj = new CoreSettings(); obj.fillFromJson(json); return obj; };
        CoreSettings.prototype.fillFromJson = function (json) { if (json)
            for (var $k in json)
                this.setProperty($k.toLowerCase(), json[$k]); };
        CoreSettings.prototype.setProperty = function (property, value) { switch (property) {
            case "scriptfile":
                this.scriptFile = value;
                return true;
            case "fontdirectory":
                this.fontDirectory = value;
                return true;
            case "file":
                this.file = value;
                return true;
            case "tex":
                this.tex = value;
                return true;
            case "tracks":
                this.tracks = value;
                return true;
            case "visibilitycheckinterval":
                this.visibilityCheckInterval = value;
                return true;
            case "enablelazyloading":
                this.enableLazyLoading = value;
                return true;
            case "engine":
                this.engine = value;
                return true;
            case "loglevel":
                this.logLevel = isNaN(parseInt(value)) ? exports.LogLevel[Object.keys(exports.LogLevel).find(function ($k) { return $k.toLowerCase() === value.toLowerCase(); })] : parseInt(value);
                return true;
            case "useworkers":
                this.useWorkers = value;
                return true;
            case "includenotebounds":
                this.includeNoteBounds = value;
                return true;
        } return false; };
        return CoreSettings;
    }());

    /**
     * Represents the progress of any data being loaded.
     */
    var ProgressEventArgs = /** @class */ (function () {
        /**
         * Initializes a new instance of the {@link ProgressEventArgs} class.
         * @param loaded
         * @param total
         */
        function ProgressEventArgs(loaded, total) {
            this.loaded = loaded;
            this.total = total;
        }
        return ProgressEventArgs;
    }());

    if (!('WorkerGlobalScope' in self)) {
        if (!Element.prototype.matches) {
            Element.prototype.matches =
                Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        if (!Element.prototype.closest) {
            Element.prototype.closest = function (s) {
                var el = this;
                do {
                    if (Element.prototype.matches.call(el, s))
                        return el;
                    el = el.parentElement || el.parentNode;
                } while (el !== null && el.nodeType === 1);
                return null;
            };
        }
        if (window.NodeList && !NodeList.prototype.forEach) {
            NodeList.prototype.forEach = Array.prototype.forEach;
        }
    }
    if (!String.prototype.startsWith) {
        String.prototype.startsWith = function (searchString, position) {
            position = position || 0;
            return this.indexOf(searchString, position) === position;
        };
    }
    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    if (!Array.prototype.find) {
        Object.defineProperty(Array.prototype, 'find', {
            value: function (predicate) {
                // 1. Let O be ? ToObject(this value).
                if (this == null) {
                    throw new TypeError('"this" is null or not defined');
                }
                var o = Object(this);
                // 2. Let len be ? ToLength(? Get(O, "length")).
                var len = o.length >>> 0;
                // 3. If IsCallable(predicate) is false, throw a TypeError exception.
                if (typeof predicate !== 'function') {
                    throw new TypeError('predicate must be a function');
                }
                // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
                var thisArg = arguments[1];
                // 5. Let k be 0.
                var k = 0;
                // 6. Repeat, while k < len
                while (k < len) {
                    // a. Let Pk be ! ToString(k).
                    // b. Let kValue be ? Get(O, Pk).
                    // c. Let testResult be ToBoolean(? Call(predicate, T, Â« kValue, k, O Â»)).
                    // d. If testResult is true, return kValue.
                    var kValue = o[k];
                    if (predicate.call(thisArg, kValue, k, o)) {
                        return kValue;
                    }
                    // e. Increase k by 1.
                    k++;
                }
                // 7. Return undefined.
                return undefined;
            },
            configurable: true,
            writable: true
        });
    }
    var importer = {
        ScoreImporter: ScoreImporter,
        ScoreLoader: ScoreLoader,
        UnsupportedFormatError: UnsupportedFormatError
    };
    var midi = {
        BeatTickLookup: BeatTickLookup,
        MasterBarTickLookup: MasterBarTickLookup,
        MidiTickLookup: MidiTickLookup,
        MidiTickLookupFindBeatResult: MidiTickLookupFindBeatResult,
        MidiFile: MidiFile,
        ControllerType: ControllerType,
        MetaDataEvent: MetaDataEvent,
        MetaEvent: MetaEvent,
        MetaEventType: MetaEventType,
        MetaNumberEvent: MetaNumberEvent,
        MidiEvent: MidiEvent,
        MidiEventType: MidiEventType,
        SystemCommonEvent: SystemCommonEvent,
        SystemCommonType: SystemCommonType,
        SystemExclusiveEvent: SystemExclusiveEvent,
        MidiFileGenerator: MidiFileGenerator,
        AlphaSynthMidiFileHandler: AlphaSynthMidiFileHandler
    };
    var model = {
        AccentuationType: AccentuationType,
        AccidentalType: AccidentalType,
        AutomationType: AutomationType,
        Automation: Automation,
        Bar: Bar,
        Beat: Beat,
        BendPoint: BendPoint,
        BendStyle: BendStyle,
        BendType: BendType,
        BrushType: BrushType,
        Chord: Chord,
        Clef: Clef,
        Color: Color,
        CrescendoType: CrescendoType,
        Duration: Duration,
        DynamicValue: DynamicValue,
        FermataType: FermataType,
        Fermata: Fermata,
        Fingers: Fingers,
        FontStyle: FontStyle,
        Font: Font,
        GraceType: GraceType,
        HarmonicType: HarmonicType,
        InstrumentArticulation: InstrumentArticulation,
        JsonConverter: JsonConverter,
        KeySignature: KeySignature,
        KeySignatureType: KeySignatureType,
        Lyrics: Lyrics,
        MasterBar: MasterBar,
        MusicFontSymbol: MusicFontSymbol,
        Note: Note,
        NoteAccidentalMode: NoteAccidentalMode,
        Ottavia: Ottavia,
        PickStroke: PickStroke,
        PlaybackInformation: PlaybackInformation,
        RenderStylesheet: RenderStylesheet,
        RepeatGroup: RepeatGroup,
        Score: Score,
        Section: Section,
        SimileMark: SimileMark,
        SlideInType: SlideInType,
        SlideOutType: SlideOutType,
        Staff: Staff,
        Track: Track,
        TripletFeel: TripletFeel,
        Tuning: Tuning,
        TupletGroup: TupletGroup,
        VibratoType: VibratoType,
        Voice: Voice,
        WhammyType: WhammyType
    };
    var rendering = {
        ScoreRenderer: ScoreRenderer,
        RenderFinishedEventArgs: RenderFinishedEventArgs,
        BarBounds: BarBounds,
        BeatBounds: BeatBounds,
        Bounds: Bounds,
        BoundsLookup: BoundsLookup,
        MasterBarBounds: MasterBarBounds,
        NoteBounds: NoteBounds,
        StaveGroupBounds: StaveGroupBounds
    };
    var synth = {
        AlphaSynth: AlphaSynth,
        PlaybackRange: PlaybackRange,
        PlayerState: PlayerState,
        PlayerStateChangedEventArgs: PlayerStateChangedEventArgs,
        PositionChangedEventArgs: PositionChangedEventArgs,
        AlphaSynthWebWorkerApi: AlphaSynthWebWorkerApi
    };

    exports.AlphaTabApi = AlphaTabApi;
    exports.AlphaTabError = AlphaTabError;
    exports.CoreSettings = CoreSettings;
    exports.DisplaySettings = DisplaySettings;
    exports.FileLoadError = FileLoadError;
    exports.FormatError = FormatError;
    exports.ImporterSettings = ImporterSettings;
    exports.Logger = Logger;
    exports.NotationSettings = NotationSettings;
    exports.PlayerSettings = PlayerSettings;
    exports.ProgressEventArgs = ProgressEventArgs;
    exports.RenderingResources = RenderingResources;
    exports.ResizeEventArgs = ResizeEventArgs;
    exports.Settings = Settings;
    exports.VibratoPlaybackSettings = VibratoPlaybackSettings;
    exports.importer = importer;
    exports.midi = midi;
    exports.model = model;
    exports.rendering = rendering;
    exports.synth = synth;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
